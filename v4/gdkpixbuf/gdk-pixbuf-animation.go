// Package gdkpixbuf was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdkpixbuf

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Modules supporting animations must derive a type from
// #GdkPixbufAnimation, providing suitable implementations of the
// virtual functions.
type PixbufAnimationClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xIsStaticImage uintptr

	xGetStaticImage uintptr

	xGetSize uintptr

	xGetIter uintptr
}

func (x *PixbufAnimationClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideIsStaticImage sets the callback function.
// returns whether the given animation is just a static image.
func (x *PixbufAnimationClass) OverrideIsStaticImage(cb func(*PixbufAnimation) bool) {
	if cb == nil {
		x.xIsStaticImage = 0
	} else {
		x.xIsStaticImage = purego.NewCallback(func(AnimationVarp uintptr) bool {
			return cb(PixbufAnimationNewFromInternalPtr(AnimationVarp))
		})
	}
}

// GetIsStaticImage gets the callback function.
// returns whether the given animation is just a static image.
func (x *PixbufAnimationClass) GetIsStaticImage() func(*PixbufAnimation) bool {
	if x.xIsStaticImage == 0 {
		return nil
	}
	var rawCallback func(AnimationVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsStaticImage)
	return func(AnimationVar *PixbufAnimation) bool {
		return rawCallback(AnimationVar.GoPointer())
	}
}

// OverrideGetStaticImage sets the callback function.
// returns a static image representing the given animation.
func (x *PixbufAnimationClass) OverrideGetStaticImage(cb func(*PixbufAnimation) *Pixbuf) {
	if cb == nil {
		x.xGetStaticImage = 0
	} else {
		x.xGetStaticImage = purego.NewCallback(func(AnimationVarp uintptr) uintptr {
			ret := cb(PixbufAnimationNewFromInternalPtr(AnimationVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetStaticImage gets the callback function.
// returns a static image representing the given animation.
func (x *PixbufAnimationClass) GetGetStaticImage() func(*PixbufAnimation) *Pixbuf {
	if x.xGetStaticImage == 0 {
		return nil
	}
	var rawCallback func(AnimationVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetStaticImage)
	return func(AnimationVar *PixbufAnimation) *Pixbuf {
		rawRet := rawCallback(AnimationVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &Pixbuf{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetSize sets the callback function.
// fills @width and @height with the frame size of the animation.
func (x *PixbufAnimationClass) OverrideGetSize(cb func(*PixbufAnimation, int, int)) {
	if cb == nil {
		x.xGetSize = 0
	} else {
		x.xGetSize = purego.NewCallback(func(AnimationVarp uintptr, WidthVarp int, HeightVarp int) {
			cb(PixbufAnimationNewFromInternalPtr(AnimationVarp), WidthVarp, HeightVarp)
		})
	}
}

// GetGetSize gets the callback function.
// fills @width and @height with the frame size of the animation.
func (x *PixbufAnimationClass) GetGetSize() func(*PixbufAnimation, int, int) {
	if x.xGetSize == 0 {
		return nil
	}
	var rawCallback func(AnimationVarp uintptr, WidthVarp int, HeightVarp int)
	purego.RegisterFunc(&rawCallback, x.xGetSize)
	return func(AnimationVar *PixbufAnimation, WidthVar int, HeightVar int) {
		rawCallback(AnimationVar.GoPointer(), WidthVar, HeightVar)
	}
}

// OverrideGetIter sets the callback function.
// returns an iterator for the given animation.
func (x *PixbufAnimationClass) OverrideGetIter(cb func(*PixbufAnimation, *glib.TimeVal) *PixbufAnimationIter) {
	if cb == nil {
		x.xGetIter = 0
	} else {
		x.xGetIter = purego.NewCallback(func(AnimationVarp uintptr, StartTimeVarp *glib.TimeVal) uintptr {
			ret := cb(PixbufAnimationNewFromInternalPtr(AnimationVarp), StartTimeVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetIter gets the callback function.
// returns an iterator for the given animation.
func (x *PixbufAnimationClass) GetGetIter() func(*PixbufAnimation, *glib.TimeVal) *PixbufAnimationIter {
	if x.xGetIter == 0 {
		return nil
	}
	var rawCallback func(AnimationVarp uintptr, StartTimeVarp *glib.TimeVal) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetIter)
	return func(AnimationVar *PixbufAnimation, StartTimeVar *glib.TimeVal) *PixbufAnimationIter {
		rawRet := rawCallback(AnimationVar.GoPointer(), StartTimeVar)
		if rawRet == 0 {
			return nil
		}
		ret := &PixbufAnimationIter{}
		ret.Ptr = rawRet
		return ret
	}
}

// Modules supporting animations must derive a type from
// #GdkPixbufAnimationIter, providing suitable implementations of the
// virtual functions.
type PixbufAnimationIterClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xGetDelayTime uintptr

	xGetPixbuf uintptr

	xOnCurrentlyLoadingFrame uintptr

	xAdvance uintptr
}

func (x *PixbufAnimationIterClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetDelayTime sets the callback function.
// returns the time in milliseconds that the current frame
//
//	should be shown.
func (x *PixbufAnimationIterClass) OverrideGetDelayTime(cb func(*PixbufAnimationIter) int) {
	if cb == nil {
		x.xGetDelayTime = 0
	} else {
		x.xGetDelayTime = purego.NewCallback(func(IterVarp uintptr) int {
			return cb(PixbufAnimationIterNewFromInternalPtr(IterVarp))
		})
	}
}

// GetGetDelayTime gets the callback function.
// returns the time in milliseconds that the current frame
//
//	should be shown.
func (x *PixbufAnimationIterClass) GetGetDelayTime() func(*PixbufAnimationIter) int {
	if x.xGetDelayTime == 0 {
		return nil
	}
	var rawCallback func(IterVarp uintptr) int
	purego.RegisterFunc(&rawCallback, x.xGetDelayTime)
	return func(IterVar *PixbufAnimationIter) int {
		return rawCallback(IterVar.GoPointer())
	}
}

// OverrideGetPixbuf sets the callback function.
// returns the current frame.
func (x *PixbufAnimationIterClass) OverrideGetPixbuf(cb func(*PixbufAnimationIter) *Pixbuf) {
	if cb == nil {
		x.xGetPixbuf = 0
	} else {
		x.xGetPixbuf = purego.NewCallback(func(IterVarp uintptr) uintptr {
			ret := cb(PixbufAnimationIterNewFromInternalPtr(IterVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetPixbuf gets the callback function.
// returns the current frame.
func (x *PixbufAnimationIterClass) GetGetPixbuf() func(*PixbufAnimationIter) *Pixbuf {
	if x.xGetPixbuf == 0 {
		return nil
	}
	var rawCallback func(IterVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetPixbuf)
	return func(IterVar *PixbufAnimationIter) *Pixbuf {
		rawRet := rawCallback(IterVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &Pixbuf{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideOnCurrentlyLoadingFrame sets the callback function.
// returns whether the current frame of @iter is
//
//	being loaded.
func (x *PixbufAnimationIterClass) OverrideOnCurrentlyLoadingFrame(cb func(*PixbufAnimationIter) bool) {
	if cb == nil {
		x.xOnCurrentlyLoadingFrame = 0
	} else {
		x.xOnCurrentlyLoadingFrame = purego.NewCallback(func(IterVarp uintptr) bool {
			return cb(PixbufAnimationIterNewFromInternalPtr(IterVarp))
		})
	}
}

// GetOnCurrentlyLoadingFrame gets the callback function.
// returns whether the current frame of @iter is
//
//	being loaded.
func (x *PixbufAnimationIterClass) GetOnCurrentlyLoadingFrame() func(*PixbufAnimationIter) bool {
	if x.xOnCurrentlyLoadingFrame == 0 {
		return nil
	}
	var rawCallback func(IterVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xOnCurrentlyLoadingFrame)
	return func(IterVar *PixbufAnimationIter) bool {
		return rawCallback(IterVar.GoPointer())
	}
}

// OverrideAdvance sets the callback function.
// advances the iterator to @current_time, possibly changing the
//
//	current frame.
func (x *PixbufAnimationIterClass) OverrideAdvance(cb func(*PixbufAnimationIter, *glib.TimeVal) bool) {
	if cb == nil {
		x.xAdvance = 0
	} else {
		x.xAdvance = purego.NewCallback(func(IterVarp uintptr, CurrentTimeVarp *glib.TimeVal) bool {
			return cb(PixbufAnimationIterNewFromInternalPtr(IterVarp), CurrentTimeVarp)
		})
	}
}

// GetAdvance gets the callback function.
// advances the iterator to @current_time, possibly changing the
//
//	current frame.
func (x *PixbufAnimationIterClass) GetAdvance() func(*PixbufAnimationIter, *glib.TimeVal) bool {
	if x.xAdvance == 0 {
		return nil
	}
	var rawCallback func(IterVarp uintptr, CurrentTimeVarp *glib.TimeVal) bool
	purego.RegisterFunc(&rawCallback, x.xAdvance)
	return func(IterVar *PixbufAnimationIter, CurrentTimeVar *glib.TimeVal) bool {
		return rawCallback(IterVar.GoPointer(), CurrentTimeVar)
	}
}

// An opaque object representing an animation.
//
// The GdkPixBuf library provides a simple mechanism to load and
// represent animations. An animation is conceptually a series of
// frames to be displayed over time.
//
// The animation may not be represented as a series of frames
// internally; for example, it may be stored as a sprite and
// instructions for moving the sprite around a background.
//
// To display an animation you don't need to understand its
// representation, however; you just ask `GdkPixbuf` what should
// be displayed at a given point in time.
type PixbufAnimation struct {
	gobject.Object
}

var xPixbufAnimationGLibType func() types.GType

func PixbufAnimationGLibType() types.GType {
	return xPixbufAnimationGLibType()
}

func PixbufAnimationNewFromInternalPtr(ptr uintptr) *PixbufAnimation {
	cls := &PixbufAnimation{}
	cls.Ptr = ptr
	return cls
}

var xNewPixbufAnimationFromFile func(string, **glib.Error) uintptr

// Creates a new animation by loading it from a file.
//
// The file format is detected automatically.
//
// If the file's format does not support multi-frame images, then an animation
// with a single frame will be created.
//
// Possible errors are in the `GDK_PIXBUF_ERROR` and `G_FILE_ERROR` domains.
func NewPixbufAnimationFromFile(FilenameVar string) (*PixbufAnimation, error) {
	var cls *PixbufAnimation
	var cerr *glib.Error

	cret := xNewPixbufAnimationFromFile(FilenameVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &PixbufAnimation{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufAnimationFromResource func(string, **glib.Error) uintptr

// Creates a new pixbuf animation by loading an image from an resource.
//
// The file format is detected automatically. If `NULL` is returned, then
// @error will be set.
func NewPixbufAnimationFromResource(ResourcePathVar string) (*PixbufAnimation, error) {
	var cls *PixbufAnimation
	var cerr *glib.Error

	cret := xNewPixbufAnimationFromResource(ResourcePathVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &PixbufAnimation{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufAnimationFromStream func(uintptr, uintptr, **glib.Error) uintptr

// Creates a new animation by loading it from an input stream.
//
// The file format is detected automatically.
//
// If `NULL` is returned, then @error will be set.
//
// The @cancellable can be used to abort the operation from another thread.
// If the operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
// returned. Other possible errors are in the `GDK_PIXBUF_ERROR` and
// `G_IO_ERROR` domains.
//
// The stream is not closed.
func NewPixbufAnimationFromStream(StreamVar *gio.InputStream, CancellableVar *gio.Cancellable) (*PixbufAnimation, error) {
	var cls *PixbufAnimation
	var cerr *glib.Error

	cret := xNewPixbufAnimationFromStream(StreamVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &PixbufAnimation{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufAnimationFromStreamFinish func(uintptr, **glib.Error) uintptr

// Finishes an asynchronous pixbuf animation creation operation started with
// [func@GdkPixbuf.PixbufAnimation.new_from_stream_async].
func NewPixbufAnimationFromStreamFinish(AsyncResultVar gio.AsyncResult) (*PixbufAnimation, error) {
	var cls *PixbufAnimation
	var cerr *glib.Error

	cret := xNewPixbufAnimationFromStreamFinish(AsyncResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &PixbufAnimation{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xPixbufAnimationGetHeight func(uintptr) int

// Queries the height of the bounding box of a pixbuf animation.
func (x *PixbufAnimation) GetHeight() int {

	cret := xPixbufAnimationGetHeight(x.GoPointer())
	return cret
}

var xPixbufAnimationGetIter func(uintptr, *glib.TimeVal) uintptr

// Get an iterator for displaying an animation.
//
// The iterator provides the frames that should be displayed at a
// given time.
//
// @start_time would normally come from g_get_current_time(), and marks
// the beginning of animation playback. After creating an iterator, you
// should immediately display the pixbuf returned by
// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install
// a timeout (with g_timeout_add()) or by some other mechanism ensure
// that you'll update the image after
// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. Each time
// the image is updated, you should reinstall the timeout with the new,
// possibly-changed delay time.
//
// As a shortcut, if @start_time is `NULL`, the result of
// g_get_current_time() will be used automatically.
//
// To update the image (i.e. possibly change the result of
// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
// call gdk_pixbuf_animation_iter_advance().
//
// If you're using #GdkPixbufLoader, in addition to updating the image
// after the delay time, you should also update it whenever you
// receive the area_updated signal and
// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns
// `TRUE`. In this case, the frame currently being fed into the loader
// has received new data, so needs to be refreshed. The delay time for
// a frame may also be modified after an area_updated signal, for
// example if the delay time for a frame is encoded in the data after
// the frame itself. So your timeout should be reinstalled after any
// area_updated signal.
//
// A delay time of -1 is possible, indicating "infinite".
func (x *PixbufAnimation) GetIter(StartTimeVar *glib.TimeVal) *PixbufAnimationIter {
	var cls *PixbufAnimationIter

	cret := xPixbufAnimationGetIter(x.GoPointer(), StartTimeVar)

	if cret == 0 {
		return nil
	}
	cls = &PixbufAnimationIter{}
	cls.Ptr = cret
	return cls
}

var xPixbufAnimationGetStaticImage func(uintptr) uintptr

// Retrieves a static image for the animation.
//
// If an animation is really just a plain image (has only one frame),
// this function returns that image.
//
// If the animation is an animation, this function returns a reasonable
// image to use as a static unanimated image, which might be the first
// frame, or something more sophisticated depending on the file format.
//
// If an animation hasn't loaded any frames yet, this function will
// return `NULL`.
func (x *PixbufAnimation) GetStaticImage() *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufAnimationGetStaticImage(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufAnimationGetWidth func(uintptr) int

// Queries the width of the bounding box of a pixbuf animation.
func (x *PixbufAnimation) GetWidth() int {

	cret := xPixbufAnimationGetWidth(x.GoPointer())
	return cret
}

var xPixbufAnimationIsStaticImage func(uintptr) bool

// Checks whether the animation is a static image.
//
// If you load a file with gdk_pixbuf_animation_new_from_file() and it
// turns out to be a plain, unanimated image, then this function will
// return `TRUE`. Use gdk_pixbuf_animation_get_static_image() to retrieve
// the image.
func (x *PixbufAnimation) IsStaticImage() bool {

	cret := xPixbufAnimationIsStaticImage(x.GoPointer())
	return cret
}

var xPixbufAnimationRef func(uintptr) uintptr

// Adds a reference to an animation.
func (x *PixbufAnimation) Ref() *PixbufAnimation {
	var cls *PixbufAnimation

	cret := xPixbufAnimationRef(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &PixbufAnimation{}
	cls.Ptr = cret
	return cls
}

var xPixbufAnimationUnref func(uintptr)

// Removes a reference from an animation.
func (x *PixbufAnimation) Unref() {

	xPixbufAnimationUnref(x.GoPointer())

}

func (c *PixbufAnimation) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *PixbufAnimation) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xPixbufAnimationNewFromStreamAsync func(uintptr, uintptr, uintptr, uintptr)

// Creates a new animation by asynchronously loading an image from an input stream.
//
// For more details see gdk_pixbuf_new_from_stream(), which is the synchronous
// version of this function.
//
// When the operation is finished, `callback` will be called in the main thread.
// You can then call gdk_pixbuf_animation_new_from_stream_finish() to get the
// result of the operation.
func PixbufAnimationNewFromStreamAsync(StreamVar *gio.InputStream, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xPixbufAnimationNewFromStreamAsync(StreamVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// An opaque object representing an iterator which points to a
// certain position in an animation.
type PixbufAnimationIter struct {
	gobject.Object
}

var xPixbufAnimationIterGLibType func() types.GType

func PixbufAnimationIterGLibType() types.GType {
	return xPixbufAnimationIterGLibType()
}

func PixbufAnimationIterNewFromInternalPtr(ptr uintptr) *PixbufAnimationIter {
	cls := &PixbufAnimationIter{}
	cls.Ptr = ptr
	return cls
}

var xPixbufAnimationIterAdvance func(uintptr, *glib.TimeVal) bool

// Possibly advances an animation to a new frame.
//
// Chooses the frame based on the start time passed to
// gdk_pixbuf_animation_get_iter().
//
// @current_time would normally come from g_get_current_time(), and
// must be greater than or equal to the time passed to
// gdk_pixbuf_animation_get_iter(), and must increase or remain
// unchanged each time gdk_pixbuf_animation_iter_get_pixbuf() is
// called. That is, you can't go backward in time; animations only
// play forward.
//
// As a shortcut, pass `NULL` for the current time and g_get_current_time()
// will be invoked on your behalf. So you only need to explicitly pass
// @current_time if you're doing something odd like playing the animation
// at double speed.
//
// If this function returns `FALSE`, there's no need to update the animation
// display, assuming the display had been rendered prior to advancing;
// if `TRUE`, you need to call gdk_pixbuf_animation_iter_get_pixbuf()
// and update the display with the new pixbuf.
func (x *PixbufAnimationIter) Advance(CurrentTimeVar *glib.TimeVal) bool {

	cret := xPixbufAnimationIterAdvance(x.GoPointer(), CurrentTimeVar)
	return cret
}

var xPixbufAnimationIterGetDelayTime func(uintptr) int

// Gets the number of milliseconds the current pixbuf should be displayed,
// or -1 if the current pixbuf should be displayed forever.
//
// The `g_timeout_add()` function conveniently takes a timeout in milliseconds,
// so you can use a timeout to schedule the next update.
//
// Note that some formats, like GIF, might clamp the timeout values in the
// image file to avoid updates that are just too quick. The minimum timeout
// for GIF images is currently 20 milliseconds.
func (x *PixbufAnimationIter) GetDelayTime() int {

	cret := xPixbufAnimationIterGetDelayTime(x.GoPointer())
	return cret
}

var xPixbufAnimationIterGetPixbuf func(uintptr) uintptr

// Gets the current pixbuf which should be displayed.
//
// The pixbuf might not be the same size as the animation itself
// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
//
// This pixbuf should be displayed for gdk_pixbuf_animation_iter_get_delay_time()
// milliseconds.
//
// The caller of this function does not own a reference to the returned
// pixbuf; the returned pixbuf will become invalid when the iterator
// advances to the next frame, which may happen anytime you call
// gdk_pixbuf_animation_iter_advance().
//
// Copy the pixbuf to keep it (don't just add a reference), as it may get
// recycled as you advance the iterator.
func (x *PixbufAnimationIter) GetPixbuf() *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufAnimationIterGetPixbuf(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufAnimationIterOnCurrentlyLoadingFrame func(uintptr) bool

// Used to determine how to respond to the area_updated signal on
// #GdkPixbufLoader when loading an animation.
//
// The `::area_updated` signal is emitted for an area of the frame currently
// streaming in to the loader. So if you're on the currently loading frame,
// you will need to redraw the screen for the updated area.
func (x *PixbufAnimationIter) OnCurrentlyLoadingFrame() bool {

	cret := xPixbufAnimationIterOnCurrentlyLoadingFrame(x.GoPointer())
	return cret
}

func (c *PixbufAnimationIter) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *PixbufAnimationIter) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GDKPIXBUF", "gdk-pixbuf-2.0")
	core.SetSharedLibraries("GDKPIXBUF", []string{"libgdk_pixbuf-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GDKPIXBUF") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPixbufAnimationGLibType, libs, "gdk_pixbuf_animation_get_type")

	core.PuregoSafeRegister(&xNewPixbufAnimationFromFile, libs, "gdk_pixbuf_animation_new_from_file")
	core.PuregoSafeRegister(&xNewPixbufAnimationFromResource, libs, "gdk_pixbuf_animation_new_from_resource")
	core.PuregoSafeRegister(&xNewPixbufAnimationFromStream, libs, "gdk_pixbuf_animation_new_from_stream")
	core.PuregoSafeRegister(&xNewPixbufAnimationFromStreamFinish, libs, "gdk_pixbuf_animation_new_from_stream_finish")

	core.PuregoSafeRegister(&xPixbufAnimationGetHeight, libs, "gdk_pixbuf_animation_get_height")
	core.PuregoSafeRegister(&xPixbufAnimationGetIter, libs, "gdk_pixbuf_animation_get_iter")
	core.PuregoSafeRegister(&xPixbufAnimationGetStaticImage, libs, "gdk_pixbuf_animation_get_static_image")
	core.PuregoSafeRegister(&xPixbufAnimationGetWidth, libs, "gdk_pixbuf_animation_get_width")
	core.PuregoSafeRegister(&xPixbufAnimationIsStaticImage, libs, "gdk_pixbuf_animation_is_static_image")
	core.PuregoSafeRegister(&xPixbufAnimationRef, libs, "gdk_pixbuf_animation_ref")
	core.PuregoSafeRegister(&xPixbufAnimationUnref, libs, "gdk_pixbuf_animation_unref")

	core.PuregoSafeRegister(&xPixbufAnimationNewFromStreamAsync, libs, "gdk_pixbuf_animation_new_from_stream_async")

	core.PuregoSafeRegister(&xPixbufAnimationIterGLibType, libs, "gdk_pixbuf_animation_iter_get_type")

	core.PuregoSafeRegister(&xPixbufAnimationIterAdvance, libs, "gdk_pixbuf_animation_iter_advance")
	core.PuregoSafeRegister(&xPixbufAnimationIterGetDelayTime, libs, "gdk_pixbuf_animation_iter_get_delay_time")
	core.PuregoSafeRegister(&xPixbufAnimationIterGetPixbuf, libs, "gdk_pixbuf_animation_iter_get_pixbuf")
	core.PuregoSafeRegister(&xPixbufAnimationIterOnCurrentlyLoadingFrame, libs, "gdk_pixbuf_animation_iter_on_currently_loading_frame")

}
