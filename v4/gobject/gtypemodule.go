// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// In order to implement dynamic loading of types based on #GTypeModule,
// the @load and @unload functions in #GTypeModuleClass must be implemented.
type TypeModuleClass struct {
	_ structs.HostLayout

	ParentClass ObjectClass

	xLoad uintptr

	xUnload uintptr

	xReserved1 uintptr

	xReserved2 uintptr

	xReserved3 uintptr

	xReserved4 uintptr
}

func (x *TypeModuleClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideLoad sets the callback function.
// loads the module and registers one or more types using
//
//	g_type_module_register_type().
func (x *TypeModuleClass) OverrideLoad(cb func(*TypeModule) bool) {
	if cb == nil {
		x.xLoad = 0
	} else {
		x.xLoad = purego.NewCallback(func(ModuleVarp uintptr) bool {
			return cb(TypeModuleNewFromInternalPtr(ModuleVarp))
		})
	}
}

// GetLoad gets the callback function.
// loads the module and registers one or more types using
//
//	g_type_module_register_type().
func (x *TypeModuleClass) GetLoad() func(*TypeModule) bool {
	if x.xLoad == 0 {
		return nil
	}
	var rawCallback func(ModuleVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xLoad)
	return func(ModuleVar *TypeModule) bool {
		return rawCallback(ModuleVar.GoPointer())
	}
}

// OverrideUnload sets the callback function.
// unloads the module
func (x *TypeModuleClass) OverrideUnload(cb func(*TypeModule)) {
	if cb == nil {
		x.xUnload = 0
	} else {
		x.xUnload = purego.NewCallback(func(ModuleVarp uintptr) {
			cb(TypeModuleNewFromInternalPtr(ModuleVarp))
		})
	}
}

// GetUnload gets the callback function.
// unloads the module
func (x *TypeModuleClass) GetUnload() func(*TypeModule) {
	if x.xUnload == 0 {
		return nil
	}
	var rawCallback func(ModuleVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnload)
	return func(ModuleVar *TypeModule) {
		rawCallback(ModuleVar.GoPointer())
	}
}

// OverrideReserved1 sets the callback function.
func (x *TypeModuleClass) OverrideReserved1(cb func()) {
	if cb == nil {
		x.xReserved1 = 0
	} else {
		x.xReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetReserved1 gets the callback function.
func (x *TypeModuleClass) GetReserved1() func() {
	if x.xReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideReserved2 sets the callback function.
func (x *TypeModuleClass) OverrideReserved2(cb func()) {
	if cb == nil {
		x.xReserved2 = 0
	} else {
		x.xReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetReserved2 gets the callback function.
func (x *TypeModuleClass) GetReserved2() func() {
	if x.xReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideReserved3 sets the callback function.
func (x *TypeModuleClass) OverrideReserved3(cb func()) {
	if cb == nil {
		x.xReserved3 = 0
	} else {
		x.xReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetReserved3 gets the callback function.
func (x *TypeModuleClass) GetReserved3() func() {
	if x.xReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideReserved4 sets the callback function.
func (x *TypeModuleClass) OverrideReserved4(cb func()) {
	if cb == nil {
		x.xReserved4 = 0
	} else {
		x.xReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetReserved4 gets the callback function.
func (x *TypeModuleClass) GetReserved4() func() {
	if x.xReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xReserved4)
	return func() {
		rawCallback()
	}
}

// `GTypeModule` provides a simple implementation of the `GTypePlugin`
// interface.
//
// The model of `GTypeModule` is a dynamically loaded module which
// implements some number of types and interface implementations.
//
// When the module is loaded, it registers its types and interfaces
// using [method@GObject.TypeModule.register_type] and
// [method@GObject.TypeModule.add_interface].
// As long as any instances of these types and interface implementations
// are in use, the module is kept loaded. When the types and interfaces
// are gone, the module may be unloaded. If the types and interfaces
// become used again, the module will be reloaded. Note that the last
// reference cannot be released from within the module code, since that
// would lead to the caller's code being unloaded before `g_object_unref()`
// returns to it.
//
// Keeping track of whether the module should be loaded or not is done by
// using a use count - it starts at zero, and whenever it is greater than
// zero, the module is loaded. The use count is maintained internally by
// the type system, but also can be explicitly controlled by
// [method@GObject.TypeModule.use] and [method@GObject.TypeModule.unuse].
// Typically, when loading a module for the first type, `g_type_module_use()`
// will be used to load it so that it can initialize its types. At some later
// point, when the module no longer needs to be loaded except for the type
// implementations it contains, `g_type_module_unuse()` is called.
//
// `GTypeModule` does not actually provide any implementation of module
// loading and unloading. To create a particular module type you must
// derive from `GTypeModule` and implement the load and unload functions
// in `GTypeModuleClass`.
type TypeModule struct {
	Object
}

var xTypeModuleGLibType func() types.GType

func TypeModuleGLibType() types.GType {
	return xTypeModuleGLibType()
}

func TypeModuleNewFromInternalPtr(ptr uintptr) *TypeModule {
	cls := &TypeModule{}
	cls.Ptr = ptr
	return cls
}

var xTypeModuleAddInterface func(uintptr, types.GType, types.GType, *InterfaceInfo)

// Registers an additional interface for a type, whose interface lives
// in the given type plugin. If the interface was already registered
// for the type in this plugin, nothing will be done.
//
// As long as any instances of the type exist, the type plugin will
// not be unloaded.
//
// Since 2.56 if @module is %NULL this will call g_type_add_interface_static()
// instead. This can be used when making a static build of the module.
func (x *TypeModule) AddInterface(InstanceTypeVar types.GType, InterfaceTypeVar types.GType, InterfaceInfoVar *InterfaceInfo) {

	xTypeModuleAddInterface(x.GoPointer(), InstanceTypeVar, InterfaceTypeVar, InterfaceInfoVar)

}

var xTypeModuleRegisterEnum func(uintptr, string, []EnumValue) types.GType

// Looks up or registers an enumeration that is implemented with a particular
// type plugin. If a type with name @type_name was previously registered,
// the #GType identifier for the type is returned, otherwise the type
// is newly registered, and the resulting #GType identifier returned.
//
// As long as any instances of the type exist, the type plugin will
// not be unloaded.
//
// Since 2.56 if @module is %NULL this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (x *TypeModule) RegisterEnum(NameVar string, ConstStaticValuesVar []EnumValue) types.GType {

	cret := xTypeModuleRegisterEnum(x.GoPointer(), NameVar, ConstStaticValuesVar)
	return cret
}

var xTypeModuleRegisterFlags func(uintptr, string, []FlagsValue) types.GType

// Looks up or registers a flags type that is implemented with a particular
// type plugin. If a type with name @type_name was previously registered,
// the #GType identifier for the type is returned, otherwise the type
// is newly registered, and the resulting #GType identifier returned.
//
// As long as any instances of the type exist, the type plugin will
// not be unloaded.
//
// Since 2.56 if @module is %NULL this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (x *TypeModule) RegisterFlags(NameVar string, ConstStaticValuesVar []FlagsValue) types.GType {

	cret := xTypeModuleRegisterFlags(x.GoPointer(), NameVar, ConstStaticValuesVar)
	return cret
}

var xTypeModuleRegisterType func(uintptr, types.GType, string, *TypeInfo, TypeFlags) types.GType

// Looks up or registers a type that is implemented with a particular
// type plugin. If a type with name @type_name was previously registered,
// the #GType identifier for the type is returned, otherwise the type
// is newly registered, and the resulting #GType identifier returned.
//
// When reregistering a type (typically because a module is unloaded
// then reloaded, and reinitialized), @module and @parent_type must
// be the same as they were previously.
//
// As long as any instances of the type exist, the type plugin will
// not be unloaded.
//
// Since 2.56 if @module is %NULL this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (x *TypeModule) RegisterType(ParentTypeVar types.GType, TypeNameVar string, TypeInfoVar *TypeInfo, FlagsVar TypeFlags) types.GType {

	cret := xTypeModuleRegisterType(x.GoPointer(), ParentTypeVar, TypeNameVar, TypeInfoVar, FlagsVar)
	return cret
}

var xTypeModuleSetName func(uintptr, string)

// Sets the name for a #GTypeModule
func (x *TypeModule) SetName(NameVar string) {

	xTypeModuleSetName(x.GoPointer(), NameVar)

}

var xTypeModuleUnuse func(uintptr)

// Decreases the use count of a #GTypeModule by one. If the
// result is zero, the module will be unloaded. (However, the
// #GTypeModule will not be freed, and types associated with the
// #GTypeModule are not unregistered. Once a #GTypeModule is
// initialized, it must exist forever.)
func (x *TypeModule) Unuse() {

	xTypeModuleUnuse(x.GoPointer())

}

var xTypeModuleUse func(uintptr) bool

// Increases the use count of a #GTypeModule by one. If the
// use count was zero before, the plugin will be loaded.
// If loading the plugin fails, the use count is reset to
// its prior value.
func (x *TypeModule) Use() bool {

	cret := xTypeModuleUse(x.GoPointer())
	return cret
}

func (c *TypeModule) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *TypeModule) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Calls the @complete_interface_info function from the
// #GTypePluginClass of @plugin. There should be no need to use this
// function outside of the GObject type system itself.
func (x *TypeModule) CompleteInterfaceInfo(InstanceTypeVar types.GType, InterfaceTypeVar types.GType, InfoVar *InterfaceInfo) {

	XGTypePluginCompleteInterfaceInfo(x.GoPointer(), InstanceTypeVar, InterfaceTypeVar, InfoVar)

}

// Calls the @complete_type_info function from the #GTypePluginClass of @plugin.
// There should be no need to use this function outside of the GObject
// type system itself.
func (x *TypeModule) CompleteTypeInfo(GTypeVar types.GType, InfoVar *TypeInfo, ValueTableVar *TypeValueTable) {

	XGTypePluginCompleteTypeInfo(x.GoPointer(), GTypeVar, InfoVar, ValueTableVar)

}

func init() {
	core.SetPackageName("GOBJECT", "gobject-2.0")
	core.SetSharedLibraries("GOBJECT", []string{"libgobject-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GOBJECT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTypeModuleGLibType, libs, "g_type_module_get_type")

	core.PuregoSafeRegister(&xTypeModuleAddInterface, libs, "g_type_module_add_interface")
	core.PuregoSafeRegister(&xTypeModuleRegisterEnum, libs, "g_type_module_register_enum")
	core.PuregoSafeRegister(&xTypeModuleRegisterFlags, libs, "g_type_module_register_flags")
	core.PuregoSafeRegister(&xTypeModuleRegisterType, libs, "g_type_module_register_type")
	core.PuregoSafeRegister(&xTypeModuleSetName, libs, "g_type_module_set_name")
	core.PuregoSafeRegister(&xTypeModuleUnuse, libs, "g_type_module_unuse")
	core.PuregoSafeRegister(&xTypeModuleUse, libs, "g_type_module_use")

}
