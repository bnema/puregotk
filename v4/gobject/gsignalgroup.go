// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// `GSignalGroup` manages a collection of signals on a `GObject`.
//
// `GSignalGroup` simplifies the process of connecting  many signals to a `GObject`
// as a group. As such there is no API to disconnect a signal from the group.
//
// In particular, this allows you to:
//
//   - Change the target instance, which automatically causes disconnection
//     of the signals from the old instance and connecting to the new instance.
//   - Block and unblock signals as a group
//   - Ensuring that blocked state transfers across target instances.
//
// One place you might want to use such a structure is with `GtkTextView` and
// `GtkTextBuffer`. Often times, you'll need to connect to many signals on
// `GtkTextBuffer` from a `GtkTextView` subclass. This allows you to create a
// signal group during instance construction, simply bind the
// `GtkTextView:buffer` property to `GSignalGroup:target` and connect
// all the signals you need. When the `GtkTextView:buffer` property changes
// all of the signals will be transitioned correctly.
type SignalGroup struct {
	Object
}

var xSignalGroupGLibType func() types.GType

func SignalGroupGLibType() types.GType {
	return xSignalGroupGLibType()
}

func SignalGroupNewFromInternalPtr(ptr uintptr) *SignalGroup {
	cls := &SignalGroup{}
	cls.Ptr = ptr
	return cls
}

var xNewSignalGroup func(types.GType) uintptr

// Creates a new #GSignalGroup for target instances of @target_type.
func NewSignalGroup(TargetTypeVar types.GType) *SignalGroup {
	var cls *SignalGroup

	cret := xNewSignalGroup(TargetTypeVar)

	if cret == 0 {
		return nil
	}
	cls = &SignalGroup{}
	cls.Ptr = cret
	return cls
}

var xSignalGroupBlock func(uintptr)

// Blocks all signal handlers managed by @self so they will not
// be called during any signal emissions. Must be unblocked exactly
// the same number of times it has been blocked to become active again.
//
// This blocked state will be kept across changes of the target instance.
func (x *SignalGroup) Block() {

	xSignalGroupBlock(x.GoPointer())

}

var xSignalGroupConnect func(uintptr, string, uintptr, uintptr)

// Connects @c_handler to the signal @detailed_signal
// on the target instance of @self.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) Connect(DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr) {

	CHandlerVarPtr := uintptr(unsafe.Pointer(CHandlerVar))
	var CHandlerVarRef uintptr
	if cbRefPtr, ok := glib.GetCallback(CHandlerVarPtr); ok {
		CHandlerVarRef = cbRefPtr
	} else {
		fcb := func() {
			cbFn := *CHandlerVar
			cbFn()
		}
		CHandlerVarRef = purego.NewCallback(fcb)
		glib.SaveCallback(CHandlerVarPtr, CHandlerVarRef)
	}

	xSignalGroupConnect(x.GoPointer(), DetailedSignalVar, CHandlerVarRef, DataVar)

}

var xSignalGroupConnectAfter func(uintptr, string, uintptr, uintptr)

// Connects @c_handler to the signal @detailed_signal
// on the target instance of @self.
//
// The @c_handler will be called after the default handler of the signal.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectAfter(DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr) {

	CHandlerVarPtr := uintptr(unsafe.Pointer(CHandlerVar))
	var CHandlerVarRef uintptr
	if cbRefPtr, ok := glib.GetCallback(CHandlerVarPtr); ok {
		CHandlerVarRef = cbRefPtr
	} else {
		fcb := func() {
			cbFn := *CHandlerVar
			cbFn()
		}
		CHandlerVarRef = purego.NewCallback(fcb)
		glib.SaveCallback(CHandlerVarPtr, CHandlerVarRef)
	}

	xSignalGroupConnectAfter(x.GoPointer(), DetailedSignalVar, CHandlerVarRef, DataVar)

}

var xSignalGroupConnectClosure func(uintptr, string, *Closure, bool)

// Connects @closure to the signal @detailed_signal on #GSignalGroup:target.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectClosure(DetailedSignalVar string, ClosureVar *Closure, AfterVar bool) {

	xSignalGroupConnectClosure(x.GoPointer(), DetailedSignalVar, ClosureVar, AfterVar)

}

var xSignalGroupConnectData func(uintptr, string, uintptr, uintptr, uintptr, ConnectFlags)

// Connects @c_handler to the signal @detailed_signal
// on the target instance of @self.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectData(DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr, NotifyVar *ClosureNotify, FlagsVar ConnectFlags) {

	CHandlerVarPtr := uintptr(unsafe.Pointer(CHandlerVar))
	var CHandlerVarRef uintptr
	if cbRefPtr, ok := glib.GetCallback(CHandlerVarPtr); ok {
		CHandlerVarRef = cbRefPtr
	} else {
		fcb := func() {
			cbFn := *CHandlerVar
			cbFn()
		}
		CHandlerVarRef = purego.NewCallback(fcb)
		glib.SaveCallback(CHandlerVarPtr, CHandlerVarRef)
	}

	NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
	var NotifyVarRef uintptr
	if cbRefPtr, ok := glib.GetCallback(NotifyVarPtr); ok {
		NotifyVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 *Closure) {
			cbFn := *NotifyVar
			cbFn(arg0, arg1)
		}
		NotifyVarRef = purego.NewCallback(fcb)
		glib.SaveCallback(NotifyVarPtr, NotifyVarRef)
	}

	xSignalGroupConnectData(x.GoPointer(), DetailedSignalVar, CHandlerVarRef, DataVar, NotifyVarRef, FlagsVar)

}

var xSignalGroupConnectObject func(uintptr, string, uintptr, uintptr, ConnectFlags)

// Connects @c_handler to the signal @detailed_signal on #GSignalGroup:target.
//
// Ensures that the @object stays alive during the call to @c_handler
// by temporarily adding a reference count. When the @object is destroyed
// the signal handler will automatically be removed.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectObject(DetailedSignalVar string, CHandlerVar *Callback, ObjectVar uintptr, FlagsVar ConnectFlags) {

	CHandlerVarPtr := uintptr(unsafe.Pointer(CHandlerVar))
	var CHandlerVarRef uintptr
	if cbRefPtr, ok := glib.GetCallback(CHandlerVarPtr); ok {
		CHandlerVarRef = cbRefPtr
	} else {
		fcb := func() {
			cbFn := *CHandlerVar
			cbFn()
		}
		CHandlerVarRef = purego.NewCallback(fcb)
		glib.SaveCallback(CHandlerVarPtr, CHandlerVarRef)
	}

	xSignalGroupConnectObject(x.GoPointer(), DetailedSignalVar, CHandlerVarRef, ObjectVar, FlagsVar)

}

var xSignalGroupConnectSwapped func(uintptr, string, uintptr, uintptr)

// Connects @c_handler to the signal @detailed_signal
// on the target instance of @self.
//
// The instance on which the signal is emitted and @data
// will be swapped when calling @c_handler.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectSwapped(DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr) {

	CHandlerVarPtr := uintptr(unsafe.Pointer(CHandlerVar))
	var CHandlerVarRef uintptr
	if cbRefPtr, ok := glib.GetCallback(CHandlerVarPtr); ok {
		CHandlerVarRef = cbRefPtr
	} else {
		fcb := func() {
			cbFn := *CHandlerVar
			cbFn()
		}
		CHandlerVarRef = purego.NewCallback(fcb)
		glib.SaveCallback(CHandlerVarPtr, CHandlerVarRef)
	}

	xSignalGroupConnectSwapped(x.GoPointer(), DetailedSignalVar, CHandlerVarRef, DataVar)

}

var xSignalGroupDupTarget func(uintptr) uintptr

// Gets the target instance used when connecting signals.
func (x *SignalGroup) DupTarget() *Object {
	var cls *Object

	cret := xSignalGroupDupTarget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xSignalGroupSetTarget func(uintptr, uintptr)

// Sets the target instance used when connecting signals. Any signal
// that has been registered with g_signal_group_connect_object() or
// similar functions will be connected to this object.
//
// If the target instance was previously set, signals will be
// disconnected from that object prior to connecting to @target.
func (x *SignalGroup) SetTarget(TargetVar *Object) {

	xSignalGroupSetTarget(x.GoPointer(), TargetVar.GoPointer())

}

var xSignalGroupUnblock func(uintptr)

// Unblocks all signal handlers managed by @self so they will be
// called again during any signal emissions unless it is blocked
// again. Must be unblocked exactly the same number of times it
// has been blocked to become active again.
func (x *SignalGroup) Unblock() {

	xSignalGroupUnblock(x.GoPointer())

}

func (c *SignalGroup) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *SignalGroup) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal is emitted when #GSignalGroup:target is set to a new value
// other than %NULL. It is similar to #GObject::notify on `target` except it
// will not emit when #GSignalGroup:target is %NULL and also allows for
// receiving the #GObject without a data-race.
func (x *SignalGroup) ConnectBind(cb *func(SignalGroup, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return SignalConnect(x.GoPointer(), "bind", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, InstanceVarp uintptr) {
		fa := SignalGroup{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, InstanceVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return SignalConnect(x.GoPointer(), "bind", cbRefPtr)
}

// This signal is emitted when the target instance of @self is set to a
// new #GObject.
//
// This signal will only be emitted if the previous target of @self is
// non-%NULL.
func (x *SignalGroup) ConnectUnbind(cb *func(SignalGroup)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return SignalConnect(x.GoPointer(), "unbind", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := SignalGroup{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return SignalConnect(x.GoPointer(), "unbind", cbRefPtr)
}

func init() {
	core.SetPackageName("GOBJECT", "gobject-2.0")
	core.SetSharedLibraries("GOBJECT", []string{"libgobject-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GOBJECT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSignalGroupGLibType, libs, "g_signal_group_get_type")

	core.PuregoSafeRegister(&xNewSignalGroup, libs, "g_signal_group_new")

	core.PuregoSafeRegister(&xSignalGroupBlock, libs, "g_signal_group_block")
	core.PuregoSafeRegister(&xSignalGroupConnect, libs, "g_signal_group_connect")
	core.PuregoSafeRegister(&xSignalGroupConnectAfter, libs, "g_signal_group_connect_after")
	core.PuregoSafeRegister(&xSignalGroupConnectClosure, libs, "g_signal_group_connect_closure")
	core.PuregoSafeRegister(&xSignalGroupConnectData, libs, "g_signal_group_connect_data")
	core.PuregoSafeRegister(&xSignalGroupConnectObject, libs, "g_signal_group_connect_object")
	core.PuregoSafeRegister(&xSignalGroupConnectSwapped, libs, "g_signal_group_connect_swapped")
	core.PuregoSafeRegister(&xSignalGroupDupTarget, libs, "g_signal_group_dup_target")
	core.PuregoSafeRegister(&xSignalGroupSetTarget, libs, "g_signal_group_set_target")
	core.PuregoSafeRegister(&xSignalGroupUnblock, libs, "g_signal_group_unblock")

}
