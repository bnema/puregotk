// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A `GValueArray` is a container structure to hold an array of generic values.
//
// The prime purpose of a `GValueArray` is for it to be used as an
// object property that holds an array of values. A `GValueArray` wraps
// an array of `GValue` elements in order for it to be used as a boxed
// type through `G_TYPE_VALUE_ARRAY`.
//
// `GValueArray` is deprecated in favour of `GArray` since GLib 2.32.
// It is possible to create a `GArray` that behaves like a `GValueArray`
// by using the size of `GValue` as the element size, and by setting
// [method@GObject.Value.unset] as the clear function using
// [func@GLib.Array.set_clear_func], for instance, the following code:
//
// ```c
//
//	GValueArray *array = g_value_array_new (10);
//
// ```
//
// can be replaced by:
//
// ```c
//
//	GArray *array = g_array_sized_new (FALSE, TRUE, sizeof (GValue), 10);
//	g_array_set_clear_func (array, (GDestroyNotify) g_value_unset);
//
// ```
type ValueArray struct {
	_ structs.HostLayout

	NValues uint

	Values *Value

	NPrealloced uint
}

var xValueArrayGLibType func() types.GType

func ValueArrayGLibType() types.GType {
	return xValueArrayGLibType()
}

func (x *ValueArray) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewValueArray func(uint) *ValueArray

// Allocate and initialize a new #GValueArray, optionally preserve space
// for @n_prealloced elements. New arrays always contain 0 elements,
// regardless of the value of @n_prealloced.
func NewValueArray(NPreallocedVar uint) *ValueArray {

	cret := xNewValueArray(NPreallocedVar)

	return cret
}

var xValueArrayAppend func(uintptr, *Value) *ValueArray

// Insert a copy of @value as last element of @value_array. If @value is
// %NULL, an uninitialized value is appended.
func (x *ValueArray) Append(ValueVar *Value) *ValueArray {

	cret := xValueArrayAppend(x.GoPointer(), ValueVar)

	return cret
}

var xValueArrayCopy func(uintptr) *ValueArray

// Construct an exact copy of a #GValueArray by duplicating all its
// contents.
func (x *ValueArray) Copy() *ValueArray {

	cret := xValueArrayCopy(x.GoPointer())

	return cret
}

var xValueArrayFree func(uintptr)

// Free a #GValueArray including its contents.
func (x *ValueArray) Free() {

	xValueArrayFree(x.GoPointer())

}

var xValueArrayGetNth func(uintptr, uint) *Value

// Return a pointer to the value at @index_ contained in @value_array.
func (x *ValueArray) GetNth(IndexVar uint) *Value {

	cret := xValueArrayGetNth(x.GoPointer(), IndexVar)

	return cret
}

var xValueArrayInsert func(uintptr, uint, *Value) *ValueArray

// Insert a copy of @value at specified position into @value_array. If @value
// is %NULL, an uninitialized value is inserted.
func (x *ValueArray) Insert(IndexVar uint, ValueVar *Value) *ValueArray {

	cret := xValueArrayInsert(x.GoPointer(), IndexVar, ValueVar)

	return cret
}

var xValueArrayPrepend func(uintptr, *Value) *ValueArray

// Insert a copy of @value as first element of @value_array. If @value is
// %NULL, an uninitialized value is prepended.
func (x *ValueArray) Prepend(ValueVar *Value) *ValueArray {

	cret := xValueArrayPrepend(x.GoPointer(), ValueVar)

	return cret
}

var xValueArrayRemove func(uintptr, uint) *ValueArray

// Remove the value at position @index_ from @value_array.
func (x *ValueArray) Remove(IndexVar uint) *ValueArray {

	cret := xValueArrayRemove(x.GoPointer(), IndexVar)

	return cret
}

var xValueArraySort func(uintptr, uintptr) *ValueArray

// Sort @value_array using @compare_func to compare the elements according to
// the semantics of #GCompareFunc.
//
// The current implementation uses the same sorting algorithm as standard
// C qsort() function.
func (x *ValueArray) Sort(CompareFuncVar *glib.CompareFunc) *ValueArray {

	var CompareFuncVarRef uintptr
	if CompareFuncVar != nil {
		CompareFuncVarPtr := uintptr(unsafe.Pointer(CompareFuncVar))
		if cbRefPtr, ok := glib.GetCallback(CompareFuncVarPtr); ok {
			CompareFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) int {
				cbFn := *CompareFuncVar
				return cbFn(arg0, arg1)
			}
			CompareFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CompareFuncVarPtr, CompareFuncVarRef, CompareFuncVar)
		}
	}

	cret := xValueArraySort(x.GoPointer(), CompareFuncVarRef)

	return cret
}

var xValueArraySortWithData func(uintptr, uintptr, uintptr) *ValueArray

// Sort @value_array using @compare_func to compare the elements according
// to the semantics of #GCompareDataFunc.
//
// The current implementation uses the same sorting algorithm as standard
// C qsort() function.
func (x *ValueArray) SortWithData(CompareFuncVar *glib.CompareDataFunc, UserDataVar uintptr) *ValueArray {

	var CompareFuncVarRef uintptr
	if CompareFuncVar != nil {
		CompareFuncVarPtr := uintptr(unsafe.Pointer(CompareFuncVar))
		if cbRefPtr, ok := glib.GetCallback(CompareFuncVarPtr); ok {
			CompareFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) int {
				cbFn := *CompareFuncVar
				return cbFn(arg0, arg1, arg2)
			}
			CompareFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CompareFuncVarPtr, CompareFuncVarRef, CompareFuncVar)
		}
	}

	cret := xValueArraySortWithData(x.GoPointer(), CompareFuncVarRef, UserDataVar)

	return cret
}

func init() {
	core.SetPackageName("GOBJECT", "gobject-2.0")
	core.SetSharedLibraries("GOBJECT", []string{"libgobject-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GOBJECT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xValueArrayGLibType, libs, "g_value_array_get_type")

	core.PuregoSafeRegister(&xNewValueArray, libs, "g_value_array_new")

	core.PuregoSafeRegister(&xValueArrayAppend, libs, "g_value_array_append")
	core.PuregoSafeRegister(&xValueArrayCopy, libs, "g_value_array_copy")
	core.PuregoSafeRegister(&xValueArrayFree, libs, "g_value_array_free")
	core.PuregoSafeRegister(&xValueArrayGetNth, libs, "g_value_array_get_nth")
	core.PuregoSafeRegister(&xValueArrayInsert, libs, "g_value_array_insert")
	core.PuregoSafeRegister(&xValueArrayPrepend, libs, "g_value_array_prepend")
	core.PuregoSafeRegister(&xValueArrayRemove, libs, "g_value_array_remove")
	core.PuregoSafeRegister(&xValueArraySort, libs, "g_value_array_sort")
	core.PuregoSafeRegister(&xValueArraySortWithData, libs, "g_value_array_sort_with_data")

}
