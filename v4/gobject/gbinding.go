// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A function to be called to transform @from_value to @to_value.
//
// If this is the @transform_to function of a binding, then @from_value
// is the @source_property on the @source object, and @to_value is the
// @target_property on the @target object. If this is the
// @transform_from function of a %G_BINDING_BIDIRECTIONAL binding,
// then those roles are reversed.
type BindingTransformFunc func(uintptr, *Value, *Value, uintptr) bool

// Flags to be passed to g_object_bind_property() or
// g_object_bind_property_full().
//
// This enumeration can be extended at later date.
type BindingFlags int

var xBindingFlagsGLibType func() types.GType

func BindingFlagsGLibType() types.GType {
	return xBindingFlagsGLibType()
}

const (

	// The default binding; if the source property
	//   changes, the target property is updated with its value.
	GBindingDefaultValue BindingFlags = 0
	// Bidirectional binding; if either the
	//   property of the source or the property of the target changes,
	//   the other is updated.
	GBindingBidirectionalValue BindingFlags = 1
	// Synchronize the values of the source and
	//   target properties when creating the binding; the direction of
	//   the synchronization is always from the source to the target.
	GBindingSyncCreateValue BindingFlags = 2
	// If the two properties being bound are
	//   booleans, setting one to %TRUE will result in the other being
	//   set to %FALSE and vice versa. This flag will only work for
	//   boolean properties, and cannot be used when passing custom
	//   transformation functions to g_object_bind_property_full().
	GBindingInvertBooleanValue BindingFlags = 4
)

// `GObject` instance (or source) and another property on another `GObject`
// instance (or target).
//
// Whenever the source property changes, the same value is applied to the
// target property; for instance, the following binding:
//
// ```c
//
//	g_object_bind_property (object1, "property-a",
//	                        object2, "property-b",
//	                        G_BINDING_DEFAULT);
//
// ```
//
// will cause the property named "property-b" of @object2 to be updated
// every time [method@GObject.set] or the specific accessor changes the value of
// the property "property-a" of @object1.
//
// It is possible to create a bidirectional binding between two properties
// of two `GObject` instances, so that if either property changes, the
// other is updated as well, for instance:
//
// ```c
//
//	g_object_bind_property (object1, "property-a",
//	                        object2, "property-b",
//	                        G_BINDING_BIDIRECTIONAL);
//
// ```
//
// will keep the two properties in sync.
//
// It is also possible to set a custom transformation function (in both
// directions, in case of a bidirectional binding) to apply a custom
// transformation from the source value to the target value before
// applying it; for instance, the following binding:
//
// ```c
//
//	g_object_bind_property_full (adjustment1, "value",
//	                             adjustment2, "value",
//	                             G_BINDING_BIDIRECTIONAL,
//	                             celsius_to_fahrenheit,
//	                             fahrenheit_to_celsius,
//	                             NULL, NULL);
//
// ```
//
// will keep the "value" property of the two adjustments in sync; the
// @celsius_to_fahrenheit function will be called whenever the "value"
// property of @adjustment1 changes and will transform the current value
// of the property before applying it to the "value" property of @adjustment2.
//
// Vice versa, the @fahrenheit_to_celsius function will be called whenever
// the "value" property of @adjustment2 changes, and will transform the
// current value of the property before applying it to the "value" property
// of @adjustment1.
//
// Note that #GBinding does not resolve cycles by itself; a cycle like
//
// ```
//
//	object1:propertyA -&gt; object2:propertyB
//	object2:propertyB -&gt; object3:propertyC
//	object3:propertyC -&gt; object1:propertyA
//
// ```
//
// might lead to an infinite loop. The loop, in this particular case,
// can be avoided if the objects emit the `GObject::notify` signal only
// if the value has effectively been changed. A binding is implemented
// using the `GObject::notify` signal, so it is susceptible to all the
// various ways of blocking a signal emission, like [func@GObject.signal_stop_emission]
// or [func@GObject.signal_handler_block].
//
// A binding will be severed, and the resources it allocates freed, whenever
// either one of the `GObject` instances it refers to are finalized, or when
// the #GBinding instance loses its last reference.
//
// Bindings for languages with garbage collection can use
// [method@GObject.Binding.unbind] to explicitly release a binding between the source
// and target properties, instead of relying on the last reference on the
// binding, source, and target instances to drop.
type Binding struct {
	Object
}

var xBindingGLibType func() types.GType

func BindingGLibType() types.GType {
	return xBindingGLibType()
}

func BindingNewFromInternalPtr(ptr uintptr) *Binding {
	cls := &Binding{}
	cls.Ptr = ptr
	return cls
}

var xBindingDupSource func(uintptr) uintptr

// Retrieves the #GObject instance used as the source of the binding.
//
// A #GBinding can outlive the source #GObject as the binding does not hold a
// strong reference to the source. If the source is destroyed before the
// binding then this function will return %NULL.
func (x *Binding) DupSource() *Object {
	var cls *Object

	cret := xBindingDupSource(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingDupTarget func(uintptr) uintptr

// Retrieves the #GObject instance used as the target of the binding.
//
// A #GBinding can outlive the target #GObject as the binding does not hold a
// strong reference to the target. If the target is destroyed before the
// binding then this function will return %NULL.
func (x *Binding) DupTarget() *Object {
	var cls *Object

	cret := xBindingDupTarget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingGetFlags func(uintptr) BindingFlags

// Retrieves the flags passed when constructing the #GBinding.
func (x *Binding) GetFlags() BindingFlags {

	cret := xBindingGetFlags(x.GoPointer())
	return cret
}

var xBindingGetSource func(uintptr) uintptr

// Retrieves the #GObject instance used as the source of the binding.
//
// A #GBinding can outlive the source #GObject as the binding does not hold a
// strong reference to the source. If the source is destroyed before the
// binding then this function will return %NULL.
//
// Use g_binding_dup_source() if the source or binding are used from different
// threads as otherwise the pointer returned from this function might become
// invalid if the source is finalized from another thread in the meantime.
func (x *Binding) GetSource() *Object {
	var cls *Object

	cret := xBindingGetSource(x.GoPointer())

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingGetSourceProperty func(uintptr) string

// Retrieves the name of the property of #GBinding:source used as the source
// of the binding.
func (x *Binding) GetSourceProperty() string {

	cret := xBindingGetSourceProperty(x.GoPointer())
	return cret
}

var xBindingGetTarget func(uintptr) uintptr

// Retrieves the #GObject instance used as the target of the binding.
//
// A #GBinding can outlive the target #GObject as the binding does not hold a
// strong reference to the target. If the target is destroyed before the
// binding then this function will return %NULL.
//
// Use g_binding_dup_target() if the target or binding are used from different
// threads as otherwise the pointer returned from this function might become
// invalid if the target is finalized from another thread in the meantime.
func (x *Binding) GetTarget() *Object {
	var cls *Object

	cret := xBindingGetTarget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingGetTargetProperty func(uintptr) string

// Retrieves the name of the property of #GBinding:target used as the target
// of the binding.
func (x *Binding) GetTargetProperty() string {

	cret := xBindingGetTargetProperty(x.GoPointer())
	return cret
}

var xBindingUnbind func(uintptr)

// Explicitly releases the binding between the source and the target
// property expressed by @binding.
//
// This function will release the reference that is being held on
// the @binding instance if the binding is still bound; if you want to hold on
// to the #GBinding instance after calling g_binding_unbind(), you will need
// to hold a reference to it.
//
// Note however that this function does not take ownership of @binding, it
// only unrefs the reference that was initially created by
// g_object_bind_property() and is owned by the binding.
func (x *Binding) Unbind() {

	xBindingUnbind(x.GoPointer())

}

func (c *Binding) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Binding) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GOBJECT", "gobject-2.0")
	core.SetSharedLibraries("GOBJECT", []string{"libgobject-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GOBJECT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xBindingFlagsGLibType, libs, "g_binding_flags_get_type")

	core.PuregoSafeRegister(&xBindingGLibType, libs, "g_binding_get_type")

	core.PuregoSafeRegister(&xBindingDupSource, libs, "g_binding_dup_source")
	core.PuregoSafeRegister(&xBindingDupTarget, libs, "g_binding_dup_target")
	core.PuregoSafeRegister(&xBindingGetFlags, libs, "g_binding_get_flags")
	core.PuregoSafeRegister(&xBindingGetSource, libs, "g_binding_get_source")
	core.PuregoSafeRegister(&xBindingGetSourceProperty, libs, "g_binding_get_source_property")
	core.PuregoSafeRegister(&xBindingGetTarget, libs, "g_binding_get_target")
	core.PuregoSafeRegister(&xBindingGetTargetProperty, libs, "g_binding_get_target_property")
	core.PuregoSafeRegister(&xBindingUnbind, libs, "g_binding_unbind")

}
