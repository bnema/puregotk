// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `PangoFontMapClass` structure holds the virtual functions for
// a particular `PangoFontMap` implementation.
type FontMapClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xLoadFont uintptr

	xListFamilies uintptr

	xLoadFontset uintptr

	ShapeEngineType uintptr

	xGetSerial uintptr

	xChanged uintptr

	xGetFamily uintptr

	xGetFace uintptr
}

func (x *FontMapClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideLoadFont sets the "load_font" callback function.
// a function to load a font with a given description. See
// pango_font_map_load_font().
func (x *FontMapClass) OverrideLoadFont(cb func(*FontMap, *Context, *FontDescription) *Font) {
	if cb == nil {
		x.xLoadFont = 0
	} else {
		x.xLoadFont = purego.NewCallback(func(FontmapVarp uintptr, ContextVarp uintptr, DescVarp *FontDescription) uintptr {
			ret := cb(FontMapNewFromInternalPtr(FontmapVarp), ContextNewFromInternalPtr(ContextVarp), DescVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLoadFont gets the "load_font" callback function.
// a function to load a font with a given description. See
// pango_font_map_load_font().
func (x *FontMapClass) GetLoadFont() func(*FontMap, *Context, *FontDescription) *Font {
	if x.xLoadFont == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, ContextVarp uintptr, DescVarp *FontDescription) uintptr
	purego.RegisterFunc(&rawCallback, x.xLoadFont)
	return func(FontmapVar *FontMap, ContextVar *Context, DescVar *FontDescription) *Font {
		rawRet := rawCallback(FontmapVar.GoPointer(), ContextVar.GoPointer(), DescVar)
		if rawRet == 0 {
			return nil
		}
		ret := &Font{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideListFamilies sets the "list_families" callback function.
// A function to list available font families. See
// pango_font_map_list_families().
func (x *FontMapClass) OverrideListFamilies(cb func(*FontMap, *uintptr, *int)) {
	if cb == nil {
		x.xListFamilies = 0
	} else {
		x.xListFamilies = purego.NewCallback(func(FontmapVarp uintptr, FamiliesVarp *uintptr, NFamiliesVarp *int) {
			cb(FontMapNewFromInternalPtr(FontmapVarp), FamiliesVarp, NFamiliesVarp)
		})
	}
}

// GetListFamilies gets the "list_families" callback function.
// A function to list available font families. See
// pango_font_map_list_families().
func (x *FontMapClass) GetListFamilies() func(*FontMap, *uintptr, *int) {
	if x.xListFamilies == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, FamiliesVarp *uintptr, NFamiliesVarp *int)
	purego.RegisterFunc(&rawCallback, x.xListFamilies)
	return func(FontmapVar *FontMap, FamiliesVar *uintptr, NFamiliesVar *int) {
		rawCallback(FontmapVar.GoPointer(), FamiliesVar, NFamiliesVar)
	}
}

// OverrideLoadFontset sets the "load_fontset" callback function.
// a function to load a fontset with a given given description
// suitable for a particular language. See pango_font_map_load_fontset().
func (x *FontMapClass) OverrideLoadFontset(cb func(*FontMap, *Context, *FontDescription, *Language) *Fontset) {
	if cb == nil {
		x.xLoadFontset = 0
	} else {
		x.xLoadFontset = purego.NewCallback(func(FontmapVarp uintptr, ContextVarp uintptr, DescVarp *FontDescription, LanguageVarp *Language) uintptr {
			ret := cb(FontMapNewFromInternalPtr(FontmapVarp), ContextNewFromInternalPtr(ContextVarp), DescVarp, LanguageVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLoadFontset gets the "load_fontset" callback function.
// a function to load a fontset with a given given description
// suitable for a particular language. See pango_font_map_load_fontset().
func (x *FontMapClass) GetLoadFontset() func(*FontMap, *Context, *FontDescription, *Language) *Fontset {
	if x.xLoadFontset == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, ContextVarp uintptr, DescVarp *FontDescription, LanguageVarp *Language) uintptr
	purego.RegisterFunc(&rawCallback, x.xLoadFontset)
	return func(FontmapVar *FontMap, ContextVar *Context, DescVar *FontDescription, LanguageVar *Language) *Fontset {
		rawRet := rawCallback(FontmapVar.GoPointer(), ContextVar.GoPointer(), DescVar, LanguageVar)
		if rawRet == 0 {
			return nil
		}
		ret := &Fontset{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetSerial sets the "get_serial" callback function.
// a function to get the serial number of the fontmap.
// See pango_font_map_get_serial().
func (x *FontMapClass) OverrideGetSerial(cb func(*FontMap) uint) {
	if cb == nil {
		x.xGetSerial = 0
	} else {
		x.xGetSerial = purego.NewCallback(func(FontmapVarp uintptr) uint {
			return cb(FontMapNewFromInternalPtr(FontmapVarp))
		})
	}
}

// GetGetSerial gets the "get_serial" callback function.
// a function to get the serial number of the fontmap.
// See pango_font_map_get_serial().
func (x *FontMapClass) GetGetSerial() func(*FontMap) uint {
	if x.xGetSerial == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr) uint
	purego.RegisterFunc(&rawCallback, x.xGetSerial)
	return func(FontmapVar *FontMap) uint {
		return rawCallback(FontmapVar.GoPointer())
	}
}

// OverrideChanged sets the "changed" callback function.
// See pango_font_map_changed()
func (x *FontMapClass) OverrideChanged(cb func(*FontMap)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(FontmapVarp uintptr) {
			cb(FontMapNewFromInternalPtr(FontmapVarp))
		})
	}
}

// GetChanged gets the "changed" callback function.
// See pango_font_map_changed()
func (x *FontMapClass) GetChanged() func(*FontMap) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(FontmapVar *FontMap) {
		rawCallback(FontmapVar.GoPointer())
	}
}

// OverrideGetFamily sets the "get_family" callback function.
func (x *FontMapClass) OverrideGetFamily(cb func(*FontMap, string) *FontFamily) {
	if cb == nil {
		x.xGetFamily = 0
	} else {
		x.xGetFamily = purego.NewCallback(func(FontmapVarp uintptr, NameVarp string) uintptr {
			ret := cb(FontMapNewFromInternalPtr(FontmapVarp), NameVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetFamily gets the "get_family" callback function.
func (x *FontMapClass) GetGetFamily() func(*FontMap, string) *FontFamily {
	if x.xGetFamily == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, NameVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetFamily)
	return func(FontmapVar *FontMap, NameVar string) *FontFamily {
		rawRet := rawCallback(FontmapVar.GoPointer(), NameVar)
		if rawRet == 0 {
			return nil
		}
		ret := &FontFamily{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetFace sets the "get_face" callback function.
func (x *FontMapClass) OverrideGetFace(cb func(*FontMap, *Font) *FontFace) {
	if cb == nil {
		x.xGetFace = 0
	} else {
		x.xGetFace = purego.NewCallback(func(FontmapVarp uintptr, FontVarp uintptr) uintptr {
			ret := cb(FontMapNewFromInternalPtr(FontmapVarp), FontNewFromInternalPtr(FontVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetFace gets the "get_face" callback function.
func (x *FontMapClass) GetGetFace() func(*FontMap, *Font) *FontFace {
	if x.xGetFace == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, FontVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetFace)
	return func(FontmapVar *FontMap, FontVar *Font) *FontFace {
		rawRet := rawCallback(FontmapVar.GoPointer(), FontVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FontFace{}
		ret.Ptr = rawRet
		return ret
	}
}

// A `PangoFontMap` represents the set of fonts available for a
// particular rendering system.
//
// This is a virtual object with implementations being specific to
// particular rendering systems.
type FontMap struct {
	gobject.Object
}

var xFontMapGLibType func() types.GType

func FontMapGLibType() types.GType {
	return xFontMapGLibType()
}

func FontMapNewFromInternalPtr(ptr uintptr) *FontMap {
	cls := &FontMap{}
	cls.Ptr = ptr
	return cls
}

var xFontMapAddFontFile func(uintptr, string, **glib.Error) bool

// Loads a font file with one or more fonts into the `PangoFontMap`.
//
// The added fonts will take precedence over preexisting
// fonts with the same name.
func (x *FontMap) AddFontFile(FilenameVar string) (bool, error) {
	var cerr *glib.Error

	cret := xFontMapAddFontFile(x.GoPointer(), FilenameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFontMapChanged func(uintptr)

// Forces a change in the fontmap, which will cause any `PangoContext`
// using this fontmap to change.
//
// This function is only useful when implementing a new backend
// for Pango, something applications won't do. Backends should
// call this function if they have attached extra data to the
// fontmap and such data is changed.
func (x *FontMap) Changed() {

	xFontMapChanged(x.GoPointer())

}

var xFontMapCreateContext func(uintptr) uintptr

// Creates a `PangoContext` connected to @fontmap.
//
// This is equivalent to [ctor@Pango.Context.new] followed by
// [method@Pango.Context.set_font_map].
//
// If you are using Pango as part of a higher-level system,
// that system may have it's own way of create a `PangoContext`.
// For instance, the GTK toolkit has, among others,
// gtk_widget_get_pango_context(). Use those instead.
func (x *FontMap) CreateContext() *Context {
	var cls *Context

	cret := xFontMapCreateContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Context{}
	cls.Ptr = cret
	return cls
}

var xFontMapGetFamily func(uintptr, string) uintptr

// Gets a font family by name.
func (x *FontMap) GetFamily(NameVar string) *FontFamily {
	var cls *FontFamily

	cret := xFontMapGetFamily(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FontFamily{}
	cls.Ptr = cret
	return cls
}

var xFontMapGetSerial func(uintptr) uint

// Returns the current serial number of @fontmap.
//
// The serial number is initialized to an small number larger than zero
// when a new fontmap is created and is increased whenever the fontmap
// is changed. It may wrap, but will never have the value 0. Since it can
// wrap, never compare it with "less than", always use "not equals".
//
// The fontmap can only be changed using backend-specific API, like changing
// fontmap resolution.
//
// This can be used to automatically detect changes to a `PangoFontMap`,
// like in `PangoContext`.
func (x *FontMap) GetSerial() uint {

	cret := xFontMapGetSerial(x.GoPointer())
	return cret
}

var xFontMapListFamilies func(uintptr, *uintptr, *int)

// List all families for a fontmap.
//
// Note that the returned families are not in any particular order.
//
// `PangoFontMap` also implemented the [iface@Gio.ListModel] interface
// for enumerating families.
func (x *FontMap) ListFamilies(FamiliesVar *uintptr, NFamiliesVar *int) {

	xFontMapListFamilies(x.GoPointer(), FamiliesVar, NFamiliesVar)

}

var xFontMapLoadFont func(uintptr, uintptr, *FontDescription) uintptr

// Load the font in the fontmap that is the closest match for @desc.
func (x *FontMap) LoadFont(ContextVar *Context, DescVar *FontDescription) *Font {
	var cls *Font

	cret := xFontMapLoadFont(x.GoPointer(), ContextVar.GoPointer(), DescVar)

	if cret == 0 {
		return nil
	}
	cls = &Font{}
	cls.Ptr = cret
	return cls
}

var xFontMapLoadFontset func(uintptr, uintptr, *FontDescription, *Language) uintptr

// Load a set of fonts in the fontmap that can be used to render
// a font matching @desc.
func (x *FontMap) LoadFontset(ContextVar *Context, DescVar *FontDescription, LanguageVar *Language) *Fontset {
	var cls *Fontset

	cret := xFontMapLoadFontset(x.GoPointer(), ContextVar.GoPointer(), DescVar, LanguageVar)

	if cret == 0 {
		return nil
	}
	cls = &Fontset{}
	cls.Ptr = cret
	return cls
}

var xFontMapReloadFont func(uintptr, uintptr, float64, uintptr, uintptr) uintptr

// Returns a new font that is like @font, except that it is scaled
// by @scale, its backend-dependent configuration (e.g. cairo font options)
// is replaced by the one in @context, and its variations are replaced
// by @variations.
//
// Note that the scaling here is meant to be linear, so this
// scaling can be used to render a font on a hi-dpi display
// without changing its optical size.
func (x *FontMap) ReloadFont(FontVar *Font, ScaleVar float64, ContextVar *Context, VariationsVar *string) *Font {
	var cls *Font

	cret := xFontMapReloadFont(x.GoPointer(), FontVar.GoPointer(), ScaleVar, ContextVar.GoPointer(), core.NullableStringToPtr(VariationsVar))

	if cret == 0 {
		return nil
	}
	cls = &Font{}
	cls.Ptr = cret
	return cls
}

func (c *FontMap) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *FontMap) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// GetPropertyNItems gets the "n-items" property.
// The number of items contained in this list.
func (x *FontMap) GetPropertyNItems() uint {
	var v gobject.Value
	x.GetProperty("n-items", &v)
	return v.GetUint()
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// See also: g_list_model_get_n_items()
func (x *FontMap) GetItem(PositionVar uint) uintptr {

	cret := gio.XGListModelGetItem(x.GoPointer(), PositionVar)
	return cret
}

// Gets the type of the items in @list.
//
// All items returned from g_list_model_get_item() are of the type
// returned by this function, or a subtype, or if the type is an
// interface, they are an implementation of that interface.
//
// The item type of a #GListModel can not change during the life of the
// model.
func (x *FontMap) GetItemType() types.GType {

	cret := gio.XGListModelGetItemType(x.GoPointer())
	return cret
}

// Gets the number of items in @list.
//
// Depending on the model implementation, calling this function may be
// less efficient than iterating the list with increasing values for
// @position until g_list_model_get_item() returns %NULL.
func (x *FontMap) GetNItems() uint {

	cret := gio.XGListModelGetNItems(x.GoPointer())
	return cret
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// This function is meant to be used by language bindings in place
// of g_list_model_get_item().
//
// See also: g_list_model_get_n_items()
func (x *FontMap) GetObject(PositionVar uint) *gobject.Object {
	var cls *gobject.Object

	cret := gio.XGListModelGetObject(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Emits the #GListModel::items-changed signal on @list.
//
// This function should only be called by classes implementing
// #GListModel. It has to be called after the internal representation
// of @list has been updated, because handlers connected to this signal
// might query the new state of the list.
//
// Implementations must only make changes to the model (as visible to
// its consumer) in places that will not cause problems for that
// consumer.  For models that are driven directly by a write API (such
// as #GListStore), changes can be reported in response to uses of that
// API.  For models that represent remote data, changes should only be
// made from a fresh mainloop dispatch.  It is particularly not
// permitted to make changes in response to a call to the #GListModel
// consumer API.
//
// Stated another way: in general, it is assumed that code making a
// series of accesses to the model via the API, without returning to the
// mainloop, and without calling other code, will continue to view the
// same contents of the model.
func (x *FontMap) ItemsChanged(PositionVar uint, RemovedVar uint, AddedVar uint) {

	gio.XGListModelItemsChanged(x.GoPointer(), PositionVar, RemovedVar, AddedVar)

}

func init() {
	core.SetPackageName("PANGO", "pango")
	core.SetSharedLibraries("PANGO", []string{"libpango-1.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("PANGO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xFontMapGLibType, libs, "pango_font_map_get_type")

	core.PuregoSafeRegister(&xFontMapAddFontFile, libs, "pango_font_map_add_font_file")
	core.PuregoSafeRegister(&xFontMapChanged, libs, "pango_font_map_changed")
	core.PuregoSafeRegister(&xFontMapCreateContext, libs, "pango_font_map_create_context")
	core.PuregoSafeRegister(&xFontMapGetFamily, libs, "pango_font_map_get_family")
	core.PuregoSafeRegister(&xFontMapGetSerial, libs, "pango_font_map_get_serial")
	core.PuregoSafeRegister(&xFontMapListFamilies, libs, "pango_font_map_list_families")
	core.PuregoSafeRegister(&xFontMapLoadFont, libs, "pango_font_map_load_font")
	core.PuregoSafeRegister(&xFontMapLoadFontset, libs, "pango_font_map_load_fontset")
	core.PuregoSafeRegister(&xFontMapReloadFont, libs, "pango_font_map_reload_font")

}
