// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `PangoFontMapClass` structure holds the virtual functions for
// a particular `PangoFontMap` implementation.
type FontMapClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xLoadFont uintptr

	xListFamilies uintptr

	xLoadFontset uintptr

	ShapeEngineType uintptr

	xGetSerial uintptr

	xChanged uintptr

	xGetFamily uintptr

	xGetFace uintptr
}

func (x *FontMapClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideLoadFont sets the callback function.
func (x *FontMapClass) OverrideLoadFont(cb func(*FontMap, *Context, *FontDescription) *Font) {
	if cb == nil {
		x.xLoadFont = 0
	} else {
		x.xLoadFont = purego.NewCallback(func(FontmapVarp uintptr, ContextVarp uintptr, DescVarp *FontDescription) uintptr {
			ret := cb(FontMapNewFromInternalPtr(FontmapVarp), ContextNewFromInternalPtr(ContextVarp), DescVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLoadFont gets the callback function.
func (x *FontMapClass) GetLoadFont() func(*FontMap, *Context, *FontDescription) *Font {
	if x.xLoadFont == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, ContextVarp uintptr, DescVarp *FontDescription) uintptr
	purego.RegisterFunc(&rawCallback, x.xLoadFont)
	return func(FontmapVar *FontMap, ContextVar *Context, DescVar *FontDescription) *Font {
		rawRet := rawCallback(FontmapVar.GoPointer(), ContextVar.GoPointer(), DescVar)
		if rawRet == 0 {
			return nil
		}
		ret := &Font{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideListFamilies sets the callback function.
func (x *FontMapClass) OverrideListFamilies(cb func(*FontMap, uintptr, int)) {
	if cb == nil {
		x.xListFamilies = 0
	} else {
		x.xListFamilies = purego.NewCallback(func(FontmapVarp uintptr, FamiliesVarp uintptr, NFamiliesVarp int) {
			cb(FontMapNewFromInternalPtr(FontmapVarp), FamiliesVarp, NFamiliesVarp)
		})
	}
}

// GetListFamilies gets the callback function.
func (x *FontMapClass) GetListFamilies() func(*FontMap, uintptr, int) {
	if x.xListFamilies == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, FamiliesVarp uintptr, NFamiliesVarp int)
	purego.RegisterFunc(&rawCallback, x.xListFamilies)
	return func(FontmapVar *FontMap, FamiliesVar uintptr, NFamiliesVar int) {
		rawCallback(FontmapVar.GoPointer(), FamiliesVar, NFamiliesVar)
	}
}

// OverrideLoadFontset sets the callback function.
func (x *FontMapClass) OverrideLoadFontset(cb func(*FontMap, *Context, *FontDescription, *Language) *Fontset) {
	if cb == nil {
		x.xLoadFontset = 0
	} else {
		x.xLoadFontset = purego.NewCallback(func(FontmapVarp uintptr, ContextVarp uintptr, DescVarp *FontDescription, LanguageVarp *Language) uintptr {
			ret := cb(FontMapNewFromInternalPtr(FontmapVarp), ContextNewFromInternalPtr(ContextVarp), DescVarp, LanguageVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLoadFontset gets the callback function.
func (x *FontMapClass) GetLoadFontset() func(*FontMap, *Context, *FontDescription, *Language) *Fontset {
	if x.xLoadFontset == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, ContextVarp uintptr, DescVarp *FontDescription, LanguageVarp *Language) uintptr
	purego.RegisterFunc(&rawCallback, x.xLoadFontset)
	return func(FontmapVar *FontMap, ContextVar *Context, DescVar *FontDescription, LanguageVar *Language) *Fontset {
		rawRet := rawCallback(FontmapVar.GoPointer(), ContextVar.GoPointer(), DescVar, LanguageVar)
		if rawRet == 0 {
			return nil
		}
		ret := &Fontset{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetSerial sets the callback function.
func (x *FontMapClass) OverrideGetSerial(cb func(*FontMap) uint) {
	if cb == nil {
		x.xGetSerial = 0
	} else {
		x.xGetSerial = purego.NewCallback(func(FontmapVarp uintptr) uint {
			return cb(FontMapNewFromInternalPtr(FontmapVarp))
		})
	}
}

// GetGetSerial gets the callback function.
func (x *FontMapClass) GetGetSerial() func(*FontMap) uint {
	if x.xGetSerial == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr) uint
	purego.RegisterFunc(&rawCallback, x.xGetSerial)
	return func(FontmapVar *FontMap) uint {
		return rawCallback(FontmapVar.GoPointer())
	}
}

// OverrideChanged sets the callback function.
func (x *FontMapClass) OverrideChanged(cb func(*FontMap)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(FontmapVarp uintptr) {
			cb(FontMapNewFromInternalPtr(FontmapVarp))
		})
	}
}

// GetChanged gets the callback function.
func (x *FontMapClass) GetChanged() func(*FontMap) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(FontmapVar *FontMap) {
		rawCallback(FontmapVar.GoPointer())
	}
}

// OverrideGetFamily sets the callback function.
func (x *FontMapClass) OverrideGetFamily(cb func(*FontMap, string) *FontFamily) {
	if cb == nil {
		x.xGetFamily = 0
	} else {
		x.xGetFamily = purego.NewCallback(func(FontmapVarp uintptr, NameVarp string) uintptr {
			ret := cb(FontMapNewFromInternalPtr(FontmapVarp), NameVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetFamily gets the callback function.
func (x *FontMapClass) GetGetFamily() func(*FontMap, string) *FontFamily {
	if x.xGetFamily == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, NameVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetFamily)
	return func(FontmapVar *FontMap, NameVar string) *FontFamily {
		rawRet := rawCallback(FontmapVar.GoPointer(), NameVar)
		if rawRet == 0 {
			return nil
		}
		ret := &FontFamily{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetFace sets the callback function.
func (x *FontMapClass) OverrideGetFace(cb func(*FontMap, *Font) *FontFace) {
	if cb == nil {
		x.xGetFace = 0
	} else {
		x.xGetFace = purego.NewCallback(func(FontmapVarp uintptr, FontVarp uintptr) uintptr {
			ret := cb(FontMapNewFromInternalPtr(FontmapVarp), FontNewFromInternalPtr(FontVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetFace gets the callback function.
func (x *FontMapClass) GetGetFace() func(*FontMap, *Font) *FontFace {
	if x.xGetFace == 0 {
		return nil
	}
	var rawCallback func(FontmapVarp uintptr, FontVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetFace)
	return func(FontmapVar *FontMap, FontVar *Font) *FontFace {
		rawRet := rawCallback(FontmapVar.GoPointer(), FontVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FontFace{}
		ret.Ptr = rawRet
		return ret
	}
}

// A `PangoFontMap` represents the set of fonts available for a
// particular rendering system.
//
// This is a virtual object with implementations being specific to
// particular rendering systems.
type FontMap struct {
	gobject.Object
}

var xFontMapGLibType func() types.GType

func FontMapGLibType() types.GType {
	return xFontMapGLibType()
}

func FontMapNewFromInternalPtr(ptr uintptr) *FontMap {
	cls := &FontMap{}
	cls.Ptr = ptr
	return cls
}

var xFontMapChanged func(uintptr)

// Forces a change in the context, which will cause any `PangoContext`
// using this fontmap to change.
//
// This function is only useful when implementing a new backend
// for Pango, something applications won't do. Backends should
// call this function if they have attached extra data to the
// context and such data is changed.
func (x *FontMap) Changed() {

	xFontMapChanged(x.GoPointer())

}

var xFontMapCreateContext func(uintptr) uintptr

// Creates a `PangoContext` connected to @fontmap.
//
// This is equivalent to [ctor@Pango.Context.new] followed by
// [method@Pango.Context.set_font_map].
//
// If you are using Pango as part of a higher-level system,
// that system may have it's own way of create a `PangoContext`.
// For instance, the GTK toolkit has, among others,
// gtk_widget_get_pango_context(). Use those instead.
func (x *FontMap) CreateContext() *Context {
	var cls *Context

	cret := xFontMapCreateContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Context{}
	cls.Ptr = cret
	return cls
}

var xFontMapGetFamily func(uintptr, string) uintptr

// Gets a font family by name.
func (x *FontMap) GetFamily(NameVar string) *FontFamily {
	var cls *FontFamily

	cret := xFontMapGetFamily(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FontFamily{}
	cls.Ptr = cret
	return cls
}

var xFontMapGetSerial func(uintptr) uint

// Returns the current serial number of @fontmap.
//
// The serial number is initialized to an small number larger than zero
// when a new fontmap is created and is increased whenever the fontmap
// is changed. It may wrap, but will never have the value 0. Since it can
// wrap, never compare it with "less than", always use "not equals".
//
// The fontmap can only be changed using backend-specific API, like changing
// fontmap resolution.
//
// This can be used to automatically detect changes to a `PangoFontMap`,
// like in `PangoContext`.
func (x *FontMap) GetSerial() uint {

	cret := xFontMapGetSerial(x.GoPointer())
	return cret
}

var xFontMapListFamilies func(uintptr, uintptr, int)

// List all families for a fontmap.
func (x *FontMap) ListFamilies(FamiliesVar uintptr, NFamiliesVar int) {

	xFontMapListFamilies(x.GoPointer(), FamiliesVar, NFamiliesVar)

}

var xFontMapLoadFont func(uintptr, uintptr, *FontDescription) uintptr

// Load the font in the fontmap that is the closest match for @desc.
func (x *FontMap) LoadFont(ContextVar *Context, DescVar *FontDescription) *Font {
	var cls *Font

	cret := xFontMapLoadFont(x.GoPointer(), ContextVar.GoPointer(), DescVar)

	if cret == 0 {
		return nil
	}
	cls = &Font{}
	cls.Ptr = cret
	return cls
}

var xFontMapLoadFontset func(uintptr, uintptr, *FontDescription, *Language) uintptr

// Load a set of fonts in the fontmap that can be used to render
// a font matching @desc.
func (x *FontMap) LoadFontset(ContextVar *Context, DescVar *FontDescription, LanguageVar *Language) *Fontset {
	var cls *Fontset

	cret := xFontMapLoadFontset(x.GoPointer(), ContextVar.GoPointer(), DescVar, LanguageVar)

	if cret == 0 {
		return nil
	}
	cls = &Fontset{}
	cls.Ptr = cret
	return cls
}

func (c *FontMap) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *FontMap) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("PANGO", "pango")
	core.SetSharedLibrary("PANGO", "libpango-1.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFontMapGLibType, lib, "pango_font_map_get_type")

	core.PuregoSafeRegister(&xFontMapChanged, lib, "pango_font_map_changed")
	core.PuregoSafeRegister(&xFontMapCreateContext, lib, "pango_font_map_create_context")
	core.PuregoSafeRegister(&xFontMapGetFamily, lib, "pango_font_map_get_family")
	core.PuregoSafeRegister(&xFontMapGetSerial, lib, "pango_font_map_get_serial")
	core.PuregoSafeRegister(&xFontMapListFamilies, lib, "pango_font_map_list_families")
	core.PuregoSafeRegister(&xFontMapLoadFont, lib, "pango_font_map_load_font")
	core.PuregoSafeRegister(&xFontMapLoadFontset, lib, "pango_font_map_load_fontset")

}
