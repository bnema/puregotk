// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// `GStringChunk` provides efficient storage of groups of strings
//
// String chunks are used to store groups of strings. Memory is
// allocated in blocks, and as strings are added to the `GStringChunk`
// they are copied into the next free position in a block. When a block
// is full a new block is allocated.
//
// When storing a large number of strings, string chunks are more
// efficient than using [func@GLib.strdup] since fewer calls to `malloc()`
// are needed, and less memory is wasted in memory allocation overheads.
//
// By adding strings with [method@GLib.StringChunk.insert_const] it is also
// possible to remove duplicates.
//
// To create a new `GStringChunk` use [func@GLib.StringChunk.new].
//
// To add strings to a `GStringChunk` use [method@GLib.StringChunk.insert].
//
// To add strings to a `GStringChunk`, but without duplicating strings
// which are already in the `GStringChunk`, use [method@GLib.StringChunk.insert_const].
//
// To free the entire `GStringChunk` use [method@GLib.StringChunk.free].
// It is not possible to free individual strings.
type StringChunk struct {
	_ structs.HostLayout
}

func (x *StringChunk) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xStringChunkClear func(uintptr)

// Frees all strings contained within the #GStringChunk.
// After calling g_string_chunk_clear() it is not safe to
// access any of the strings which were contained within it.
func (x *StringChunk) Clear() {

	xStringChunkClear(x.GoPointer())

}

var xStringChunkFree func(uintptr)

// Frees all memory allocated by the #GStringChunk.
// After calling g_string_chunk_free() it is not safe to
// access any of the strings which were contained within it.
func (x *StringChunk) Free() {

	xStringChunkFree(x.GoPointer())

}

var xStringChunkInsert func(uintptr, string) string

// Adds a copy of @string to the #GStringChunk.
// It returns a pointer to the new copy of the string
// in the #GStringChunk. The characters in the string
// can be changed, if necessary, though you should not
// change anything after the end of the string.
//
// Unlike g_string_chunk_insert_const(), this function
// does not check for duplicates. Also strings added
// with g_string_chunk_insert() will not be searched
// by g_string_chunk_insert_const() when looking for
// duplicates.
func (x *StringChunk) Insert(StringVar string) string {

	cret := xStringChunkInsert(x.GoPointer(), StringVar)
	return cret
}

var xStringChunkInsertConst func(uintptr, string) string

// Adds a copy of @string to the #GStringChunk, unless the same
// string has already been added to the #GStringChunk with
// g_string_chunk_insert_const().
//
// This function is useful if you need to copy a large number
// of strings but do not want to waste space storing duplicates.
// But you must remember that there may be several pointers to
// the same string, and so any changes made to the strings
// should be done very carefully.
//
// Note that g_string_chunk_insert_const() will not return a
// pointer to a string added with g_string_chunk_insert(), even
// if they do match.
func (x *StringChunk) InsertConst(StringVar string) string {

	cret := xStringChunkInsertConst(x.GoPointer(), StringVar)
	return cret
}

var xStringChunkInsertLen func(uintptr, string, int) string

// Adds a copy of the first @len bytes of @string to the #GStringChunk.
// The copy is nul-terminated.
//
// Since this function does not stop at nul bytes, it is the caller's
// responsibility to ensure that @string has at least @len addressable
// bytes.
//
// The characters in the returned string can be changed, if necessary,
// though you should not change anything after the end of the string.
func (x *StringChunk) InsertLen(StringVar string, LenVar int) string {

	cret := xStringChunkInsertLen(x.GoPointer(), StringVar, LenVar)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xStringChunkClear, libs, "g_string_chunk_clear")
	core.PuregoSafeRegister(&xStringChunkFree, libs, "g_string_chunk_free")
	core.PuregoSafeRegister(&xStringChunkInsert, libs, "g_string_chunk_insert")
	core.PuregoSafeRegister(&xStringChunkInsertConst, libs, "g_string_chunk_insert_const")
	core.PuregoSafeRegister(&xStringChunkInsertLen, libs, "g_string_chunk_insert_len")

}
