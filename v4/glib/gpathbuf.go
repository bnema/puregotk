// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// `GPathBuf` is a helper type that allows you to easily build paths from
// individual elements, using the platform specific conventions for path
// separators.
//
// ```c
// g_auto (GPathBuf) path;
//
// g_path_buf_init (&amp;path);
//
// g_path_buf_push (&amp;path, "usr");
// g_path_buf_push (&amp;path, "bin");
// g_path_buf_push (&amp;path, "echo");
//
// g_autofree char *echo = g_path_buf_to_path (&amp;path);
// g_assert_cmpstr (echo, ==, "/usr/bin/echo");
// ```
//
// You can also load a full path and then operate on its components:
//
// ```c
// g_auto (GPathBuf) path;
//
// g_path_buf_init_from_path (&amp;path, "/usr/bin/echo");
//
// g_path_buf_pop (&amp;path);
// g_path_buf_push (&amp;path, "sh");
//
// g_autofree char *sh = g_path_buf_to_path (&amp;path);
// g_assert_cmpstr (sh, ==, "/usr/bin/sh");
// ```
type PathBuf struct {
	_ structs.HostLayout

	Dummy [8]uintptr
}

func (x *PathBuf) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xPathBufClear func(uintptr)

// Clears the contents of the path buffer.
//
// This function should be use to free the resources in a stack-allocated
// `GPathBuf` initialized using g_path_buf_init() or
// g_path_buf_init_from_path().
func (x *PathBuf) Clear() {

	xPathBufClear(x.GoPointer())

}

var xPathBufClearToPath func(uintptr) string

// Clears the contents of the path buffer and returns the built path.
//
// This function returns `NULL` if the `GPathBuf` is empty.
//
// See also: g_path_buf_to_path()
func (x *PathBuf) ClearToPath() string {

	cret := xPathBufClearToPath(x.GoPointer())
	return cret
}

var xPathBufCopy func(uintptr) *PathBuf

// Copies the contents of a path buffer into a new `GPathBuf`.
func (x *PathBuf) Copy() *PathBuf {

	cret := xPathBufCopy(x.GoPointer())
	return cret
}

var xPathBufFree func(uintptr)

// Frees a `GPathBuf` allocated by g_path_buf_new().
func (x *PathBuf) Free() {

	xPathBufFree(x.GoPointer())

}

var xPathBufFreeToPath func(uintptr) string

// Frees a `GPathBuf` allocated by g_path_buf_new(), and
// returns the path inside the buffer.
//
// This function returns `NULL` if the `GPathBuf` is empty.
//
// See also: g_path_buf_to_path()
func (x *PathBuf) FreeToPath() string {

	cret := xPathBufFreeToPath(x.GoPointer())
	return cret
}

var xPathBufInit func(uintptr) *PathBuf

// Initializes a `GPathBuf` instance.
func (x *PathBuf) Init() *PathBuf {

	cret := xPathBufInit(x.GoPointer())
	return cret
}

var xPathBufInitFromPath func(uintptr, string) *PathBuf

// Initializes a `GPathBuf` instance with the given path.
func (x *PathBuf) InitFromPath(PathVar string) *PathBuf {

	cret := xPathBufInitFromPath(x.GoPointer(), PathVar)
	return cret
}

var xPathBufPop func(uintptr) bool

// Removes the last element of the path buffer.
//
// If there is only one element in the path buffer (for example, `/` on
// Unix-like operating systems or the drive on Windows systems), it will
// not be removed and %FALSE will be returned instead.
//
// |[&lt;!-- language="C" --&gt;
// GPathBuf buf, cmp;
//
// g_path_buf_init_from_path (&amp;buf, "/bin/sh");
//
// g_path_buf_pop (&amp;buf);
// g_path_buf_init_from_path (&amp;cmp, "/bin");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
//
// g_path_buf_pop (&amp;buf);
// g_path_buf_init_from_path (&amp;cmp, "/");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
//
// g_path_buf_clear (&amp;buf);
// ]|
func (x *PathBuf) Pop() bool {

	cret := xPathBufPop(x.GoPointer())
	return cret
}

var xPathBufPush func(uintptr, string) *PathBuf

// Extends the given path buffer with @path.
//
// If @path is absolute, it replaces the current path.
//
// If @path contains a directory separator, the buffer is extended by
// as many elements the path provides.
//
// On Windows, both forward slashes and backslashes are treated as
// directory separators. On other platforms, %G_DIR_SEPARATOR_S is the
// only directory separator.
//
// |[&lt;!-- language="C" --&gt;
// GPathBuf buf, cmp;
//
// g_path_buf_init_from_path (&amp;buf, "/tmp");
// g_path_buf_push (&amp;buf, ".X11-unix/X0");
// g_path_buf_init_from_path (&amp;cmp, "/tmp/.X11-unix/X0");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
//
// g_path_buf_push (&amp;buf, "/etc/locale.conf");
// g_path_buf_init_from_path (&amp;cmp, "/etc/locale.conf");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
//
// g_path_buf_clear (&amp;buf);
// ]|
func (x *PathBuf) Push(PathVar string) *PathBuf {

	cret := xPathBufPush(x.GoPointer(), PathVar)
	return cret
}

var xPathBufSetExtension func(uintptr, string) bool

// Adds an extension to the file name in the path buffer.
//
// If @extension is `NULL`, the extension will be unset.
//
// If the path buffer does not have a file name set, this function returns
// `FALSE` and leaves the path buffer unmodified.
func (x *PathBuf) SetExtension(ExtensionVar string) bool {

	cret := xPathBufSetExtension(x.GoPointer(), ExtensionVar)
	return cret
}

var xPathBufSetFilename func(uintptr, string) bool

// Sets the file name of the path.
//
// If the path buffer is empty, the filename is left unset and this
// function returns `FALSE`.
//
// If the path buffer only contains the root element (on Unix-like operating
// systems) or the drive (on Windows), this is the equivalent of pushing
// the new @file_name.
//
// If the path buffer contains a path, this is the equivalent of
// popping the path buffer and pushing @file_name, creating a
// sibling of the original path.
//
// |[&lt;!-- language="C" --&gt;
// GPathBuf buf, cmp;
//
// g_path_buf_init_from_path (&amp;buf, "/");
//
// g_path_buf_set_filename (&amp;buf, "bar");
// g_path_buf_init_from_path (&amp;cmp, "/bar");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
//
// g_path_buf_set_filename (&amp;buf, "baz.txt");
// g_path_buf_init_from_path (&amp;cmp, "/baz.txt");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp);
// g_path_buf_clear (&amp;cmp);
//
// g_path_buf_clear (&amp;buf);
// ]|
func (x *PathBuf) SetFilename(FileNameVar string) bool {

	cret := xPathBufSetFilename(x.GoPointer(), FileNameVar)
	return cret
}

var xPathBufToPath func(uintptr) string

// Retrieves the built path from the path buffer.
//
// On Windows, the result contains backslashes as directory separators,
// even if forward slashes were used in input.
//
// If the path buffer is empty, this function returns `NULL`.
func (x *PathBuf) ToPath() string {

	cret := xPathBufToPath(x.GoPointer())
	return cret
}

var xPathBufEqual func(uintptr, uintptr) bool

// Compares two path buffers for equality and returns `TRUE`
// if they are equal.
//
// The paths inside the path buffers are not going to be normalized,
// so `X/Y/Z/A/..`, `X/./Y/Z` and `X/Y/Z` are not going to be considered
// equal.
//
// This function can be passed to g_hash_table_new() as the
// `key_equal_func` parameter.
func PathBufEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xPathBufEqual(V1Var, V2Var)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPathBufEqual, libs, "g_path_buf_equal")

	core.PuregoSafeRegister(&xPathBufClear, libs, "g_path_buf_clear")
	core.PuregoSafeRegister(&xPathBufClearToPath, libs, "g_path_buf_clear_to_path")
	core.PuregoSafeRegister(&xPathBufCopy, libs, "g_path_buf_copy")
	core.PuregoSafeRegister(&xPathBufFree, libs, "g_path_buf_free")
	core.PuregoSafeRegister(&xPathBufFreeToPath, libs, "g_path_buf_free_to_path")
	core.PuregoSafeRegister(&xPathBufInit, libs, "g_path_buf_init")
	core.PuregoSafeRegister(&xPathBufInitFromPath, libs, "g_path_buf_init_from_path")
	core.PuregoSafeRegister(&xPathBufPop, libs, "g_path_buf_pop")
	core.PuregoSafeRegister(&xPathBufPush, libs, "g_path_buf_push")
	core.PuregoSafeRegister(&xPathBufSetExtension, libs, "g_path_buf_set_extension")
	core.PuregoSafeRegister(&xPathBufSetFilename, libs, "g_path_buf_set_filename")
	core.PuregoSafeRegister(&xPathBufToPath, libs, "g_path_buf_to_path")

}
