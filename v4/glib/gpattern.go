// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A `GPatternSpec` struct is the ‘compiled’ form of a glob-style pattern.
//
// The [func@GLib.pattern_match_simple] and [method@GLib.PatternSpec.match] functions
// match a string against a pattern containing `*` and `?` wildcards with similar
// semantics as the standard `glob()` function: `*` matches an arbitrary,
// possibly empty, string, `?` matches an arbitrary character.
//
// Note that in contrast to [`glob()`](man:glob(3)), the `/` character can be
// matched by the wildcards, there are no `[…]` character ranges and `*` and `?`
// can not be escaped to include them literally in a pattern.
//
// When multiple strings must be matched against the same pattern, it is better
// to compile the pattern to a [struct@GLib.PatternSpec] using
// [ctor@GLib.PatternSpec.new] and use [method@GLib.PatternSpec.match_string]
// instead of [func@GLib.pattern_match_simple]. This avoids the overhead of repeated
// pattern compilation.
type PatternSpec struct {
	_ structs.HostLayout
}

var xPatternSpecGLibType func() types.GType

func PatternSpecGLibType() types.GType {
	return xPatternSpecGLibType()
}

func (x *PatternSpec) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewPatternSpec func(string) *PatternSpec

// Compiles a pattern to a [type@GLib.PatternSpec].
func NewPatternSpec(PatternVar string) *PatternSpec {

	cret := xNewPatternSpec(PatternVar)
	return cret
}

var xPatternSpecCopy func(uintptr) *PatternSpec

// Copies @pspec in a new [type@GLib.PatternSpec].
func (x *PatternSpec) Copy() *PatternSpec {

	cret := xPatternSpecCopy(x.GoPointer())
	return cret
}

var xPatternSpecEqual func(uintptr, *PatternSpec) bool

// Compares two compiled pattern specs and returns whether they will
// match the same set of strings.
func (x *PatternSpec) Equal(Pspec2Var *PatternSpec) bool {

	cret := xPatternSpecEqual(x.GoPointer(), Pspec2Var)
	return cret
}

var xPatternSpecFree func(uintptr)

// Frees the memory allocated for the [type@GLib.PatternSpec].
func (x *PatternSpec) Free() {

	xPatternSpecFree(x.GoPointer())

}

var xPatternSpecMatch func(uintptr, uint, string, uintptr) bool

// Matches a string against a compiled pattern.
//
// Passing the correct
// length of the string given is mandatory. The reversed string can be
// omitted by passing `NULL`, this is more efficient if the reversed
// version of the string to be matched is not at hand, as
// [method@GLib.PatternSpec.match] will only construct it if the compiled pattern
// requires reverse matches.
//
// Note that, if the user code will (possibly) match a string against a
// multitude of patterns containing wildcards, chances are high that
// some patterns will require a reversed string. In this case, it’s
// more efficient to provide the reversed string to avoid multiple
// constructions thereof in the various calls to [method@GLib.PatternSpec.match].
//
// Note also that the reverse of a UTF-8 encoded string can in general
// not be obtained by [func@GLib.strreverse]. This works only if the string
// does not contain any multibyte characters. GLib offers the
// [func@GLib.utf8_strreverse] function to reverse UTF-8 encoded strings.
func (x *PatternSpec) Match(StringLengthVar uint, StringVar string, StringReversedVar *string) bool {

	cret := xPatternSpecMatch(x.GoPointer(), StringLengthVar, StringVar, core.NullableStringToPtr(StringReversedVar))
	return cret
}

var xPatternSpecMatchString func(uintptr, string) bool

// Matches a string against a compiled pattern.
//
// If the string is to be
// matched against more than one pattern, consider using
// [method@GLib.PatternSpec.match] instead while supplying the reversed string.
func (x *PatternSpec) MatchString(StringVar string) bool {

	cret := xPatternSpecMatchString(x.GoPointer(), StringVar)
	return cret
}

var xPatternMatch func(*PatternSpec, uint, string, uintptr) bool

// Matches a string against a compiled pattern.
//
// Passing the correct
// length of the string given is mandatory. The reversed string can be
// omitted by passing `NULL`, this is more efficient if the reversed
// version of the string to be matched is not at hand, as
// `g_pattern_match()` will only construct it if the compiled pattern
// requires reverse matches.
//
// Note that, if the user code will (possibly) match a string against a
// multitude of patterns containing wildcards, chances are high that
// some patterns will require a reversed string. In this case, it’s
// more efficient to provide the reversed string to avoid multiple
// constructions thereof in the various calls to `g_pattern_match()`.
//
// Note also that the reverse of a UTF-8 encoded string can in general
// not be obtained by [func@GLib.strreverse]. This works only if the string
// does not contain any multibyte characters. GLib offers the
// [func@GLib.utf8_strreverse] function to reverse UTF-8 encoded strings.
func PatternMatch(PspecVar *PatternSpec, StringLengthVar uint, StringVar string, StringReversedVar *string) bool {

	cret := xPatternMatch(PspecVar, StringLengthVar, StringVar, core.NullableStringToPtr(StringReversedVar))
	return cret
}

var xPatternMatchSimple func(string, string) bool

// Matches a string against a pattern given as a string.
//
// If this
// function is to be called in a loop, it’s more efficient to compile
// the pattern once with [ctor@GLib.PatternSpec.new] and call
// [method@GLib.PatternSpec.match_string] repeatedly.
func PatternMatchSimple(PatternVar string, StringVar string) bool {

	cret := xPatternMatchSimple(PatternVar, StringVar)
	return cret
}

var xPatternMatchString func(*PatternSpec, string) bool

// Matches a string against a compiled pattern.
//
// If the string is to be
// matched against more than one pattern, consider using
// [method@GLib.PatternSpec.match] instead while supplying the reversed string.
func PatternMatchString(PspecVar *PatternSpec, StringVar string) bool {

	cret := xPatternMatchString(PspecVar, StringVar)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPatternMatch, libs, "g_pattern_match")
	core.PuregoSafeRegister(&xPatternMatchSimple, libs, "g_pattern_match_simple")
	core.PuregoSafeRegister(&xPatternMatchString, libs, "g_pattern_match_string")

	core.PuregoSafeRegister(&xPatternSpecGLibType, libs, "g_pattern_spec_get_type")

	core.PuregoSafeRegister(&xNewPatternSpec, libs, "g_pattern_spec_new")

	core.PuregoSafeRegister(&xPatternSpecCopy, libs, "g_pattern_spec_copy")
	core.PuregoSafeRegister(&xPatternSpecEqual, libs, "g_pattern_spec_equal")
	core.PuregoSafeRegister(&xPatternSpecFree, libs, "g_pattern_spec_free")
	core.PuregoSafeRegister(&xPatternSpecMatch, libs, "g_pattern_spec_match")
	core.PuregoSafeRegister(&xPatternSpecMatchString, libs, "g_pattern_spec_match_string")

}
