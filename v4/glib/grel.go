// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// A `GRelation` is a table of data which can be indexed on any number
// of fields, rather like simple database tables. A `GRelation` contains
// a number of records, called tuples. Each record contains a number of
// fields. Records are not ordered, so it is not possible to find the
// record at a particular index.
//
// Note that `GRelation` tables are currently limited to 2 fields.
//
// To create a `GRelation`, use [func@GLib.Relation.new].
//
// To specify which fields should be indexed, use [method@GLib.Relation.index].
// Note that this must be called before any tuples are added to the
// `GRelation`.
//
// To add records to a `GRelation` use [method@GLib.Relation.insert].
//
// To determine if a given record appears in a `GRelation`, use
// [method@GLib.Relation.exists]. Note that fields are compared directly, so
// pointers must point to the exact same position (i.e. different
// copies of the same string will not match.)
//
// To count the number of records which have a particular value in a
// given field, use [method@GLib.Relation.count].
//
// To get all the records which have a particular value in a given
// field, use [method@GLib.Relation.select]. To access fields of the resulting
// records, use [method@GLib.Tuples.index]. To free the resulting records use
// [method@GLib.Tuples.destroy].
//
// To delete all records which have a particular value in a given
// field, use [method@GLib.Relation.delete].
//
// To destroy the `GRelation`, use [method@GLib.Relation.destroy].
//
// To help debug `GRelation` objects, use [method@GLib.Relation.print].
//
// `GRelation` has been marked as deprecated, since this API has never
// been fully implemented, is not very actively maintained and rarely
// used.
type Relation struct {
	_ structs.HostLayout
}

func (x *Relation) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xRelationCount func(uintptr, uintptr, int) int

// Returns the number of tuples in a #GRelation that have the given
// value in the given field.
func (x *Relation) Count(KeyVar uintptr, FieldVar int) int {

	cret := xRelationCount(x.GoPointer(), KeyVar, FieldVar)
	return cret
}

var xRelationDelete func(uintptr, uintptr, int) int

// Deletes any records from a #GRelation that have the given key value
// in the given field.
func (x *Relation) Delete(KeyVar uintptr, FieldVar int) int {

	cret := xRelationDelete(x.GoPointer(), KeyVar, FieldVar)
	return cret
}

var xRelationDestroy func(uintptr)

// Destroys the #GRelation, freeing all memory allocated. However, it
// does not free memory allocated for the tuple data, so you should
// free that first if appropriate.
func (x *Relation) Destroy() {

	xRelationDestroy(x.GoPointer())

}

var xRelationExists func(uintptr, ...interface{}) bool

// Returns %TRUE if a record with the given values exists in a
// #GRelation. Note that the values are compared directly, so that, for
// example, two copies of the same string will not match.
func (x *Relation) Exists(varArgs ...interface{}) bool {

	cret := xRelationExists(x.GoPointer(), varArgs...)
	return cret
}

var xRelationIndex func(uintptr, int, uintptr, uintptr)

// Creates an index on the given field. Note that this must be called
// before any records are added to the #GRelation.
func (x *Relation) Index(FieldVar int, HashFuncVar *HashFunc, KeyEqualFuncVar *EqualFunc) {

	var HashFuncVarRef uintptr
	if HashFuncVar != nil {
		HashFuncVarPtr := uintptr(unsafe.Pointer(HashFuncVar))
		if cbRefPtr, ok := GetCallback(HashFuncVarPtr); ok {
			HashFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) uint {
				cbFn := *HashFuncVar
				return cbFn(arg0)
			}
			HashFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(HashFuncVarPtr, HashFuncVarRef)
		}
	}

	var KeyEqualFuncVarRef uintptr
	if KeyEqualFuncVar != nil {
		KeyEqualFuncVarPtr := uintptr(unsafe.Pointer(KeyEqualFuncVar))
		if cbRefPtr, ok := GetCallback(KeyEqualFuncVarPtr); ok {
			KeyEqualFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) bool {
				cbFn := *KeyEqualFuncVar
				return cbFn(arg0, arg1)
			}
			KeyEqualFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(KeyEqualFuncVarPtr, KeyEqualFuncVarRef)
		}
	}

	xRelationIndex(x.GoPointer(), FieldVar, HashFuncVarRef, KeyEqualFuncVarRef)

}

var xRelationInsert func(uintptr, ...interface{})

// Inserts a record into a #GRelation.
func (x *Relation) Insert(varArgs ...interface{}) {

	xRelationInsert(x.GoPointer(), varArgs...)

}

var xRelationPrint func(uintptr)

// Outputs information about all records in a #GRelation, as well as
// the indexes. It is for debugging.
func (x *Relation) Print() {

	xRelationPrint(x.GoPointer())

}

var xRelationSelect func(uintptr, uintptr, int) *Tuples

// Returns all of the tuples which have the given key in the given
// field. Use g_tuples_index() to access the returned records. The
// returned records should be freed with g_tuples_destroy().
func (x *Relation) Select(KeyVar uintptr, FieldVar int) *Tuples {

	cret := xRelationSelect(x.GoPointer(), KeyVar, FieldVar)
	return cret
}

// The #GTuples struct is used to return records (or tuples) from the
// #GRelation by g_relation_select(). It only contains one public
// member - the number of records that matched. To access the matched
// records, you must use g_tuples_index().
type Tuples struct {
	_ structs.HostLayout

	Len uint
}

func (x *Tuples) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTuplesDestroy func(uintptr)

// Frees the records which were returned by g_relation_select(). This
// should always be called after g_relation_select() when you are
// finished with the records. The records are not removed from the
// #GRelation.
func (x *Tuples) Destroy() {

	xTuplesDestroy(x.GoPointer())

}

var xTuplesIndex func(uintptr, int, int) uintptr

// Gets a field from the records returned by g_relation_select(). It
// returns the given field of the record at the given index. The
// returned value should not be changed.
func (x *Tuples) Index(IndexVar int, FieldVar int) uintptr {

	cret := xTuplesIndex(x.GoPointer(), IndexVar, FieldVar)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xRelationCount, libs, "g_relation_count")
	core.PuregoSafeRegister(&xRelationDelete, libs, "g_relation_delete")
	core.PuregoSafeRegister(&xRelationDestroy, libs, "g_relation_destroy")
	core.PuregoSafeRegister(&xRelationExists, libs, "g_relation_exists")
	core.PuregoSafeRegister(&xRelationIndex, libs, "g_relation_index")
	core.PuregoSafeRegister(&xRelationInsert, libs, "g_relation_insert")
	core.PuregoSafeRegister(&xRelationPrint, libs, "g_relation_print")
	core.PuregoSafeRegister(&xRelationSelect, libs, "g_relation_select")

	core.PuregoSafeRegister(&xTuplesDestroy, libs, "g_tuples_destroy")
	core.PuregoSafeRegister(&xTuplesIndex, libs, "g_tuples_index")

}
