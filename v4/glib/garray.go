// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Contains the public fields of a `GArray`.
type Array struct {
	_ structs.HostLayout

	Data uintptr

	Len uint
}

var xArrayGLibType func() types.GType

func ArrayGLibType() types.GType {
	return xArrayGLibType()
}

func (x *Array) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Contains the public fields of a `GByteArray`.
type ByteArray struct {
	_ structs.HostLayout

	Data byte

	Len uint
}

var xByteArrayGLibType func() types.GType

func ByteArrayGLibType() types.GType {
	return xByteArrayGLibType()
}

func (x *ByteArray) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A simple reference counted data type representing an immutable sequence of
// zero or more bytes from an unspecified origin.
//
// The purpose of a `GBytes` is to keep the memory region that it holds
// alive for as long as anyone holds a reference to the bytes.  When
// the last reference count is dropped, the memory is released. Multiple
// unrelated callers can use byte data in the `GBytes` without coordinating
// their activities, resting assured that the byte data will not change or
// move while they hold a reference.
//
// A `GBytes` can come from many different origins that may have
// different procedures for freeing the memory region.  Examples are
// memory from [func@GLib.malloc], from memory slices, from a
// [struct@GLib.MappedFile] or memory from other allocators.
//
// `GBytes` work well as keys in [struct@GLib.HashTable]. Use
// [method@GLib.Bytes.equal] and [method@GLib.Bytes.hash] as parameters to
// [func@GLib.HashTable.new] or [func@GLib.HashTable.new_full].
// `GBytes` can also be used as keys in a [struct@GLib.Tree] by passing the
// [method@GLib.Bytes.compare] function to [ctor@GLib.Tree.new].
//
// The data pointed to by this bytes must not be modified. For a mutable
// array of bytes see [struct@GLib.ByteArray]. Use
// [method@GLib.Bytes.unref_to_array] to create a mutable array for a `GBytes`
// sequence. To create an immutable `GBytes` from a mutable
// [struct@GLib.ByteArray], use the [func@GLib.ByteArray.free_to_bytes]
// function.
type Bytes struct {
	_ structs.HostLayout
}

var xBytesGLibType func() types.GType

func BytesGLibType() types.GType {
	return xBytesGLibType()
}

func (x *Bytes) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewBytes func([]byte, uint) *Bytes

// Creates a new [struct@GLib.Bytes] from @data.
//
// @data is copied. If @size is 0, @data may be `NULL`.
//
// As an optimization, [ctor@GLib.Bytes.new] may avoid an extra allocation by
// copying the data within the resulting bytes structure if sufficiently small
// (since GLib 2.84).
func NewBytes(DataVar []byte, SizeVar uint) *Bytes {

	cret := xNewBytes(DataVar, SizeVar)
	return cret
}

var xNewBytesStatic func([]byte, uint) *Bytes

// Creates a new [struct@GLib.Bytes] from static data.
//
// @data must be static (ie: never modified or freed). It may be `NULL` if @size
// is 0.
func NewBytesStatic(DataVar []byte, SizeVar uint) *Bytes {

	cret := xNewBytesStatic(DataVar, SizeVar)
	return cret
}

var xNewBytesTake func(uintptr, uint) *Bytes

// Creates a new [struct@GLib.Bytes] from @data.
//
// After this call, @data belongs to the `GBytes` and may no longer be
// modified by the caller. The memory of @data has to be dynamically
// allocated and will eventually be freed with [func@GLib.free].
//
// For creating `GBytes` with memory from other allocators, see
// [ctor@GLib.Bytes.new_with_free_func].
//
// @data may be `NULL` if @size is 0.
func NewBytesTake(DataVar uintptr, SizeVar uint) *Bytes {

	cret := xNewBytesTake(DataVar, SizeVar)
	return cret
}

var xNewBytesWithFreeFunc func([]byte, uint, uintptr, uintptr) *Bytes

// Creates a [struct@GLib.Bytes] from @data.
//
// When the last reference is dropped, @free_func will be called with the
// @user_data argument.
//
// @data must not be modified after this call is made until @free_func has
// been called to indicate that the bytes is no longer in use.
//
// @data may be `NULL` if @size is 0.
func NewBytesWithFreeFunc(DataVar []byte, SizeVar uint, FreeFuncVar *DestroyNotify, UserDataVar uintptr) *Bytes {

	FreeFuncVarPtr := uintptr(unsafe.Pointer(FreeFuncVar))
	var FreeFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(FreeFuncVarPtr); ok {
		FreeFuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr) {
			cbFn := *FreeFuncVar
			cbFn(arg0)
		}
		FreeFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(FreeFuncVarPtr, FreeFuncVarRef)
	}

	cret := xNewBytesWithFreeFunc(DataVar, SizeVar, FreeFuncVarRef, UserDataVar)
	return cret
}

var xBytesCompare func(uintptr, uintptr) int

// Compares the two [struct@GLib.Bytes] values.
//
// This function can be used to sort `GBytes` instances in lexicographical
// order.
//
// If @bytes1 and @bytes2 have different length but the shorter one is a
// prefix of the longer one then the shorter one is considered to be less than
// the longer one. Otherwise the first byte where both differ is used for
// comparison. If @bytes1 has a smaller value at that position it is
// considered less, otherwise greater than @bytes2.
func (x *Bytes) Compare(Bytes2Var uintptr) int {

	cret := xBytesCompare(x.GoPointer(), Bytes2Var)
	return cret
}

var xBytesEqual func(uintptr, uintptr) bool

// Compares the two [struct@GLib.Bytes] values being pointed to and returns
// `TRUE` if they are equal.
//
// This function can be passed to [func@GLib.HashTable.new] as the
// @key_equal_func parameter, when using non-`NULL` `GBytes` pointers as keys in
// a [struct@GLib.HashTable].
func (x *Bytes) Equal(Bytes2Var uintptr) bool {

	cret := xBytesEqual(x.GoPointer(), Bytes2Var)
	return cret
}

var xBytesGetData func(uintptr, *uint) uintptr

// Get the byte data in the [struct@GLib.Bytes].
//
// This data should not be modified.
//
// This function will always return the same pointer for a given `GBytes`.
//
// `NULL` may be returned if @size is 0. This is not guaranteed, as the `GBytes`
// may represent an empty string with @data non-`NULL` and @size as 0. `NULL`
// will not be returned if @size is non-zero.
func (x *Bytes) GetData(SizeVar *uint) uintptr {

	cret := xBytesGetData(x.GoPointer(), SizeVar)
	return cret
}

var xBytesGetRegion func(uintptr, uint, uint, uint) uintptr

// Gets a pointer to a region in @bytes.
//
// The region starts at @offset many bytes from the start of the data
// and contains @n_elements many elements of @element_size size.
//
// @n_elements may be zero, but @element_size must always be non-zero.
// Ideally, @element_size is a static constant (eg: `sizeof` a struct).
//
// This function does careful bounds checking (including checking for
// arithmetic overflows) and returns a non-`NULL` pointer if the
// specified region lies entirely within the @bytes. If the region is
// in some way out of range, or if an overflow has occurred, then `NULL`
// is returned.
//
// Note: it is possible to have a valid zero-size region. In this case,
// the returned pointer will be equal to the base pointer of the data of
// @bytes, plus @offset.  This will be non-`NULL` except for the case
// where @bytes itself was a zero-sized region.  Since it is unlikely
// that you will be using this function to check for a zero-sized region
// in a zero-sized @bytes, `NULL` effectively always means ‘error’.
func (x *Bytes) GetRegion(ElementSizeVar uint, OffsetVar uint, NElementsVar uint) uintptr {

	cret := xBytesGetRegion(x.GoPointer(), ElementSizeVar, OffsetVar, NElementsVar)
	return cret
}

var xBytesGetSize func(uintptr) uint

// Get the size of the byte data in the [struct@GLib.Bytes].
//
// This function will always return the same value for a given `GBytes`.
func (x *Bytes) GetSize() uint {

	cret := xBytesGetSize(x.GoPointer())
	return cret
}

var xBytesHash func(uintptr) uint

// Creates an integer hash code for the byte data in the [struct@GLib.Bytes].
//
// This function can be passed to [func@GLib.HashTable.new] as the
// @key_hash_func parameter, when using non-`NULL` `GBytes` pointers as keys in
// a [struct@GLib.HashTable].
func (x *Bytes) Hash() uint {

	cret := xBytesHash(x.GoPointer())
	return cret
}

var xBytesNewFromBytes func(uintptr, uint, uint) *Bytes

// Creates a [struct@GLib.Bytes] which is a subsection of another `GBytes`.
//
// The @offset + @length may not be longer than the size of @bytes.
//
// A reference to @bytes will be held by the newly created `GBytes` until
// the byte data is no longer needed.
//
// Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
// @bytes will be returned with the reference count incremented by 1. If @bytes
// is a slice of another `GBytes`, then the resulting `GBytes` will reference
// the same `GBytes` instead of @bytes. This allows consumers to simplify the
// usage of `GBytes` when asynchronously writing to streams.
func (x *Bytes) NewFromBytes(OffsetVar uint, LengthVar uint) *Bytes {

	cret := xBytesNewFromBytes(x.GoPointer(), OffsetVar, LengthVar)
	return cret
}

var xBytesRef func(uintptr) *Bytes

// Increase the reference count on @bytes.
func (x *Bytes) Ref() *Bytes {

	cret := xBytesRef(x.GoPointer())
	return cret
}

var xBytesUnref func(uintptr)

// Releases a reference on @bytes.
//
// This may result in the bytes being freed. If @bytes is `NULL`, it will
// return immediately.
func (x *Bytes) Unref() {

	xBytesUnref(x.GoPointer())

}

var xBytesUnrefToArray func(uintptr) uintptr

// Unreferences the bytes, and returns a new mutable [struct@GLib.ByteArray]
// containing the same byte data.
//
// As an optimization, the byte data is transferred to the array without copying
// if this was the last reference to @bytes and @bytes was created with
// [ctor@GLib.Bytes.new], [ctor@GLib.Bytes.new_take] or
// [func@GLib.ByteArray.free_to_bytes] and the buffer was larger than the size
// [struct@GLib.Bytes] may internalize within its allocation. In all other cases
// the data is copied.
//
// Do not use it if @bytes contains more than %G_MAXUINT
// bytes. [struct@GLib.ByteArray] stores the length of its data in `guint`,
// which may be shorter than `gsize`, that @bytes is using.
func (x *Bytes) UnrefToArray() uintptr {

	cret := xBytesUnrefToArray(x.GoPointer())
	return cret
}

var xBytesUnrefToData func(uintptr, *uint) uintptr

// Unreferences the bytes, and returns a pointer the same byte data
// contents.
//
// As an optimization, the byte data is returned without copying if this was
// the last reference to @bytes and @bytes was created with
// [ctor@GLib.Bytes.new], [ctor@GLib.Bytes.new_take] or
// [func@GLib.ByteArray.free_to_bytes] and the buffer was larger than the size
// [struct@GLib.Bytes] may internalize within its allocation. In all other cases
// the data is copied.
func (x *Bytes) UnrefToData(SizeVar *uint) uintptr {

	cret := xBytesUnrefToData(x.GoPointer(), SizeVar)
	return cret
}

// Contains the public fields of a `GPtrArray`.
type PtrArray struct {
	_ structs.HostLayout

	Pdata uintptr

	Len uint
}

var xPtrArrayGLibType func() types.GType

func PtrArrayGLibType() types.GType {
	return xPtrArrayGLibType()
}

func (x *PtrArray) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xArrayNewTake func(uintptr, uint, bool, uint) uintptr

// Creates a new `GArray` with @data as array data, @len as length and a
// reference count of 1.
//
// This avoids having to copy the data manually, when it can just be
// inherited.
// After this call, @data belongs to the `GArray` and may no longer be
// modified by the caller. The memory of @data has to be dynamically
// allocated and will eventually be freed with [func@GLib.free].
//
// In case the elements need to be cleared when the array is freed, use
// [func@GLib.Array.set_clear_func] to set a [callback@GLib.DestroyNotify]
// function to perform such task.
//
// Do not use it if @len or @element_size are greater than
//
//	[`G_MAXUINT`](types.html#guint). `GArray` stores the length of its data in
//	`guint`, which may be shorter than `gsize`.
func ArrayNewTake(DataVar uintptr, LenVar uint, ClearVar bool, ElementSizeVar uint) uintptr {

	cret := xArrayNewTake(DataVar, LenVar, ClearVar, ElementSizeVar)
	return cret
}

var xArrayNewTakeZeroTerminated func(uintptr, bool, uint) uintptr

// Creates a new `GArray` with @data as array data, computing the length of it
// and setting the reference count to 1.
//
// This avoids having to copy the data manually, when it can just be
// inherited.
// After this call, @data belongs to the `GArray` and may no longer be
// modified by the caller. The memory of @data has to be dynamically
// allocated and will eventually be freed with [func@GLib.free].
//
// The length is calculated by iterating through @data until the first `NULL`
// element is found.
//
// In case the elements need to be cleared when the array is freed, use
// [func@GLib.Array.set_clear_func] to set a [callback@GLib.DestroyNotify]
// function to perform such task.
//
// Do not use it if @data length or @element_size are greater than
// [`G_MAXUINT`](types.html#guint). `GArray` stores the length of its data in
// `guint`, which may be shorter than `gsize`.
func ArrayNewTakeZeroTerminated(DataVar uintptr, ClearVar bool, ElementSizeVar uint) uintptr {

	cret := xArrayNewTakeZeroTerminated(DataVar, ClearVar, ElementSizeVar)
	return cret
}

var xByteArrayAppend func([]byte, []byte, uint) uintptr

// Adds the given bytes to the end of the `GByteArray`.
// The array will grow in size automatically if necessary.
func ByteArrayAppend(ArrayVar []byte, DataVar []byte, LenVar uint) uintptr {

	cret := xByteArrayAppend(ArrayVar, DataVar, LenVar)
	return cret
}

var xByteArrayFree func([]byte, bool) uintptr

// Frees the memory allocated by the `GByteArray`. If @free_segment is
// true it frees the actual byte data. If the reference count of
// @array is greater than one, the `GByteArray` wrapper is preserved but
// the size of @array will be set to zero.
func ByteArrayFree(ArrayVar []byte, FreeSegmentVar bool) uintptr {

	cret := xByteArrayFree(ArrayVar, FreeSegmentVar)
	return cret
}

var xByteArrayFreeToBytes func([]byte) *Bytes

// Transfers the data from the `GByteArray` into a new immutable
// [struct@GLib.Bytes].
//
// The `GByteArray` is freed unless the reference count of @array is greater
// than one, in which the `GByteArray` wrapper is preserved but the size of
// @array will be set to zero.
//
// This is identical to using [ctor@GLib.Bytes.new_take] and
// [func@GLib.ByteArray.free] together.
func ByteArrayFreeToBytes(ArrayVar []byte) *Bytes {

	cret := xByteArrayFreeToBytes(ArrayVar)
	return cret
}

var xByteArrayNew func() uintptr

// Creates a new `GByteArray` with a reference count of 1.
func ByteArrayNew() uintptr {

	cret := xByteArrayNew()
	return cret
}

var xByteArrayNewTake func([]byte, uint) uintptr

// Creates a byte array containing the @data.
// After this call, @data belongs to the `GByteArray` and may no longer be
// modified by the caller. The memory of @data has to be dynamically
// allocated and will eventually be freed with [func@GLib.free].
//
// Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
// `GByteArray` stores the length of its data in `guint`, which may be shorter
// than `gsize`.
func ByteArrayNewTake(DataVar []byte, LenVar uint) uintptr {

	cret := xByteArrayNewTake(DataVar, LenVar)
	return cret
}

var xByteArrayPrepend func([]byte, []byte, uint) uintptr

// Adds the given data to the start of the `GByteArray`.
// The array will grow in size automatically if necessary.
func ByteArrayPrepend(ArrayVar []byte, DataVar []byte, LenVar uint) uintptr {

	cret := xByteArrayPrepend(ArrayVar, DataVar, LenVar)
	return cret
}

var xByteArrayRef func([]byte) uintptr

// Atomically increments the reference count of @array by one.
// This function is thread-safe and may be called from any thread.
func ByteArrayRef(ArrayVar []byte) uintptr {

	cret := xByteArrayRef(ArrayVar)
	return cret
}

var xByteArrayRemoveIndex func([]byte, uint) uintptr

// Removes the byte at the given index from a `GByteArray`.
// The following bytes are moved down one place.
func ByteArrayRemoveIndex(ArrayVar []byte, IndexVar uint) uintptr {

	cret := xByteArrayRemoveIndex(ArrayVar, IndexVar)
	return cret
}

var xByteArrayRemoveIndexFast func([]byte, uint) uintptr

// Removes the byte at the given index from a `GByteArray`. The last
// element in the array is used to fill in the space, so this function
// does not preserve the order of the `GByteArray`. But it is faster
// than [func@GLib.ByteArray.remove_index].
func ByteArrayRemoveIndexFast(ArrayVar []byte, IndexVar uint) uintptr {

	cret := xByteArrayRemoveIndexFast(ArrayVar, IndexVar)
	return cret
}

var xByteArrayRemoveRange func([]byte, uint, uint) uintptr

// Removes the given number of bytes starting at the given index from a
// `GByteArray`. The following elements are moved to close the gap.
func ByteArrayRemoveRange(ArrayVar []byte, IndexVar uint, LengthVar uint) uintptr {

	cret := xByteArrayRemoveRange(ArrayVar, IndexVar, LengthVar)
	return cret
}

var xByteArraySetSize func([]byte, uint) uintptr

// Sets the size of the `GByteArray`, expanding it if necessary.
func ByteArraySetSize(ArrayVar []byte, LengthVar uint) uintptr {

	cret := xByteArraySetSize(ArrayVar, LengthVar)
	return cret
}

var xByteArraySizedNew func(uint) uintptr

// Creates a new `GByteArray` with @reserved_size bytes preallocated.
// This avoids frequent reallocation, if you are going to add many
// bytes to the array. Note however that the size of the array is still
// 0.
func ByteArraySizedNew(ReservedSizeVar uint) uintptr {

	cret := xByteArraySizedNew(ReservedSizeVar)
	return cret
}

var xByteArraySort func([]byte, uintptr)

// Sorts a byte array, using @compare_func which should be a
// `qsort()`-style comparison function (returns less than zero for first
// arg is less than second arg, zero for equal, greater than zero if
// first arg is greater than second arg).
//
// If two array elements compare equal, their order in the sorted array
// is undefined. If you want equal elements to keep their order (i.e.
// you want a stable sort) you can write a comparison function that,
// if two elements would otherwise compare equal, compares them by
// their addresses.
func ByteArraySort(ArrayVar []byte, CompareFuncVar *CompareFunc) {

	CompareFuncVarPtr := uintptr(unsafe.Pointer(CompareFuncVar))
	var CompareFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(CompareFuncVarPtr); ok {
		CompareFuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr) int {
			cbFn := *CompareFuncVar
			return cbFn(arg0, arg1)
		}
		CompareFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(CompareFuncVarPtr, CompareFuncVarRef)
	}

	xByteArraySort(ArrayVar, CompareFuncVarRef)

}

var xByteArraySortWithData func([]byte, uintptr, uintptr)

// Like [func@GLib.ByteArray.sort], but the comparison function takes an extra
// user data argument.
func ByteArraySortWithData(ArrayVar []byte, CompareFuncVar *CompareDataFunc, UserDataVar uintptr) {

	CompareFuncVarPtr := uintptr(unsafe.Pointer(CompareFuncVar))
	var CompareFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(CompareFuncVarPtr); ok {
		CompareFuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) int {
			cbFn := *CompareFuncVar
			return cbFn(arg0, arg1, arg2)
		}
		CompareFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(CompareFuncVarPtr, CompareFuncVarRef)
	}

	xByteArraySortWithData(ArrayVar, CompareFuncVarRef, UserDataVar)

}

var xByteArraySteal func([]byte, *uint) uintptr

// Frees the data in the array and resets the size to zero, while
// the underlying array is preserved for use elsewhere and returned
// to the caller.
func ByteArraySteal(ArrayVar []byte, LenVar *uint) uintptr {

	cret := xByteArraySteal(ArrayVar, LenVar)
	return cret
}

var xByteArrayUnref func([]byte)

// Atomically decrements the reference count of @array by one. If the
// reference count drops to 0, all memory allocated by the array is
// released. This function is thread-safe and may be called from any
// thread.
func ByteArrayUnref(ArrayVar []byte) {

	xByteArrayUnref(ArrayVar)

}

var xPtrArrayFind func([]uintptr, uintptr, *uint) bool

// Checks whether @needle exists in @haystack. If the element is found, true
// is returned and the element’s index is returned in @index_ (if non-`NULL`).
// Otherwise, false is returned and @index_ is undefined. If @needle exists
// multiple times in @haystack, the index of the first instance is returned.
//
// This does pointer comparisons only. If you want to use more complex equality
// checks, such as string comparisons, use
// [func@GLib.PtrArray.find_with_equal_func].
func PtrArrayFind(HaystackVar []uintptr, NeedleVar uintptr, IndexVar *uint) bool {

	cret := xPtrArrayFind(HaystackVar, NeedleVar, IndexVar)
	return cret
}

var xPtrArrayFindWithEqualFunc func([]uintptr, uintptr, uintptr, *uint) bool

// Checks whether @needle exists in @haystack, using the given @equal_func.
// If the element is found, true is returned and the element’s index is
// returned in @index_ (if non-`NULL`). Otherwise, false is returned and @index_
// is undefined. If @needle exists multiple times in @haystack, the index of
// the first instance is returned.
//
// @equal_func is called with the element from the array as its first parameter,
// and @needle as its second parameter. If @equal_func is `NULL`, pointer
// equality is used.
func PtrArrayFindWithEqualFunc(HaystackVar []uintptr, NeedleVar uintptr, EqualFuncVar *EqualFunc, IndexVar *uint) bool {

	var EqualFuncVarRef uintptr
	if EqualFuncVar != nil {
		EqualFuncVarPtr := uintptr(unsafe.Pointer(EqualFuncVar))
		if cbRefPtr, ok := GetCallback(EqualFuncVarPtr); ok {
			EqualFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) bool {
				cbFn := *EqualFuncVar
				return cbFn(arg0, arg1)
			}
			EqualFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(EqualFuncVarPtr, EqualFuncVarRef)
		}
	}

	cret := xPtrArrayFindWithEqualFunc(HaystackVar, NeedleVar, EqualFuncVarRef, IndexVar)
	return cret
}

var xPtrArrayNewFromArray func([]uintptr, uint, uintptr, uintptr, uintptr) uintptr

// Creates a new `GPtrArray`, copying @len pointers from @data, and setting
// the array’s reference count to 1.
//
// This avoids having to manually add each element one by one.
//
// If @copy_func is provided, then it is used to copy each element before
// adding them to the new array. If it is `NULL` then the pointers are copied
// directly.
//
// It also sets @element_free_func for freeing each element when the array is
// destroyed either via [func@GLib.PtrArray.unref], when
// [func@GLib.PtrArray.free] is called with @free_segment set to true or when
// removing elements.
//
// Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
// `GPtrArray` stores the length of its data in `guint`, which may be shorter
// than `gsize`.
func PtrArrayNewFromArray(DataVar []uintptr, LenVar uint, CopyFuncVar *CopyFunc, CopyFuncUserDataVar uintptr, ElementFreeFuncVar *DestroyNotify) uintptr {

	var CopyFuncVarRef uintptr
	if CopyFuncVar != nil {
		CopyFuncVarPtr := uintptr(unsafe.Pointer(CopyFuncVar))
		if cbRefPtr, ok := GetCallback(CopyFuncVarPtr); ok {
			CopyFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) uintptr {
				cbFn := *CopyFuncVar
				return cbFn(arg0, arg1)
			}
			CopyFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(CopyFuncVarPtr, CopyFuncVarRef)
		}
	}

	var ElementFreeFuncVarRef uintptr
	if ElementFreeFuncVar != nil {
		ElementFreeFuncVarPtr := uintptr(unsafe.Pointer(ElementFreeFuncVar))
		if cbRefPtr, ok := GetCallback(ElementFreeFuncVarPtr); ok {
			ElementFreeFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *ElementFreeFuncVar
				cbFn(arg0)
			}
			ElementFreeFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(ElementFreeFuncVarPtr, ElementFreeFuncVarRef)
		}
	}

	cret := xPtrArrayNewFromArray(DataVar, LenVar, CopyFuncVarRef, CopyFuncUserDataVar, ElementFreeFuncVarRef)
	return cret
}

var xPtrArrayNewFromNullTerminatedArray func([]uintptr, uintptr, uintptr, uintptr) uintptr

// Creates a new `GPtrArray` copying the pointers from @data after having
// computed the length of it and with a reference count of 1.
// This avoids having to manually add each element one by one.
// If @copy_func is provided, then it is used to copy the data in the new
// array.
// It also sets @element_free_func for freeing each element when the array is
// destroyed either via [func@GLib.PtrArray.unref], when
// [func@GLib.PtrArray.free] is called with @free_segment set to true or when
// removing elements.
//
// Do not use it if the @data has more than [`G_MAXUINT`](types.html#guint)
// elements. `GPtrArray` stores the length of its data in `guint`, which may be
// shorter than `gsize`.
func PtrArrayNewFromNullTerminatedArray(DataVar []uintptr, CopyFuncVar *CopyFunc, CopyFuncUserDataVar uintptr, ElementFreeFuncVar *DestroyNotify) uintptr {

	var CopyFuncVarRef uintptr
	if CopyFuncVar != nil {
		CopyFuncVarPtr := uintptr(unsafe.Pointer(CopyFuncVar))
		if cbRefPtr, ok := GetCallback(CopyFuncVarPtr); ok {
			CopyFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) uintptr {
				cbFn := *CopyFuncVar
				return cbFn(arg0, arg1)
			}
			CopyFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(CopyFuncVarPtr, CopyFuncVarRef)
		}
	}

	var ElementFreeFuncVarRef uintptr
	if ElementFreeFuncVar != nil {
		ElementFreeFuncVarPtr := uintptr(unsafe.Pointer(ElementFreeFuncVar))
		if cbRefPtr, ok := GetCallback(ElementFreeFuncVarPtr); ok {
			ElementFreeFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *ElementFreeFuncVar
				cbFn(arg0)
			}
			ElementFreeFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(ElementFreeFuncVarPtr, ElementFreeFuncVarRef)
		}
	}

	cret := xPtrArrayNewFromNullTerminatedArray(DataVar, CopyFuncVarRef, CopyFuncUserDataVar, ElementFreeFuncVarRef)
	return cret
}

var xPtrArrayNewTake func([]uintptr, uint, uintptr) uintptr

// Creates a new `GPtrArray` with @data as pointers, @len as length and a
// reference count of 1.
//
// This avoids having to copy such data manually.
// After this call, @data belongs to the `GPtrArray` and may no longer be
// modified by the caller. The memory of @data has to be dynamically
// allocated and will eventually be freed with [func@GLib.free].
//
// It also sets @element_free_func for freeing each element when the array is
// destroyed either via [func@GLib.PtrArray.unref], when
// [func@GLib.PtrArray.free] is called with @free_segment set to true or when
// removing elements.
//
// Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
// `GPtrArray` stores the length of its data in `guint`, which may be shorter
// than `gsize`.
func PtrArrayNewTake(DataVar []uintptr, LenVar uint, ElementFreeFuncVar *DestroyNotify) uintptr {

	var ElementFreeFuncVarRef uintptr
	if ElementFreeFuncVar != nil {
		ElementFreeFuncVarPtr := uintptr(unsafe.Pointer(ElementFreeFuncVar))
		if cbRefPtr, ok := GetCallback(ElementFreeFuncVarPtr); ok {
			ElementFreeFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *ElementFreeFuncVar
				cbFn(arg0)
			}
			ElementFreeFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(ElementFreeFuncVarPtr, ElementFreeFuncVarRef)
		}
	}

	cret := xPtrArrayNewTake(DataVar, LenVar, ElementFreeFuncVarRef)
	return cret
}

var xPtrArrayNewTakeNullTerminated func([]uintptr, uintptr) uintptr

// Creates a new `GPtrArray` with @data as pointers, computing the length of it
// and setting the reference count to 1.
//
// This avoids having to copy such data manually.
// After this call, @data belongs to the `GPtrArray` and may no longer be
// modified by the caller. The memory of @data has to be dynamically
// allocated and will eventually be freed with [func@GLib.free].
//
// The length is calculated by iterating through @data until the first `NULL`
// element is found.
//
// It also sets @element_free_func for freeing each element when the array is
// destroyed either via [func@GLib.PtrArray.unref], when
// [func@GLib.PtrArray.free] is called with @free_segment set to true or when
// removing elements.
//
// Do not use it if the @data length is greater than
// [`G_MAXUINT`](types.html#guint). `GPtrArray` stores the length of its data
// in `guint`, which may be shorter than `gsize`.
func PtrArrayNewTakeNullTerminated(DataVar []uintptr, ElementFreeFuncVar *DestroyNotify) uintptr {

	var ElementFreeFuncVarRef uintptr
	if ElementFreeFuncVar != nil {
		ElementFreeFuncVarPtr := uintptr(unsafe.Pointer(ElementFreeFuncVar))
		if cbRefPtr, ok := GetCallback(ElementFreeFuncVarPtr); ok {
			ElementFreeFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *ElementFreeFuncVar
				cbFn(arg0)
			}
			ElementFreeFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(ElementFreeFuncVarPtr, ElementFreeFuncVarRef)
		}
	}

	cret := xPtrArrayNewTakeNullTerminated(DataVar, ElementFreeFuncVarRef)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xArrayNewTake, libs, "g_array_new_take")
	core.PuregoSafeRegister(&xArrayNewTakeZeroTerminated, libs, "g_array_new_take_zero_terminated")
	core.PuregoSafeRegister(&xByteArrayAppend, libs, "g_byte_array_append")
	core.PuregoSafeRegister(&xByteArrayFree, libs, "g_byte_array_free")
	core.PuregoSafeRegister(&xByteArrayFreeToBytes, libs, "g_byte_array_free_to_bytes")
	core.PuregoSafeRegister(&xByteArrayNew, libs, "g_byte_array_new")
	core.PuregoSafeRegister(&xByteArrayNewTake, libs, "g_byte_array_new_take")
	core.PuregoSafeRegister(&xByteArrayPrepend, libs, "g_byte_array_prepend")
	core.PuregoSafeRegister(&xByteArrayRef, libs, "g_byte_array_ref")
	core.PuregoSafeRegister(&xByteArrayRemoveIndex, libs, "g_byte_array_remove_index")
	core.PuregoSafeRegister(&xByteArrayRemoveIndexFast, libs, "g_byte_array_remove_index_fast")
	core.PuregoSafeRegister(&xByteArrayRemoveRange, libs, "g_byte_array_remove_range")
	core.PuregoSafeRegister(&xByteArraySetSize, libs, "g_byte_array_set_size")
	core.PuregoSafeRegister(&xByteArraySizedNew, libs, "g_byte_array_sized_new")
	core.PuregoSafeRegister(&xByteArraySort, libs, "g_byte_array_sort")
	core.PuregoSafeRegister(&xByteArraySortWithData, libs, "g_byte_array_sort_with_data")
	core.PuregoSafeRegister(&xByteArraySteal, libs, "g_byte_array_steal")
	core.PuregoSafeRegister(&xByteArrayUnref, libs, "g_byte_array_unref")
	core.PuregoSafeRegister(&xPtrArrayFind, libs, "g_ptr_array_find")
	core.PuregoSafeRegister(&xPtrArrayFindWithEqualFunc, libs, "g_ptr_array_find_with_equal_func")
	core.PuregoSafeRegister(&xPtrArrayNewFromArray, libs, "g_ptr_array_new_from_array")
	core.PuregoSafeRegister(&xPtrArrayNewFromNullTerminatedArray, libs, "g_ptr_array_new_from_null_terminated_array")
	core.PuregoSafeRegister(&xPtrArrayNewTake, libs, "g_ptr_array_new_take")
	core.PuregoSafeRegister(&xPtrArrayNewTakeNullTerminated, libs, "g_ptr_array_new_take_null_terminated")

	core.PuregoSafeRegister(&xArrayGLibType, libs, "g_array_get_type")

	core.PuregoSafeRegister(&xByteArrayGLibType, libs, "g_byte_array_get_type")

	core.PuregoSafeRegister(&xBytesGLibType, libs, "g_bytes_get_type")

	core.PuregoSafeRegister(&xNewBytes, libs, "g_bytes_new")
	core.PuregoSafeRegister(&xNewBytesStatic, libs, "g_bytes_new_static")
	core.PuregoSafeRegister(&xNewBytesTake, libs, "g_bytes_new_take")
	core.PuregoSafeRegister(&xNewBytesWithFreeFunc, libs, "g_bytes_new_with_free_func")

	core.PuregoSafeRegister(&xBytesCompare, libs, "g_bytes_compare")
	core.PuregoSafeRegister(&xBytesEqual, libs, "g_bytes_equal")
	core.PuregoSafeRegister(&xBytesGetData, libs, "g_bytes_get_data")
	core.PuregoSafeRegister(&xBytesGetRegion, libs, "g_bytes_get_region")
	core.PuregoSafeRegister(&xBytesGetSize, libs, "g_bytes_get_size")
	core.PuregoSafeRegister(&xBytesHash, libs, "g_bytes_hash")
	core.PuregoSafeRegister(&xBytesNewFromBytes, libs, "g_bytes_new_from_bytes")
	core.PuregoSafeRegister(&xBytesRef, libs, "g_bytes_ref")
	core.PuregoSafeRegister(&xBytesUnref, libs, "g_bytes_unref")
	core.PuregoSafeRegister(&xBytesUnrefToArray, libs, "g_bytes_unref_to_array")
	core.PuregoSafeRegister(&xBytesUnrefToData, libs, "g_bytes_unref_to_data")

	core.PuregoSafeRegister(&xPtrArrayGLibType, libs, "g_ptr_array_get_type")

}
