// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// HMACs should be used when producing a cookie or hash based on data
// and a key. Simple mechanisms for using SHA1 and other algorithms to
// digest a key and data together are vulnerable to various security
// issues.
// [HMAC](http://en.wikipedia.org/wiki/HMAC)
// uses algorithms like SHA1 in a secure way to produce a digest of a
// key and data.
//
// Both the key and data are arbitrary byte arrays of bytes or characters.
//
// Support for HMAC Digests has been added in GLib 2.30, and support for SHA-512
// in GLib 2.42. Support for SHA-384 was added in GLib 2.52.
//
// To create a new `GHmac`, use [ctor@GLib.Hmac.new]. To free a `GHmac`, use
// [method@GLib.Hmac.unref].
type Hmac struct {
	_ structs.HostLayout
}

var xHmacGLibType func() types.GType

func HmacGLibType() types.GType {
	return xHmacGLibType()
}

func (x *Hmac) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewHmac func(ChecksumType, []byte, uint) *Hmac

// Creates a new #GHmac, using the digest algorithm @digest_type.
// If the @digest_type is not known, %NULL is returned.
// A #GHmac can be used to compute the HMAC of a key and an
// arbitrary binary blob, using different hashing algorithms.
//
// A #GHmac works by feeding a binary blob through g_hmac_update()
// until the data is complete; the digest can then be extracted
// using g_hmac_get_string(), which will return the checksum as a
// hexadecimal string; or g_hmac_get_digest(), which will return a
// array of raw bytes. Once either g_hmac_get_string() or
// g_hmac_get_digest() have been called on a #GHmac, the HMAC
// will be closed and it won't be possible to call g_hmac_update()
// on it anymore.
//
// Support for digests of type %G_CHECKSUM_SHA512 has been added in GLib 2.42.
// Support for %G_CHECKSUM_SHA384 was added in GLib 2.52.
func NewHmac(DigestTypeVar ChecksumType, KeyVar []byte, KeyLenVar uint) *Hmac {

	cret := xNewHmac(DigestTypeVar, KeyVar, KeyLenVar)

	return cret
}

var xHmacCopy func(uintptr) *Hmac

// Copies a #GHmac. If @hmac has been closed, by calling
// g_hmac_get_string() or g_hmac_get_digest(), the copied
// HMAC will be closed as well.
func (x *Hmac) Copy() *Hmac {

	cret := xHmacCopy(x.GoPointer())

	return cret
}

var xHmacGetDigest func(uintptr, []byte, uint)

// Gets the digest from @checksum as a raw binary array and places it
// into @buffer. The size of the digest depends on the type of checksum.
//
// Once this function has been called, the #GHmac is closed and can
// no longer be updated with g_checksum_update().
func (x *Hmac) GetDigest(BufferVar []byte, DigestLenVar uint) {

	xHmacGetDigest(x.GoPointer(), BufferVar, DigestLenVar)

}

var xHmacGetString func(uintptr) string

// Gets the HMAC as a hexadecimal string.
//
// Once this function has been called the #GHmac can no longer be
// updated with g_hmac_update().
//
// The hexadecimal characters will be lower case.
func (x *Hmac) GetString() string {

	cret := xHmacGetString(x.GoPointer())

	return cret
}

var xHmacRef func(uintptr) *Hmac

// Atomically increments the reference count of @hmac by one.
//
// This function is MT-safe and may be called from any thread.
func (x *Hmac) Ref() *Hmac {

	cret := xHmacRef(x.GoPointer())

	return cret
}

var xHmacUnref func(uintptr)

// Atomically decrements the reference count of @hmac by one.
//
// If the reference count drops to 0, all keys and values will be
// destroyed, and all memory allocated by the hash table is released.
// This function is MT-safe and may be called from any thread.
// Frees the memory allocated for @hmac.
func (x *Hmac) Unref() {

	xHmacUnref(x.GoPointer())

}

var xHmacUpdate func(uintptr, []byte, int)

// Feeds @data into an existing #GHmac.
//
// The HMAC must still be open, that is g_hmac_get_string() or
// g_hmac_get_digest() must not have been called on @hmac.
func (x *Hmac) Update(DataVar []byte, LengthVar int) {

	xHmacUpdate(x.GoPointer(), DataVar, LengthVar)

}

var xComputeHmacForBytes func(ChecksumType, *Bytes, *Bytes) string

// Computes the HMAC for a binary @data. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string()
// and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
func ComputeHmacForBytes(DigestTypeVar ChecksumType, KeyVar *Bytes, DataVar *Bytes) string {

	cret := xComputeHmacForBytes(DigestTypeVar, KeyVar, DataVar)

	return cret
}

var xComputeHmacForData func(ChecksumType, []byte, uint, []byte, uint) string

// Computes the HMAC for a binary @data of @length. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string()
// and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
func ComputeHmacForData(DigestTypeVar ChecksumType, KeyVar []byte, KeyLenVar uint, DataVar []byte, LengthVar uint) string {

	cret := xComputeHmacForData(DigestTypeVar, KeyVar, KeyLenVar, DataVar, LengthVar)

	return cret
}

var xComputeHmacForString func(ChecksumType, []byte, uint, string, int) string

// Computes the HMAC for a string.
//
// The hexadecimal string returned will be in lower case.
func ComputeHmacForString(DigestTypeVar ChecksumType, KeyVar []byte, KeyLenVar uint, StrVar string, LengthVar int) string {

	cret := xComputeHmacForString(DigestTypeVar, KeyVar, KeyLenVar, StrVar, LengthVar)

	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xComputeHmacForBytes, libs, "g_compute_hmac_for_bytes")
	core.PuregoSafeRegister(&xComputeHmacForData, libs, "g_compute_hmac_for_data")
	core.PuregoSafeRegister(&xComputeHmacForString, libs, "g_compute_hmac_for_string")

	core.PuregoSafeRegister(&xHmacGLibType, libs, "g_hmac_get_type")

	core.PuregoSafeRegister(&xNewHmac, libs, "g_hmac_new")

	core.PuregoSafeRegister(&xHmacCopy, libs, "g_hmac_copy")
	core.PuregoSafeRegister(&xHmacGetDigest, libs, "g_hmac_get_digest")
	core.PuregoSafeRegister(&xHmacGetString, libs, "g_hmac_get_string")
	core.PuregoSafeRegister(&xHmacRef, libs, "g_hmac_ref")
	core.PuregoSafeRegister(&xHmacUnref, libs, "g_hmac_unref")
	core.PuregoSafeRegister(&xHmacUpdate, libs, "g_hmac_update")

}
