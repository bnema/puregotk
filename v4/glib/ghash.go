// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Specifies the type of the function passed to
// [func@GLib.HashTable.find], [func@GLib.HashTable.foreach_remove], and
// [func@GLib.HashTable.foreach_steal].
//
// The function is called with each key/value pair, together with
// the @user_data parameter passed to the calling function.
//
// The function should return true if the key/value pair should be
// selected, meaning it has been found or it should be removed from the
// [struct@GLib.HashTable], depending on the calling function.
type HRFunc func(uintptr, uintptr, uintptr) bool

// The #GHashTable struct is an opaque data structure to represent a
// [Hash Table](data-structures.html#hash-tables). It should only be accessed via the
// following functions.
type HashTable struct {
	_ structs.HostLayout
}

var xHashTableGLibType func() types.GType

func HashTableGLibType() types.GType {
	return xHashTableGLibType()
}

func (x *HashTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A GHashTableIter structure represents an iterator that can be used
// to iterate over the elements of a #GHashTable. GHashTableIter
// structures are typically allocated on the stack and then initialized
// with g_hash_table_iter_init().
//
// The iteration order of a #GHashTableIter over the keys/values in a hash
// table is not defined.
type HashTableIter struct {
	_ structs.HostLayout

	Dummy1 uintptr

	Dummy2 uintptr

	Dummy3 uintptr

	Dummy4 int

	Dummy5 bool

	Dummy6 uintptr
}

func (x *HashTableIter) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xHashTableIterGetHashTable func(uintptr) *HashTable

// Returns the #GHashTable associated with @iter.
func (x *HashTableIter) GetHashTable() *HashTable {

	cret := xHashTableIterGetHashTable(x.GoPointer())
	return cret
}

var xHashTableIterInit func(uintptr, *HashTable)

// Initializes a key/value pair iterator and associates it with
// @hash_table. Modifying the hash table after calling this function
// invalidates the returned iterator.
//
// The iteration order of a #GHashTableIter over the keys/values in a hash
// table is not defined.
//
// |[&lt;!-- language="C" --&gt;
// GHashTableIter iter;
// gpointer key, value;
//
// g_hash_table_iter_init (&amp;iter, hash_table);
// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
//
//	{
//	  // do something with key and value
//	}
//
// ]|
func (x *HashTableIter) Init(HashTableVar *HashTable) {

	xHashTableIterInit(x.GoPointer(), HashTableVar)

}

var xHashTableIterNext func(uintptr, *uintptr, *uintptr) bool

// Advances @iter and retrieves the key and/or value that are now
// pointed to as a result of this advancement. If %FALSE is returned,
// @key and @value are not set, and the iterator becomes invalid.
func (x *HashTableIter) Next(KeyVar *uintptr, ValueVar *uintptr) bool {

	cret := xHashTableIterNext(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xHashTableIterRemove func(uintptr)

// Removes the key/value pair currently pointed to by the iterator
// from its associated #GHashTable. Can only be called after
// g_hash_table_iter_next() returned %TRUE, and cannot be called
// more than once for the same key/value pair.
//
// If the #GHashTable was created using g_hash_table_new_full(),
// the key and value are freed using the supplied destroy functions,
// otherwise you have to make sure that any dynamically allocated
// values are freed yourself.
//
// It is safe to continue iterating the #GHashTable afterward:
// |[&lt;!-- language="C" --&gt;
// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
//
//	{
//	  if (condition)
//	    g_hash_table_iter_remove (&amp;iter);
//	}
//
// ]|
func (x *HashTableIter) Remove() {

	xHashTableIterRemove(x.GoPointer())

}

var xHashTableIterReplace func(uintptr, uintptr)

// Replaces the value currently pointed to by the iterator
// from its associated #GHashTable. Can only be called after
// g_hash_table_iter_next() returned %TRUE.
//
// If you supplied a @value_destroy_func when creating the
// #GHashTable, the old value is freed using that function.
func (x *HashTableIter) Replace(ValueVar uintptr) {

	xHashTableIterReplace(x.GoPointer(), ValueVar)

}

var xHashTableIterSteal func(uintptr)

// Removes the key/value pair currently pointed to by the
// iterator from its associated #GHashTable, without calling
// the key and value destroy functions. Can only be called
// after g_hash_table_iter_next() returned %TRUE, and cannot
// be called more than once for the same key/value pair.
func (x *HashTableIter) Steal() {

	xHashTableIterSteal(x.GoPointer())

}

var xDirectEqual func(uintptr, uintptr) bool

// Compares two #gpointer arguments and returns %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using opaque pointers compared by pointer value as
// keys in a #GHashTable.
//
// This equality function is also appropriate for keys that are integers
// stored in pointers, such as `GINT_TO_POINTER (n)`.
func DirectEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xDirectEqual(V1Var, V2Var)
	return cret
}

var xDirectHash func(uintptr) uint

// Converts a gpointer to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using opaque pointers compared by pointer value as keys in a
// #GHashTable.
//
// This hash function is also appropriate for keys that are integers
// stored in pointers, such as `GINT_TO_POINTER (n)`.
func DirectHash(VVar uintptr) uint {

	cret := xDirectHash(VVar)
	return cret
}

var xDoubleEqual func(uintptr, uintptr) bool

// Compares the two #gdouble values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to doubles as keys in a
// #GHashTable.
func DoubleEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xDoubleEqual(V1Var, V2Var)
	return cret
}

var xDoubleHash func(uintptr) uint

// Converts a pointer to a #gdouble to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to doubles as keys in a #GHashTable.
func DoubleHash(VVar uintptr) uint {

	cret := xDoubleHash(VVar)
	return cret
}

var xHashTableAdd func(*HashTable, uintptr) bool

// This is a convenience function for using a #GHashTable as a set.  It
// is equivalent to calling g_hash_table_replace() with @key as both the
// key and the value.
//
// In particular, this means that if @key already exists in the hash table, then
// the old copy of @key in the hash table is freed and @key replaces it in the
// table.
//
// When a hash table only ever contains keys that have themselves as the
// corresponding value it is able to be stored more efficiently.  See
// the discussion in the section description.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableAdd(HashTableVar *HashTable, KeyVar uintptr) bool {

	cret := xHashTableAdd(HashTableVar, KeyVar)
	return cret
}

var xHashTableContains func(*HashTable, uintptr) bool

// Checks if @key is in @hash_table.
func HashTableContains(HashTableVar *HashTable, KeyVar uintptr) bool {

	cret := xHashTableContains(HashTableVar, KeyVar)
	return cret
}

var xHashTableDestroy func(*HashTable)

// Destroys all keys and values in the #GHashTable and decrements its
// reference count by 1. If keys and/or values are dynamically allocated,
// you should either free them first or create the #GHashTable with destroy
// notifiers using g_hash_table_new_full(). In the latter case the destroy
// functions you supplied will be called on all keys and values during the
// destruction phase.
func HashTableDestroy(HashTableVar *HashTable) {

	xHashTableDestroy(HashTableVar)

}

var xHashTableFind func(*HashTable, uintptr, uintptr) uintptr

// Calls the given function for key/value pairs in the #GHashTable
// until @predicate returns %TRUE. The function is passed the key
// and value of each pair, and the given @user_data parameter. The
// hash table may not be modified while iterating over it (you can't
// add/remove items).
//
// Note, that hash tables are really only optimized for forward
// lookups, i.e. g_hash_table_lookup(). So code that frequently issues
// g_hash_table_find() or g_hash_table_foreach() (e.g. in the order of
// once per every entry in a hash table) should probably be reworked
// to use additional or different data structures for reverse lookups
// (keep in mind that an O(n) find/foreach operation issued for all n
// values in a hash table ends up needing O(n*n) operations).
func HashTableFind(HashTableVar *HashTable, PredicateVar *HRFunc, UserDataVar uintptr) uintptr {

	var PredicateVarRef uintptr
	if PredicateVar != nil {
		PredicateVarPtr := uintptr(unsafe.Pointer(PredicateVar))
		if cbRefPtr, ok := GetCallback(PredicateVarPtr); ok {
			PredicateVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) bool {
				cbFn := *PredicateVar
				return cbFn(arg0, arg1, arg2)
			}
			PredicateVarRef = purego.NewCallback(fcb)
			SaveCallback(PredicateVarPtr, PredicateVarRef)
		}
	}

	cret := xHashTableFind(HashTableVar, PredicateVarRef, UserDataVar)
	return cret
}

var xHashTableForeach func(*HashTable, uintptr, uintptr)

// Calls the given function for each of the key/value pairs in the
// #GHashTable.  The function is passed the key and value of each
// pair, and the given @user_data parameter.  The hash table may not
// be modified while iterating over it (you can't add/remove
// items). To remove all items matching a predicate, use
// g_hash_table_foreach_remove().
//
// The order in which g_hash_table_foreach() iterates over the keys/values in
// the hash table is not defined.
//
// See g_hash_table_find() for performance caveats for linear
// order searches in contrast to g_hash_table_lookup().
func HashTableForeach(HashTableVar *HashTable, FuncVar *HFunc, UserDataVar uintptr) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *FuncVar
				cbFn(arg0, arg1, arg2)
			}
			FuncVarRef = purego.NewCallback(fcb)
			SaveCallback(FuncVarPtr, FuncVarRef)
		}
	}

	xHashTableForeach(HashTableVar, FuncVarRef, UserDataVar)

}

var xHashTableForeachRemove func(*HashTable, uintptr, uintptr) uint

// Calls the given function for each key/value pair in the
// #GHashTable. If the function returns %TRUE, then the key/value
// pair is removed from the #GHashTable. If you supplied key or
// value destroy functions when creating the #GHashTable, they are
// used to free the memory allocated for the removed keys and values.
//
// See #GHashTableIter for an alternative way to loop over the
// key/value pairs in the hash table.
func HashTableForeachRemove(HashTableVar *HashTable, FuncVar *HRFunc, UserDataVar uintptr) uint {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) bool {
				cbFn := *FuncVar
				return cbFn(arg0, arg1, arg2)
			}
			FuncVarRef = purego.NewCallback(fcb)
			SaveCallback(FuncVarPtr, FuncVarRef)
		}
	}

	cret := xHashTableForeachRemove(HashTableVar, FuncVarRef, UserDataVar)
	return cret
}

var xHashTableForeachSteal func(*HashTable, uintptr, uintptr) uint

// Calls the given function for each key/value pair in the
// #GHashTable. If the function returns %TRUE, then the key/value
// pair is removed from the #GHashTable, but no key or value
// destroy functions are called.
//
// See #GHashTableIter for an alternative way to loop over the
// key/value pairs in the hash table.
func HashTableForeachSteal(HashTableVar *HashTable, FuncVar *HRFunc, UserDataVar uintptr) uint {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) bool {
				cbFn := *FuncVar
				return cbFn(arg0, arg1, arg2)
			}
			FuncVarRef = purego.NewCallback(fcb)
			SaveCallback(FuncVarPtr, FuncVarRef)
		}
	}

	cret := xHashTableForeachSteal(HashTableVar, FuncVarRef, UserDataVar)
	return cret
}

var xHashTableGetKeysAsPtrArray func(*HashTable) uintptr

// Retrieves every key inside @hash_table, as a #GPtrArray.
// The returned data is valid until changes to the hash release those keys.
//
// This iterates over every entry in the hash table to build its return value.
// To iterate over the entries in a #GHashTable more efficiently, use a
// #GHashTableIter.
//
// You should always unref the returned array with g_ptr_array_unref().
func HashTableGetKeysAsPtrArray(HashTableVar *HashTable) uintptr {

	cret := xHashTableGetKeysAsPtrArray(HashTableVar)
	return cret
}

var xHashTableGetValuesAsPtrArray func(*HashTable) uintptr

// Retrieves every value inside @hash_table, as a #GPtrArray.
// The returned data is valid until changes to the hash release those values.
//
// This iterates over every entry in the hash table to build its return value.
// To iterate over the entries in a #GHashTable more efficiently, use a
// #GHashTableIter.
//
// You should always unref the returned array with g_ptr_array_unref().
func HashTableGetValuesAsPtrArray(HashTableVar *HashTable) uintptr {

	cret := xHashTableGetValuesAsPtrArray(HashTableVar)
	return cret
}

var xHashTableInsert func(*HashTable, uintptr, uintptr) bool

// Inserts a new key and value into a #GHashTable.
//
// If the key already exists in the #GHashTable its current
// value is replaced with the new value. If you supplied a
// @value_destroy_func when creating the #GHashTable, the old
// value is freed using that function. If you supplied a
// @key_destroy_func when creating the #GHashTable, the passed
// key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableInsert(HashTableVar *HashTable, KeyVar uintptr, ValueVar uintptr) bool {

	cret := xHashTableInsert(HashTableVar, KeyVar, ValueVar)
	return cret
}

var xHashTableLookup func(*HashTable, uintptr) uintptr

// Looks up a key in a #GHashTable. Note that this function cannot
// distinguish between a key that is not present and one which is present
// and has the value %NULL. If you need this distinction, use
// g_hash_table_lookup_extended().
func HashTableLookup(HashTableVar *HashTable, KeyVar uintptr) uintptr {

	cret := xHashTableLookup(HashTableVar, KeyVar)
	return cret
}

var xHashTableLookupExtended func(*HashTable, uintptr, *uintptr, *uintptr) bool

// Looks up a key in the #GHashTable, returning the original key and the
// associated value and a #gboolean which is %TRUE if the key was found. This
// is useful if you need to free the memory allocated for the original key,
// for example before calling g_hash_table_remove().
//
// You can actually pass %NULL for @lookup_key to test
// whether the %NULL key exists, provided the hash and equal functions
// of @hash_table are %NULL-safe.
func HashTableLookupExtended(HashTableVar *HashTable, LookupKeyVar uintptr, OrigKeyVar *uintptr, ValueVar *uintptr) bool {

	cret := xHashTableLookupExtended(HashTableVar, LookupKeyVar, OrigKeyVar, ValueVar)
	return cret
}

var xHashTableNewSimilar func(*HashTable) *HashTable

// Creates a new #GHashTable like g_hash_table_new_full() with a reference
// count of 1.
//
// It inherits the hash function, the key equal function, the key destroy function,
// as well as the value destroy function, from @other_hash_table.
//
// The returned hash table will be empty; it will not contain the keys
// or values from @other_hash_table.
func HashTableNewSimilar(OtherHashTableVar *HashTable) *HashTable {

	cret := xHashTableNewSimilar(OtherHashTableVar)
	return cret
}

var xHashTableRef func(*HashTable) *HashTable

// Atomically increments the reference count of @hash_table by one.
// This function is MT-safe and may be called from any thread.
func HashTableRef(HashTableVar *HashTable) *HashTable {

	cret := xHashTableRef(HashTableVar)
	return cret
}

var xHashTableRemove func(*HashTable, uintptr) bool

// Removes a key and its associated value from a #GHashTable.
//
// If the #GHashTable was created using g_hash_table_new_full(), the
// key and value are freed using the supplied destroy functions, otherwise
// you have to make sure that any dynamically allocated values are freed
// yourself.
func HashTableRemove(HashTableVar *HashTable, KeyVar uintptr) bool {

	cret := xHashTableRemove(HashTableVar, KeyVar)
	return cret
}

var xHashTableRemoveAll func(*HashTable)

// Removes all keys and their associated values from a #GHashTable.
//
// If the #GHashTable was created using g_hash_table_new_full(),
// the keys and values are freed using the supplied destroy functions,
// otherwise you have to make sure that any dynamically allocated
// values are freed yourself.
func HashTableRemoveAll(HashTableVar *HashTable) {

	xHashTableRemoveAll(HashTableVar)

}

var xHashTableReplace func(*HashTable, uintptr, uintptr) bool

// Inserts a new key and value into a #GHashTable similar to
// g_hash_table_insert(). The difference is that if the key
// already exists in the #GHashTable, it gets replaced by the
// new key. If you supplied a @value_destroy_func when creating
// the #GHashTable, the old value is freed using that function.
// If you supplied a @key_destroy_func when creating the
// #GHashTable, the old key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableReplace(HashTableVar *HashTable, KeyVar uintptr, ValueVar uintptr) bool {

	cret := xHashTableReplace(HashTableVar, KeyVar, ValueVar)
	return cret
}

var xHashTableSize func(*HashTable) uint

// Returns the number of elements contained in the #GHashTable.
func HashTableSize(HashTableVar *HashTable) uint {

	cret := xHashTableSize(HashTableVar)
	return cret
}

var xHashTableSteal func(*HashTable, uintptr) bool

// Removes a key and its associated value from a #GHashTable without
// calling the key and value destroy functions.
func HashTableSteal(HashTableVar *HashTable, KeyVar uintptr) bool {

	cret := xHashTableSteal(HashTableVar, KeyVar)
	return cret
}

var xHashTableStealAll func(*HashTable)

// Removes all keys and their associated values from a #GHashTable
// without calling the key and value destroy functions.
func HashTableStealAll(HashTableVar *HashTable) {

	xHashTableStealAll(HashTableVar)

}

var xHashTableStealAllKeys func(*HashTable) uintptr

// Removes all keys and their associated values from a #GHashTable
// without calling the key destroy functions, returning the keys
// as a #GPtrArray with the free func set to the @hash_table key
// destroy function.
func HashTableStealAllKeys(HashTableVar *HashTable) uintptr {

	cret := xHashTableStealAllKeys(HashTableVar)
	return cret
}

var xHashTableStealAllValues func(*HashTable) uintptr

// Removes all keys and their associated values from a #GHashTable
// without calling the value destroy functions, returning the values
// as a #GPtrArray with the free func set to the @hash_table value
// destroy function.
func HashTableStealAllValues(HashTableVar *HashTable) uintptr {

	cret := xHashTableStealAllValues(HashTableVar)
	return cret
}

var xHashTableStealExtended func(*HashTable, uintptr, *uintptr, *uintptr) bool

// Looks up a key in the #GHashTable, stealing the original key and the
// associated value and returning %TRUE if the key was found. If the key was
// not found, %FALSE is returned.
//
// If found, the stolen key and value are removed from the hash table without
// calling the key and value destroy functions, and ownership is transferred to
// the caller of this method, as with g_hash_table_steal(). That is the case
// regardless whether @stolen_key or @stolen_value output parameters are
// requested.
//
// You can pass %NULL for @lookup_key, provided the hash and equal functions
// of @hash_table are %NULL-safe.
//
// The dictionary implementation optimizes for having all values identical to
// their keys, for example by using g_hash_table_add(). Before 2.82, when
// stealing both the key and the value from such a dictionary, the value was
// %NULL. Since 2.82, the returned value and key will be the same.
func HashTableStealExtended(HashTableVar *HashTable, LookupKeyVar uintptr, StolenKeyVar *uintptr, StolenValueVar *uintptr) bool {

	cret := xHashTableStealExtended(HashTableVar, LookupKeyVar, StolenKeyVar, StolenValueVar)
	return cret
}

var xHashTableUnref func(*HashTable)

// Atomically decrements the reference count of @hash_table by one.
// If the reference count drops to 0, all keys and values will be
// destroyed, and all memory allocated by the hash table is released.
// This function is MT-safe and may be called from any thread.
func HashTableUnref(HashTableVar *HashTable) {

	xHashTableUnref(HashTableVar)

}

var xInt64Equal func(uintptr, uintptr) bool

// Compares the two #gint64 values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to 64-bit integers as keys in a
// #GHashTable.
func Int64Equal(V1Var uintptr, V2Var uintptr) bool {

	cret := xInt64Equal(V1Var, V2Var)
	return cret
}

var xInt64Hash func(uintptr) uint

// Converts a pointer to a #gint64 to a hash value.
//
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to 64-bit integer values as keys in a
// #GHashTable.
func Int64Hash(VVar uintptr) uint {

	cret := xInt64Hash(VVar)
	return cret
}

var xIntEqual func(uintptr, uintptr) bool

// Compares the two #gint values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to integers as keys in a
// #GHashTable.
//
// Note that this function acts on pointers to #gint, not on #gint
// directly: if your hash table's keys are of the form
// `GINT_TO_POINTER (n)`, use g_direct_equal() instead.
func IntEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xIntEqual(V1Var, V2Var)
	return cret
}

var xIntHash func(uintptr) uint

// Converts a pointer to a #gint to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to integer values as keys in a #GHashTable.
//
// Note that this function acts on pointers to #gint, not on #gint
// directly: if your hash table's keys are of the form
// `GINT_TO_POINTER (n)`, use g_direct_hash() instead.
func IntHash(VVar uintptr) uint {

	cret := xIntHash(VVar)
	return cret
}

var xStrEqual func(uintptr, uintptr) bool

// Compares two strings for byte-by-byte equality and returns %TRUE
// if they are equal. It can be passed to g_hash_table_new() as the
// @key_equal_func parameter, when using non-%NULL strings as keys in a
// #GHashTable.
//
// This function is typically used for hash table comparisons, but can be used
// for general purpose comparisons of non-%NULL strings. For a %NULL-safe string
// comparison function, see g_strcmp0().
func StrEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xStrEqual(V1Var, V2Var)
	return cret
}

var xStrHash func(uintptr) uint

// Converts a string to a hash value.
//
// This function implements the widely used "djb" hash apparently
// posted by Daniel Bernstein to comp.lang.c some time ago.  The 32
// bit unsigned hash value starts at 5381 and for each byte 'c' in
// the string, is updated: `hash = hash * 33 + c`. This function
// uses the signed value of each byte.
//
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL strings as keys in a #GHashTable.
//
// Note that this function may not be a perfect fit for all use cases.
// For example, it produces some hash collisions with strings as short
// as 2.
func StrHash(VVar uintptr) uint {

	cret := xStrHash(VVar)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xDirectEqual, libs, "g_direct_equal")
	core.PuregoSafeRegister(&xDirectHash, libs, "g_direct_hash")
	core.PuregoSafeRegister(&xDoubleEqual, libs, "g_double_equal")
	core.PuregoSafeRegister(&xDoubleHash, libs, "g_double_hash")
	core.PuregoSafeRegister(&xHashTableAdd, libs, "g_hash_table_add")
	core.PuregoSafeRegister(&xHashTableContains, libs, "g_hash_table_contains")
	core.PuregoSafeRegister(&xHashTableDestroy, libs, "g_hash_table_destroy")
	core.PuregoSafeRegister(&xHashTableFind, libs, "g_hash_table_find")
	core.PuregoSafeRegister(&xHashTableForeach, libs, "g_hash_table_foreach")
	core.PuregoSafeRegister(&xHashTableForeachRemove, libs, "g_hash_table_foreach_remove")
	core.PuregoSafeRegister(&xHashTableForeachSteal, libs, "g_hash_table_foreach_steal")
	core.PuregoSafeRegister(&xHashTableGetKeysAsPtrArray, libs, "g_hash_table_get_keys_as_ptr_array")
	core.PuregoSafeRegister(&xHashTableGetValuesAsPtrArray, libs, "g_hash_table_get_values_as_ptr_array")
	core.PuregoSafeRegister(&xHashTableInsert, libs, "g_hash_table_insert")
	core.PuregoSafeRegister(&xHashTableLookup, libs, "g_hash_table_lookup")
	core.PuregoSafeRegister(&xHashTableLookupExtended, libs, "g_hash_table_lookup_extended")
	core.PuregoSafeRegister(&xHashTableNewSimilar, libs, "g_hash_table_new_similar")
	core.PuregoSafeRegister(&xHashTableRef, libs, "g_hash_table_ref")
	core.PuregoSafeRegister(&xHashTableRemove, libs, "g_hash_table_remove")
	core.PuregoSafeRegister(&xHashTableRemoveAll, libs, "g_hash_table_remove_all")
	core.PuregoSafeRegister(&xHashTableReplace, libs, "g_hash_table_replace")
	core.PuregoSafeRegister(&xHashTableSize, libs, "g_hash_table_size")
	core.PuregoSafeRegister(&xHashTableSteal, libs, "g_hash_table_steal")
	core.PuregoSafeRegister(&xHashTableStealAll, libs, "g_hash_table_steal_all")
	core.PuregoSafeRegister(&xHashTableStealAllKeys, libs, "g_hash_table_steal_all_keys")
	core.PuregoSafeRegister(&xHashTableStealAllValues, libs, "g_hash_table_steal_all_values")
	core.PuregoSafeRegister(&xHashTableStealExtended, libs, "g_hash_table_steal_extended")
	core.PuregoSafeRegister(&xHashTableUnref, libs, "g_hash_table_unref")
	core.PuregoSafeRegister(&xInt64Equal, libs, "g_int64_equal")
	core.PuregoSafeRegister(&xInt64Hash, libs, "g_int64_hash")
	core.PuregoSafeRegister(&xIntEqual, libs, "g_int_equal")
	core.PuregoSafeRegister(&xIntHash, libs, "g_int_hash")
	core.PuregoSafeRegister(&xStrEqual, libs, "g_str_equal")
	core.PuregoSafeRegister(&xStrHash, libs, "g_str_hash")

	core.PuregoSafeRegister(&xHashTableGLibType, libs, "g_hash_table_get_type")

	core.PuregoSafeRegister(&xHashTableIterGetHashTable, libs, "g_hash_table_iter_get_hash_table")
	core.PuregoSafeRegister(&xHashTableIterInit, libs, "g_hash_table_iter_init")
	core.PuregoSafeRegister(&xHashTableIterNext, libs, "g_hash_table_iter_next")
	core.PuregoSafeRegister(&xHashTableIterRemove, libs, "g_hash_table_iter_remove")
	core.PuregoSafeRegister(&xHashTableIterReplace, libs, "g_hash_table_iter_replace")
	core.PuregoSafeRegister(&xHashTableIterSteal, libs, "g_hash_table_iter_steal")

}
