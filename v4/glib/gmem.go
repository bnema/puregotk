// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// A set of functions used to perform memory allocation. The same #GMemVTable must
// be used for all allocations in the same program; a call to g_mem_set_vtable(),
// if it exists, should be prior to any use of GLib.
//
// This functions related to this has been deprecated in 2.46, and no longer work.
type MemVTable struct {
	_ structs.HostLayout

	xMalloc uintptr

	xRealloc uintptr

	xFree uintptr

	xCalloc uintptr

	xTryMalloc uintptr

	xTryRealloc uintptr
}

func (x *MemVTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideMalloc sets the callback function.
// function to use for allocating memory.
func (x *MemVTable) OverrideMalloc(cb func(uint) uintptr) {
	if cb == nil {
		x.xMalloc = 0
	} else {
		x.xMalloc = purego.NewCallback(func(NBytesVarp uint) uintptr {
			return cb(NBytesVarp)
		})
	}
}

// GetMalloc gets the callback function.
// function to use for allocating memory.
func (x *MemVTable) GetMalloc() func(uint) uintptr {
	if x.xMalloc == 0 {
		return nil
	}
	var rawCallback func(NBytesVarp uint) uintptr
	purego.RegisterFunc(&rawCallback, x.xMalloc)
	return func(NBytesVar uint) uintptr {
		return rawCallback(NBytesVar)
	}
}

// OverrideRealloc sets the callback function.
// function to use for reallocating memory.
func (x *MemVTable) OverrideRealloc(cb func(uintptr, uint) uintptr) {
	if cb == nil {
		x.xRealloc = 0
	} else {
		x.xRealloc = purego.NewCallback(func(MemVarp uintptr, NBytesVarp uint) uintptr {
			return cb(MemVarp, NBytesVarp)
		})
	}
}

// GetRealloc gets the callback function.
// function to use for reallocating memory.
func (x *MemVTable) GetRealloc() func(uintptr, uint) uintptr {
	if x.xRealloc == 0 {
		return nil
	}
	var rawCallback func(MemVarp uintptr, NBytesVarp uint) uintptr
	purego.RegisterFunc(&rawCallback, x.xRealloc)
	return func(MemVar uintptr, NBytesVar uint) uintptr {
		return rawCallback(MemVar, NBytesVar)
	}
}

// OverrideFree sets the callback function.
// function to use to free memory.
func (x *MemVTable) OverrideFree(cb func(uintptr)) {
	if cb == nil {
		x.xFree = 0
	} else {
		x.xFree = purego.NewCallback(func(MemVarp uintptr) {
			cb(MemVarp)
		})
	}
}

// GetFree gets the callback function.
// function to use to free memory.
func (x *MemVTable) GetFree() func(uintptr) {
	if x.xFree == 0 {
		return nil
	}
	var rawCallback func(MemVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xFree)
	return func(MemVar uintptr) {
		rawCallback(MemVar)
	}
}

// OverrideCalloc sets the callback function.
// function to use for allocating zero-filled memory.
func (x *MemVTable) OverrideCalloc(cb func(uint, uint) uintptr) {
	if cb == nil {
		x.xCalloc = 0
	} else {
		x.xCalloc = purego.NewCallback(func(NBlocksVarp uint, NBlockBytesVarp uint) uintptr {
			return cb(NBlocksVarp, NBlockBytesVarp)
		})
	}
}

// GetCalloc gets the callback function.
// function to use for allocating zero-filled memory.
func (x *MemVTable) GetCalloc() func(uint, uint) uintptr {
	if x.xCalloc == 0 {
		return nil
	}
	var rawCallback func(NBlocksVarp uint, NBlockBytesVarp uint) uintptr
	purego.RegisterFunc(&rawCallback, x.xCalloc)
	return func(NBlocksVar uint, NBlockBytesVar uint) uintptr {
		return rawCallback(NBlocksVar, NBlockBytesVar)
	}
}

// OverrideTryMalloc sets the callback function.
// function to use for allocating memory without a default error handler.
func (x *MemVTable) OverrideTryMalloc(cb func(uint) uintptr) {
	if cb == nil {
		x.xTryMalloc = 0
	} else {
		x.xTryMalloc = purego.NewCallback(func(NBytesVarp uint) uintptr {
			return cb(NBytesVarp)
		})
	}
}

// GetTryMalloc gets the callback function.
// function to use for allocating memory without a default error handler.
func (x *MemVTable) GetTryMalloc() func(uint) uintptr {
	if x.xTryMalloc == 0 {
		return nil
	}
	var rawCallback func(NBytesVarp uint) uintptr
	purego.RegisterFunc(&rawCallback, x.xTryMalloc)
	return func(NBytesVar uint) uintptr {
		return rawCallback(NBytesVar)
	}
}

// OverrideTryRealloc sets the callback function.
// function to use for reallocating memory without a default error handler.
func (x *MemVTable) OverrideTryRealloc(cb func(uintptr, uint) uintptr) {
	if cb == nil {
		x.xTryRealloc = 0
	} else {
		x.xTryRealloc = purego.NewCallback(func(MemVarp uintptr, NBytesVarp uint) uintptr {
			return cb(MemVarp, NBytesVarp)
		})
	}
}

// GetTryRealloc gets the callback function.
// function to use for reallocating memory without a default error handler.
func (x *MemVTable) GetTryRealloc() func(uintptr, uint) uintptr {
	if x.xTryRealloc == 0 {
		return nil
	}
	var rawCallback func(MemVarp uintptr, NBytesVarp uint) uintptr
	purego.RegisterFunc(&rawCallback, x.xTryRealloc)
	return func(MemVar uintptr, NBytesVar uint) uintptr {
		return rawCallback(MemVar, NBytesVar)
	}
}

var xAlignedAlloc func(uint, uint, uint) uintptr

// This function is similar to g_malloc(), allocating (@n_blocks * @n_block_bytes)
// bytes, but care is taken to align the allocated memory to with the given
// alignment value. Additionally, it will detect possible overflow during
// multiplication.
//
// If the allocation fails (because the system is out of memory),
// the program is terminated.
//
// Aligned memory allocations returned by this function can only be
// freed using g_aligned_free_sized() or g_aligned_free().
func AlignedAlloc(NBlocksVar uint, NBlockBytesVar uint, AlignmentVar uint) uintptr {

	cret := xAlignedAlloc(NBlocksVar, NBlockBytesVar, AlignmentVar)
	return cret
}

var xAlignedAlloc0 func(uint, uint, uint) uintptr

// This function is similar to g_aligned_alloc(), but it will
// also clear the allocated memory before returning it.
func AlignedAlloc0(NBlocksVar uint, NBlockBytesVar uint, AlignmentVar uint) uintptr {

	cret := xAlignedAlloc0(NBlocksVar, NBlockBytesVar, AlignmentVar)
	return cret
}

var xAlignedFree func(uintptr)

// Frees the memory allocated by g_aligned_alloc().
func AlignedFree(MemVar uintptr) {

	xAlignedFree(MemVar)

}

var xAlignedFreeSized func(uintptr, uint, uint)

// Frees the memory pointed to by @mem, assuming it is has the given @size and
// @alignment.
//
// If @mem is %NULL this is a no-op (and @size is ignored).
//
// It is an error if @size doesn’t match the size, or @alignment doesn’t match
// the alignment, passed when @mem was allocated. @size and @alignment are
// passed to this function to allow optimizations in the allocator. If you
// don’t know either of them, use g_aligned_free() instead.
func AlignedFreeSized(MemVar uintptr, AlignmentVar uint, SizeVar uint) {

	xAlignedFreeSized(MemVar, AlignmentVar, SizeVar)

}

var xClearPointer func(uintptr, uintptr)

// Clears a reference to a variable.
//
// @pp must not be %NULL.
//
// If the reference is %NULL then this function does nothing.
// Otherwise, the variable is destroyed using @destroy and the
// pointer is set to %NULL.
//
// A macro is also included that allows this function to be used without
// pointer casts. This will mask any warnings about incompatible function types
// or calling conventions, so you must ensure that your @destroy function is
// compatible with being called as [callback@GLib.DestroyNotify] using the
// standard calling convention for the platform that GLib was compiled for;
// otherwise the program will experience undefined behaviour.
//
// Examples of this kind of undefined behaviour include using many Windows Win32
// APIs, as well as many if not all OpenGL and Vulkan calls on 32-bit Windows,
// which typically use the `__stdcall` calling convention rather than the
// `__cdecl` calling convention.
//
// The affected functions can be used by wrapping them in a
// [callback@GLib.DestroyNotify] that is declared with the standard calling
// convention:
//
// ```c
// // Wrapper needed to avoid mismatched calling conventions on Windows
// static void
// destroy_sync (void *sync)
//
//	{
//	  glDeleteSync (sync);
//	}
//
// // …
//
// g_clear_pointer (&amp;sync, destroy_sync);
// ```
func ClearPointer(PpVar uintptr, DestroyVar *DestroyNotify) {

	xClearPointer(PpVar, NewCallback(DestroyVar))

}

var xFree func(uintptr)

// Frees the memory pointed to by @mem.
//
// If you know the allocated size of @mem, calling g_free_sized() may be faster,
// depending on the libc implementation in use.
//
// Starting from GLib 2.78, this may happen automatically in case a GCC
// compatible compiler is used with some optimization level and the allocated
// size is known at compile time (see [documentation of
// `__builtin_object_size()`](https://gcc.gnu.org/onlinedocs/gcc/Object-Size-Checking.html)
// to understand its caveats).
//
// If @mem is %NULL it simply returns, so there is no need to check @mem
// against %NULL before calling this function.
func Free(MemVar uintptr) {

	xFree(MemVar)

}

var xFreeSized func(uintptr, uint)

// Frees the memory pointed to by @mem, assuming it is has the given @size.
//
// If @mem is %NULL this is a no-op (and @size is ignored).
//
// It is an error if @size doesn’t match the size passed when @mem was
// allocated. @size is passed to this function to allow optimizations in the
// allocator. If you don’t know the allocation size, use g_free() instead.
//
// In case a GCC compatible compiler is used, this function may be used
// automatically via g_free() if the allocated size is known at compile time,
// since GLib 2.78.
func FreeSized(MemVar uintptr, SizeVar uint) {

	xFreeSized(MemVar, SizeVar)

}

var xMalloc func(uint) uintptr

// Allocates @n_bytes bytes of memory.
// If @n_bytes is 0 it returns %NULL.
//
// If the allocation fails (because the system is out of memory),
// the program is terminated.
func Malloc(NBytesVar uint) uintptr {

	cret := xMalloc(NBytesVar)
	return cret
}

var xMalloc0 func(uint) uintptr

// Allocates @n_bytes bytes of memory, initialized to 0's.
// If @n_bytes is 0 it returns %NULL.
//
// If the allocation fails (because the system is out of memory),
// the program is terminated.
func Malloc0(NBytesVar uint) uintptr {

	cret := xMalloc0(NBytesVar)
	return cret
}

var xMalloc0N func(uint, uint) uintptr

// This function is similar to g_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
// but care is taken to detect possible overflow during multiplication.
//
// If the allocation fails (because the system is out of memory),
// the program is terminated.
func Malloc0N(NBlocksVar uint, NBlockBytesVar uint) uintptr {

	cret := xMalloc0N(NBlocksVar, NBlockBytesVar)
	return cret
}

var xMallocN func(uint, uint) uintptr

// This function is similar to g_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
// but care is taken to detect possible overflow during multiplication.
//
// If the allocation fails (because the system is out of memory),
// the program is terminated.
func MallocN(NBlocksVar uint, NBlockBytesVar uint) uintptr {

	cret := xMallocN(NBlocksVar, NBlockBytesVar)
	return cret
}

var xMemIsSystemMalloc func() bool

// Checks whether the allocator used by g_malloc() is the system's
// malloc implementation. If it returns %TRUE memory allocated with
// malloc() can be used interchangeably with memory allocated using g_malloc().
// This function is useful for avoiding an extra copy of allocated memory returned
// by a non-GLib-based API.
func MemIsSystemMalloc() bool {

	cret := xMemIsSystemMalloc()
	return cret
}

var xMemProfile func()

// GLib used to support some tools for memory profiling, but this
// no longer works. There are many other useful tools for memory
// profiling these days which can be used instead.
func MemProfile() {

	xMemProfile()

}

var xMemSetVtable func(*MemVTable)

// This function used to let you override the memory allocation function.
// However, its use was incompatible with the use of global constructors
// in GLib and GIO, because those use the GLib allocators before main is
// reached. Therefore this function is now deprecated and is just a stub.
func MemSetVtable(VtableVar *MemVTable) {

	xMemSetVtable(VtableVar)

}

var xRealloc func(uintptr, uint) uintptr

// Reallocates the memory pointed to by @mem, so that it now has space for
// @n_bytes bytes of memory. It returns the new address of the memory, which may
// have been moved. @mem may be %NULL, in which case it's considered to
// have zero-length. @n_bytes may be 0, in which case %NULL will be returned
// and @mem will be freed unless it is %NULL.
//
// If the allocation fails (because the system is out of memory),
// the program is terminated.
func Realloc(MemVar uintptr, NBytesVar uint) uintptr {

	cret := xRealloc(MemVar, NBytesVar)
	return cret
}

var xReallocN func(uintptr, uint, uint) uintptr

// This function is similar to g_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
// but care is taken to detect possible overflow during multiplication.
//
// If the allocation fails (because the system is out of memory),
// the program is terminated.
func ReallocN(MemVar uintptr, NBlocksVar uint, NBlockBytesVar uint) uintptr {

	cret := xReallocN(MemVar, NBlocksVar, NBlockBytesVar)
	return cret
}

var xTryMalloc func(uint) uintptr

// Attempts to allocate @n_bytes, and returns %NULL on failure.
// Contrast with g_malloc(), which aborts the program on failure.
func TryMalloc(NBytesVar uint) uintptr {

	cret := xTryMalloc(NBytesVar)
	return cret
}

var xTryMalloc0 func(uint) uintptr

// Attempts to allocate @n_bytes, initialized to 0's, and returns %NULL on
// failure. Contrast with g_malloc0(), which aborts the program on failure.
func TryMalloc0(NBytesVar uint) uintptr {

	cret := xTryMalloc0(NBytesVar)
	return cret
}

var xTryMalloc0N func(uint, uint) uintptr

// This function is similar to g_try_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
// but care is taken to detect possible overflow during multiplication.
func TryMalloc0N(NBlocksVar uint, NBlockBytesVar uint) uintptr {

	cret := xTryMalloc0N(NBlocksVar, NBlockBytesVar)
	return cret
}

var xTryMallocN func(uint, uint) uintptr

// This function is similar to g_try_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
// but care is taken to detect possible overflow during multiplication.
func TryMallocN(NBlocksVar uint, NBlockBytesVar uint) uintptr {

	cret := xTryMallocN(NBlocksVar, NBlockBytesVar)
	return cret
}

var xTryRealloc func(uintptr, uint) uintptr

// Attempts to realloc @mem to a new size, @n_bytes, and returns %NULL
// on failure. Contrast with g_realloc(), which aborts the program
// on failure.
//
// If @mem is %NULL, behaves the same as g_try_malloc().
func TryRealloc(MemVar uintptr, NBytesVar uint) uintptr {

	cret := xTryRealloc(MemVar, NBytesVar)
	return cret
}

var xTryReallocN func(uintptr, uint, uint) uintptr

// This function is similar to g_try_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
// but care is taken to detect possible overflow during multiplication.
func TryReallocN(MemVar uintptr, NBlocksVar uint, NBlockBytesVar uint) uintptr {

	cret := xTryReallocN(MemVar, NBlocksVar, NBlockBytesVar)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAlignedAlloc, libs, "g_aligned_alloc")
	core.PuregoSafeRegister(&xAlignedAlloc0, libs, "g_aligned_alloc0")
	core.PuregoSafeRegister(&xAlignedFree, libs, "g_aligned_free")
	core.PuregoSafeRegister(&xAlignedFreeSized, libs, "g_aligned_free_sized")
	core.PuregoSafeRegister(&xClearPointer, libs, "g_clear_pointer")
	core.PuregoSafeRegister(&xFree, libs, "g_free")
	core.PuregoSafeRegister(&xFreeSized, libs, "g_free_sized")
	core.PuregoSafeRegister(&xMalloc, libs, "g_malloc")
	core.PuregoSafeRegister(&xMalloc0, libs, "g_malloc0")
	core.PuregoSafeRegister(&xMalloc0N, libs, "g_malloc0_n")
	core.PuregoSafeRegister(&xMallocN, libs, "g_malloc_n")
	core.PuregoSafeRegister(&xMemIsSystemMalloc, libs, "g_mem_is_system_malloc")
	core.PuregoSafeRegister(&xMemProfile, libs, "g_mem_profile")
	core.PuregoSafeRegister(&xMemSetVtable, libs, "g_mem_set_vtable")
	core.PuregoSafeRegister(&xRealloc, libs, "g_realloc")
	core.PuregoSafeRegister(&xReallocN, libs, "g_realloc_n")
	core.PuregoSafeRegister(&xTryMalloc, libs, "g_try_malloc")
	core.PuregoSafeRegister(&xTryMalloc0, libs, "g_try_malloc0")
	core.PuregoSafeRegister(&xTryMalloc0N, libs, "g_try_malloc0_n")
	core.PuregoSafeRegister(&xTryMallocN, libs, "g_try_malloc_n")
	core.PuregoSafeRegister(&xTryRealloc, libs, "g_try_realloc")
	core.PuregoSafeRegister(&xTryReallocN, libs, "g_try_realloc_n")

}
