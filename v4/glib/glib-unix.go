// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// The type of functions to be called when a UNIX fd watch source
// triggers.
type UnixFDSourceFunc func(int, IOCondition, uintptr) bool

// A Unix pipe. The advantage of this type over `int[2]` is that it can
// be closed automatically when it goes out of scope, using `g_auto(GUnixPipe)`,
// on compilers that support that feature.
type UnixPipe struct {
	_ structs.HostLayout

	Fds [2]int
}

func (x *UnixPipe) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Mnemonic constants for the ends of a Unix pipe.
type UnixPipeEnd int

const (

	// The readable file descriptor 0
	GUnixPipeEndReadValue UnixPipeEnd = 0
	// The writable file descriptor 1
	GUnixPipeEndWriteValue UnixPipeEnd = 1
)

var xClosefrom func(int) int

// Close every file descriptor equal to or greater than @lowfd.
//
// Typically @lowfd will be 3, to leave standard input, standard output
// and standard error open.
//
// This is the same as Linux `close_range (lowfd, ~0U, 0)`,
// but portable to other OSs and to older versions of Linux.
// Equivalently, it is the same as BSD `closefrom (lowfd)`, but portable,
// and async-signal-safe on all OSs.
//
// This function is async-signal safe, making it safe to call from a
// signal handler or a [callback@GLib.SpawnChildSetupFunc], as long as @lowfd is
// non-negative.
// See [`signal(7)`](man:signal(7)) and
// [`signal-safety(7)`](man:signal-safety(7)) for more details.
func Closefrom(LowfdVar int) int {

	cret := xClosefrom(LowfdVar)
	return cret
}

var xFdwalkSetCloexec func(int) int

// Mark every file descriptor equal to or greater than @lowfd to be closed
// at the next `execve()` or similar, as if via the `FD_CLOEXEC` flag.
//
// Typically @lowfd will be 3, to leave standard input, standard output
// and standard error open after exec.
//
// This is the same as Linux `close_range (lowfd, ~0U, CLOSE_RANGE_CLOEXEC)`,
// but portable to other OSs and to older versions of Linux.
//
// This function is async-signal safe, making it safe to call from a
// signal handler or a [callback@GLib.SpawnChildSetupFunc], as long as @lowfd is
// non-negative.
// See [`signal(7)`](man:signal(7)) and
// [`signal-safety(7)`](man:signal-safety(7)) for more details.
func FdwalkSetCloexec(LowfdVar int) int {

	cret := xFdwalkSetCloexec(LowfdVar)
	return cret
}

var xUnixFdAdd func(int, IOCondition, uintptr, uintptr) uint

// Sets a function to be called when the IO condition, as specified by
// @condition becomes true for @fd.
//
// @function will be called when the specified IO condition becomes
// %TRUE.  The function is expected to clear whatever event caused the
// IO condition to become true and return %TRUE in order to be notified
// when it happens again.  If @function returns %FALSE then the watch
// will be cancelled.
//
// The return value of this function can be passed to g_source_remove()
// to cancel the watch at any time that it exists.
//
// The source will never close the fd -- you must do it yourself.
func UnixFdAdd(FdVar int, ConditionVar IOCondition, FunctionVar *UnixFDSourceFunc, UserDataVar uintptr) uint {

	cret := xUnixFdAdd(FdVar, ConditionVar, NewCallback(FunctionVar), UserDataVar)
	return cret
}

var xUnixFdAddFull func(int, int, IOCondition, uintptr, uintptr, uintptr) uint

// Sets a function to be called when the IO condition, as specified by
// @condition becomes true for @fd.
//
// This is the same as g_unix_fd_add(), except that it allows you to
// specify a non-default priority and a provide a #GDestroyNotify for
// @user_data.
func UnixFdAddFull(PriorityVar int, FdVar int, ConditionVar IOCondition, FunctionVar *UnixFDSourceFunc, UserDataVar uintptr, NotifyVar *DestroyNotify) uint {

	cret := xUnixFdAddFull(PriorityVar, FdVar, ConditionVar, NewCallback(FunctionVar), UserDataVar, NewCallback(NotifyVar))
	return cret
}

var xUnixFdSourceNew func(int, IOCondition) *Source

// Creates a #GSource to watch for a particular I/O condition on a file
// descriptor.
//
// The source will never close the @fd — you must do it yourself.
//
// Any callback attached to the returned #GSource must have type
// #GUnixFDSourceFunc.
func UnixFdSourceNew(FdVar int, ConditionVar IOCondition) *Source {

	cret := xUnixFdSourceNew(FdVar, ConditionVar)
	return cret
}

var xUnixGetPasswdEntry func(string, **Error) uintptr

// Get the `passwd` file entry for the given @user_name using `getpwnam_r()`.
// This can fail if the given @user_name doesn’t exist.
//
// The returned `struct passwd` has been allocated using g_malloc() and should
// be freed using g_free(). The strings referenced by the returned struct are
// included in the same allocation, so are valid until the `struct passwd` is
// freed.
//
// This function is safe to call from multiple threads concurrently.
//
// You will need to include `pwd.h` to get the definition of `struct passwd`.
func UnixGetPasswdEntry(UserNameVar string) (uintptr, error) {
	var cerr *Error

	cret := xUnixGetPasswdEntry(UserNameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixOpenPipe func([2]int, int, **Error) bool

// Similar to the UNIX pipe() call, but on modern systems like Linux
// uses the pipe2() system call, which atomically creates a pipe with
// the configured flags.
//
// As of GLib 2.78, the supported flags are `O_CLOEXEC`/`FD_CLOEXEC` (see below)
// and `O_NONBLOCK`. Prior to GLib 2.78, only `FD_CLOEXEC` was supported — if
// you wanted to configure `O_NONBLOCK` then that had to be done separately with
// `fcntl()`.
//
// Since GLib 2.80, the constants %G_UNIX_PIPE_END_READ and
// %G_UNIX_PIPE_END_WRITE can be used as mnemonic indexes in @fds.
//
// It is a programmer error to call this function with unsupported flags, and a
// critical warning will be raised.
//
// As of GLib 2.78, it is preferred to pass `O_CLOEXEC` in, rather than
// `FD_CLOEXEC`, as that matches the underlying `pipe()` API more closely. Prior
// to 2.78, only `FD_CLOEXEC` was supported. Support for `FD_CLOEXEC` may be
// deprecated and removed in future.
func UnixOpenPipe(FdsVar [2]int, FlagsVar int) (bool, error) {
	var cerr *Error

	cret := xUnixOpenPipe(FdsVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixSetFdNonblocking func(int, bool, **Error) bool

// Control the non-blocking state of the given file descriptor,
// according to @nonblock. On most systems this uses %O_NONBLOCK, but
// on some older ones may use %O_NDELAY.
func UnixSetFdNonblocking(FdVar int, NonblockVar bool) (bool, error) {
	var cerr *Error

	cret := xUnixSetFdNonblocking(FdVar, NonblockVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixSignalAdd func(int, uintptr, uintptr) uint

// A convenience function for g_unix_signal_source_new(), which
// attaches to the default #GMainContext.  You can remove the watch
// using g_source_remove().
func UnixSignalAdd(SignumVar int, HandlerVar *SourceFunc, UserDataVar uintptr) uint {

	cret := xUnixSignalAdd(SignumVar, NewCallback(HandlerVar), UserDataVar)
	return cret
}

var xUnixSignalAddFull func(int, int, uintptr, uintptr, uintptr) uint

// A convenience function for g_unix_signal_source_new(), which
// attaches to the default #GMainContext.  You can remove the watch
// using g_source_remove().
func UnixSignalAddFull(PriorityVar int, SignumVar int, HandlerVar *SourceFunc, UserDataVar uintptr, NotifyVar *DestroyNotify) uint {

	cret := xUnixSignalAddFull(PriorityVar, SignumVar, NewCallback(HandlerVar), UserDataVar, NewCallback(NotifyVar))
	return cret
}

var xUnixSignalSourceNew func(int) *Source

// Create a #GSource that will be dispatched upon delivery of the UNIX
// signal @signum.  In GLib versions before 2.36, only `SIGHUP`, `SIGINT`,
// `SIGTERM` can be monitored.  In GLib 2.36, `SIGUSR1` and `SIGUSR2`
// were added. In GLib 2.54, `SIGWINCH` was added.
//
// Note that unlike the UNIX default, all sources which have created a
// watch will be dispatched, regardless of which underlying thread
// invoked g_unix_signal_source_new().
//
// For example, an effective use of this function is to handle `SIGTERM`
// cleanly; flushing any outstanding files, and then calling
// g_main_loop_quit().  It is not safe to do any of this from a regular
// UNIX signal handler; such a handler may be invoked while malloc() or
// another library function is running, causing reentrancy issues if the
// handler attempts to use those functions.  None of the GLib/GObject
// API is safe against this kind of reentrancy.
//
// The interaction of this source when combined with native UNIX
// functions like sigprocmask() is not defined.
//
// The source will not initially be associated with any #GMainContext
// and must be added to one with g_source_attach() before it will be
// executed.
func UnixSignalSourceNew(SignumVar int) *Source {

	cret := xUnixSignalSourceNew(SignumVar)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibrary("GLIB", "libgobject-2.0.so.0,libglib-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xClosefrom, lib, "g_closefrom")
	core.PuregoSafeRegister(&xFdwalkSetCloexec, lib, "g_fdwalk_set_cloexec")
	core.PuregoSafeRegister(&xUnixFdAdd, lib, "g_unix_fd_add")
	core.PuregoSafeRegister(&xUnixFdAddFull, lib, "g_unix_fd_add_full")
	core.PuregoSafeRegister(&xUnixFdSourceNew, lib, "g_unix_fd_source_new")
	core.PuregoSafeRegister(&xUnixGetPasswdEntry, lib, "g_unix_get_passwd_entry")
	core.PuregoSafeRegister(&xUnixOpenPipe, lib, "g_unix_open_pipe")
	core.PuregoSafeRegister(&xUnixSetFdNonblocking, lib, "g_unix_set_fd_nonblocking")
	core.PuregoSafeRegister(&xUnixSignalAdd, lib, "g_unix_signal_add")
	core.PuregoSafeRegister(&xUnixSignalAddFull, lib, "g_unix_signal_add_full")
	core.PuregoSafeRegister(&xUnixSignalSourceNew, lib, "g_unix_signal_source_new")

}
