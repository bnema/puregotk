// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

var xAtomicRcBoxAcquire func(uintptr) uintptr

// Atomically acquires a reference on the data pointed by @mem_block.
func AtomicRcBoxAcquire(MemBlockVar uintptr) uintptr {

	cret := xAtomicRcBoxAcquire(MemBlockVar)
	return cret
}

var xAtomicRcBoxAlloc func(uint) uintptr

// Allocates @block_size bytes of memory, and adds atomic
// reference counting semantics to it.
//
// The data will be freed when its reference count drops to
// zero.
//
// The allocated data is guaranteed to be suitably aligned for any
// built-in type.
func AtomicRcBoxAlloc(BlockSizeVar uint) uintptr {

	cret := xAtomicRcBoxAlloc(BlockSizeVar)
	return cret
}

var xAtomicRcBoxAlloc0 func(uint) uintptr

// Allocates @block_size bytes of memory, and adds atomic
// reference counting semantics to it.
//
// The contents of the returned data is set to zero.
//
// The data will be freed when its reference count drops to
// zero.
//
// The allocated data is guaranteed to be suitably aligned for any
// built-in type.
func AtomicRcBoxAlloc0(BlockSizeVar uint) uintptr {

	cret := xAtomicRcBoxAlloc0(BlockSizeVar)
	return cret
}

var xAtomicRcBoxDup func(uint, uintptr) uintptr

// Allocates a new block of data with atomic reference counting
// semantics, and copies @block_size bytes of @mem_block
// into it.
func AtomicRcBoxDup(BlockSizeVar uint, MemBlockVar uintptr) uintptr {

	cret := xAtomicRcBoxDup(BlockSizeVar, MemBlockVar)
	return cret
}

var xAtomicRcBoxGetSize func(uintptr) uint

// Retrieves the size of the reference counted data pointed by @mem_block.
func AtomicRcBoxGetSize(MemBlockVar uintptr) uint {

	cret := xAtomicRcBoxGetSize(MemBlockVar)
	return cret
}

var xAtomicRcBoxRelease func(uintptr)

// Atomically releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will free the
// resources allocated for @mem_block.
func AtomicRcBoxRelease(MemBlockVar uintptr) {

	xAtomicRcBoxRelease(MemBlockVar)

}

var xAtomicRcBoxReleaseFull func(uintptr, uintptr)

// Atomically releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will call @clear_func
// to clear the contents of @mem_block, and then will free the
// resources allocated for @mem_block.
//
// Note that implementing weak references via @clear_func is not thread-safe:
// clearing a pointer to the memory from the callback can race with another
// thread trying to access it as @mem_block already has a reference count of 0
// when the callback is called and will be freed.
func AtomicRcBoxReleaseFull(MemBlockVar uintptr, ClearFuncVar *DestroyNotify) {

	var ClearFuncVarRef uintptr
	if ClearFuncVar != nil {
		ClearFuncVarPtr := uintptr(unsafe.Pointer(ClearFuncVar))
		if cbRefPtr, ok := GetCallback(ClearFuncVarPtr); ok {
			ClearFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *ClearFuncVar
				cbFn(arg0)
			}
			ClearFuncVarRef = purego.NewCallback(fcb)
			SaveCallbackWithClosure(ClearFuncVarPtr, ClearFuncVarRef, ClearFuncVar)
		}
	}

	xAtomicRcBoxReleaseFull(MemBlockVar, ClearFuncVarRef)

}

var xRcBoxAcquire func(uintptr) uintptr

// Acquires a reference on the data pointed by @mem_block.
func RcBoxAcquire(MemBlockVar uintptr) uintptr {

	cret := xRcBoxAcquire(MemBlockVar)
	return cret
}

var xRcBoxAlloc func(uint) uintptr

// Allocates @block_size bytes of memory, and adds reference
// counting semantics to it.
//
// The data will be freed when its reference count drops to
// zero.
//
// The allocated data is guaranteed to be suitably aligned for any
// built-in type.
func RcBoxAlloc(BlockSizeVar uint) uintptr {

	cret := xRcBoxAlloc(BlockSizeVar)
	return cret
}

var xRcBoxAlloc0 func(uint) uintptr

// Allocates @block_size bytes of memory, and adds reference
// counting semantics to it.
//
// The contents of the returned data is set to zero.
//
// The data will be freed when its reference count drops to
// zero.
//
// The allocated data is guaranteed to be suitably aligned for any
// built-in type.
func RcBoxAlloc0(BlockSizeVar uint) uintptr {

	cret := xRcBoxAlloc0(BlockSizeVar)
	return cret
}

var xRcBoxDup func(uint, uintptr) uintptr

// Allocates a new block of data with reference counting
// semantics, and copies @block_size bytes of @mem_block
// into it.
func RcBoxDup(BlockSizeVar uint, MemBlockVar uintptr) uintptr {

	cret := xRcBoxDup(BlockSizeVar, MemBlockVar)
	return cret
}

var xRcBoxGetSize func(uintptr) uint

// Retrieves the size of the reference counted data pointed by @mem_block.
func RcBoxGetSize(MemBlockVar uintptr) uint {

	cret := xRcBoxGetSize(MemBlockVar)
	return cret
}

var xRcBoxRelease func(uintptr)

// Releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will free the
// resources allocated for @mem_block.
func RcBoxRelease(MemBlockVar uintptr) {

	xRcBoxRelease(MemBlockVar)

}

var xRcBoxReleaseFull func(uintptr, uintptr)

// Releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will call @clear_func
// to clear the contents of @mem_block, and then will free the
// resources allocated for @mem_block.
func RcBoxReleaseFull(MemBlockVar uintptr, ClearFuncVar *DestroyNotify) {

	var ClearFuncVarRef uintptr
	if ClearFuncVar != nil {
		ClearFuncVarPtr := uintptr(unsafe.Pointer(ClearFuncVar))
		if cbRefPtr, ok := GetCallback(ClearFuncVarPtr); ok {
			ClearFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *ClearFuncVar
				cbFn(arg0)
			}
			ClearFuncVarRef = purego.NewCallback(fcb)
			SaveCallbackWithClosure(ClearFuncVarPtr, ClearFuncVarRef, ClearFuncVar)
		}
	}

	xRcBoxReleaseFull(MemBlockVar, ClearFuncVarRef)

}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAtomicRcBoxAcquire, libs, "g_atomic_rc_box_acquire")
	core.PuregoSafeRegister(&xAtomicRcBoxAlloc, libs, "g_atomic_rc_box_alloc")
	core.PuregoSafeRegister(&xAtomicRcBoxAlloc0, libs, "g_atomic_rc_box_alloc0")
	core.PuregoSafeRegister(&xAtomicRcBoxDup, libs, "g_atomic_rc_box_dup")
	core.PuregoSafeRegister(&xAtomicRcBoxGetSize, libs, "g_atomic_rc_box_get_size")
	core.PuregoSafeRegister(&xAtomicRcBoxRelease, libs, "g_atomic_rc_box_release")
	core.PuregoSafeRegister(&xAtomicRcBoxReleaseFull, libs, "g_atomic_rc_box_release_full")
	core.PuregoSafeRegister(&xRcBoxAcquire, libs, "g_rc_box_acquire")
	core.PuregoSafeRegister(&xRcBoxAlloc, libs, "g_rc_box_alloc")
	core.PuregoSafeRegister(&xRcBoxAlloc0, libs, "g_rc_box_alloc0")
	core.PuregoSafeRegister(&xRcBoxDup, libs, "g_rc_box_dup")
	core.PuregoSafeRegister(&xRcBoxGetSize, libs, "g_rc_box_get_size")
	core.PuregoSafeRegister(&xRcBoxRelease, libs, "g_rc_box_release")
	core.PuregoSafeRegister(&xRcBoxReleaseFull, libs, "g_rc_box_release_full")

}
