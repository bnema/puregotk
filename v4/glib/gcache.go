// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// Specifies the type of the @value_destroy_func and @key_destroy_func
// functions passed to g_cache_new(). The functions are passed a
// pointer to the #GCache key or #GCache value and should free any
// memory and other resources associated with it.
type CacheDestroyFunc func(uintptr)

// Specifies the type of the @key_dup_func function passed to
// g_cache_new(). The function is passed a key
// (__not__ a value as the prototype implies) and
// should return a duplicate of the key.
type CacheDupFunc func(uintptr) uintptr

// Specifies the type of the @value_new_func function passed to
// g_cache_new(). It is passed a #GCache key and should create the
// value corresponding to the key.
type CacheNewFunc func(uintptr) uintptr

// A `GCache` allows sharing of complex data structures, in order to
// save system resources.
//
// `GCache` uses keys and values. A `GCache` key describes the properties
// of a particular resource. A `GCache` value is the actual resource.
//
// `GCache` has been marked as deprecated, since this API is rarely
// used and not very actively maintained.
type Cache struct {
	_ structs.HostLayout
}

func (x *Cache) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xCacheDestroy func(uintptr)

// Frees the memory allocated for the #GCache.
//
// Note that it does not destroy the keys and values which were
// contained in the #GCache.
func (x *Cache) Destroy() {

	xCacheDestroy(x.GoPointer())

}

var xCacheInsert func(uintptr, uintptr) uintptr

// Gets the value corresponding to the given key, creating it if
// necessary. It first checks if the value already exists in the
// #GCache, by using the @key_equal_func function passed to
// g_cache_new(). If it does already exist it is returned, and its
// reference count is increased by one. If the value does not currently
// exist, if is created by calling the @value_new_func. The key is
// duplicated by calling @key_dup_func and the duplicated key and value
// are inserted into the #GCache.
func (x *Cache) Insert(KeyVar uintptr) uintptr {

	cret := xCacheInsert(x.GoPointer(), KeyVar)
	return cret
}

var xCacheKeyForeach func(uintptr, uintptr, uintptr)

// Calls the given function for each of the keys in the #GCache.
//
// NOTE @func is passed three parameters, the value and key of a cache
// entry and the @user_data. The order of value and key is different
// from the order in which g_hash_table_foreach() passes key-value
// pairs to its callback function !
func (x *Cache) KeyForeach(FuncVar *HFunc, UserDataVar uintptr) {

	FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
	var FuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(FuncVarPtr); ok {
		FuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
			cbFn := *FuncVar
			cbFn(arg0, arg1, arg2)
		}
		FuncVarRef = purego.NewCallback(fcb)
		SaveCallback(FuncVarPtr, FuncVarRef)
	}

	xCacheKeyForeach(x.GoPointer(), FuncVarRef, UserDataVar)

}

var xCacheRemove func(uintptr, uintptr)

// Decreases the reference count of the given value. If it drops to 0
// then the value and its corresponding key are destroyed, using the
// @value_destroy_func and @key_destroy_func passed to g_cache_new().
func (x *Cache) Remove(ValueVar uintptr) {

	xCacheRemove(x.GoPointer(), ValueVar)

}

var xCacheValueForeach func(uintptr, uintptr, uintptr)

// Calls the given function for each of the values in the #GCache.
func (x *Cache) ValueForeach(FuncVar *HFunc, UserDataVar uintptr) {

	FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
	var FuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(FuncVarPtr); ok {
		FuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
			cbFn := *FuncVar
			cbFn(arg0, arg1, arg2)
		}
		FuncVarRef = purego.NewCallback(fcb)
		SaveCallback(FuncVarPtr, FuncVarRef)
	}

	xCacheValueForeach(x.GoPointer(), FuncVarRef, UserDataVar)

}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCacheDestroy, libs, "g_cache_destroy")
	core.PuregoSafeRegister(&xCacheInsert, libs, "g_cache_insert")
	core.PuregoSafeRegister(&xCacheKeyForeach, libs, "g_cache_key_foreach")
	core.PuregoSafeRegister(&xCacheRemove, libs, "g_cache_remove")
	core.PuregoSafeRegister(&xCacheValueForeach, libs, "g_cache_value_foreach")

}
