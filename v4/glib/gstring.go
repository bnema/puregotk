// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A `GString` is an object that handles the memory management of a C string.
//
// The emphasis of `GString` is on text, typically UTF-8. Crucially, the "str" member
// of a `GString` is guaranteed to have a trailing nul character, and it is therefore
// always safe to call functions such as `strchr()` or `strdup()` on it.
//
// However, a `GString` can also hold arbitrary binary data, because it has a "len" member,
// which includes any possible embedded nul characters in the data. Conceptually then,
// `GString` is like a `GByteArray` with the addition of many convenience methods for
// text, and a guaranteed nul terminator.
type String struct {
	_ structs.HostLayout

	Str uintptr

	Len uint

	AllocatedLen uint
}

var xStringGLibType func() types.GType

func StringGLibType() types.GType {
	return xStringGLibType()
}

func (x *String) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewString func(uintptr) *String

// Creates a new #GString, initialized with the given string.
func NewString(InitVar *string) *String {

	InitVarPtr, InitVarBytes := core.NullableStringToPtr(InitVar)

	cret := xNewString(InitVarPtr)

	runtime.KeepAlive(InitVarBytes)

	return cret
}

var xNewStringLen func(string, int) *String

// Creates a new #GString with @len bytes of the @init buffer.
// Because a length is provided, @init need not be nul-terminated,
// and can contain embedded nul bytes.
//
// Since this function does not stop at nul bytes, it is the caller's
// responsibility to ensure that @init has at least @len addressable
// bytes.
func NewStringLen(InitVar string, LenVar int) *String {

	cret := xNewStringLen(InitVar, LenVar)

	return cret
}

var xNewStringTake func(uintptr) *String

// Creates a new #GString, initialized with the given string.
//
// After this call, @init belongs to the #GString and may no longer be
// modified by the caller. The memory of @init has to be dynamically
// allocated and will eventually be freed with g_free().
func NewStringTake(InitVar *string) *String {

	cret := xNewStringTake(core.GStrdupNullable(InitVar))

	return cret
}

var xStringSizedNew func(uint) *String

// Creates a new #GString, with enough space for @dfl_size
// bytes. This is useful if you are going to add a lot of
// text to the string and don't want it to be reallocated
// too often.
func StringSizedNew(DflSizeVar uint) *String {

	cret := xStringSizedNew(DflSizeVar)

	return cret
}

var xStringAppend func(uintptr, string) *String

// Adds a string onto the end of a #GString, expanding
// it if necessary.
func (x *String) Append(ValVar string) *String {

	cret := xStringAppend(x.GoPointer(), ValVar)

	return cret
}

var xStringAppendC func(uintptr, byte) *String

// Adds a byte onto the end of a #GString, expanding
// it if necessary.
func (x *String) AppendC(CVar byte) *String {

	cret := xStringAppendC(x.GoPointer(), CVar)

	return cret
}

var xStringAppendLen func(uintptr, string, int) *String

// Appends @len bytes of @val to @string.
//
// If @len is positive, @val may contain embedded nuls and need
// not be nul-terminated. It is the caller's responsibility to
// ensure that @val has at least @len addressable bytes.
//
// If @len is negative, @val must be nul-terminated and @len
// is considered to request the entire string length. This
// makes g_string_append_len() equivalent to g_string_append().
func (x *String) AppendLen(ValVar string, LenVar int) *String {

	cret := xStringAppendLen(x.GoPointer(), ValVar, LenVar)

	return cret
}

var xStringAppendPrintf func(uintptr, string, ...interface{})

// Appends a formatted string onto the end of a #GString.
// This function is similar to g_string_printf() except
// that the text is appended to the #GString.
func (x *String) AppendPrintf(FormatVar string, varArgs ...interface{}) {

	xStringAppendPrintf(x.GoPointer(), FormatVar, varArgs...)

}

var xStringAppendUnichar func(uintptr, uint32) *String

// Converts a Unicode character into UTF-8, and appends it
// to the string.
func (x *String) AppendUnichar(WcVar uint32) *String {

	cret := xStringAppendUnichar(x.GoPointer(), WcVar)

	return cret
}

var xStringAppendUriEscaped func(uintptr, string, string, bool) *String

// Appends @unescaped to @string, escaping any characters that
// are reserved in URIs using URI-style escape sequences.
func (x *String) AppendUriEscaped(UnescapedVar string, ReservedCharsAllowedVar string, AllowUtf8Var bool) *String {

	cret := xStringAppendUriEscaped(x.GoPointer(), UnescapedVar, ReservedCharsAllowedVar, AllowUtf8Var)

	return cret
}

var xStringAppendVprintf func(uintptr, string, []interface{})

// Appends a formatted string onto the end of a #GString.
// This function is similar to g_string_append_printf()
// except that the arguments to the format string are passed
// as a va_list.
func (x *String) AppendVprintf(FormatVar string, ArgsVar []interface{}) {

	xStringAppendVprintf(x.GoPointer(), FormatVar, ArgsVar)

}

var xStringAsciiDown func(uintptr) *String

// Converts all uppercase ASCII letters to lowercase ASCII letters.
func (x *String) AsciiDown() *String {

	cret := xStringAsciiDown(x.GoPointer())

	return cret
}

var xStringAsciiUp func(uintptr) *String

// Converts all lowercase ASCII letters to uppercase ASCII letters.
func (x *String) AsciiUp() *String {

	cret := xStringAsciiUp(x.GoPointer())

	return cret
}

var xStringAssign func(uintptr, string) *String

// Copies the bytes from a string into a #GString,
// destroying any previous contents. It is rather like
// the standard strcpy() function, except that you do not
// have to worry about having enough space to copy the string.
func (x *String) Assign(RvalVar string) *String {

	cret := xStringAssign(x.GoPointer(), RvalVar)

	return cret
}

var xStringCopy func(uintptr) *String

// Copies the [struct@GLib.String] instance and its contents.
//
// This will preserve the allocation length of the [struct@GLib.String] in the
// copy.
func (x *String) Copy() *String {

	cret := xStringCopy(x.GoPointer())

	return cret
}

var xStringDown func(uintptr) *String

// Converts a #GString to lowercase.
func (x *String) Down() *String {

	cret := xStringDown(x.GoPointer())

	return cret
}

var xStringEqual func(uintptr, *String) bool

// Compares two strings for equality, returning %TRUE if they are equal.
// For use with #GHashTable.
func (x *String) Equal(V2Var *String) bool {

	cret := xStringEqual(x.GoPointer(), V2Var)

	return cret
}

var xStringErase func(uintptr, int, int) *String

// Removes @len bytes from a #GString, starting at position @pos.
// The rest of the #GString is shifted down to fill the gap.
func (x *String) Erase(PosVar int, LenVar int) *String {

	cret := xStringErase(x.GoPointer(), PosVar, LenVar)

	return cret
}

var xStringFree func(uintptr, bool) string

// Frees the memory allocated for the #GString.
// If @free_segment is %TRUE it also frees the character data.  If
// it's %FALSE, the caller gains ownership of the buffer and must
// free it after use with g_free().
//
// Instead of passing %FALSE to this function, consider using
// g_string_free_and_steal().
func (x *String) Free(FreeSegmentVar bool) string {

	cret := xStringFree(x.GoPointer(), FreeSegmentVar)

	return cret
}

var xStringFreeAndSteal func(uintptr) string

// Frees the memory allocated for the #GString.
//
// The caller gains ownership of the buffer and
// must free it after use with g_free().
func (x *String) FreeAndSteal() string {

	cret := xStringFreeAndSteal(x.GoPointer())

	return cret
}

var xStringFreeToBytes func(uintptr) *Bytes

// Transfers ownership of the contents of @string to a newly allocated
// #GBytes.  The #GString structure itself is deallocated, and it is
// therefore invalid to use @string after invoking this function.
//
// Note that while #GString ensures that its buffer always has a
// trailing nul character (not reflected in its "len"), the returned
// #GBytes does not include this extra nul; i.e. it has length exactly
// equal to the "len" member.
func (x *String) FreeToBytes() *Bytes {

	cret := xStringFreeToBytes(x.GoPointer())

	return cret
}

var xStringHash func(uintptr) uint

// Creates a hash code for @str; for use with #GHashTable.
func (x *String) Hash() uint {

	cret := xStringHash(x.GoPointer())

	return cret
}

var xStringInsert func(uintptr, int, string) *String

// Inserts a copy of a string into a #GString,
// expanding it if necessary.
func (x *String) Insert(PosVar int, ValVar string) *String {

	cret := xStringInsert(x.GoPointer(), PosVar, ValVar)

	return cret
}

var xStringInsertC func(uintptr, int, byte) *String

// Inserts a byte into a #GString, expanding it if necessary.
func (x *String) InsertC(PosVar int, CVar byte) *String {

	cret := xStringInsertC(x.GoPointer(), PosVar, CVar)

	return cret
}

var xStringInsertLen func(uintptr, int, string, int) *String

// Inserts @len bytes of @val into @string at @pos.
//
// If @len is positive, @val may contain embedded nuls and need
// not be nul-terminated. It is the caller's responsibility to
// ensure that @val has at least @len addressable bytes.
//
// If @len is negative, @val must be nul-terminated and @len
// is considered to request the entire string length.
//
// If @pos is -1, bytes are inserted at the end of the string.
func (x *String) InsertLen(PosVar int, ValVar string, LenVar int) *String {

	cret := xStringInsertLen(x.GoPointer(), PosVar, ValVar, LenVar)

	return cret
}

var xStringInsertUnichar func(uintptr, int, uint32) *String

// Converts a Unicode character into UTF-8, and insert it
// into the string at the given position.
func (x *String) InsertUnichar(PosVar int, WcVar uint32) *String {

	cret := xStringInsertUnichar(x.GoPointer(), PosVar, WcVar)

	return cret
}

var xStringOverwrite func(uintptr, uint, string) *String

// Overwrites part of a string, lengthening it if necessary.
func (x *String) Overwrite(PosVar uint, ValVar string) *String {

	cret := xStringOverwrite(x.GoPointer(), PosVar, ValVar)

	return cret
}

var xStringOverwriteLen func(uintptr, uint, string, int) *String

// Overwrites part of a string, lengthening it if necessary.
// This function will work with embedded nuls.
func (x *String) OverwriteLen(PosVar uint, ValVar string, LenVar int) *String {

	cret := xStringOverwriteLen(x.GoPointer(), PosVar, ValVar, LenVar)

	return cret
}

var xStringPrepend func(uintptr, string) *String

// Adds a string on to the start of a #GString,
// expanding it if necessary.
func (x *String) Prepend(ValVar string) *String {

	cret := xStringPrepend(x.GoPointer(), ValVar)

	return cret
}

var xStringPrependC func(uintptr, byte) *String

// Adds a byte onto the start of a #GString,
// expanding it if necessary.
func (x *String) PrependC(CVar byte) *String {

	cret := xStringPrependC(x.GoPointer(), CVar)

	return cret
}

var xStringPrependLen func(uintptr, string, int) *String

// Prepends @len bytes of @val to @string.
//
// If @len is positive, @val may contain embedded nuls and need
// not be nul-terminated. It is the caller's responsibility to
// ensure that @val has at least @len addressable bytes.
//
// If @len is negative, @val must be nul-terminated and @len
// is considered to request the entire string length. This
// makes g_string_prepend_len() equivalent to g_string_prepend().
func (x *String) PrependLen(ValVar string, LenVar int) *String {

	cret := xStringPrependLen(x.GoPointer(), ValVar, LenVar)

	return cret
}

var xStringPrependUnichar func(uintptr, uint32) *String

// Converts a Unicode character into UTF-8, and prepends it
// to the string.
func (x *String) PrependUnichar(WcVar uint32) *String {

	cret := xStringPrependUnichar(x.GoPointer(), WcVar)

	return cret
}

var xStringPrintf func(uintptr, string, ...interface{})

// Writes a formatted string into a #GString.
// This is similar to the standard sprintf() function,
// except that the #GString buffer automatically expands
// to contain the results. The previous contents of the
// #GString are destroyed.
func (x *String) Printf(FormatVar string, varArgs ...interface{}) {

	xStringPrintf(x.GoPointer(), FormatVar, varArgs...)

}

var xStringReplace func(uintptr, string, string, uint) uint

// Replaces the string @find with the string @replace in a #GString up to
// @limit times. If the number of instances of @find in the #GString is
// less than @limit, all instances are replaced. If @limit is `0`,
// all instances of @find are replaced.
//
// If @find is the empty string, since versions 2.69.1 and 2.68.4 the
// replacement will be inserted no more than once per possible position
// (beginning of string, end of string and between characters). This did
// not work correctly in earlier versions.
func (x *String) Replace(FindVar string, ReplaceVar string, LimitVar uint) uint {

	cret := xStringReplace(x.GoPointer(), FindVar, ReplaceVar, LimitVar)

	return cret
}

var xStringSetSize func(uintptr, uint) *String

// Sets the length of a #GString. If the length is less than
// the current length, the string will be truncated. If the
// length is greater than the current length, the contents
// of the newly added area are undefined. (However, as
// always, string-&gt;str[string-&gt;len] will be a nul byte.)
func (x *String) SetSize(LenVar uint) *String {

	cret := xStringSetSize(x.GoPointer(), LenVar)

	return cret
}

var xStringTruncate func(uintptr, uint) *String

// Cuts off the end of the GString, leaving the first @len bytes.
func (x *String) Truncate(LenVar uint) *String {

	cret := xStringTruncate(x.GoPointer(), LenVar)

	return cret
}

var xStringUp func(uintptr) *String

// Converts a #GString to uppercase.
func (x *String) Up() *String {

	cret := xStringUp(x.GoPointer())

	return cret
}

var xStringVprintf func(uintptr, string, []interface{})

// Writes a formatted string into a #GString.
// This function is similar to g_string_printf() except that
// the arguments to the format string are passed as a va_list.
func (x *String) Vprintf(FormatVar string, ArgsVar []interface{}) {

	xStringVprintf(x.GoPointer(), FormatVar, ArgsVar)

}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xStringGLibType, libs, "g_gstring_get_type")

	core.PuregoSafeRegister(&xNewString, libs, "g_string_new")
	core.PuregoSafeRegister(&xNewStringLen, libs, "g_string_new_len")
	core.PuregoSafeRegister(&xNewStringTake, libs, "g_string_new_take")
	core.PuregoSafeRegister(&xStringSizedNew, libs, "g_string_sized_new")

	core.PuregoSafeRegister(&xStringAppend, libs, "g_string_append")
	core.PuregoSafeRegister(&xStringAppendC, libs, "g_string_append_c")
	core.PuregoSafeRegister(&xStringAppendLen, libs, "g_string_append_len")
	core.PuregoSafeRegister(&xStringAppendPrintf, libs, "g_string_append_printf")
	core.PuregoSafeRegister(&xStringAppendUnichar, libs, "g_string_append_unichar")
	core.PuregoSafeRegister(&xStringAppendUriEscaped, libs, "g_string_append_uri_escaped")
	core.PuregoSafeRegister(&xStringAppendVprintf, libs, "g_string_append_vprintf")
	core.PuregoSafeRegister(&xStringAsciiDown, libs, "g_string_ascii_down")
	core.PuregoSafeRegister(&xStringAsciiUp, libs, "g_string_ascii_up")
	core.PuregoSafeRegister(&xStringAssign, libs, "g_string_assign")
	core.PuregoSafeRegister(&xStringCopy, libs, "g_string_copy")
	core.PuregoSafeRegister(&xStringDown, libs, "g_string_down")
	core.PuregoSafeRegister(&xStringEqual, libs, "g_string_equal")
	core.PuregoSafeRegister(&xStringErase, libs, "g_string_erase")
	core.PuregoSafeRegister(&xStringFree, libs, "g_string_free")
	core.PuregoSafeRegister(&xStringFreeAndSteal, libs, "g_string_free_and_steal")
	core.PuregoSafeRegister(&xStringFreeToBytes, libs, "g_string_free_to_bytes")
	core.PuregoSafeRegister(&xStringHash, libs, "g_string_hash")
	core.PuregoSafeRegister(&xStringInsert, libs, "g_string_insert")
	core.PuregoSafeRegister(&xStringInsertC, libs, "g_string_insert_c")
	core.PuregoSafeRegister(&xStringInsertLen, libs, "g_string_insert_len")
	core.PuregoSafeRegister(&xStringInsertUnichar, libs, "g_string_insert_unichar")
	core.PuregoSafeRegister(&xStringOverwrite, libs, "g_string_overwrite")
	core.PuregoSafeRegister(&xStringOverwriteLen, libs, "g_string_overwrite_len")
	core.PuregoSafeRegister(&xStringPrepend, libs, "g_string_prepend")
	core.PuregoSafeRegister(&xStringPrependC, libs, "g_string_prepend_c")
	core.PuregoSafeRegister(&xStringPrependLen, libs, "g_string_prepend_len")
	core.PuregoSafeRegister(&xStringPrependUnichar, libs, "g_string_prepend_unichar")
	core.PuregoSafeRegister(&xStringPrintf, libs, "g_string_printf")
	core.PuregoSafeRegister(&xStringReplace, libs, "g_string_replace")
	core.PuregoSafeRegister(&xStringSetSize, libs, "g_string_set_size")
	core.PuregoSafeRegister(&xStringTruncate, libs, "g_string_truncate")
	core.PuregoSafeRegister(&xStringUp, libs, "g_string_up")
	core.PuregoSafeRegister(&xStringVprintf, libs, "g_string_vprintf")

}
