// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// The `GThreadPool` struct represents a thread pool.
//
// A thread pool is useful when you wish to asynchronously fork out the execution of work
// and continue working in your own thread. If that will happen often, the overhead of starting
// and destroying a thread each time might be too high. In such cases reusing already started
// threads seems like a good idea. And it indeed is, but implementing this can be tedious
// and error-prone.
//
// Therefore GLib provides thread pools for your convenience. An added advantage is, that the
// threads can be shared between the different subsystems of your program, when they are using GLib.
//
// To create a new thread pool, you use [func@GLib.ThreadPool.new].
// It is destroyed by [method@GLib.ThreadPool.free].
//
// If you want to execute a certain task within a thread pool, use [method@GLib.ThreadPool.push].
//
// To get the current number of running threads you call [method@GLib.ThreadPool.get_num_threads].
// To get the number of still unprocessed tasks you call [method@GLib.ThreadPool.unprocessed].
// To control the maximum number of threads for a thread pool, you use
// [method@GLib.ThreadPool.get_max_threads]. and [method@GLib.ThreadPool.set_max_threads].
//
// Finally you can control the number of unused threads, that are kept alive by GLib for future use.
// The current number can be fetched with [func@GLib.ThreadPool.get_num_unused_threads].
// The maximum number can be controlled by [func@GLib.ThreadPool.get_max_unused_threads] and
// [func@GLib.ThreadPool.set_max_unused_threads]. All currently unused threads
// can be stopped by calling [func@GLib.ThreadPool.stop_unused_threads].
type ThreadPool struct {
	_ structs.HostLayout

	Func Func

	UserData uintptr

	Exclusive bool
}

func (x *ThreadPool) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xThreadPoolFree func(uintptr, bool, bool)

// Frees all resources allocated for @pool.
//
// If @immediate is %TRUE, no new task is processed for @pool.
// Otherwise @pool is not freed before the last task is processed.
// Note however, that no thread of this pool is interrupted while
// processing a task. Instead at least all still running threads
// can finish their tasks before the @pool is freed.
//
// If @wait_ is %TRUE, this function does not return before all
// tasks to be processed (dependent on @immediate, whether all
// or only the currently running) are ready.
// Otherwise this function returns immediately.
//
// After calling this function @pool must not be used anymore.
func (x *ThreadPool) Free(ImmediateVar bool, WaitVar bool) {

	xThreadPoolFree(x.GoPointer(), ImmediateVar, WaitVar)

}

var xThreadPoolGetMaxThreads func(uintptr) int

// Returns the maximal number of threads for @pool.
func (x *ThreadPool) GetMaxThreads() int {

	cret := xThreadPoolGetMaxThreads(x.GoPointer())
	return cret
}

var xThreadPoolGetNumThreads func(uintptr) uint

// Returns the number of threads currently running in @pool.
func (x *ThreadPool) GetNumThreads() uint {

	cret := xThreadPoolGetNumThreads(x.GoPointer())
	return cret
}

var xThreadPoolMoveToFront func(uintptr, uintptr) bool

// Moves the item to the front of the queue of unprocessed
// items, so that it will be processed next.
func (x *ThreadPool) MoveToFront(DataVar uintptr) bool {

	cret := xThreadPoolMoveToFront(x.GoPointer(), DataVar)
	return cret
}

var xThreadPoolPush func(uintptr, uintptr, **Error) bool

// Inserts @data into the list of tasks to be executed by @pool.
//
// When the number of currently running threads is lower than the
// maximal allowed number of threads, a new thread is started (or
// reused) with the properties given to g_thread_pool_new().
// Otherwise, @data stays in the queue until a thread in this pool
// finishes its previous task and processes @data.
//
// @error can be %NULL to ignore errors, or non-%NULL to report
// errors. An error can only occur when a new thread couldn't be
// created. In that case @data is simply appended to the queue of
// work to do.
//
// Before version 2.32, this function did not return a success status.
func (x *ThreadPool) Push(DataVar uintptr) (bool, error) {
	var cerr *Error

	cret := xThreadPoolPush(x.GoPointer(), DataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xThreadPoolSetMaxThreads func(uintptr, int, **Error) bool

// Sets the maximal allowed number of threads for @pool.
// A value of -1 means that the maximal number of threads
// is unlimited. If @pool is an exclusive thread pool, setting
// the maximal number of threads to -1 is not allowed.
//
// Setting @max_threads to 0 means stopping all work for @pool.
// It is effectively frozen until @max_threads is set to a non-zero
// value again.
//
// A thread is never terminated while calling @func, as supplied by
// g_thread_pool_new(). Instead the maximal number of threads only
// has effect for the allocation of new threads in g_thread_pool_push().
// A new thread is allocated, whenever the number of currently
// running threads in @pool is smaller than the maximal number.
//
// @error can be %NULL to ignore errors, or non-%NULL to report
// errors. An error can only occur when a new thread couldn't be
// created.
//
// Before version 2.32, this function did not return a success status.
func (x *ThreadPool) SetMaxThreads(MaxThreadsVar int) (bool, error) {
	var cerr *Error

	cret := xThreadPoolSetMaxThreads(x.GoPointer(), MaxThreadsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xThreadPoolSetSortFunction func(uintptr, uintptr, uintptr)

// Sets the function used to sort the list of tasks. This allows the
// tasks to be processed by a priority determined by @func, and not
// just in the order in which they were added to the pool.
//
// Note, if the maximum number of threads is more than 1, the order
// that threads are executed cannot be guaranteed 100%. Threads are
// scheduled by the operating system and are executed at random. It
// cannot be assumed that threads are executed in the order they are
// created.
func (x *ThreadPool) SetSortFunction(FuncVar *CompareDataFunc, UserDataVar uintptr) {

	xThreadPoolSetSortFunction(x.GoPointer(), NewCallback(FuncVar), UserDataVar)

}

var xThreadPoolUnprocessed func(uintptr) uint

// Returns the number of tasks still unprocessed in @pool.
func (x *ThreadPool) Unprocessed() uint {

	cret := xThreadPoolUnprocessed(x.GoPointer())
	return cret
}

var xThreadPoolGetMaxIdleTime func() uint

// This function will return the maximum @interval that a
// thread will wait in the thread pool for new tasks before
// being stopped.
//
// If this function returns 0, threads waiting in the thread
// pool for new work are not stopped.
func ThreadPoolGetMaxIdleTime() uint {

	cret := xThreadPoolGetMaxIdleTime()
	return cret
}

var xThreadPoolGetMaxUnusedThreads func() int

// Returns the maximal allowed number of unused threads.
func ThreadPoolGetMaxUnusedThreads() int {

	cret := xThreadPoolGetMaxUnusedThreads()
	return cret
}

var xThreadPoolGetNumUnusedThreads func() uint

// Returns the number of currently unused threads.
func ThreadPoolGetNumUnusedThreads() uint {

	cret := xThreadPoolGetNumUnusedThreads()
	return cret
}

var xThreadPoolSetMaxIdleTime func(uint)

// This function will set the maximum @interval that a thread
// waiting in the pool for new tasks can be idle for before
// being stopped. This function is similar to calling
// g_thread_pool_stop_unused_threads() on a regular timeout,
// except this is done on a per thread basis.
//
// By setting @interval to 0, idle threads will not be stopped.
//
// The default value is 15000 (15 seconds).
func ThreadPoolSetMaxIdleTime(IntervalVar uint) {

	xThreadPoolSetMaxIdleTime(IntervalVar)

}

var xThreadPoolSetMaxUnusedThreads func(int)

// Sets the maximal number of unused threads to @max_threads.
// If @max_threads is -1, no limit is imposed on the number
// of unused threads.
//
// The default value is 8 since GLib 2.84. Previously the default value was 2.
func ThreadPoolSetMaxUnusedThreads(MaxThreadsVar int) {

	xThreadPoolSetMaxUnusedThreads(MaxThreadsVar)

}

var xThreadPoolStopUnusedThreads func()

// Stops all currently unused threads. This does not change the
// maximal number of unused threads. This function can be used to
// regularly stop all unused threads e.g. from g_timeout_add().
func ThreadPoolStopUnusedThreads() {

	xThreadPoolStopUnusedThreads()

}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibrary("GLIB", "libgobject-2.0.so.0,libglib-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xThreadPoolGetMaxIdleTime, lib, "g_thread_pool_get_max_idle_time")
	core.PuregoSafeRegister(&xThreadPoolGetMaxUnusedThreads, lib, "g_thread_pool_get_max_unused_threads")
	core.PuregoSafeRegister(&xThreadPoolGetNumUnusedThreads, lib, "g_thread_pool_get_num_unused_threads")
	core.PuregoSafeRegister(&xThreadPoolSetMaxIdleTime, lib, "g_thread_pool_set_max_idle_time")
	core.PuregoSafeRegister(&xThreadPoolSetMaxUnusedThreads, lib, "g_thread_pool_set_max_unused_threads")
	core.PuregoSafeRegister(&xThreadPoolStopUnusedThreads, lib, "g_thread_pool_stop_unused_threads")

	core.PuregoSafeRegister(&xThreadPoolFree, lib, "g_thread_pool_free")
	core.PuregoSafeRegister(&xThreadPoolGetMaxThreads, lib, "g_thread_pool_get_max_threads")
	core.PuregoSafeRegister(&xThreadPoolGetNumThreads, lib, "g_thread_pool_get_num_threads")
	core.PuregoSafeRegister(&xThreadPoolMoveToFront, lib, "g_thread_pool_move_to_front")
	core.PuregoSafeRegister(&xThreadPoolPush, lib, "g_thread_pool_push")
	core.PuregoSafeRegister(&xThreadPoolSetMaxThreads, lib, "g_thread_pool_set_max_threads")
	core.PuregoSafeRegister(&xThreadPoolSetSortFunction, lib, "g_thread_pool_set_sort_function")
	core.PuregoSafeRegister(&xThreadPoolUnprocessed, lib, "g_thread_pool_unprocessed")

}
