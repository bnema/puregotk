// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

const (
	// Evaluates to the initial reference count for `gatomicrefcount`.
	//
	// This macro is useful for initializing `gatomicrefcount` fields inside
	// structures, for instance:
	//
	// |[&lt;!-- language="C" --&gt;
	// typedef struct {
	//   gatomicrefcount ref_count;
	//   char *name;
	//   char *address;
	// } Person;
	//
	// static const Person default_person = {
	//   .ref_count = G_ATOMIC_REF_COUNT_INIT,
	//   .name = "Default name",
	//   .address = "Default address",
	// };
	// ]|
	ATOMIC_REF_COUNT_INIT int = 1
	// Evaluates to the initial reference count for `grefcount`.
	//
	// This macro is useful for initializing `grefcount` fields inside
	// structures, for instance:
	//
	// |[&lt;!-- language="C" --&gt;
	// typedef struct {
	//   grefcount ref_count;
	//   char *name;
	//   char *address;
	// } Person;
	//
	// static const Person default_person = {
	//   .ref_count = G_REF_COUNT_INIT,
	//   .name = "Default name",
	//   .address = "Default address",
	// };
	// ]|
	REF_COUNT_INIT int = -1
)

var xAtomicRefCountCompare func(int, int) bool

// Atomically compares the current value of @arc with @val.
func AtomicRefCountCompare(ArcVar int, ValVar int) bool {

	cret := xAtomicRefCountCompare(ArcVar, ValVar)
	return cret
}

var xAtomicRefCountDec func(int) bool

// Atomically decreases the reference count.
//
// If %TRUE is returned, the reference count reached 0. After this point, @arc
// is an undefined state and must be reinitialized with
// g_atomic_ref_count_init() to be used again.
func AtomicRefCountDec(ArcVar int) bool {

	cret := xAtomicRefCountDec(ArcVar)
	return cret
}

var xAtomicRefCountInc func(int)

// Atomically increases the reference count.
func AtomicRefCountInc(ArcVar int) {

	xAtomicRefCountInc(ArcVar)

}

var xAtomicRefCountInit func(int)

// Initializes a reference count variable to 1.
func AtomicRefCountInit(ArcVar int) {

	xAtomicRefCountInit(ArcVar)

}

var xRefCountCompare func(int, int) bool

// Compares the current value of @rc with @val.
func RefCountCompare(RcVar int, ValVar int) bool {

	cret := xRefCountCompare(RcVar, ValVar)
	return cret
}

var xRefCountDec func(int) bool

// Decreases the reference count.
//
// If %TRUE is returned, the reference count reached 0. After this point, @rc
// is an undefined state and must be reinitialized with
// g_ref_count_init() to be used again.
func RefCountDec(RcVar int) bool {

	cret := xRefCountDec(RcVar)
	return cret
}

var xRefCountInc func(int)

// Increases the reference count.
func RefCountInc(RcVar int) {

	xRefCountInc(RcVar)

}

var xRefCountInit func(int)

// Initializes a reference count variable to 1.
func RefCountInit(RcVar int) {

	xRefCountInit(RcVar)

}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAtomicRefCountCompare, libs, "g_atomic_ref_count_compare")
	core.PuregoSafeRegister(&xAtomicRefCountDec, libs, "g_atomic_ref_count_dec")
	core.PuregoSafeRegister(&xAtomicRefCountInc, libs, "g_atomic_ref_count_inc")
	core.PuregoSafeRegister(&xAtomicRefCountInit, libs, "g_atomic_ref_count_init")
	core.PuregoSafeRegister(&xRefCountCompare, libs, "g_ref_count_compare")
	core.PuregoSafeRegister(&xRefCountDec, libs, "g_ref_count_dec")
	core.PuregoSafeRegister(&xRefCountInc, libs, "g_ref_count_inc")
	core.PuregoSafeRegister(&xRefCountInit, libs, "g_ref_count_init")

}
