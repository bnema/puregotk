// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

var xAtomicIntAdd func(uintptr, int) int

// Atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic += val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Before version 2.30, this function did not return a value
// (but g_atomic_int_exchange_and_add() did, and had the same meaning).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntAdd(AtomicVar uintptr, ValVar int) int {

	cret := xAtomicIntAdd(AtomicVar, ValVar)
	return cret
}

var xAtomicIntAnd func(uintptr, uint) uint

// Performs an atomic bitwise 'and' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic &amp;= val; return tmp; }`.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntAnd(AtomicVar uintptr, ValVar uint) uint {

	cret := xAtomicIntAnd(AtomicVar, ValVar)
	return cret
}

var xAtomicIntCompareAndExchange func(uintptr, int, int) bool

// Compares @atomic to @oldval and, if equal, sets it to @newval.
// If @atomic was not equal to @oldval then no change occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of
// `{ if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntCompareAndExchange(AtomicVar uintptr, OldvalVar int, NewvalVar int) bool {

	cret := xAtomicIntCompareAndExchange(AtomicVar, OldvalVar, NewvalVar)
	return cret
}

var xAtomicIntCompareAndExchangeFull func(uintptr, int, int, int) bool

// Compares @atomic to @oldval and, if equal, sets it to @newval.
// If @atomic was not equal to @oldval then no change occurs.
// In any case the value of @atomic before this operation is stored in @preval.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of
// `{ *preval = *atomic; if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// See also g_atomic_int_compare_and_exchange()
func AtomicIntCompareAndExchangeFull(AtomicVar uintptr, OldvalVar int, NewvalVar int, PrevalVar int) bool {

	cret := xAtomicIntCompareAndExchangeFull(AtomicVar, OldvalVar, NewvalVar, PrevalVar)
	return cret
}

var xAtomicIntDecAndTest func(uintptr) bool

// Decrements the value of @atomic by 1.
//
// Think of this operation as an atomic version of
// `{ *atomic -= 1; return (*atomic == 0); }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntDecAndTest(AtomicVar uintptr) bool {

	cret := xAtomicIntDecAndTest(AtomicVar)
	return cret
}

var xAtomicIntExchange func(uintptr, int) int

// Sets the @atomic to @newval and returns the old value from @atomic.
//
// This exchange is done atomically.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic = val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntExchange(AtomicVar uintptr, NewvalVar int) int {

	cret := xAtomicIntExchange(AtomicVar, NewvalVar)
	return cret
}

var xAtomicIntExchangeAndAdd func(uintptr, int) int

// This function existed before g_atomic_int_add() returned the prior
// value of the integer (which it now does).  It is retained only for
// compatibility reasons.  Don't use this function in new code.
func AtomicIntExchangeAndAdd(AtomicVar uintptr, ValVar int) int {

	cret := xAtomicIntExchangeAndAdd(AtomicVar, ValVar)
	return cret
}

var xAtomicIntGet func(uintptr) int

// Gets the current value of @atomic.
//
// This call acts as a full compiler and hardware
// memory barrier (before the get).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntGet(AtomicVar uintptr) int {

	cret := xAtomicIntGet(AtomicVar)
	return cret
}

var xAtomicIntInc func(uintptr)

// Increments the value of @atomic by 1.
//
// Think of this operation as an atomic version of `{ *atomic += 1; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntInc(AtomicVar uintptr) {

	xAtomicIntInc(AtomicVar)

}

var xAtomicIntOr func(uintptr, uint) uint

// Performs an atomic bitwise 'or' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic |= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntOr(AtomicVar uintptr, ValVar uint) uint {

	cret := xAtomicIntOr(AtomicVar, ValVar)
	return cret
}

var xAtomicIntSet func(uintptr, int)

// Sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware
// memory barrier (after the set).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntSet(AtomicVar uintptr, NewvalVar int) {

	xAtomicIntSet(AtomicVar, NewvalVar)

}

var xAtomicIntXor func(uintptr, uint) uint

// Performs an atomic bitwise 'xor' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic ^= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntXor(AtomicVar uintptr, ValVar uint) uint {

	cret := xAtomicIntXor(AtomicVar, ValVar)
	return cret
}

var xAtomicPointerAdd func(uintptr, int) int

// Atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic += val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
//
// In GLib 2.80, the return type was changed from #gssize to #gintptr to add
// support for platforms with 128-bit pointers. This should not affect existing
// code.
func AtomicPointerAdd(AtomicVar uintptr, ValVar int) int {

	cret := xAtomicPointerAdd(AtomicVar, ValVar)
	return cret
}

var xAtomicPointerAnd func(uintptr, uint) uintptr

// Performs an atomic bitwise 'and' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic &amp;= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
//
// In GLib 2.80, the return type was changed from #gsize to #guintptr to add
// support for platforms with 128-bit pointers. This should not affect existing
// code.
func AtomicPointerAnd(AtomicVar uintptr, ValVar uint) uintptr {

	cret := xAtomicPointerAnd(AtomicVar, ValVar)
	return cret
}

var xAtomicPointerCompareAndExchange func(uintptr, uintptr, uintptr) bool

// Compares @atomic to @oldval and, if equal, sets it to @newval.
// If @atomic was not equal to @oldval then no change occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of
// `{ if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerCompareAndExchange(AtomicVar uintptr, OldvalVar uintptr, NewvalVar uintptr) bool {

	cret := xAtomicPointerCompareAndExchange(AtomicVar, OldvalVar, NewvalVar)
	return cret
}

var xAtomicPointerCompareAndExchangeFull func(uintptr, uintptr, uintptr, uintptr) bool

// Compares @atomic to @oldval and, if equal, sets it to @newval.
// If @atomic was not equal to @oldval then no change occurs.
// In any case the value of @atomic before this operation is stored in @preval.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of
// `{ *preval = *atomic; if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// See also g_atomic_pointer_compare_and_exchange()
func AtomicPointerCompareAndExchangeFull(AtomicVar uintptr, OldvalVar uintptr, NewvalVar uintptr, PrevalVar uintptr) bool {

	cret := xAtomicPointerCompareAndExchangeFull(AtomicVar, OldvalVar, NewvalVar, PrevalVar)
	return cret
}

var xAtomicPointerExchange func(uintptr, uintptr) uintptr

// Sets the @atomic to @newval and returns the old value from @atomic.
//
// This exchange is done atomically.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic = val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerExchange(AtomicVar uintptr, NewvalVar uintptr) uintptr {

	cret := xAtomicPointerExchange(AtomicVar, NewvalVar)
	return cret
}

var xAtomicPointerGet func(uintptr) uintptr

// Gets the current value of @atomic.
//
// This call acts as a full compiler and hardware
// memory barrier (before the get).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerGet(AtomicVar uintptr) uintptr {

	cret := xAtomicPointerGet(AtomicVar)
	return cret
}

var xAtomicPointerOr func(uintptr, uint) uintptr

// Performs an atomic bitwise 'or' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic |= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
//
// In GLib 2.80, the return type was changed from #gsize to #guintptr to add
// support for platforms with 128-bit pointers. This should not affect existing
// code.
func AtomicPointerOr(AtomicVar uintptr, ValVar uint) uintptr {

	cret := xAtomicPointerOr(AtomicVar, ValVar)
	return cret
}

var xAtomicPointerSet func(uintptr, uintptr)

// Sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware
// memory barrier (after the set).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerSet(AtomicVar uintptr, NewvalVar uintptr) {

	xAtomicPointerSet(AtomicVar, NewvalVar)

}

var xAtomicPointerXor func(uintptr, uint) uintptr

// Performs an atomic bitwise 'xor' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic ^= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
//
// In GLib 2.80, the return type was changed from #gsize to #guintptr to add
// support for platforms with 128-bit pointers. This should not affect existing
// code.
func AtomicPointerXor(AtomicVar uintptr, ValVar uint) uintptr {

	cret := xAtomicPointerXor(AtomicVar, ValVar)
	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAtomicIntAdd, libs, "g_atomic_int_add")
	core.PuregoSafeRegister(&xAtomicIntAnd, libs, "g_atomic_int_and")
	core.PuregoSafeRegister(&xAtomicIntCompareAndExchange, libs, "g_atomic_int_compare_and_exchange")
	core.PuregoSafeRegister(&xAtomicIntCompareAndExchangeFull, libs, "g_atomic_int_compare_and_exchange_full")
	core.PuregoSafeRegister(&xAtomicIntDecAndTest, libs, "g_atomic_int_dec_and_test")
	core.PuregoSafeRegister(&xAtomicIntExchange, libs, "g_atomic_int_exchange")
	core.PuregoSafeRegister(&xAtomicIntExchangeAndAdd, libs, "g_atomic_int_exchange_and_add")
	core.PuregoSafeRegister(&xAtomicIntGet, libs, "g_atomic_int_get")
	core.PuregoSafeRegister(&xAtomicIntInc, libs, "g_atomic_int_inc")
	core.PuregoSafeRegister(&xAtomicIntOr, libs, "g_atomic_int_or")
	core.PuregoSafeRegister(&xAtomicIntSet, libs, "g_atomic_int_set")
	core.PuregoSafeRegister(&xAtomicIntXor, libs, "g_atomic_int_xor")
	core.PuregoSafeRegister(&xAtomicPointerAdd, libs, "g_atomic_pointer_add")
	core.PuregoSafeRegister(&xAtomicPointerAnd, libs, "g_atomic_pointer_and")
	core.PuregoSafeRegister(&xAtomicPointerCompareAndExchange, libs, "g_atomic_pointer_compare_and_exchange")
	core.PuregoSafeRegister(&xAtomicPointerCompareAndExchangeFull, libs, "g_atomic_pointer_compare_and_exchange_full")
	core.PuregoSafeRegister(&xAtomicPointerExchange, libs, "g_atomic_pointer_exchange")
	core.PuregoSafeRegister(&xAtomicPointerGet, libs, "g_atomic_pointer_get")
	core.PuregoSafeRegister(&xAtomicPointerOr, libs, "g_atomic_pointer_or")
	core.PuregoSafeRegister(&xAtomicPointerSet, libs, "g_atomic_pointer_set")
	core.PuregoSafeRegister(&xAtomicPointerXor, libs, "g_atomic_pointer_xor")

}
