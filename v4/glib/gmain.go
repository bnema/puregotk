// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Prototype of a #GChildWatchSource callback, called when a child
// process has exited.
//
// To interpret @wait_status, see the documentation for
// [func@GLib.spawn_check_wait_status]. In particular,
// on Unix platforms, note that it is usually not equal
// to the integer passed to `exit()` or returned from `main()`.
type ChildWatchFunc func(Pid, int, uintptr)

// Specifies the type of function passed to [func@GLib.clear_handle_id] The
// implementation is expected to free the resource identified by @handle_id;
// for instance, if @handle_id is a [struct@GLib.Source] ID,
// [func@GLib.Source.remove] can be used.
type ClearHandleFunc func(uint)

// Dispose function for @source. See [method@GLib.Source.set_dispose_function]
// for details.
type SourceDisposeFunc func(*Source)

// This is just a placeholder for #GClosureMarshal,
// which cannot be used here for dependency reasons.
type SourceDummyMarshal func()

// Specifies the type of function passed to [func@GLib.timeout_add],
// [func@GLib.timeout_add_full], [func@GLib.idle_add], and
// [func@GLib.idle_add_full].
//
// When calling [method@GLib.Source.set_callback], you may need to cast a
// function of a different type to this type. Use [func@GLib.SOURCE_FUNC] to
// avoid warnings about incompatible function types.
type SourceFunc func(uintptr) bool

// Checks if the source is ready to be dispatched.
//
// Called after all the file descriptors are polled. The source
// should return %TRUE if it is ready to be dispatched. Note that some
// time may have passed since the previous prepare function was called,
// so the source should be checked again here.
//
// Since 2.36 this may be `NULL`, in which case the effect is
// as if the function always returns `FALSE`.
type SourceFuncsCheckFunc func(*Source) bool

// Dispatches the source callback.
//
// Called to dispatch the event source, after it has returned
// `TRUE` in either its prepare or its check function, or if a ready time
// has been reached. The dispatch function receives a callback function and
// user data. The callback function may be `NULL` if the source was never
// connected to a callback using [method@GLib.Source.set_callback]. The dispatch
// function should call the callback function with @user_data and whatever
// additional parameters are needed for this type of event source. The
// return value of the dispatch function should be [const@GLib.SOURCE_REMOVE]
// if the source should be removed or [const@GLib.SOURCE_CONTINUE] to keep it.
type SourceFuncsDispatchFunc func(*Source, uintptr, uintptr) bool

// Finalizes the source.
//
// Called when the source is finalized. At this point, the source
// will have been destroyed, had its callback cleared, and have been removed
// from its [type@GLib.MainContext], but it will still have its final reference
// count, so methods can be called on it from within this function.
type SourceFuncsFinalizeFunc func(*Source)

// Checks the source for readiness.
//
// Called before all the file descriptors are polled. If the
// source can determine that it is ready here (without waiting for the
// results of the poll call) it should return %TRUE. It can also return
// a @timeout_ value which should be the maximum timeout (in milliseconds)
// which should be passed to the poll call. The actual timeout used will
// be `-1` if all sources returned `-1`, or it will be the minimum of all
// the @timeout_ values returned which were greater than or equal to `0`.
// If the prepare function returns a timeout and the source also has a
// ready time set, then the lower of the two will be used.
//
// Since 2.36 this may be `NULL`, in which case the effect is as if the
// function always returns `FALSE` with a timeout of `-1`.
type SourceFuncsPrepareFunc func(*Source, *int) bool

// A source function that is only called once before being removed from the main
// context automatically.
//
// See: [func@GLib.idle_add_once], [func@GLib.timeout_add_once]
type SourceOnceFunc func(uintptr)

// The `GMainContext` struct is an opaque data
// type representing a set of sources to be handled in a main loop.
type MainContext struct {
	_ structs.HostLayout
}

var xMainContextGLibType func() types.GType

func MainContextGLibType() types.GType {
	return xMainContextGLibType()
}

func (x *MainContext) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewMainContext func() *MainContext

// Creates a new [struct@GLib.MainContext] structure.
func NewMainContext() *MainContext {

	cret := xNewMainContext()

	return cret
}

var xNewMainContextWithFlags func(MainContextFlags) *MainContext

// Creates a new [struct@GLib.MainContext] structure.
func NewMainContextWithFlags(FlagsVar MainContextFlags) *MainContext {

	cret := xNewMainContextWithFlags(FlagsVar)

	return cret
}

var xMainContextAcquire func(uintptr) bool

// Tries to become the owner of the specified context.
//
// If some other thread is the owner of the context,
// returns false immediately. Ownership is properly
// recursive: the owner can require ownership again
// and will release ownership when [method@GLib.MainContext.release]
// is called as many times as [method@GLib.MainContext.acquire].
//
// You must be the owner of a context before you
// can call [method@GLib.MainContext.prepare], [method@GLib.MainContext.query],
// [method@GLib.MainContext.check], [method@GLib.MainContext.dispatch],
// [method@GLib.MainContext.release].
//
// Since 2.76 @context can be `NULL` to use the global-default
// main context.
func (x *MainContext) Acquire() bool {

	cret := xMainContextAcquire(x.GoPointer())

	return cret
}

var xMainContextAddPoll func(uintptr, *PollFD, int)

// Adds a file descriptor to the set of file descriptors polled for
// this context.
//
// This will very seldom be used directly. Instead
// a typical event source will use `g_source_add_unix_fd()` instead.
func (x *MainContext) AddPoll(FdVar *PollFD, PriorityVar int) {

	xMainContextAddPoll(x.GoPointer(), FdVar, PriorityVar)

}

var xMainContextCheck func(uintptr, int, []PollFD, int) bool

// Passes the results of polling back to the main loop.
//
// You should be
// careful to pass @fds and its length @n_fds as received from
// [method@GLib.MainContext.query], as this functions relies on assumptions
// on how @fds is filled.
//
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
//
// Since 2.76 @context can be `NULL` to use the global-default
// main context.
func (x *MainContext) Check(MaxPriorityVar int, FdsVar []PollFD, NFdsVar int) bool {

	cret := xMainContextCheck(x.GoPointer(), MaxPriorityVar, FdsVar, NFdsVar)

	return cret
}

var xMainContextDispatch func(uintptr)

// Dispatches all pending sources.
//
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
//
// Since 2.76 @context can be `NULL` to use the global-default
// main context.
func (x *MainContext) Dispatch() {

	xMainContextDispatch(x.GoPointer())

}

var xMainContextFindSourceByFuncsUserData func(uintptr, *SourceFuncs, uintptr) *Source

// Finds a source with the given source functions and user data.
//
// If multiple sources exist with the same source function and user data,
// the first one found will be returned.
func (x *MainContext) FindSourceByFuncsUserData(FuncsVar *SourceFuncs, UserDataVar uintptr) *Source {

	cret := xMainContextFindSourceByFuncsUserData(x.GoPointer(), FuncsVar, UserDataVar)

	return cret
}

var xMainContextFindSourceById func(uintptr, uint) *Source

// Finds a [struct@GLib.Source] given a pair of context and ID.
//
// It is a programmer error to attempt to look up a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a
// source ID which may have already been removed.  An example is when
// scheduling an idle to run in another thread with [func@GLib.idle_add]: the
// idle may already have run and been removed by the time this function
// is called on its (now invalid) source ID.  This source ID may have
// been reissued, leading to the operation being performed against the
// wrong source.
func (x *MainContext) FindSourceById(SourceIdVar uint) *Source {

	cret := xMainContextFindSourceById(x.GoPointer(), SourceIdVar)

	return cret
}

var xMainContextFindSourceByUserData func(uintptr, uintptr) *Source

// Finds a source with the given user data for the callback.
//
// If multiple sources exist with the same user data, the first
// one found will be returned.
func (x *MainContext) FindSourceByUserData(UserDataVar uintptr) *Source {

	cret := xMainContextFindSourceByUserData(x.GoPointer(), UserDataVar)

	return cret
}

var xMainContextGetPollFunc func(uintptr) uintptr

// Gets the poll function set by [method@GLib.MainContext.set_poll_func].
func (x *MainContext) GetPollFunc() uintptr {

	cret := xMainContextGetPollFunc(x.GoPointer())

	return cret
}

var xMainContextInvoke func(uintptr, uintptr, uintptr)

// Invokes a function in such a way that @context is owned during the
// invocation of @function.
//
// If @context is `NULL` then the global-default main context — as
// returned by [func@GLib.MainContext.default] — is used.
//
// If @context is owned by the current thread, @function is called
// directly.  Otherwise, if @context is the thread-default main context
// of the current thread and [method@GLib.MainContext.acquire] succeeds,
// then @function is called and [method@GLib.MainContext.release] is called
// afterwards.
//
// In any other case, an idle source is created to call @function and
// that source is attached to @context (presumably to be run in another
// thread).  The idle source is attached with [const@GLib.PRIORITY_DEFAULT]
// priority.  If you want a different priority, use
// [method@GLib.MainContext.invoke_full].
//
// Note that, as with normal idle functions, @function should probably return
// [const@GLib.SOURCE_REMOVE].  If it returns [const@GLib.SOURCE_CONTINUE], it
// will be continuously run in a loop (and may prevent this call from returning).
func (x *MainContext) Invoke(FunctionVar *SourceFunc, DataVar uintptr) {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FunctionVar
				return cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	xMainContextInvoke(x.GoPointer(), FunctionVarRef, DataVar)

}

var xMainContextInvokeFull func(uintptr, int, uintptr, uintptr, uintptr)

// Invokes a function in such a way that @context is owned during the
// invocation of @function.
//
// This function is the same as [method@GLib.MainContext.invoke] except that it
// lets you specify the priority in case @function ends up being
// scheduled as an idle and also lets you give a [callback@GLib.DestroyNotify]
// for @data.
//
// The @notify function should not assume that it is called from any particular
// thread or with any particular context acquired.
func (x *MainContext) InvokeFull(PriorityVar int, FunctionVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FunctionVar
				return cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	var NotifyVarRef uintptr
	if NotifyVar != nil {
		NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
		if cbRefPtr, ok := GetCallback(NotifyVarPtr); ok {
			NotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *NotifyVar
				cbFn(arg0)
			}
			NotifyVarRef = purego.NewCallback(fcb)
			SaveCallback(NotifyVarPtr, NotifyVarRef)
		}
	}

	xMainContextInvokeFull(x.GoPointer(), PriorityVar, FunctionVarRef, DataVar, NotifyVarRef)

}

var xMainContextIsOwner func(uintptr) bool

// Determines whether this thread holds the (recursive)
// ownership of this [struct@GLib.MainContext].
//
// This is useful to
// know before waiting on another thread that may be
// blocking to get ownership of @context.
func (x *MainContext) IsOwner() bool {

	cret := xMainContextIsOwner(x.GoPointer())

	return cret
}

var xMainContextIteration func(uintptr, bool) bool

// Runs a single iteration for the given main loop.
//
// This involves
// checking to see if any event sources are ready to be processed,
// then if no events sources are ready and @may_block is true, waiting
// for a source to become ready, then dispatching the highest priority
// events sources that are ready. Otherwise, if @may_block is false,
// this function does not wait for sources to become ready, and only the highest
// priority sources which are already ready (if any) will be dispatched.
//
// Note that even when @may_block is true, it is still possible for
// [method@GLib.MainContext.iteration] to return false, since the wait may
// be interrupted for other reasons than an event source becoming ready.
func (x *MainContext) Iteration(MayBlockVar bool) bool {

	cret := xMainContextIteration(x.GoPointer(), MayBlockVar)

	return cret
}

var xMainContextPending func(uintptr) bool

// Checks if any sources have pending events for the given context.
func (x *MainContext) Pending() bool {

	cret := xMainContextPending(x.GoPointer())

	return cret
}

var xMainContextPopThreadDefault func(uintptr)

// Pops @context off the thread-default context stack (verifying that
// it was on the top of the stack).
func (x *MainContext) PopThreadDefault() {

	xMainContextPopThreadDefault(x.GoPointer())

}

var xMainContextPrepare func(uintptr, *int) bool

// Prepares to poll sources within a main loop.
//
// The resulting information
// for polling is determined by calling [method@GLib.MainContext.query].
//
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
func (x *MainContext) Prepare(PriorityVar *int) bool {

	cret := xMainContextPrepare(x.GoPointer(), PriorityVar)

	return cret
}

var xMainContextPushThreadDefault func(uintptr)

// Acquires @context and sets it as the thread-default context for the
// current thread. This will cause certain asynchronous operations
// (such as most [Gio](../gio/index.html)-based I/O) which are
// started in this thread to run under @context and deliver their
// results to its main loop, rather than running under the global
// default main context in the main thread. Note that calling this function
// changes the context returned by [func@GLib.MainContext.get_thread_default],
// not the one returned by [func@GLib.MainContext.default], so it does not
// affect the context used by functions like [func@GLib.idle_add].
//
// Normally you would call this function shortly after creating a new
// thread, passing it a [struct@GLib.MainContext] which will be run by a
// [struct@GLib.MainLoop] in that thread, to set a new default context for all
// async operations in that thread. In this case you may not need to
// ever call [method@GLib.MainContext.pop_thread_default], assuming you want
// the new [struct@GLib.MainContext] to be the default for the whole lifecycle
// of the thread.
//
// If you don’t have control over how the new thread was created (e.g.
// in the new thread isn’t newly created, or if the thread life
// cycle is managed by a #GThreadPool), it is always suggested to wrap
// the logic that needs to use the new [struct@GLib.MainContext] inside a
// [method@GLib.MainContext.push_thread_default] /
// [method@GLib.MainContext.pop_thread_default] pair, otherwise threads that
// are re-used will end up never explicitly releasing the
// [struct@GLib.MainContext] reference they hold.
//
// In some cases you may want to schedule a single operation in a
// non-default context, or temporarily use a non-default context in
// the main thread. In that case, you can wrap the call to the
// asynchronous operation inside a
// [method@GLib.MainContext.push_thread_default] /
// [method@GLib.MainContext.pop_thread_default] pair, but it is up to you to
// ensure that no other asynchronous operations accidentally get
// started while the non-default context is active.
//
// Beware that libraries that predate this function may not correctly
// handle being used from a thread with a thread-default context. For example,
// see `g_file_supports_thread_contexts()`.
func (x *MainContext) PushThreadDefault() {

	xMainContextPushThreadDefault(x.GoPointer())

}

var xMainContextPusherNew func(uintptr) *MainContextPusher

// Push @main_context as the new thread-default main context for the current
// thread, using [method@GLib.MainContext.push_thread_default], and return a
// new [alias@GLib.MainContextPusher]. Pop with g_main_context_pusher_free().
// Using [method@GLib.MainContext.pop_thread_default] on @main_context while a
// [alias@GLib.MainContextPusher] exists for it can lead to undefined behaviour.
//
// Using two [alias@GLib.MainContextPusher]s in the same scope is not allowed,
// as it leads to an undefined pop order.
//
// This is intended to be used with g_autoptr().  Note that g_autoptr()
// is only available when using GCC or clang, so the following example
// will only work with those compilers:
// |[
// typedef struct
//
//	{
//	  ...
//	  GMainContext *context;
//	  ...
//	} MyObject;
//
// static void
// my_object_do_stuff (MyObject *self)
//
//	{
//	  g_autoptr(GMainContextPusher) pusher = g_main_context_pusher_new (self-&gt;context);
//
//	  // Code with main context as the thread default here
//
//	  if (cond)
//	    // No need to pop
//	    return;
//
//	  // Optionally early pop
//	  g_clear_pointer (&amp;pusher, g_main_context_pusher_free);
//
//	  // Code with main context no longer the thread default here
//	}
//
// ]|
func (x *MainContext) PusherNew() *MainContextPusher {

	cret := xMainContextPusherNew(x.GoPointer())

	return cret
}

var xMainContextQuery func(uintptr, int, *int, *[]PollFD, int) int

// Determines information necessary to poll this main loop.
//
// You should
// be careful to pass the resulting @fds array and its length @n_fds
// as-is when calling [method@GLib.MainContext.check], as this function relies
// on assumptions made when the array is filled.
//
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
func (x *MainContext) Query(MaxPriorityVar int, TimeoutVar *int, FdsVar *[]PollFD, NFdsVar int) int {

	cret := xMainContextQuery(x.GoPointer(), MaxPriorityVar, TimeoutVar, FdsVar, NFdsVar)

	return cret
}

var xMainContextRef func(uintptr) *MainContext

// Increases the reference count on a [struct@GLib.MainContext] object by one.
func (x *MainContext) Ref() *MainContext {

	cret := xMainContextRef(x.GoPointer())

	return cret
}

var xMainContextRelease func(uintptr)

// Releases ownership of a context previously acquired by this thread
// with [method@GLib.MainContext.acquire].
//
// If the context was acquired multiple
// times, the ownership will be released only when [method@GLib.MainContext.release]
// is called as many times as it was acquired.
//
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
func (x *MainContext) Release() {

	xMainContextRelease(x.GoPointer())

}

var xMainContextRemovePoll func(uintptr, *PollFD)

// Removes file descriptor from the set of file descriptors to be
// polled for a particular context.
func (x *MainContext) RemovePoll(FdVar *PollFD) {

	xMainContextRemovePoll(x.GoPointer(), FdVar)

}

var xMainContextSetPollFunc func(uintptr, uintptr)

// Sets the function to use to handle polling of file descriptors.
//
// It will be used instead of the [`poll()`](man:poll(2)) system call
// (or GLib’s replacement function, which is used where
// `poll()` isn’t available).
//
// This function could possibly be used to integrate the GLib event
// loop with an external event loop.
func (x *MainContext) SetPollFunc(FuncVar *PollFunc) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 *PollFD, arg1 uint, arg2 int) int {
				cbFn := *FuncVar
				return cbFn(arg0, arg1, arg2)
			}
			FuncVarRef = purego.NewCallback(fcb)
			SaveCallback(FuncVarPtr, FuncVarRef)
		}
	}

	xMainContextSetPollFunc(x.GoPointer(), FuncVarRef)

}

var xMainContextUnref func(uintptr)

// Decreases the reference count on a [struct@GLib.MainContext] object by one.
// If
// the result is zero, free the context and free all associated memory.
func (x *MainContext) Unref() {

	xMainContextUnref(x.GoPointer())

}

var xMainContextWait func(uintptr, *Cond, *Mutex) bool

// Tries to become the owner of the specified context, and waits on @cond if
// another thread is the owner.
//
// This is the same as [method@GLib.MainContext.acquire], but if another thread
// is the owner, atomically drop @mutex and wait on @cond until
// that owner releases ownership or until @cond is signaled, then
// try again (once) to become the owner.
func (x *MainContext) Wait(CondVar *Cond, MutexVar *Mutex) bool {

	cret := xMainContextWait(x.GoPointer(), CondVar, MutexVar)

	return cret
}

var xMainContextWakeup func(uintptr)

// Wake up @context if it’s currently blocking in
// [method@GLib.MainContext.iteration], causing it to stop blocking.
//
// The @context could be blocking waiting for a source to become ready.
// Otherwise, if @context is not currently blocking, this function causes the
// next invocation of [method@GLib.MainContext.iteration] to return without
// blocking.
//
// This API is useful for low-level control over [struct@GLib.MainContext]; for
// example, integrating it with main loop implementations such as
// [struct@GLib.MainLoop].
//
// Another related use for this function is when implementing a main
// loop with a termination condition, computed from multiple threads:
//
// ```c
//
//	#define NUM_TASKS 10
//	static gint tasks_remaining = NUM_TASKS;  // (atomic)
//	...
//
//	while (g_atomic_int_get (&amp;tasks_remaining) != 0)
//	  g_main_context_iteration (NULL, TRUE);
//
// ```
//
// Then in a thread:
// ```c
//
//	perform_work ();
//
//	if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
//	  g_main_context_wakeup (NULL);
//
// ```
func (x *MainContext) Wakeup() {

	xMainContextWakeup(x.GoPointer())

}

// The `GMainLoop` struct is an opaque data type
// representing the main event loop of a GLib or GTK application.
type MainLoop struct {
	_ structs.HostLayout
}

var xMainLoopGLibType func() types.GType

func MainLoopGLibType() types.GType {
	return xMainLoopGLibType()
}

func (x *MainLoop) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewMainLoop func(*MainContext, bool) *MainLoop

// Creates a new [struct@GLib.MainLoop] structure.
func NewMainLoop(ContextVar *MainContext, IsRunningVar bool) *MainLoop {

	cret := xNewMainLoop(ContextVar, IsRunningVar)

	return cret
}

var xMainLoopGetContext func(uintptr) *MainContext

// Returns the [struct@GLib.MainContext] of @loop.
func (x *MainLoop) GetContext() *MainContext {

	cret := xMainLoopGetContext(x.GoPointer())

	return cret
}

var xMainLoopIsRunning func(uintptr) bool

// Checks to see if the main loop is currently being run via
// [method@GLib.MainLoop.run].
func (x *MainLoop) IsRunning() bool {

	cret := xMainLoopIsRunning(x.GoPointer())

	return cret
}

var xMainLoopQuit func(uintptr)

// Stops a [struct@GLib.MainLoop] from running. Any calls to
// [method@GLib.MainLoop.run] for the loop will return.
//
// Note that sources that have already been dispatched when
// [method@GLib.MainLoop.quit] is called will still be executed.
func (x *MainLoop) Quit() {

	xMainLoopQuit(x.GoPointer())

}

var xMainLoopRef func(uintptr) *MainLoop

// Increases the reference count on a [struct@GLib.MainLoop] object by one.
func (x *MainLoop) Ref() *MainLoop {

	cret := xMainLoopRef(x.GoPointer())

	return cret
}

var xMainLoopRun func(uintptr)

// Runs a main loop until [method@GLib.MainLoop.quit] is called on the loop.
//
// If this is called from the thread of the loop’s [struct@GLib.MainContext],
// it will process events from the loop, otherwise it will
// simply wait.
func (x *MainLoop) Run() {

	xMainLoopRun(x.GoPointer())

}

var xMainLoopUnref func(uintptr)

// Decreases the reference count on a [struct@GLib.MainLoop] object by one.
//
// If the result is zero, the loop and all associated memory are freed.
func (x *MainLoop) Unref() {

	xMainLoopUnref(x.GoPointer())

}

// The `GSource` struct is an opaque data type
// representing an event source.
type Source struct {
	_ structs.HostLayout

	CallbackData uintptr

	CallbackFuncs *SourceCallbackFuncs

	SourceFuncs *SourceFuncs

	RefCount uint

	Context *MainContext

	Priority int32

	Flags uint

	SourceId uint

	PollFds *SList

	Prev *Source

	Next *Source

	Name uintptr

	Priv *SourcePrivate
}

var xSourceGLibType func() types.GType

func SourceGLibType() types.GType {
	return xSourceGLibType()
}

func (x *Source) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewSource func(*SourceFuncs, uint) *Source

// Creates a new [struct@GLib.Source] structure.
//
// The size is specified to
// allow creating structures derived from [struct@GLib.Source] that contain
// additional data. The size passed in must be at least
// `sizeof (GSource)`.
//
// The source will not initially be associated with any [struct@GLib.MainContext]
// and must be added to one with [method@GLib.Source.attach] before it will be
// executed.
func NewSource(SourceFuncsVar *SourceFuncs, StructSizeVar uint) *Source {

	cret := xNewSource(SourceFuncsVar, StructSizeVar)

	return cret
}

var xSourceAddChildSource func(uintptr, *Source)

// Adds @child_source to @source as a ‘polled’ source.
//
// When @source is added to a [struct@GLib.MainContext], @child_source will be
// automatically added with the same priority. When @child_source is triggered,
// it will cause @source to dispatch (in addition to calling its own callback),
// and when @source is destroyed, it will destroy @child_source as well.
//
// The @source will also still be dispatched if its own prepare/check functions
// indicate that it is ready.
//
// If you don’t need @child_source to do anything on its own when it
// triggers, you can call `g_source_set_dummy_callback()` on it to set a
// callback that does nothing (except return true if appropriate).
//
// The @source will hold a reference on @child_source while @child_source
// is attached to it.
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
func (x *Source) AddChildSource(ChildSourceVar *Source) {

	xSourceAddChildSource(x.GoPointer(), ChildSourceVar)

}

var xSourceAddPoll func(uintptr, *PollFD)

// Adds a file descriptor to the set of file descriptors polled for
// this source.
//
// This is usually combined with [ctor@GLib.Source.new] to add an
// event source. The event source’s check function will typically test
// the @revents field in the [struct@GLib.PollFD] struct and return true if
// events need to be processed.
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
//
// Using this API forces the linear scanning of event sources on each
// main loop iteration.  Newly-written event sources should try to use
// `g_source_add_unix_fd()` instead of this API.
func (x *Source) AddPoll(FdVar *PollFD) {

	xSourceAddPoll(x.GoPointer(), FdVar)

}

var xSourceAddUnixFd func(uintptr, int, IOCondition) uintptr

// Monitors @fd for the IO events in @events.
//
// The tag returned by this function can be used to remove or modify the
// monitoring of the @fd using [method@GLib.Source.remove_unix_fd] or
// [method@GLib.Source.modify_unix_fd].
//
// It is not necessary to remove the file descriptor before destroying the
// source; it will be cleaned up automatically.
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (x *Source) AddUnixFd(FdVar int, EventsVar IOCondition) uintptr {

	cret := xSourceAddUnixFd(x.GoPointer(), FdVar, EventsVar)

	return cret
}

var xSourceAttach func(uintptr, *MainContext) uint

// Adds a [struct@GLib.Source] to a @context so that it will be executed within
// that context.
//
// Remove it by calling [method@GLib.Source.destroy].
//
// This function is safe to call from any thread, regardless of which thread
// the @context is running in.
func (x *Source) Attach(ContextVar *MainContext) uint {

	cret := xSourceAttach(x.GoPointer(), ContextVar)

	return cret
}

var xSourceDestroy func(uintptr)

// Removes a source from its [struct@GLib.MainContext], if any, and marks it as
// destroyed.
//
// The source cannot be subsequently added to another
// context. It is safe to call this on sources which have already been
// removed from their context.
//
// This does not unref the [struct@GLib.Source]: if you still hold a reference,
// use [method@GLib.Source.unref] to drop it.
//
// This function is safe to call from any thread, regardless of which thread
// the [struct@GLib.MainContext] is running in.
//
// If the source is currently attached to a [struct@GLib.MainContext],
// destroying it will effectively unset the callback similar to calling
// [method@GLib.Source.set_callback]. This can mean, that the data’s
// [callback@GLib.DestroyNotify] gets called right away.
func (x *Source) Destroy() {

	xSourceDestroy(x.GoPointer())

}

var xSourceDupContext func(uintptr) *MainContext

// Gets a reference to the [struct@GLib.MainContext] with which the source is
// associated.
//
// You can call this on a source that has been destroyed. You can
// always call this function on the source returned from
// [func@GLib.main_current_source].
func (x *Source) DupContext() *MainContext {

	cret := xSourceDupContext(x.GoPointer())

	return cret
}

var xSourceGetCanRecurse func(uintptr) bool

// Checks whether a source is allowed to be called recursively.
//
// See [method@GLib.Source.set_can_recurse].
func (x *Source) GetCanRecurse() bool {

	cret := xSourceGetCanRecurse(x.GoPointer())

	return cret
}

var xSourceGetContext func(uintptr) *MainContext

// Gets the [struct@GLib.MainContext] with which the source is associated.
//
// You can call this on a source that has been destroyed, provided
// that the [struct@GLib.MainContext] it was attached to still exists (in which
// case it will return that [struct@GLib.MainContext]). In particular, you can
// always call this function on the source returned from
// [func@GLib.main_current_source]. But calling this function on a source
// whose [struct@GLib.MainContext] has been destroyed is an error.
//
// If the associated [struct@GLib.MainContext] could be destroy concurrently from
// a different thread, then this function is not safe to call and
// [method@GLib.Source.dup_context] should be used instead.
func (x *Source) GetContext() *MainContext {

	cret := xSourceGetContext(x.GoPointer())

	return cret
}

var xSourceGetCurrentTime func(uintptr, *TimeVal)

// This function ignores @source and is otherwise the same as
// [func@GLib.get_current_time].
func (x *Source) GetCurrentTime(TimevalVar *TimeVal) {

	xSourceGetCurrentTime(x.GoPointer(), TimevalVar)

}

var xSourceGetId func(uintptr) uint

// Returns the numeric ID for a particular source.
//
// The ID of a source
// is a positive integer which is unique within a particular main loop
// context. The reverse mapping from ID to source is done by
// [method@GLib.MainContext.find_source_by_id].
//
// You can only call this function while the source is associated to a
// [struct@GLib.MainContext] instance; calling this function before
// [method@GLib.Source.attach] or after [method@GLib.Source.destroy] yields
// undefined behavior. The ID returned is unique within the
// [struct@GLib.MainContext] instance passed to [method@GLib.Source.attach].
func (x *Source) GetId() uint {

	cret := xSourceGetId(x.GoPointer())

	return cret
}

var xSourceGetName func(uintptr) string

// Gets a name for the source, used in debugging and profiling.
//
// The
// name may be `NULL` if it has never been set with [method@GLib.Source.set_name].
func (x *Source) GetName() string {

	cret := xSourceGetName(x.GoPointer())

	return cret
}

var xSourceGetPriority func(uintptr) int

// Gets the priority of a source.
func (x *Source) GetPriority() int {

	cret := xSourceGetPriority(x.GoPointer())

	return cret
}

var xSourceGetReadyTime func(uintptr) int64

// Gets the ‘ready time’ of @source, as set by
// [method@GLib.Source.set_ready_time].
//
// Any time before or equal to the current monotonic time (including zero)
// is an indication that the source will fire immediately.
func (x *Source) GetReadyTime() int64 {

	cret := xSourceGetReadyTime(x.GoPointer())

	return cret
}

var xSourceGetTime func(uintptr) int64

// Gets the time to be used when checking this source.
//
// The advantage of
// calling this function over calling [func@GLib.get_monotonic_time] directly is
// that when checking multiple sources, GLib can cache a single value
// instead of having to repeatedly get the system monotonic time.
//
// The time here is the system monotonic time, if available, or some
// other reasonable alternative otherwise.  See [func@GLib.get_monotonic_time].
func (x *Source) GetTime() int64 {

	cret := xSourceGetTime(x.GoPointer())

	return cret
}

var xSourceIsDestroyed func(uintptr) bool

// Returns whether @source has been destroyed.
//
// This is important when you operate upon your objects
// from within idle handlers, but may have freed the object
// before the dispatch of your idle handler.
//
// ```c
// static gboolean
// idle_callback (gpointer data)
//
//	{
//	  SomeWidget *self = data;
//
//	  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
//	  // do stuff with self
//	  self-&gt;idle_id = 0;
//	  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
//
//	  return G_SOURCE_REMOVE;
//	}
//
// static void
// some_widget_do_stuff_later (SomeWidget *self)
//
//	{
//	  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
//	  self-&gt;idle_id = g_idle_add (idle_callback, self);
//	  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
//	}
//
// static void
// some_widget_init (SomeWidget *self)
//
//	{
//	  g_mutex_init (&amp;self-&gt;idle_id_mutex);
//
//	  // ...
//	}
//
// static void
// some_widget_finalize (GObject *object)
//
//	{
//	  SomeWidget *self = SOME_WIDGET (object);
//
//	  if (self-&gt;idle_id)
//	    g_source_remove (self-&gt;idle_id);
//
//	  g_mutex_clear (&amp;self-&gt;idle_id_mutex);
//
//	  G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
//	}
//
// ```
//
// This will fail in a multi-threaded application if the
// widget is destroyed before the idle handler fires due
// to the use after free in the callback. A solution, to
// this particular problem, is to check to if the source
// has already been destroy within the callback.
//
// ```c
// static gboolean
// idle_callback (gpointer data)
//
//	{
//	  SomeWidget *self = data;
//
//	  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
//	  if (!g_source_is_destroyed (g_main_current_source ()))
//	    {
//	      // do stuff with self
//	    }
//	  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
//
//	  return FALSE;
//	}
//
// ```
//
// Calls to this function from a thread other than the one acquired by the
// [struct@GLib.MainContext] the [struct@GLib.Source] is attached to are typically
// redundant, as the source could be destroyed immediately after this function
// returns. However, once a source is destroyed it cannot be un-destroyed, so
// this function can be used for opportunistic checks from any thread.
func (x *Source) IsDestroyed() bool {

	cret := xSourceIsDestroyed(x.GoPointer())

	return cret
}

var xSourceModifyUnixFd func(uintptr, uintptr, IOCondition)

// Updates the event mask to watch for the file descriptor identified by @tag.
//
// The @tag is the tag returned from [method@GLib.Source.add_unix_fd].
//
// If you want to remove a file descriptor, don’t set its event mask to zero.
// Instead, call [method@GLib.Source.remove_unix_fd].
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (x *Source) ModifyUnixFd(TagVar uintptr, NewEventsVar IOCondition) {

	xSourceModifyUnixFd(x.GoPointer(), TagVar, NewEventsVar)

}

var xSourceQueryUnixFd func(uintptr, uintptr) IOCondition

// Queries the events reported for the file descriptor corresponding to @tag
// on @source during the last poll.
//
// The return value of this function is only defined when the function
// is called from the check or dispatch functions for @source.
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (x *Source) QueryUnixFd(TagVar uintptr) IOCondition {

	cret := xSourceQueryUnixFd(x.GoPointer(), TagVar)

	return cret
}

var xSourceRef func(uintptr) *Source

// Increases the reference count on a source by one.
func (x *Source) Ref() *Source {

	cret := xSourceRef(x.GoPointer())

	return cret
}

var xSourceRemoveChildSource func(uintptr, *Source)

// Detaches @child_source from @source and destroys it.
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
func (x *Source) RemoveChildSource(ChildSourceVar *Source) {

	xSourceRemoveChildSource(x.GoPointer(), ChildSourceVar)

}

var xSourceRemovePoll func(uintptr, *PollFD)

// Removes a file descriptor from the set of file descriptors polled for
// this source.
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
func (x *Source) RemovePoll(FdVar *PollFD) {

	xSourceRemovePoll(x.GoPointer(), FdVar)

}

var xSourceRemoveUnixFd func(uintptr, uintptr)

// Reverses the effect of a previous call to [method@GLib.Source.add_unix_fd].
//
// You only need to call this if you want to remove a file descriptor from being
// watched while keeping the same source around.  In the normal case you
// will just want to destroy the source.
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (x *Source) RemoveUnixFd(TagVar uintptr) {

	xSourceRemoveUnixFd(x.GoPointer(), TagVar)

}

var xSourceSetCallback func(uintptr, uintptr, uintptr, uintptr)

// Sets the callback function for a source. The callback for a source is
// called from the source’s dispatch function.
//
// The exact type of @func depends on the type of source; ie. you
// should not count on @func being called with @data as its first
// parameter. Cast @func with [func@GLib.SOURCE_FUNC] to avoid warnings about
// incompatible function types.
//
// See [main loop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle memory management of @data.
//
// Typically, you won’t use this function. Instead use functions specific
// to the type of source you are using, such as [func@GLib.idle_add] or
// [func@GLib.timeout_add].
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
//
// Note that [method@GLib.Source.destroy] for a currently attached source has the effect
// of also unsetting the callback.
func (x *Source) SetCallback(FuncVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FuncVar
				return cbFn(arg0)
			}
			FuncVarRef = purego.NewCallback(fcb)
			SaveCallback(FuncVarPtr, FuncVarRef)
		}
	}

	var NotifyVarRef uintptr
	if NotifyVar != nil {
		NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
		if cbRefPtr, ok := GetCallback(NotifyVarPtr); ok {
			NotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *NotifyVar
				cbFn(arg0)
			}
			NotifyVarRef = purego.NewCallback(fcb)
			SaveCallback(NotifyVarPtr, NotifyVarRef)
		}
	}

	xSourceSetCallback(x.GoPointer(), FuncVarRef, DataVar, NotifyVarRef)

}

var xSourceSetCallbackIndirect func(uintptr, uintptr, *SourceCallbackFuncs)

// Sets the callback function storing the data as a reference counted callback
// ‘object’.
//
// This is used internally. Note that calling
// [method@GLib.Source.set_callback_indirect] assumes
// an initial reference count on @callback_data, and thus
// `callback_funcs-&gt;unref` will eventually be called once more than
// `callback_funcs-&gt;ref`.
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
func (x *Source) SetCallbackIndirect(CallbackDataVar uintptr, CallbackFuncsVar *SourceCallbackFuncs) {

	xSourceSetCallbackIndirect(x.GoPointer(), CallbackDataVar, CallbackFuncsVar)

}

var xSourceSetCanRecurse func(uintptr, bool)

// Sets whether a source can be called recursively.
//
// If @can_recurse is true, then while the source is being dispatched then this
// source will be processed normally. Otherwise, all processing of this
// source is blocked until the dispatch function returns.
func (x *Source) SetCanRecurse(CanRecurseVar bool) {

	xSourceSetCanRecurse(x.GoPointer(), CanRecurseVar)

}

var xSourceSetDisposeFunction func(uintptr, uintptr)

// Set @dispose as dispose function on @source.
//
// The @dispose function will be called once the reference count of @source
// reaches zero but before any of the state of the source is freed, especially
// before the finalize function (set as part of the [type@GLib.SourceFuncs]) is
// called.
//
// This means that at this point @source is still a valid [struct@GLib.Source]
// and it is allow for the reference count to increase again until @dispose
// returns.
//
// The dispose function can be used to clear any ‘weak’ references to
// the @source in other data structures in a thread-safe way where it is
// possible for another thread to increase the reference count of @source again
// while it is being freed.
//
// The finalize function can not be used for this purpose as at that
// point @source is already partially freed and not valid any more.
//
// This should only ever be called from [struct@GLib.Source] implementations.
func (x *Source) SetDisposeFunction(DisposeVar *SourceDisposeFunc) {

	var DisposeVarRef uintptr
	if DisposeVar != nil {
		DisposeVarPtr := uintptr(unsafe.Pointer(DisposeVar))
		if cbRefPtr, ok := GetCallback(DisposeVarPtr); ok {
			DisposeVarRef = cbRefPtr
		} else {
			fcb := func(arg0 *Source) {
				cbFn := *DisposeVar
				cbFn(arg0)
			}
			DisposeVarRef = purego.NewCallback(fcb)
			SaveCallback(DisposeVarPtr, DisposeVarRef)
		}
	}

	xSourceSetDisposeFunction(x.GoPointer(), DisposeVarRef)

}

var xSourceSetFuncs func(uintptr, *SourceFuncs)

// Sets the source functions of an unattached source.
//
// These can be used to override the default implementations for the type
// of @source.
func (x *Source) SetFuncs(FuncsVar *SourceFuncs) {

	xSourceSetFuncs(x.GoPointer(), FuncsVar)

}

var xSourceSetName func(uintptr, string)

// Sets a name for the source, used in debugging and profiling.
//
// The name defaults to `NULL`.
//
// The source name should describe in a human-readable way
// what the source does. For example, ‘X11 event queue’
// or ‘GTK repaint idle handler’.
//
// It is permitted to call this function multiple times, but is not
// recommended due to the potential performance impact.  For example,
// one could change the name in the `check` function of a
// [struct@GLib.SourceFuncs] to include details like the event type in the
// source name.
//
// Use caution if changing the name while another thread may be
// accessing it with [method@GLib.Source.get_name]; that function does not copy
// the value, and changing the value will free it while the other thread
// may be attempting to use it.
//
// Also see [method@GLib.Source.set_static_name].
func (x *Source) SetName(NameVar string) {

	xSourceSetName(x.GoPointer(), NameVar)

}

var xSourceSetPriority func(uintptr, int)

// Sets the priority of a source.
//
// While the main loop is being run, a
// source will be dispatched if it is ready to be dispatched and no
// sources at a higher (numerically smaller) priority are ready to be
// dispatched.
//
// A child source always has the same priority as its parent.  It is not
// permitted to change the priority of a source once it has been added
// as a child of another source.
func (x *Source) SetPriority(PriorityVar int) {

	xSourceSetPriority(x.GoPointer(), PriorityVar)

}

var xSourceSetReadyTime func(uintptr, int64)

// Sets a source to be dispatched when the given monotonic time is
// reached (or passed).
//
// If the monotonic time is in the past (as it
// always will be if @ready_time is `0`) then the source will be
// dispatched immediately.
//
// If @ready_time is `-1` then the source is never woken up on the basis
// of the passage of time.
//
// Dispatching the source does not reset the ready time.  You should do
// so yourself, from the source dispatch function.
//
// Note that if you have a pair of sources where the ready time of one
// suggests that it will be delivered first but the priority for the
// other suggests that it would be delivered first, and the ready time
// for both sources is reached during the same main context iteration,
// then the order of dispatch is undefined.
//
// It is a no-op to call this function on a [struct@GLib.Source] which has
// already been destroyed with [method@GLib.Source.destroy].
//
// This API is only intended to be used by implementations of [struct@GLib.Source].
// Do not call this API on a [struct@GLib.Source] that you did not create.
func (x *Source) SetReadyTime(ReadyTimeVar int64) {

	xSourceSetReadyTime(x.GoPointer(), ReadyTimeVar)

}

var xSourceSetStaticName func(uintptr, string)

// A variant of [method@GLib.Source.set_name] that does not
// duplicate the @name, and can only be used with
// string literals.
func (x *Source) SetStaticName(NameVar string) {

	xSourceSetStaticName(x.GoPointer(), NameVar)

}

var xSourceUnref func(uintptr)

// Decreases the reference count of a source by one.
//
// If the resulting reference count is zero the source and associated
// memory will be destroyed.
func (x *Source) Unref() {

	xSourceUnref(x.GoPointer())

}

// The `GSourceCallbackFuncs` struct contains
// functions for managing callback objects.
type SourceCallbackFuncs struct {
	_ structs.HostLayout

	xRef uintptr

	xUnref uintptr

	xGet uintptr
}

func (x *SourceCallbackFuncs) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideRef sets the "ref" callback function.
// Called when a reference is added to the callback object
func (x *SourceCallbackFuncs) OverrideRef(cb func(uintptr)) {
	if cb == nil {
		x.xRef = 0
	} else {
		x.xRef = purego.NewCallback(func(CbDataVarp uintptr) {
			cb(CbDataVarp)
		})
	}
}

// GetRef gets the "ref" callback function.
// Called when a reference is added to the callback object
func (x *SourceCallbackFuncs) GetRef() func(uintptr) {
	if x.xRef == 0 {
		return nil
	}
	var rawCallback func(CbDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRef)
	return func(CbDataVar uintptr) {
		rawCallback(CbDataVar)
	}
}

// OverrideUnref sets the "unref" callback function.
// Called when a reference to the callback object is dropped
func (x *SourceCallbackFuncs) OverrideUnref(cb func(uintptr)) {
	if cb == nil {
		x.xUnref = 0
	} else {
		x.xUnref = purego.NewCallback(func(CbDataVarp uintptr) {
			cb(CbDataVarp)
		})
	}
}

// GetUnref gets the "unref" callback function.
// Called when a reference to the callback object is dropped
func (x *SourceCallbackFuncs) GetUnref() func(uintptr) {
	if x.xUnref == 0 {
		return nil
	}
	var rawCallback func(CbDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnref)
	return func(CbDataVar uintptr) {
		rawCallback(CbDataVar)
	}
}

// OverrideGet sets the "get" callback function.
// Called to extract the callback function and data from the
//
//	callback object.
func (x *SourceCallbackFuncs) OverrideGet(cb func(uintptr, *Source, *SourceFunc, uintptr)) {
	if cb == nil {
		x.xGet = 0
	} else {
		x.xGet = purego.NewCallback(func(CbDataVarp uintptr, SourceVarp *Source, FuncVarp uintptr, DataVarp uintptr) {
			cb(CbDataVarp, SourceVarp, (*SourceFunc)(unsafe.Pointer(FuncVarp)), DataVarp)
		})
	}
}

// GetGet gets the "get" callback function.
// Called to extract the callback function and data from the
//
//	callback object.
func (x *SourceCallbackFuncs) GetGet() func(uintptr, *Source, *SourceFunc, uintptr) {
	if x.xGet == 0 {
		return nil
	}
	var rawCallback func(CbDataVarp uintptr, SourceVarp *Source, FuncVarp uintptr, DataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xGet)
	return func(CbDataVar uintptr, SourceVar *Source, FuncVar *SourceFunc, DataVar uintptr) {
		rawCallback(CbDataVar, SourceVar, NewCallback(FuncVar), DataVar)
	}
}

// The `GSourceFuncs` struct contains a table of
// functions used to handle event sources in a generic manner.
//
// For idle sources, the prepare and check functions always return %TRUE
// to indicate that the source is always ready to be processed. The prepare
// function also returns a timeout value of 0 to ensure that the poll() call
// doesn't block (since that would be time wasted which could have been spent
// running the idle function).
//
// For timeout sources, the prepare and check functions both return %TRUE
// if the timeout interval has expired. The prepare function also returns
// a timeout value to ensure that the poll() call doesn't block too long
// and miss the next timeout.
//
// For file descriptor sources, the prepare function typically returns %FALSE,
// since it must wait until poll() has been called before it knows whether
// any events need to be processed. It sets the returned timeout to -1 to
// indicate that it doesn't mind how long the poll() call blocks. In the
// check function, it tests the results of the poll() call to see if the
// required condition has been met, and returns %TRUE if so.
type SourceFuncs struct {
	_ structs.HostLayout

	Prepare SourceFuncsPrepareFunc

	Check SourceFuncsCheckFunc

	Dispatch SourceFuncsDispatchFunc

	Finalize SourceFuncsFinalizeFunc

	ClosureCallback SourceFunc

	ClosureMarshal SourceDummyMarshal
}

func (x *SourceFuncs) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type SourcePrivate struct {
	_ structs.HostLayout
}

func (x *SourcePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Opaque type. See g_main_context_pusher_new() for details.
type MainContextPusher = uintptr

const (
	// Use this for default priority event sources.
	//
	// In GLib this priority is used when adding timeout functions
	// with [func@GLib.timeout_add]. In GDK this priority is used for events
	// from the X server.
	PRIORITY_DEFAULT int = 0
	// Use this for default priority idle functions.
	//
	// In GLib this priority is used when adding idle functions with
	// [func@GLib.idle_add].
	PRIORITY_DEFAULT_IDLE int = 200
	// Use this for high priority event sources.
	//
	// It is not used within GLib or GTK.
	PRIORITY_HIGH int = -100
	// Use this for high priority idle functions.
	//
	// GTK uses %G_PRIORITY_HIGH_IDLE + 10 for resizing operations,
	// and %G_PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is
	// done to ensure that any pending resizes are processed before any
	// pending redraws, so that widgets are not redrawn twice unnecessarily.)
	PRIORITY_HIGH_IDLE int = 100
	// Use this for very low priority background tasks.
	//
	// It is not used within GLib or GTK.
	PRIORITY_LOW int = 300
	// Use this macro as the return value of a [callback@GLib.SourceFunc] to leave
	// the [struct@GLib.Source] in the main loop.
	SOURCE_CONTINUE bool = true
	// Use this macro as the return value of a [callback@GLib.SourceFunc] to remove
	// the [struct@GLib.Source] from the main loop.
	SOURCE_REMOVE bool = false
)

// Flags to pass to [ctor@GLib.MainContext.new_with_flags] which affect the
// behaviour of a [struct@GLib.MainContext].
type MainContextFlags int

const (

	// Default behaviour.
	GMainContextFlagsNoneValue MainContextFlags = 0
	// Assume that polling for events will
	// free the thread to process other jobs. That's useful if you're using
	// `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in
	// other event loops.
	GMainContextFlagsOwnerlessPollingValue MainContextFlags = 1
)

var xChildWatchAdd func(Pid, uintptr, uintptr) uint

// Sets a function to be called when the child indicated by @pid
// exits, at a default priority, [const@GLib.PRIORITY_DEFAULT].
//
// If you obtain @pid from [func@GLib.spawn_async] or
// [func@GLib.spawn_async_with_pipes] you will need to pass
// [flags@GLib.SpawnFlags.DO_NOT_REAP_CHILD] as a flag to the spawn function for
// the child watching to work.
//
// Note that on platforms where [type@GLib.Pid] must be explicitly closed
// (see [func@GLib.spawn_close_pid]) @pid must not be closed while the
// source is still active. Typically, you will want to call
// [func@GLib.spawn_close_pid] in the callback function for the source.
//
// GLib supports only a single callback per process ID.
// On POSIX platforms, the same restrictions mentioned for
// [func@GLib.child_watch_source_new] apply to this function.
//
// This internally creates a main loop source using
// [func@GLib.child_watch_source_new] and attaches it to the main loop context
// using [method@GLib.Source.attach]. You can do these steps manually if you
// need greater control.
func ChildWatchAdd(PidVar Pid, FunctionVar *ChildWatchFunc, DataVar uintptr) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 Pid, arg1 int, arg2 uintptr) {
				cbFn := *FunctionVar
				cbFn(arg0, arg1, arg2)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	cret := xChildWatchAdd(PidVar, FunctionVarRef, DataVar)

	return cret
}

var xChildWatchAddFull func(int, Pid, uintptr, uintptr, uintptr) uint

// Sets a function to be called when the child indicated by @pid
// exits, at the priority @priority.
//
// If you obtain @pid from [func@GLib.spawn_async] or
// [func@GLib.spawn_async_with_pipes] you will need to pass
// [flags@GLib.SpawnFlags.DO_NOT_REAP_CHILD] as a flag to the spawn function for
// the child watching to work.
//
// In many programs, you will want to call [func@GLib.spawn_check_wait_status]
// in the callback to determine whether or not the child exited
// successfully.
//
// Also, note that on platforms where [type@GLib.Pid] must be explicitly closed
// (see [func@GLib.spawn_close_pid]) @pid must not be closed while the source
// is still active.  Typically, you should invoke [func@GLib.spawn_close_pid]
// in the callback function for the source.
//
// GLib supports only a single callback per process ID.
// On POSIX platforms, the same restrictions mentioned for
// [func@GLib.child_watch_source_new] apply to this function.
//
// This internally creates a main loop source using
// [func@GLib.child_watch_source_new] and attaches it to the main loop context
// using [method@GLib.Source.attach]. You can do these steps manually if you
// need greater control.
func ChildWatchAddFull(PriorityVar int, PidVar Pid, FunctionVar *ChildWatchFunc, DataVar uintptr, NotifyVar *DestroyNotify) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 Pid, arg1 int, arg2 uintptr) {
				cbFn := *FunctionVar
				cbFn(arg0, arg1, arg2)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	var NotifyVarRef uintptr
	if NotifyVar != nil {
		NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
		if cbRefPtr, ok := GetCallback(NotifyVarPtr); ok {
			NotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *NotifyVar
				cbFn(arg0)
			}
			NotifyVarRef = purego.NewCallback(fcb)
			SaveCallback(NotifyVarPtr, NotifyVarRef)
		}
	}

	cret := xChildWatchAddFull(PriorityVar, PidVar, FunctionVarRef, DataVar, NotifyVarRef)

	return cret
}

var xChildWatchSourceNew func(Pid) *Source

// Creates a new child watch source.
//
// The source will not initially be associated with any
// [struct@GLib.MainContext] and must be added to one with
// [method@GLib.Source.attach] before it will be executed.
//
// Note that child watch sources can only be used in conjunction with
// `g_spawn...` when the [flags@GLib.SpawnFlags.DO_NOT_REAP_CHILD] flag is used.
//
// Note that on platforms where [type@GLib.Pid] must be explicitly closed
// (see [func@GLib.spawn_close_pid]) @pid must not be closed while the
// source is still active. Typically, you will want to call
// [func@GLib.spawn_close_pid] in the callback function for the source.
//
// On POSIX platforms, the following restrictions apply to this API
// due to limitations in POSIX process interfaces:
//
//   - @pid must be a child of this process.
//   - @pid must be positive.
//   - The application must not call [`waitpid()`](man:waitpid(1)) with a
//     non-positive first argument, for instance in another thread.
//   - The application must not wait for @pid to exit by any other
//     mechanism, including `waitpid(pid, ...)` or a second child-watch
//     source for the same @pid.
//   - The application must not ignore `SIGCHLD`.
//   - Before 2.78, the application could not send a signal ([`kill()`](man:kill(2))) to the
//     watched @pid in a race free manner. Since 2.78, you can do that while the
//     associated [struct@GLib.MainContext] is acquired.
//   - Before 2.78, even after destroying the [struct@GLib.Source], you could not
//     be sure that @pid wasn’t already reaped. Hence, it was also not
//     safe to `kill()` or `waitpid()` on the process ID after the child watch
//     source was gone. Destroying the source before it fired made it
//     impossible to reliably reap the process.
//
// If any of those conditions are not met, this and related APIs will
// not work correctly. This can often be diagnosed via a GLib warning
// stating that `ECHILD` was received by `waitpid()`.
//
// Calling [`waitpid()`](man:waitpid(2)) for specific processes other than @pid
// remains a valid thing to do.
func ChildWatchSourceNew(PidVar Pid) *Source {

	cret := xChildWatchSourceNew(PidVar)

	return cret
}

var xClearHandleId func(uint, uintptr)

// Clears a numeric handler, such as a [struct@GLib.Source] ID.
//
// The @tag_ptr must be a valid pointer to the variable holding the handler.
//
// If the ID is zero then this function does nothing.
// Otherwise, @clear_func is called with the ID as a parameter, and the tag is
// set to zero.
//
// A macro is also included that allows this function to be used without
// pointer casts.
func ClearHandleId(TagPtrVar uint, ClearFuncVar *ClearHandleFunc) {

	var ClearFuncVarRef uintptr
	if ClearFuncVar != nil {
		ClearFuncVarPtr := uintptr(unsafe.Pointer(ClearFuncVar))
		if cbRefPtr, ok := GetCallback(ClearFuncVarPtr); ok {
			ClearFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uint) {
				cbFn := *ClearFuncVar
				cbFn(arg0)
			}
			ClearFuncVarRef = purego.NewCallback(fcb)
			SaveCallback(ClearFuncVarPtr, ClearFuncVarRef)
		}
	}

	xClearHandleId(TagPtrVar, ClearFuncVarRef)

}

var xGetCurrentTime func(*TimeVal)

// Queries the system wall-clock time.
//
// This is equivalent to the UNIX [`gettimeofday()`](man:gettimeofday(2))
// function, but portable.
//
// You may find [func@GLib.get_real_time] to be more convenient.
func GetCurrentTime(ResultVar *TimeVal) {

	xGetCurrentTime(ResultVar)

}

var xGetMonotonicTime func() int64

// Queries the system monotonic time.
//
// The monotonic clock will always increase and doesn’t suffer
// discontinuities when the user (or NTP) changes the system time.  It
// may or may not continue to tick during times where the machine is
// suspended.
//
// We try to use the clock that corresponds as closely as possible to
// the passage of time as measured by system calls such as
// [`poll()`](man:poll(2)) but it
// may not always be possible to do this.
func GetMonotonicTime() int64 {

	cret := xGetMonotonicTime()

	return cret
}

var xGetRealTime func() int64

// Queries the system wall-clock time.
//
// This is equivalent to the UNIX [`gettimeofday()`](man:gettimeofday(2))
// function, but portable.
//
// You should only use this call if you are actually interested in the real
// wall-clock time. [func@GLib.get_monotonic_time] is probably more useful for
// measuring intervals.
func GetRealTime() int64 {

	cret := xGetRealTime()

	return cret
}

var xIdleAdd func(uintptr, uintptr) uint

// Adds a function to be called whenever there are no higher priority
// events pending to the default main loop.
//
// The function is given the
// default idle priority, [const@GLib.PRIORITY_DEFAULT_IDLE].  If the function
// returns [const@GLib.SOURCE_REMOVE] it is automatically removed from the list
// of event sources and will not be called again.
//
// See [main loop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using [func@GLib.idle_source_new]
// and attaches it to the global [struct@GLib.MainContext] using
// [method@GLib.Source.attach], so the callback will be invoked in whichever
// thread is running that main context. You can do these steps manually if you
// need greater control or to use a custom main context.
func IdleAdd(FunctionVar *SourceFunc, DataVar uintptr) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FunctionVar
				return cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	cret := xIdleAdd(FunctionVarRef, DataVar)

	return cret
}

var xIdleAddFull func(int, uintptr, uintptr, uintptr) uint

// Adds a function to be called whenever there are no higher priority
// events pending.
//
// If the function returns [const@GLib.SOURCE_REMOVE] it is automatically
// removed from the list of event sources and will not be called again.
//
// See [main loop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using [func@GLib.idle_source_new]
// and attaches it to the global [struct@GLib.MainContext] using
// [method@GLib.Source.attach], so the callback will be invoked in whichever
// thread is running that main context. You can do these steps manually if you
// need greater control or to use a custom main context.
func IdleAddFull(PriorityVar int, FunctionVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FunctionVar
				return cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	var NotifyVarRef uintptr
	if NotifyVar != nil {
		NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
		if cbRefPtr, ok := GetCallback(NotifyVarPtr); ok {
			NotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *NotifyVar
				cbFn(arg0)
			}
			NotifyVarRef = purego.NewCallback(fcb)
			SaveCallback(NotifyVarPtr, NotifyVarRef)
		}
	}

	cret := xIdleAddFull(PriorityVar, FunctionVarRef, DataVar, NotifyVarRef)

	return cret
}

var xIdleAddOnce func(uintptr, uintptr) uint

// Adds a function to be called whenever there are no higher priority
// events pending to the default main loop.
//
// The function is given the
// default idle priority, [const@GLib.PRIORITY_DEFAULT_IDLE].
//
// The function will only be called once and then the source will be
// automatically removed from the main context.
//
// This function otherwise behaves like [func@GLib.idle_add].
func IdleAddOnce(FunctionVar *SourceOnceFunc, DataVar uintptr) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *FunctionVar
				cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	cret := xIdleAddOnce(FunctionVarRef, DataVar)

	return cret
}

var xIdleRemoveByData func(uintptr) bool

// Removes the idle function with the given data.
func IdleRemoveByData(DataVar uintptr) bool {

	cret := xIdleRemoveByData(DataVar)

	return cret
}

var xIdleSourceNew func() *Source

// Creates a new idle source.
//
// The source will not initially be associated with any
// [struct@GLib.MainContext] and must be added to one with
// [method@GLib.Source.attach] before it will be executed. Note that the
// default priority for idle sources is [const@GLib.PRIORITY_DEFAULT_IDLE], as
// compared to other sources which have a default priority of
// [const@GLib.PRIORITY_DEFAULT].
func IdleSourceNew() *Source {

	cret := xIdleSourceNew()

	return cret
}

var xMainContextDefault func() *MainContext

// Returns the global-default main context.
//
// This is the main context
// used for main loop functions when a main loop is not explicitly
// specified, and corresponds to the ‘main’ main loop. See also
// [func@GLib.MainContext.get_thread_default].
func MainContextDefault() *MainContext {

	cret := xMainContextDefault()

	return cret
}

var xMainContextGetThreadDefault func() *MainContext

// Gets the thread-default main context for this thread.
//
// Asynchronous operations that want to be able to be run in contexts other than
// the default one should call this method or
// [func@GLib.MainContext.ref_thread_default] to get a
// [struct@GLib.MainContext] to add their [struct@GLib.Source]s to. (Note that
// even in single-threaded programs applications may sometimes want to
// temporarily push a non-default context, so it is not safe to assume that
// this will always return `NULL` if you are running in the default thread.)
//
// If you need to hold a reference on the context, use
// [func@GLib.MainContext.ref_thread_default] instead.
func MainContextGetThreadDefault() *MainContext {

	cret := xMainContextGetThreadDefault()

	return cret
}

var xMainContextRefThreadDefault func() *MainContext

// Gets a reference to the thread-default [struct@GLib.MainContext] for this
// thread
//
// This is the same as [func@GLib.MainContext.get_thread_default], but it also
// adds a reference to the returned main context with [method@GLib.MainContext.ref].
// In addition, unlike
// [func@GLib.MainContext.get_thread_default], if the thread-default context
// is the global-default context, this will return that
// [struct@GLib.MainContext] (with a ref added to it) rather than returning
// `NULL`.
func MainContextRefThreadDefault() *MainContext {

	cret := xMainContextRefThreadDefault()

	return cret
}

var xMainCurrentSource func() *Source

// Returns the currently firing source for this thread.
func MainCurrentSource() *Source {

	cret := xMainCurrentSource()

	return cret
}

var xMainDepth func() int

// Returns the depth of the stack of calls to
// [method@GLib.MainContext.dispatch] on any #GMainContext in the current thread.
//
// That is, when called from the top level, it gives `0`. When
// called from within a callback from [method@GLib.MainContext.iteration]
// (or [method@GLib.MainLoop.run], etc.) it returns `1`. When called from within
// a callback to a recursive call to [method@GLib.MainContext.iteration],
// it returns `2`. And so forth.
//
// This function is useful in a situation like the following:
// Imagine an extremely simple ‘garbage collected’ system.
//
// ```c
// static GList *free_list;
//
// gpointer
// allocate_memory (gsize size)
//
//	{
//	  gpointer result = g_malloc (size);
//	  free_list = g_list_prepend (free_list, result);
//	  return result;
//	}
//
// void
// free_allocated_memory (void)
//
//	{
//	  GList *l;
//	  for (l = free_list; l; l = l-&gt;next);
//	    g_free (l-&gt;data);
//	  g_list_free (free_list);
//	  free_list = NULL;
//	 }
//
// [...]
//
// while (TRUE);
//
//	{
//	  g_main_context_iteration (NULL, TRUE);
//	  free_allocated_memory();
//	 }
//
// ```
//
// This works from an application, however, if you want to do the same
// thing from a library, it gets more difficult, since you no longer
// control the main loop. You might think you can simply use an idle
// function to make the call to `free_allocated_memory()`, but that
// doesn’t work, since the idle function could be called from a
// recursive callback. This can be fixed by using [func@GLib.main_depth]
//
// ```c
// gpointer
// allocate_memory (gsize size)
//
//	{
//	  FreeListBlock *block = g_new (FreeListBlock, 1);
//	  block-&gt;mem = g_malloc (size);
//	  block-&gt;depth = g_main_depth ();
//	  free_list = g_list_prepend (free_list, block);
//	  return block-&gt;mem;
//	}
//
// void
// free_allocated_memory (void)
//
//	{
//	  GList *l;
//
//	  int depth = g_main_depth ();
//	  for (l = free_list; l; );
//	    {
//	      GList *next = l-&gt;next;
//	      FreeListBlock *block = l-&gt;data;
//	      if (block-&gt;depth &gt; depth)
//	        {
//	          g_free (block-&gt;mem);
//	          g_free (block);
//	          free_list = g_list_delete_link (free_list, l);
//	        }
//
//	      l = next;
//	    }
//	  }
//
// ```
//
// There is a temptation to use [func@GLib.main_depth] to solve
// problems with reentrancy. For instance, while waiting for data
// to be received from the network in response to a menu item,
// the menu item might be selected again. It might seem that
// one could make the menu item’s callback return immediately
// and do nothing if [func@GLib.main_depth] returns a value greater than 1.
// However, this should be avoided since the user then sees selecting
// the menu item do nothing. Furthermore, you’ll find yourself adding
// these checks all over your code, since there are doubtless many,
// many things that the user could do. Instead, you can use the
// following techniques:
//
//  1. Use `gtk_widget_set_sensitive()` or modal dialogs to prevent
//     the user from interacting with elements while the main
//     loop is recursing.
//
//  2. Avoid main loop recursion in situations where you can’t handle
//     arbitrary  callbacks. Instead, structure your code so that you
//     simply return to the main loop and then get called again when
//     there is more work to do.
func MainDepth() int {

	cret := xMainDepth()

	return cret
}

var xSourceRemove func(uint) bool

// Removes the source with the given ID from the default main context.
//
// You must
// use [method@GLib.Source.destroy] for sources added to a non-default main context.
//
// The ID of a [struct@GLib.Source] is given by [method@GLib.Source.get_id], or will be
// returned by the functions [method@GLib.Source.attach], [func@GLib.idle_add],
// [func@GLib.idle_add_full], [func@GLib.timeout_add],
// [func@GLib.timeout_add_full], [func@GLib.child_watch_add],
// [func@GLib.child_watch_add_full], [func@GLib.io_add_watch], and
// [func@GLib.io_add_watch_full].
//
// It is a programmer error to attempt to remove a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a
// source ID which may have already been removed.  An example is when
// scheduling an idle to run in another thread with [func@GLib.idle_add]: the
// idle may already have run and been removed by the time this function
// is called on its (now invalid) source ID.  This source ID may have
// been reissued, leading to the operation being performed against the
// wrong source.
func SourceRemove(TagVar uint) bool {

	cret := xSourceRemove(TagVar)

	return cret
}

var xSourceRemoveByFuncsUserData func(*SourceFuncs, uintptr) bool

// Removes a source from the default main loop context given the
// source functions and user data.
//
// If multiple sources exist with the same source functions and user data, only
// one will be destroyed.
func SourceRemoveByFuncsUserData(FuncsVar *SourceFuncs, UserDataVar uintptr) bool {

	cret := xSourceRemoveByFuncsUserData(FuncsVar, UserDataVar)

	return cret
}

var xSourceRemoveByUserData func(uintptr) bool

// Removes a source from the default main loop context given the user
// data for the callback.
//
// If multiple sources exist with the same user data, only one will be destroyed.
func SourceRemoveByUserData(UserDataVar uintptr) bool {

	cret := xSourceRemoveByUserData(UserDataVar)

	return cret
}

var xSourceSetNameById func(uint, string)

// Sets the name of a source using its ID.
//
// This is a convenience utility to set source names from the return
// value of [func@GLib.idle_add], [func@GLib.timeout_add], etc.
//
// It is a programmer error to attempt to set the name of a non-existent
// source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a
// source ID which may have already been removed.  An example is when
// scheduling an idle to run in another thread with [func@GLib.idle_add]: the
// idle may already have run and been removed by the time this function
// is called on its (now invalid) source ID.  This source ID may have
// been reissued, leading to the operation being performed against the
// wrong source.
func SourceSetNameById(TagVar uint, NameVar string) {

	xSourceSetNameById(TagVar, NameVar)

}

var xTimeoutAdd func(uint, uintptr, uintptr) uint

// Sets a function to be called at regular intervals, with the default
// priority, [const@GLib.PRIORITY_DEFAULT].
//
// The given @function is called repeatedly until it returns
// [const@GLib.SOURCE_REMOVE], at which point the timeout is
// automatically destroyed and the function will not be called again. The first
// call to the function will be at the end of the first @interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing.
// After each call to the timeout function, the time of the next
// timeout is recalculated based on the current time and the given interval
// (it does not try to ‘catch up’ time lost in delays).
//
// See [main loop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
//
// If you want to have a timer in the ‘seconds’ range and do not care
// about the exact time of the first call of the timer, use the
// [func@GLib.timeout_add_seconds] function; this function allows for more
// optimizations and more efficient system power usage.
//
// This internally creates a main loop source using
// [func@GLib.timeout_source_new] and attaches it to the global
// [struct@GLib.MainContext] using [method@GLib.Source.attach], so the callback
// will be invoked in whichever thread is running that main context. You can do
// these steps manually if you need greater control or to use a custom main
// context.
//
// It is safe to call this function from any thread.
//
// The interval given is in terms of monotonic time, not wall clock
// time. See [func@GLib.get_monotonic_time].
func TimeoutAdd(IntervalVar uint, FunctionVar *SourceFunc, DataVar uintptr) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FunctionVar
				return cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	cret := xTimeoutAdd(IntervalVar, FunctionVarRef, DataVar)

	return cret
}

var xTimeoutAddFull func(int, uint, uintptr, uintptr, uintptr) uint

// Sets a function to be called at regular intervals, with the given
// priority.
//
// The function is called repeatedly until it returns
// [const@GLib.SOURCE_REMOVE], at which point the timeout is automatically
// destroyed and
// the function will not be called again.  The @notify function is
// called when the timeout is destroyed.  The first call to the
// function will be at the end of the first @interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing.
// After each call to the timeout function, the time of the next
// timeout is recalculated based on the current time and the given interval
// (it does not try to ‘catch up’ time lost in delays).
//
// See [main loop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using
// [func@GLib.timeout_source_new] and attaches it to the global
// [struct@GLib.MainContext] using [method@GLib.Source.attach], so the callback
// will be invoked in whichever thread is running that main context. You can do
// these steps manually if you need greater control or to use a custom main
// context.
//
// The interval given is in terms of monotonic time, not wall clock time.
// See [func@GLib.get_monotonic_time].
func TimeoutAddFull(PriorityVar int, IntervalVar uint, FunctionVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FunctionVar
				return cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	var NotifyVarRef uintptr
	if NotifyVar != nil {
		NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
		if cbRefPtr, ok := GetCallback(NotifyVarPtr); ok {
			NotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *NotifyVar
				cbFn(arg0)
			}
			NotifyVarRef = purego.NewCallback(fcb)
			SaveCallback(NotifyVarPtr, NotifyVarRef)
		}
	}

	cret := xTimeoutAddFull(PriorityVar, IntervalVar, FunctionVarRef, DataVar, NotifyVarRef)

	return cret
}

var xTimeoutAddOnce func(uint, uintptr, uintptr) uint

// Sets a function to be called after @interval milliseconds have elapsed,
// with the default priority, [const@GLib.PRIORITY_DEFAULT].
//
// The given @function is called once and then the source will be automatically
// removed from the main context.
//
// This function otherwise behaves like [func@GLib.timeout_add].
func TimeoutAddOnce(IntervalVar uint, FunctionVar *SourceOnceFunc, DataVar uintptr) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *FunctionVar
				cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	cret := xTimeoutAddOnce(IntervalVar, FunctionVarRef, DataVar)

	return cret
}

var xTimeoutAddSeconds func(uint, uintptr, uintptr) uint

// Sets a function to be called at regular intervals with the default
// priority, [const@GLib.PRIORITY_DEFAULT].
//
// The function is called repeatedly until it returns [const@GLib.SOURCE_REMOVE],
// at which point the timeout is automatically destroyed
// and the function will not be called again.
//
// This internally creates a main loop source using
// [func@GLib.timeout_source_new_seconds] and attaches it to the main loop context
// using [method@GLib.Source.attach]. You can do these steps manually if you need
// greater control. Also see [func@GLib.timeout_add_seconds_full].
//
// It is safe to call this function from any thread.
//
// Note that the first call of the timer may not be precise for timeouts
// of one second. If you need finer precision and have such a timeout,
// you may want to use [func@GLib.timeout_add] instead.
//
// See [main loop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
//
// The interval given is in terms of monotonic time, not wall clock
// time. See [func@GLib.get_monotonic_time].
func TimeoutAddSeconds(IntervalVar uint, FunctionVar *SourceFunc, DataVar uintptr) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FunctionVar
				return cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	cret := xTimeoutAddSeconds(IntervalVar, FunctionVarRef, DataVar)

	return cret
}

var xTimeoutAddSecondsFull func(int, uint, uintptr, uintptr, uintptr) uint

// Sets a function to be called at regular intervals, with @priority.
//
// The function is called repeatedly until it returns [const@GLib.SOURCE_REMOVE],
// at which point the timeout is automatically destroyed and
// the function will not be called again.
//
// Unlike [func@GLib.timeout_add], this function operates at whole second
// granularity. The initial starting point of the timer is determined by the
// implementation and the implementation is expected to group multiple timers
// together so that they fire all at the same time. To allow this grouping,
// the @interval to the first timer is rounded and can deviate up to one second
// from the specified interval. Subsequent timer iterations will generally run
// at the specified interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing.
// After each call to the timeout function, the time of the next
// timeout is recalculated based on the current time and the given @interval
//
// See [main loop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
//
// If you want timing more precise than whole seconds, use
// [func@GLib.timeout_add] instead.
//
// The grouping of timers to fire at the same time results in a more power
// and CPU efficient behavior so if your timer is in multiples of seconds
// and you don’t require the first timer exactly one second from now, the
// use of [func@GLib.timeout_add_seconds] is preferred over
// [func@GLib.timeout_add].
//
// This internally creates a main loop source using
// [func@GLib.timeout_source_new_seconds] and attaches it to the main loop
// context using [method@GLib.Source.attach]. You can do these steps manually
// if you need greater control.
//
// It is safe to call this function from any thread.
//
// The interval given is in terms of monotonic time, not wall clock
// time. See [func@GLib.get_monotonic_time].
func TimeoutAddSecondsFull(PriorityVar int, IntervalVar uint, FunctionVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) bool {
				cbFn := *FunctionVar
				return cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	var NotifyVarRef uintptr
	if NotifyVar != nil {
		NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
		if cbRefPtr, ok := GetCallback(NotifyVarPtr); ok {
			NotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *NotifyVar
				cbFn(arg0)
			}
			NotifyVarRef = purego.NewCallback(fcb)
			SaveCallback(NotifyVarPtr, NotifyVarRef)
		}
	}

	cret := xTimeoutAddSecondsFull(PriorityVar, IntervalVar, FunctionVarRef, DataVar, NotifyVarRef)

	return cret
}

var xTimeoutAddSecondsOnce func(uint, uintptr, uintptr) uint

// This function behaves like [func@GLib.timeout_add_once] but with a range in
// seconds.
func TimeoutAddSecondsOnce(IntervalVar uint, FunctionVar *SourceOnceFunc, DataVar uintptr) uint {

	var FunctionVarRef uintptr
	if FunctionVar != nil {
		FunctionVarPtr := uintptr(unsafe.Pointer(FunctionVar))
		if cbRefPtr, ok := GetCallback(FunctionVarPtr); ok {
			FunctionVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *FunctionVar
				cbFn(arg0)
			}
			FunctionVarRef = purego.NewCallback(fcb)
			SaveCallback(FunctionVarPtr, FunctionVarRef)
		}
	}

	cret := xTimeoutAddSecondsOnce(IntervalVar, FunctionVarRef, DataVar)

	return cret
}

var xTimeoutSourceNew func(uint) *Source

// Creates a new timeout source.
//
// The source will not initially be associated with any [struct@GLib.MainContext]
// and must be added to one with [method@GLib.Source.attach] before it will be
// executed.
//
// The interval given is in terms of monotonic time, not wall clock
// time.  See [func@GLib.get_monotonic_time].
func TimeoutSourceNew(IntervalVar uint) *Source {

	cret := xTimeoutSourceNew(IntervalVar)

	return cret
}

var xTimeoutSourceNewSeconds func(uint) *Source

// Creates a new timeout source.
//
// The source will not initially be associated with any
// [struct@GLib.MainContext] and must be added to one with
// [method@GLib.Source.attach] before it will be executed.
//
// The scheduling granularity/accuracy of this timeout source will be
// in seconds.
//
// The interval given is in terms of monotonic time, not wall clock time.
// See [func@GLib.get_monotonic_time].
func TimeoutSourceNewSeconds(IntervalVar uint) *Source {

	cret := xTimeoutSourceNewSeconds(IntervalVar)

	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xChildWatchAdd, libs, "g_child_watch_add")
	core.PuregoSafeRegister(&xChildWatchAddFull, libs, "g_child_watch_add_full")
	core.PuregoSafeRegister(&xChildWatchSourceNew, libs, "g_child_watch_source_new")
	core.PuregoSafeRegister(&xClearHandleId, libs, "g_clear_handle_id")
	core.PuregoSafeRegister(&xGetCurrentTime, libs, "g_get_current_time")
	core.PuregoSafeRegister(&xGetMonotonicTime, libs, "g_get_monotonic_time")
	core.PuregoSafeRegister(&xGetRealTime, libs, "g_get_real_time")
	core.PuregoSafeRegister(&xIdleAdd, libs, "g_idle_add")
	core.PuregoSafeRegister(&xIdleAddFull, libs, "g_idle_add_full")
	core.PuregoSafeRegister(&xIdleAddOnce, libs, "g_idle_add_once")
	core.PuregoSafeRegister(&xIdleRemoveByData, libs, "g_idle_remove_by_data")
	core.PuregoSafeRegister(&xIdleSourceNew, libs, "g_idle_source_new")
	core.PuregoSafeRegister(&xMainContextDefault, libs, "g_main_context_default")
	core.PuregoSafeRegister(&xMainContextGetThreadDefault, libs, "g_main_context_get_thread_default")
	core.PuregoSafeRegister(&xMainContextRefThreadDefault, libs, "g_main_context_ref_thread_default")
	core.PuregoSafeRegister(&xMainCurrentSource, libs, "g_main_current_source")
	core.PuregoSafeRegister(&xMainDepth, libs, "g_main_depth")
	core.PuregoSafeRegister(&xSourceRemove, libs, "g_source_remove")
	core.PuregoSafeRegister(&xSourceRemoveByFuncsUserData, libs, "g_source_remove_by_funcs_user_data")
	core.PuregoSafeRegister(&xSourceRemoveByUserData, libs, "g_source_remove_by_user_data")
	core.PuregoSafeRegister(&xSourceSetNameById, libs, "g_source_set_name_by_id")
	core.PuregoSafeRegister(&xTimeoutAdd, libs, "g_timeout_add")
	core.PuregoSafeRegister(&xTimeoutAddFull, libs, "g_timeout_add_full")
	core.PuregoSafeRegister(&xTimeoutAddOnce, libs, "g_timeout_add_once")
	core.PuregoSafeRegister(&xTimeoutAddSeconds, libs, "g_timeout_add_seconds")
	core.PuregoSafeRegister(&xTimeoutAddSecondsFull, libs, "g_timeout_add_seconds_full")
	core.PuregoSafeRegister(&xTimeoutAddSecondsOnce, libs, "g_timeout_add_seconds_once")
	core.PuregoSafeRegister(&xTimeoutSourceNew, libs, "g_timeout_source_new")
	core.PuregoSafeRegister(&xTimeoutSourceNewSeconds, libs, "g_timeout_source_new_seconds")

	core.PuregoSafeRegister(&xMainContextGLibType, libs, "g_main_context_get_type")

	core.PuregoSafeRegister(&xNewMainContext, libs, "g_main_context_new")
	core.PuregoSafeRegister(&xNewMainContextWithFlags, libs, "g_main_context_new_with_flags")

	core.PuregoSafeRegister(&xMainContextAcquire, libs, "g_main_context_acquire")
	core.PuregoSafeRegister(&xMainContextAddPoll, libs, "g_main_context_add_poll")
	core.PuregoSafeRegister(&xMainContextCheck, libs, "g_main_context_check")
	core.PuregoSafeRegister(&xMainContextDispatch, libs, "g_main_context_dispatch")
	core.PuregoSafeRegister(&xMainContextFindSourceByFuncsUserData, libs, "g_main_context_find_source_by_funcs_user_data")
	core.PuregoSafeRegister(&xMainContextFindSourceById, libs, "g_main_context_find_source_by_id")
	core.PuregoSafeRegister(&xMainContextFindSourceByUserData, libs, "g_main_context_find_source_by_user_data")
	core.PuregoSafeRegister(&xMainContextGetPollFunc, libs, "g_main_context_get_poll_func")
	core.PuregoSafeRegister(&xMainContextInvoke, libs, "g_main_context_invoke")
	core.PuregoSafeRegister(&xMainContextInvokeFull, libs, "g_main_context_invoke_full")
	core.PuregoSafeRegister(&xMainContextIsOwner, libs, "g_main_context_is_owner")
	core.PuregoSafeRegister(&xMainContextIteration, libs, "g_main_context_iteration")
	core.PuregoSafeRegister(&xMainContextPending, libs, "g_main_context_pending")
	core.PuregoSafeRegister(&xMainContextPopThreadDefault, libs, "g_main_context_pop_thread_default")
	core.PuregoSafeRegister(&xMainContextPrepare, libs, "g_main_context_prepare")
	core.PuregoSafeRegister(&xMainContextPushThreadDefault, libs, "g_main_context_push_thread_default")
	core.PuregoSafeRegister(&xMainContextPusherNew, libs, "g_main_context_pusher_new")
	core.PuregoSafeRegister(&xMainContextQuery, libs, "g_main_context_query")
	core.PuregoSafeRegister(&xMainContextRef, libs, "g_main_context_ref")
	core.PuregoSafeRegister(&xMainContextRelease, libs, "g_main_context_release")
	core.PuregoSafeRegister(&xMainContextRemovePoll, libs, "g_main_context_remove_poll")
	core.PuregoSafeRegister(&xMainContextSetPollFunc, libs, "g_main_context_set_poll_func")
	core.PuregoSafeRegister(&xMainContextUnref, libs, "g_main_context_unref")
	core.PuregoSafeRegister(&xMainContextWait, libs, "g_main_context_wait")
	core.PuregoSafeRegister(&xMainContextWakeup, libs, "g_main_context_wakeup")

	core.PuregoSafeRegister(&xMainLoopGLibType, libs, "g_main_loop_get_type")

	core.PuregoSafeRegister(&xNewMainLoop, libs, "g_main_loop_new")

	core.PuregoSafeRegister(&xMainLoopGetContext, libs, "g_main_loop_get_context")
	core.PuregoSafeRegister(&xMainLoopIsRunning, libs, "g_main_loop_is_running")
	core.PuregoSafeRegister(&xMainLoopQuit, libs, "g_main_loop_quit")
	core.PuregoSafeRegister(&xMainLoopRef, libs, "g_main_loop_ref")
	core.PuregoSafeRegister(&xMainLoopRun, libs, "g_main_loop_run")
	core.PuregoSafeRegister(&xMainLoopUnref, libs, "g_main_loop_unref")

	core.PuregoSafeRegister(&xSourceGLibType, libs, "g_source_get_type")

	core.PuregoSafeRegister(&xNewSource, libs, "g_source_new")

	core.PuregoSafeRegister(&xSourceAddChildSource, libs, "g_source_add_child_source")
	core.PuregoSafeRegister(&xSourceAddPoll, libs, "g_source_add_poll")
	core.PuregoSafeRegister(&xSourceAddUnixFd, libs, "g_source_add_unix_fd")
	core.PuregoSafeRegister(&xSourceAttach, libs, "g_source_attach")
	core.PuregoSafeRegister(&xSourceDestroy, libs, "g_source_destroy")
	core.PuregoSafeRegister(&xSourceDupContext, libs, "g_source_dup_context")
	core.PuregoSafeRegister(&xSourceGetCanRecurse, libs, "g_source_get_can_recurse")
	core.PuregoSafeRegister(&xSourceGetContext, libs, "g_source_get_context")
	core.PuregoSafeRegister(&xSourceGetCurrentTime, libs, "g_source_get_current_time")
	core.PuregoSafeRegister(&xSourceGetId, libs, "g_source_get_id")
	core.PuregoSafeRegister(&xSourceGetName, libs, "g_source_get_name")
	core.PuregoSafeRegister(&xSourceGetPriority, libs, "g_source_get_priority")
	core.PuregoSafeRegister(&xSourceGetReadyTime, libs, "g_source_get_ready_time")
	core.PuregoSafeRegister(&xSourceGetTime, libs, "g_source_get_time")
	core.PuregoSafeRegister(&xSourceIsDestroyed, libs, "g_source_is_destroyed")
	core.PuregoSafeRegister(&xSourceModifyUnixFd, libs, "g_source_modify_unix_fd")
	core.PuregoSafeRegister(&xSourceQueryUnixFd, libs, "g_source_query_unix_fd")
	core.PuregoSafeRegister(&xSourceRef, libs, "g_source_ref")
	core.PuregoSafeRegister(&xSourceRemoveChildSource, libs, "g_source_remove_child_source")
	core.PuregoSafeRegister(&xSourceRemovePoll, libs, "g_source_remove_poll")
	core.PuregoSafeRegister(&xSourceRemoveUnixFd, libs, "g_source_remove_unix_fd")
	core.PuregoSafeRegister(&xSourceSetCallback, libs, "g_source_set_callback")
	core.PuregoSafeRegister(&xSourceSetCallbackIndirect, libs, "g_source_set_callback_indirect")
	core.PuregoSafeRegister(&xSourceSetCanRecurse, libs, "g_source_set_can_recurse")
	core.PuregoSafeRegister(&xSourceSetDisposeFunction, libs, "g_source_set_dispose_function")
	core.PuregoSafeRegister(&xSourceSetFuncs, libs, "g_source_set_funcs")
	core.PuregoSafeRegister(&xSourceSetName, libs, "g_source_set_name")
	core.PuregoSafeRegister(&xSourceSetPriority, libs, "g_source_set_priority")
	core.PuregoSafeRegister(&xSourceSetReadyTime, libs, "g_source_set_ready_time")
	core.PuregoSafeRegister(&xSourceSetStaticName, libs, "g_source_set_static_name")
	core.PuregoSafeRegister(&xSourceUnref, libs, "g_source_unref")

}
