// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// The type used for test case functions that take an extra pointer
// argument.
type TestDataFunc func(uintptr)

// The type used for functions that operate on test fixtures.
//
// This is used for the fixture setup and teardown functions
// as well as for the testcases themselves.
//
// @user_data is a pointer to the data that was given when
// registering the test case.
//
// @fixture will be a pointer to the area of memory allocated by the
// test framework, of the size requested.  If the requested size was
// zero then @fixture will be equal to @user_data.
type TestFixtureFunc func(uintptr, uintptr)

// The type used for test case functions.
type TestFunc func()

// Specifies the prototype of fatal log handler functions.
type TestLogFatalFunc func(string, LogLevelFlags, string, uintptr) bool

// An opaque structure representing a test case.
type TestCase struct {
	_ structs.HostLayout
}

func (x *TestCase) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTestCaseFree func(uintptr)

// Free the @test_case.
func (x *TestCase) Free() {

	xTestCaseFree(x.GoPointer())

}

type TestConfig struct {
	_ structs.HostLayout

	TestInitialized bool

	TestQuick bool

	TestPerf bool

	TestVerbose bool

	TestQuiet bool

	TestUndefined bool
}

func (x *TestConfig) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TestLogBuffer struct {
	_ structs.HostLayout

	Data *String

	Msgs *SList
}

func (x *TestLogBuffer) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTestLogBufferFree func(uintptr)

// Internal function for gtester to free test log messages, no ABI guarantees provided.
func (x *TestLogBuffer) Free() {

	xTestLogBufferFree(x.GoPointer())

}

var xTestLogBufferPop func(uintptr) *TestLogMsg

// Internal function for gtester to retrieve test log messages, no ABI guarantees provided.
func (x *TestLogBuffer) Pop() *TestLogMsg {

	cret := xTestLogBufferPop(x.GoPointer())
	return cret
}

var xTestLogBufferPush func(uintptr, uint, byte)

// Internal function for gtester to decode test log messages, no ABI guarantees provided.
func (x *TestLogBuffer) Push(NBytesVar uint, BytesVar byte) {

	xTestLogBufferPush(x.GoPointer(), NBytesVar, BytesVar)

}

type TestLogMsg struct {
	_ structs.HostLayout

	LogType TestLogType

	NStrings uint

	Strings uintptr

	NNums uint

	Nums float64
}

func (x *TestLogMsg) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTestLogMsgFree func(uintptr)

// Internal function for gtester to free test log messages, no ABI guarantees provided.
func (x *TestLogMsg) Free() {

	xTestLogMsgFree(x.GoPointer())

}

// An opaque structure representing a test suite.
type TestSuite struct {
	_ structs.HostLayout
}

func (x *TestSuite) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTestSuiteAdd func(uintptr, *TestCase)

// Adds @test_case to @suite.
func (x *TestSuite) Add(TestCaseVar *TestCase) {

	xTestSuiteAdd(x.GoPointer(), TestCaseVar)

}

var xTestSuiteAddSuite func(uintptr, *TestSuite)

// Adds @nestedsuite to @suite.
func (x *TestSuite) AddSuite(NestedsuiteVar *TestSuite) {

	xTestSuiteAddSuite(x.GoPointer(), NestedsuiteVar)

}

var xTestSuiteFree func(uintptr)

// Frees the @suite and all nested suites.
func (x *TestSuite) Free() {

	xTestSuiteFree(x.GoPointer())

}

const (
	// A value that can be passed as an option to [func@GLib.test_init].
	//
	// Creates a unique temporary directory for each unit test and uses sets
	// XDG directories to point into subdirectories of it for the duration of
	// the unit test. The directory tree is cleaned up after the test finishes
	// successfully.
	//
	// Note that this doesn’t take effect until [func@GLib.test_run] is called,
	// so calls to (for example) [func@GLib.get_home_dir] will return the
	// system-wide value when made in a test program’s main() function.
	//
	// The following functions will return subdirectories of the temporary directory
	// when this option is used. The specific subdirectory paths in use are not
	// guaranteed to be stable API — always use a getter function to retrieve them.
	//
	//  - [func@GLib.get_home_dir]
	//  - [func@GLib.get_user_cache_dir]
	//  - [func@GLib.get_system_config_dirs]
	//  - [func@GLib.get_user_config_dir]
	//  - [func@GLib.get_system_data_dirs]
	//  - [func@GLib.get_user_data_dir]
	//  - [func@GLib.get_user_state_dir]
	//  - [func@GLib.get_user_runtime_dir]
	//
	// The subdirectories may not be created by the test harness; as with normal
	// calls to functions like [func@GLib.get_user_cache_dir], the caller must
	// be prepared to create the directory if it doesn’t exist.
	TEST_OPTION_ISOLATE_DIRS string = "isolate_dirs"
	// A value that can be passed as an option to [func@GLib.test_init].
	//
	// If this option is given, assertions will not abort the process, but
	// call [func@GLib.test_fail]. Equivalent to [func@GLib.test_set_nonfatal_assertions].
	TEST_OPTION_NONFATAL_ASSERTIONS string = "nonfatal-assertions"
	// A value that can be passed as an option to [func@GLib.test_init].
	//
	// If this option is given, [func@GLib.test_init] will not call [func@GLib.set_prgname].
	TEST_OPTION_NO_PRGNAME string = "no_g_set_prgname"
)

// Flags to pass to [func@GLib.test_trap_subprocess] to control input and output.
//
// Note that in contrast with [func@GLib.test_trap_fork], the default
// behavior of [func@GLib.test_trap_subprocess] is to not show stdout
// and stderr.
type TestSubprocessFlags int

const (

	// Default behaviour. Since: 2.74
	GTestSubprocessDefaultValue TestSubprocessFlags = 0
	// If this flag is given, the child
	//   process will inherit the parent's stdin. Otherwise, the child's
	//   stdin is redirected to `/dev/null`.
	GTestSubprocessInheritStdinValue TestSubprocessFlags = 1
	// If this flag is given, the child
	//   process will inherit the parent's stdout. Otherwise, the child's
	//   stdout will not be visible, but it will be captured to allow
	//   later tests with [func@GLib.test_trap_assert_stdout].
	GTestSubprocessInheritStdoutValue TestSubprocessFlags = 2
	// If this flag is given, the child
	//   process will inherit the parent's stderr. Otherwise, the child's
	//   stderr will not be visible, but it will be captured to allow
	//   later tests with [func@GLib.test_trap_assert_stderr].
	GTestSubprocessInheritStderrValue TestSubprocessFlags = 4
)

// Flags to pass to [func@GLib.test_trap_fork] to control input and output.
//
// Test traps are guards around forked tests. These flags determine what traps to set.
type TestTrapFlags int

const (

	// Default behaviour. Since: 2.74
	GTestTrapDefaultValue TestTrapFlags = 0
	// Redirect stdout of the test child to
	//     `/dev/null` so it cannot be observed on the console during test
	//     runs. The actual output is still captured though to allow later
	//     tests with g_test_trap_assert_stdout().
	GTestTrapSilenceStdoutValue TestTrapFlags = 128
	// Redirect stderr of the test child to
	//     `/dev/null` so it cannot be observed on the console during test
	//     runs. The actual output is still captured though to allow later
	//     tests with g_test_trap_assert_stderr().
	GTestTrapSilenceStderrValue TestTrapFlags = 256
	// If this flag is given, stdin of the
	//     child process is shared with stdin of its parent process.
	//     It is redirected to `/dev/null` otherwise.
	GTestTrapInheritStdinValue TestTrapFlags = 512
)

// The type of file to return the filename for, when used with
// [func@GLib.test_build_filename].
//
// These two options correspond rather directly to the 'dist' and
// 'built' terminology that automake uses and are explicitly used to
// distinguish between the 'srcdir' and 'builddir' being separate. All
// files in your project should either be dist (in the `EXTRA_DIST` or
// `dist_schema_DATA` sense, in which case they will always be in the
// srcdir) or built (in the `BUILT_SOURCES` sense, in which case they
// will always be in the builddir).
//
// Note: As a general rule of automake, files that are generated only as
// part of the build-from-git process (but then are distributed with the
// tarball) always go in srcdir (even if doing a srcdir != builddir
// build from git) and are considered as distributed files.
//
// The same principles apply for other build systems, such as meson.
type TestFileType int

const (

	// a file that was included in the distribution tarball
	GTestDistValue TestFileType = 0
	// a file that was built on the compiling machine
	GTestBuiltValue TestFileType = 1
)

type TestLogType int

const (
	GTestLogNoneValue TestLogType = 0

	GTestLogErrorValue TestLogType = 1

	GTestLogStartBinaryValue TestLogType = 2

	GTestLogListCaseValue TestLogType = 3

	GTestLogSkipCaseValue TestLogType = 4

	GTestLogStartCaseValue TestLogType = 5

	GTestLogStopCaseValue TestLogType = 6

	GTestLogMinResultValue TestLogType = 7

	GTestLogMaxResultValue TestLogType = 8

	GTestLogMessageValue TestLogType = 9

	GTestLogStartSuiteValue TestLogType = 10

	GTestLogStopSuiteValue TestLogType = 11
)

type TestResult int

const (
	GTestRunSuccessValue TestResult = 0

	GTestRunSkippedValue TestResult = 1

	GTestRunFailureValue TestResult = 2

	GTestRunIncompleteValue TestResult = 3
)

var xAssertionMessage func(string, string, int, string, string)

func AssertionMessage(DomainVar string, FileVar string, LineVar int, FuncVar string, MessageVar string) {

	xAssertionMessage(DomainVar, FileVar, LineVar, FuncVar, MessageVar)

}

var xAssertionMessageCmpint func(string, string, int, string, string, uint64, string, uint64, byte)

func AssertionMessageCmpint(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, Arg1Var uint64, CmpVar string, Arg2Var uint64, NumtypeVar byte) {

	xAssertionMessageCmpint(DomainVar, FileVar, LineVar, FuncVar, ExprVar, Arg1Var, CmpVar, Arg2Var, NumtypeVar)

}

var xAssertionMessageCmpnum func(string, string, int, string, string, float64, string, float64, byte)

func AssertionMessageCmpnum(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, Arg1Var float64, CmpVar string, Arg2Var float64, NumtypeVar byte) {

	xAssertionMessageCmpnum(DomainVar, FileVar, LineVar, FuncVar, ExprVar, Arg1Var, CmpVar, Arg2Var, NumtypeVar)

}

var xAssertionMessageCmpstr func(string, string, int, string, string, string, string, string)

func AssertionMessageCmpstr(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, Arg1Var string, CmpVar string, Arg2Var string) {

	xAssertionMessageCmpstr(DomainVar, FileVar, LineVar, FuncVar, ExprVar, Arg1Var, CmpVar, Arg2Var)

}

var xAssertionMessageCmpstrv func(string, string, int, string, string, string, string, uint)

func AssertionMessageCmpstrv(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, Arg1Var string, Arg2Var string, FirstWrongIdxVar uint) {

	xAssertionMessageCmpstrv(DomainVar, FileVar, LineVar, FuncVar, ExprVar, Arg1Var, Arg2Var, FirstWrongIdxVar)

}

var xAssertionMessageError func(string, string, int, string, string, *Error, Quark, int)

func AssertionMessageError(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, ErrorVar *Error, ErrorDomainVar Quark, ErrorCodeVar int) {

	xAssertionMessageError(DomainVar, FileVar, LineVar, FuncVar, ExprVar, ErrorVar, ErrorDomainVar, ErrorCodeVar)

}

var xAssertionMessageExpr func(string, string, int, string, string)

// Internal function used to print messages from the public
// g_assert() and g_assert_not_reached() macros.
func AssertionMessageExpr(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string) {

	xAssertionMessageExpr(DomainVar, FileVar, LineVar, FuncVar, ExprVar)

}

var xStrcmp0 func(string, string) int

// Compares @str1 and @str2 like `strcmp()`.
//
// Handles `NULL` gracefully by sorting it before non-`NULL` strings.
// Comparing two `NULL` pointers returns 0.
func Strcmp0(Str1Var string, Str2Var string) int {

	cret := xStrcmp0(Str1Var, Str2Var)
	return cret
}

var xTestAddDataFunc func(string, uintptr, uintptr)

// Creates a new test case.
//
// This function is similar to [func@GLib.test_create_case].
// However the test is assumed to use no fixture, and test suites are
// automatically created on the fly and added to the root fixture,
// based on the /-separated portions of @testpath. The @test_data
// argument will be passed as first argument to @test_func.
//
// If @testpath includes the component "subprocess" anywhere in it,
// the test will be skipped by default, and only run if explicitly
// required via the `-p` command-line option or [func@GLib.test_trap_subprocess].
//
// No component of @testpath may start with a dot (`.`) if the
// [const@GLib.TEST_OPTION_ISOLATE_DIRS] option is being used;
// and it is recommended to do so even if it isn’t.
func TestAddDataFunc(TestpathVar string, TestDataVar uintptr, TestFuncVar *TestDataFunc) {

	TestFuncVarPtr := uintptr(unsafe.Pointer(TestFuncVar))
	var TestFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(TestFuncVarPtr); ok {
		TestFuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr) {
			cbFn := *TestFuncVar
			cbFn(arg0)
		}
		TestFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(TestFuncVarPtr, TestFuncVarRef)
	}

	xTestAddDataFunc(TestpathVar, TestDataVar, TestFuncVarRef)

}

var xTestAddDataFuncFull func(string, uintptr, uintptr, uintptr)

// Creates a new test case.
//
// In contrast to [func@GLib.test_add_data_func], this function
// is freeing @test_data after the test run is complete.
func TestAddDataFuncFull(TestpathVar string, TestDataVar uintptr, TestFuncVar *TestDataFunc, DataFreeFuncVar *DestroyNotify) {

	TestFuncVarPtr := uintptr(unsafe.Pointer(TestFuncVar))
	var TestFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(TestFuncVarPtr); ok {
		TestFuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr) {
			cbFn := *TestFuncVar
			cbFn(arg0)
		}
		TestFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(TestFuncVarPtr, TestFuncVarRef)
	}

	DataFreeFuncVarPtr := uintptr(unsafe.Pointer(DataFreeFuncVar))
	var DataFreeFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(DataFreeFuncVarPtr); ok {
		DataFreeFuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr) {
			cbFn := *DataFreeFuncVar
			cbFn(arg0)
		}
		DataFreeFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(DataFreeFuncVarPtr, DataFreeFuncVarRef)
	}

	xTestAddDataFuncFull(TestpathVar, TestDataVar, TestFuncVarRef, DataFreeFuncVarRef)

}

var xTestAddFunc func(string, uintptr)

// Creates a new test case.
//
// This function is similar to [func@GLib.test_create_case].
// However the test is assumed to use no fixture, and test suites are
// automatically created on the fly and added to the root fixture,
// based on the /-separated portions of @testpath.
//
// If @testpath includes the component "subprocess" anywhere in it,
// the test will be skipped by default, and only run if explicitly
// required via the `-p` command-line option or [func@GLib.test_trap_subprocess].
//
// No component of @testpath may start with a dot (`.`) if the
// [const@GLib.TEST_OPTION_ISOLATE_DIRS] option is being used; and
// it is recommended to do so even if it isn’t.
func TestAddFunc(TestpathVar string, TestFuncVar *TestFunc) {

	TestFuncVarPtr := uintptr(unsafe.Pointer(TestFuncVar))
	var TestFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(TestFuncVarPtr); ok {
		TestFuncVarRef = cbRefPtr
	} else {
		fcb := func() {
			cbFn := *TestFuncVar
			cbFn()
		}
		TestFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(TestFuncVarPtr, TestFuncVarRef)
	}

	xTestAddFunc(TestpathVar, TestFuncVarRef)

}

var xTestAddVtable func(string, uint, uintptr, uintptr, uintptr, uintptr)

func TestAddVtable(TestpathVar string, DataSizeVar uint, TestDataVar uintptr, DataSetupVar *TestFixtureFunc, DataTestVar *TestFixtureFunc, DataTeardownVar *TestFixtureFunc) {

	DataSetupVarPtr := uintptr(unsafe.Pointer(DataSetupVar))
	var DataSetupVarRef uintptr
	if cbRefPtr, ok := GetCallback(DataSetupVarPtr); ok {
		DataSetupVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr) {
			cbFn := *DataSetupVar
			cbFn(arg0, arg1)
		}
		DataSetupVarRef = purego.NewCallback(fcb)
		SaveCallback(DataSetupVarPtr, DataSetupVarRef)
	}

	DataTestVarPtr := uintptr(unsafe.Pointer(DataTestVar))
	var DataTestVarRef uintptr
	if cbRefPtr, ok := GetCallback(DataTestVarPtr); ok {
		DataTestVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr) {
			cbFn := *DataTestVar
			cbFn(arg0, arg1)
		}
		DataTestVarRef = purego.NewCallback(fcb)
		SaveCallback(DataTestVarPtr, DataTestVarRef)
	}

	DataTeardownVarPtr := uintptr(unsafe.Pointer(DataTeardownVar))
	var DataTeardownVarRef uintptr
	if cbRefPtr, ok := GetCallback(DataTeardownVarPtr); ok {
		DataTeardownVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr) {
			cbFn := *DataTeardownVar
			cbFn(arg0, arg1)
		}
		DataTeardownVarRef = purego.NewCallback(fcb)
		SaveCallback(DataTeardownVarPtr, DataTeardownVarRef)
	}

	xTestAddVtable(TestpathVar, DataSizeVar, TestDataVar, DataSetupVarRef, DataTestVarRef, DataTeardownVarRef)

}

var xTestAssertExpectedMessagesInternal func(string, string, int, string)

func TestAssertExpectedMessagesInternal(DomainVar string, FileVar string, LineVar int, FuncVar string) {

	xTestAssertExpectedMessagesInternal(DomainVar, FileVar, LineVar, FuncVar)

}

var xTestBug func(string)

// Adds a message to test reports that associates a bug URI with a test case.
//
// Bug URIs are constructed from a base URI set with [func@GLib.test_bug_base]
// and @bug_uri_snippet. If [func@GLib.test_bug_base] has not been called, it is
// assumed to be the empty string, so a full URI can be provided to
// [func@GLib.test_bug] instead.
//
// See also [func@GLib.test_summary].
//
// Since GLib 2.70, the base URI is not prepended to @bug_uri_snippet
// if it is already a valid URI.
func TestBug(BugUriSnippetVar string) {

	xTestBug(BugUriSnippetVar)

}

var xTestBugBase func(string)

// Specifies the base URI for bug reports.
//
// The base URI is used to construct bug report messages for
// [func@GLib.test_message] when [func@GLib.test_bug] is called.
// Calling this function outside of a test case sets the
// default base URI for all test cases. Calling it from within
// a test case changes the base URI for the scope of the test
// case only.
// Bug URIs are constructed by appending a bug specific URI
// portion to @uri_pattern, or by replacing the special string
// `%s` within @uri_pattern if that is present.
//
// If [func@GLib.test_bug_base] is not called, bug URIs are formed
// solely from the value provided by [func@GLib.test_bug].
func TestBugBase(UriPatternVar string) {

	xTestBugBase(UriPatternVar)

}

var xTestBuildFilename func(TestFileType, string, ...interface{}) string

// Creates the pathname to a data file that is required for a test.
//
// This function is conceptually similar to [func@GLib.build_filename]
// except that the first argument has been replaced with a
// [enum@GLib.TestFileType] argument.
//
// The data file should either have been distributed with the module
// containing the test ([enum@GLib.TestFileType.dist] or built as part of the
// buildcsystem of that module ([enum@GLib.TestFileType.built]).
//
// In order for this function to work in srcdir != builddir situations,
// the `G_TEST_SRCDIR` and `G_TEST_BUILDDIR` environment variables need
// to have been defined. As of 2.38, this is done by the glib.mk that is
// included in GLib. Please ensure that your copy is up to date before
// using this function.
//
// In case neither variable is set, this function will fall back to
// using the dirname portion of `argv[0]`, possibly removing ".libs".
// This allows for casual running of tests directly from the commandline
// in the srcdir == builddir case and should also support running of
// installed tests, assuming the data files have been installed in the
// same relative path as the test binary.
func TestBuildFilename(FileTypeVar TestFileType, FirstPathVar string, varArgs ...interface{}) string {

	cret := xTestBuildFilename(FileTypeVar, FirstPathVar, varArgs...)
	return cret
}

var xTestCreateCase func(string, uint, uintptr, uintptr, uintptr, uintptr) *TestCase

// Creates a new [struct@GLib.TestCase].
//
// This API is fairly low level, and calling [func@GLib.test_add] or
// [func@GLib.test_add_func] is preferable.
//
// When this test is executed, a fixture structure of size @data_size
// will be automatically allocated and filled with zeros. Then @data_setup
// is called to initialize the fixture. After fixture setup, the actual test
// function @data_test is called. Once the test run completes, the
// fixture structure is torn down by calling @data_teardown and after
// that the memory is automatically released by the test framework.
//
// Splitting up a test run into fixture setup, test function and
// fixture teardown is most useful if the same fixture type is used for
// multiple tests. In this cases, [func@GLib.test_create_case] will be
// called with the same type of fixture (the @data_size argument), but
// varying @test_name and @data_test arguments.
func TestCreateCase(TestNameVar string, DataSizeVar uint, TestDataVar uintptr, DataSetupVar *TestFixtureFunc, DataTestVar *TestFixtureFunc, DataTeardownVar *TestFixtureFunc) *TestCase {

	DataSetupVarPtr := uintptr(unsafe.Pointer(DataSetupVar))
	var DataSetupVarRef uintptr
	if cbRefPtr, ok := GetCallback(DataSetupVarPtr); ok {
		DataSetupVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr) {
			cbFn := *DataSetupVar
			cbFn(arg0, arg1)
		}
		DataSetupVarRef = purego.NewCallback(fcb)
		SaveCallback(DataSetupVarPtr, DataSetupVarRef)
	}

	DataTestVarPtr := uintptr(unsafe.Pointer(DataTestVar))
	var DataTestVarRef uintptr
	if cbRefPtr, ok := GetCallback(DataTestVarPtr); ok {
		DataTestVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr) {
			cbFn := *DataTestVar
			cbFn(arg0, arg1)
		}
		DataTestVarRef = purego.NewCallback(fcb)
		SaveCallback(DataTestVarPtr, DataTestVarRef)
	}

	DataTeardownVarPtr := uintptr(unsafe.Pointer(DataTeardownVar))
	var DataTeardownVarRef uintptr
	if cbRefPtr, ok := GetCallback(DataTeardownVarPtr); ok {
		DataTeardownVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr, arg1 uintptr) {
			cbFn := *DataTeardownVar
			cbFn(arg0, arg1)
		}
		DataTeardownVarRef = purego.NewCallback(fcb)
		SaveCallback(DataTeardownVarPtr, DataTeardownVarRef)
	}

	cret := xTestCreateCase(TestNameVar, DataSizeVar, TestDataVar, DataSetupVarRef, DataTestVarRef, DataTeardownVarRef)
	return cret
}

var xTestCreateSuite func(string) *TestSuite

// Creates a new test suite with the name @suite_name.
func TestCreateSuite(SuiteNameVar string) *TestSuite {

	cret := xTestCreateSuite(SuiteNameVar)
	return cret
}

var xTestDisableCrashReporting func()

// Attempts to disable system crash reporting infrastructure.
//
// This function should be called before exercising code paths that are
// expected or intended to crash, to avoid wasting resources in system-wide
// crash collection infrastructure such as systemd-coredump or abrt.
func TestDisableCrashReporting() {

	xTestDisableCrashReporting()

}

var xTestExpectMessage func(string, LogLevelFlags, string)

// Indicates that a message with the given @log_domain and @log_level,
// with text matching @pattern, is expected to be logged.
//
// When this message is logged, it will not be printed, and the test case will
// not abort.
//
// This API may only be used with the old logging API ([func@GLib.log] without
// `G_LOG_USE_STRUCTURED` defined). It will not work with the structured logging
// API. See [Testing for Messages](logging.html#testing-for-messages).
//
// Use [func@GLib.test_assert_expected_messages] to assert that all
// previously-expected messages have been seen and suppressed.
//
// You can call this multiple times in a row, if multiple messages are
// expected as a result of a single call. (The messages must appear in
// the same order as the calls to [func@GLib.test_expect_message].)
//
// For example:
//
// ```c
// // g_main_context_push_thread_default() should fail if the
// // context is already owned by another thread.
// g_test_expect_message (G_LOG_DOMAIN,
//
//	G_LOG_LEVEL_CRITICAL,
//	"assertion*acquired_context*failed");
//
// g_main_context_push_thread_default (bad_context);
// g_test_assert_expected_messages ();
// ```
//
// Note that you cannot use this to test [func@GLib.error] messages, since
// [func@GLib.error] intentionally never returns even if the program doesn’t
// abort; use [func@GLib.test_trap_subprocess] in this case.
//
// If messages at [flags@GLib.LogLevelFlags.LEVEL_DEBUG] are emitted, but not explicitly
// expected via [func@GLib.test_expect_message] then they will be ignored.
func TestExpectMessage(LogDomainVar string, LogLevelVar LogLevelFlags, PatternVar string) {

	xTestExpectMessage(LogDomainVar, LogLevelVar, PatternVar)

}

var xTestFail func()

// Indicates that a test failed.
//
// This function can be called multiple times from the same test.
// You can use this function if your test failed in a recoverable way.
//
// Do not use this function if the failure of a test could cause
// other tests to malfunction.
//
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
//
// If not called from inside a test, this function does nothing.
//
// Note that unlike [func@GLib.test_skip] and [func@GLib.test_incomplete],
// this function does not log a message alongside the test failure.
// If details of the test failure are available, either log them with
// [func@GLib.test_message] before [func@GLib.test_fail], or use
// [func@GLib.test_fail_printf] instead.
func TestFail() {

	xTestFail()

}

var xTestFailPrintf func(string, ...interface{})

// Indicates that a test failed and records a message.
//
// Also see [func@GLib.test_fail].
//
// The message is formatted as if by [func@GLib.strdup_printf].
func TestFailPrintf(FormatVar string, varArgs ...interface{}) {

	xTestFailPrintf(FormatVar, varArgs...)

}

var xTestFailed func() bool

// Returns whether a test has already failed.
//
// This will be the case when [func@GLib.test_fail],
// [func@GLib.test_incomplete] or [func@GLib.test_skip] have
// been called, but also if an assertion has failed.
//
// This can be useful to return early from a test if
// continuing after a failed assertion might be harmful.
//
// The return value of this function is only meaningful
// if it is called from inside a test function.
func TestFailed() bool {

	cret := xTestFailed()
	return cret
}

var xTestGetDir func(TestFileType) string

// Gets the pathname of the directory containing test files of the type
// specified by @file_type.
//
// This is approximately the same as calling `g_test_build_filename(".")`,
// but you don't need to free the return value.
func TestGetDir(FileTypeVar TestFileType) string {

	cret := xTestGetDir(FileTypeVar)
	return cret
}

var xTestGetFilename func(TestFileType, string, ...interface{}) string

// Gets the pathname to a data file that is required for a test.
//
// This is the same as [func@GLib.test_build_filename] with two differences.
// The first difference is that you must only use this function from within
// a testcase function. The second difference is that you need not free
// the return value — it will be automatically freed when the testcase
// finishes running.
//
// It is safe to use this function from a thread inside of a testcase
// but you must ensure that all such uses occur before the main testcase
// function returns (ie: it is best to ensure that all threads have been
// joined).
func TestGetFilename(FileTypeVar TestFileType, FirstPathVar string, varArgs ...interface{}) string {

	cret := xTestGetFilename(FileTypeVar, FirstPathVar, varArgs...)
	return cret
}

var xTestGetPath func() string

// Gets the test path for the test currently being run.
//
// In essence, it will be the same string passed as the first argument
// to e.g. [func@GLib.test_add] when the test was added.
//
// This function returns a valid string only within a test function.
//
// Note that this is a test path, not a file system path.
func TestGetPath() string {

	cret := xTestGetPath()
	return cret
}

var xTestGetRoot func() *TestSuite

// Gets the toplevel test suite for the test path API.
func TestGetRoot() *TestSuite {

	cret := xTestGetRoot()
	return cret
}

var xTestIncomplete func(string)

// Indicates that a test failed because of some incomplete
// functionality.
//
// This function can be called multiple times from the same test.
//
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
//
// If not called from inside a test, this function does nothing.
func TestIncomplete(MsgVar string) {

	xTestIncomplete(MsgVar)

}

var xTestIncompletePrintf func(string, ...interface{})

// Indicates that a test failed because of some incomplete
// functionality.
//
// Equivalent to [func@GLib.test_incomplete], but the explanation
// is formatted as if by [func@GLib.strdup_printf].
func TestIncompletePrintf(FormatVar string, varArgs ...interface{}) {

	xTestIncompletePrintf(FormatVar, varArgs...)

}

var xTestInit func(int, string, ...interface{})

// Initializes the GLib testing framework.
//
// This includes seeding the test random number generator,
// setting the program name, and parsing test-related commandline args.
//
// This should be called before calling any other `g_test_*()` functions.
//
// The following arguments are understood:
//
//   - `-l`: List test cases available in a test executable.
//
//   - `--seed=SEED`: Provide a random seed to reproduce test
//     runs using random numbers.
//
//   - `--verbose`: Run tests verbosely.
//
//   - `-q`, `--quiet`: Run tests quietly.
//
//   - `-p PATH`: Execute all tests matching the given path.
//
//   - `-s PATH`: Skip all tests matching the given path.
//     This can also be used to force a test to run that would otherwise
//     be skipped (ie, a test whose name contains "/subprocess").
//
//   - `-m {perf|slow|thorough|quick|undefined|no-undefined}`: Execute tests according
//     to these test modes:
//
//     `perf`: Performance tests, may take long and report results (off by default).
//
//     `slow`, `thorough`: Slow and thorough tests, may take quite long and maximize
//     coverage (off by default).
//
//     `quick`: Quick tests, should run really quickly and give good coverage (the default).
//
//     `undefined`: Tests for undefined behaviour, may provoke programming errors
//     under [func@GLib.test_trap_subprocess] or [func@GLib.test_expect_message]
//     to check that appropriate assertions or warnings are given (the default).
//
//     `no-undefined`: Avoid tests for undefined behaviour.
//
// - `--debug-log`: Debug test logging output.
//
// Any parsed arguments are removed from @argv, and @argc is adjust accordingly.
//
// The following options are supported:
//
//   - `G_TEST_OPTION_NO_PRGNAME`: Causes g_test_init() to not call
//     [func@GLib.set_prgname]. Since. 2.84
//   - `G_TEST_OPTION_ISOLATE_DIRS`: Creates a unique temporary directory for each
//     unit test and sets XDG directories to point there for the duration of the unit
//     test. See [const@GLib.TEST_OPTION_ISOLATE_DIRS].
//   - `G_TEST_OPTION_NONFATAL_ASSERTIONS`: This has the same effect as
//     [func@GLib.test_set_nonfatal_assertions]. Since 2.84
//
// Since 2.58, if tests are compiled with `G_DISABLE_ASSERT` defined, `g_test_init()`
// will print an error and exit. This is to prevent no-op tests from being executed,
// as [func@GLib.assert] is commonly (erroneously) used in unit tests, and is a no-op
// when compiled with `G_DISABLE_ASSERT`. Ensure your tests are compiled without
// `G_DISABLE_ASSERT` defined.
func TestInit(ArgcVar int, ArgvVar string, varArgs ...interface{}) {

	xTestInit(ArgcVar, ArgvVar, varArgs...)

}

var xTestLogSetFatalHandler func(uintptr, uintptr)

// Installs a non-error fatal log handler which can be
// used to decide whether log messages which are counted
// as fatal abort the program.
//
// The use case here is that you are running a test case
// that depends on particular libraries or circumstances
// and cannot prevent certain known critical or warning
// messages. So you install a handler that compares the
// domain and message to precisely not abort in such a case.
//
// Note that the handler is reset at the beginning of
// any test case, so you have to set it inside each test
// function which needs the special behavior.
//
// This handler has no effect on g_error messages.
//
// This handler also has no effect on structured log messages (using
// [func@GLib.log_structured] or [func@GLib.log_structured_array]). To change the fatal
// behaviour for specific log messages, programs must install a custom log
// writer function using [func@GLib.log_set_writer_func].See
// [Using Structured Logging](logging.html#using-structured-logging).
func TestLogSetFatalHandler(LogFuncVar *TestLogFatalFunc, UserDataVar uintptr) {

	LogFuncVarPtr := uintptr(unsafe.Pointer(LogFuncVar))
	var LogFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(LogFuncVarPtr); ok {
		LogFuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 string, arg1 LogLevelFlags, arg2 string, arg3 uintptr) bool {
			cbFn := *LogFuncVar
			return cbFn(arg0, arg1, arg2, arg3)
		}
		LogFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(LogFuncVarPtr, LogFuncVarRef)
	}

	xTestLogSetFatalHandler(LogFuncVarRef, UserDataVar)

}

var xTestLogTypeName func(TestLogType) string

func TestLogTypeName(LogTypeVar TestLogType) string {

	cret := xTestLogTypeName(LogTypeVar)
	return cret
}

var xTestMaximizedResult func(float64, string, ...interface{})

// Reports the result of a performance or measurement test.
//
// The test should generally strive to maximize the reported
// quantities (larger values are better than smaller ones),
// this and @maximized_quantity can determine sorting
// order for test result reports.
func TestMaximizedResult(MaximizedQuantityVar float64, FormatVar string, varArgs ...interface{}) {

	xTestMaximizedResult(MaximizedQuantityVar, FormatVar, varArgs...)

}

var xTestMessage func(string, ...interface{})

// Adds a message to the test report.
func TestMessage(FormatVar string, varArgs ...interface{}) {

	xTestMessage(FormatVar, varArgs...)

}

var xTestMinimizedResult func(float64, string, ...interface{})

// Reports the result of a performance or measurement test.
//
// The test should generally strive to minimize the reported
// quantities (smaller values are better than larger ones),
// this and @minimized_quantity can determine sorting
// order for test result reports.
func TestMinimizedResult(MinimizedQuantityVar float64, FormatVar string, varArgs ...interface{}) {

	xTestMinimizedResult(MinimizedQuantityVar, FormatVar, varArgs...)

}

var xTestQueueDestroy func(uintptr, uintptr)

// Enqueues a callback @destroy_func to be executed during the next test case
// teardown phase.
//
// This is most useful to auto destroy allocated test resources at the end
// of a test run. Resources are released in reverse queue order, that means
// enqueueing callback `A` before callback `B` will cause `B()` to be called
// before `A()` during teardown.
func TestQueueDestroy(DestroyFuncVar *DestroyNotify, DestroyDataVar uintptr) {

	DestroyFuncVarPtr := uintptr(unsafe.Pointer(DestroyFuncVar))
	var DestroyFuncVarRef uintptr
	if cbRefPtr, ok := GetCallback(DestroyFuncVarPtr); ok {
		DestroyFuncVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr) {
			cbFn := *DestroyFuncVar
			cbFn(arg0)
		}
		DestroyFuncVarRef = purego.NewCallback(fcb)
		SaveCallback(DestroyFuncVarPtr, DestroyFuncVarRef)
	}

	xTestQueueDestroy(DestroyFuncVarRef, DestroyDataVar)

}

var xTestQueueFree func(uintptr)

// Enqueues a pointer to be released with [func@GLib.free]
// during the next teardown phase.
//
// This is equivalent to calling [func@GLib.test_queue_destroy]
// with a destroy callback of [func@GLib.free].
func TestQueueFree(GfreePointerVar uintptr) {

	xTestQueueFree(GfreePointerVar)

}

var xTestRandDouble func() float64

// Gets a reproducible random floating point number.
//
// See [func@GLib.test_rand_int] for details on test case random numbers.
func TestRandDouble() float64 {

	cret := xTestRandDouble()
	return cret
}

var xTestRandDoubleRange func(float64, float64) float64

// Gets a reproducible random floating point number out of a specified range.
//
// See [func@GLib.test_rand_int] for details on test case random numbers.
func TestRandDoubleRange(RangeStartVar float64, RangeEndVar float64) float64 {

	cret := xTestRandDoubleRange(RangeStartVar, RangeEndVar)
	return cret
}

var xTestRandInt func() int32

// Gets a reproducible random integer number.
//
// The random numbers generated by the g_test_rand_*() family of functions
// change with every new test program start, unless the --seed option is
// given when starting test programs.
//
// For individual test cases however, the random number generator is
// reseeded, to avoid dependencies between tests and to make --seed
// effective for all test cases.
func TestRandInt() int32 {

	cret := xTestRandInt()
	return cret
}

var xTestRandIntRange func(int32, int32) int32

// Gets a reproducible random integer number out of a specified range.
//
// See [func@GLib.test_rand_int] for details on test case random numbers.
func TestRandIntRange(BeginVar int32, EndVar int32) int32 {

	cret := xTestRandIntRange(BeginVar, EndVar)
	return cret
}

var xTestRun func() int

// Runs all tests under the toplevel suite.
//
// The toplevel suite can be retrieved with [func@GLib.test_get_root].
//
// Similar to [func@GLib.test_run_suite], the test cases to be run are
// filtered according to test path arguments (`-p testpath` and `-s testpath`)
// as parsed by [func@GLib.test_init]. [func@GLib.test_run_suite] or
// [func@GLib.test_run] may only be called once in a program.
//
// In general, the tests and sub-suites within each suite are run in
// the order in which they are defined. However, note that prior to
// GLib 2.36, there was a bug in the `g_test_add_*`
// functions which caused them to create multiple suites with the same
// name, meaning that if you created tests "/foo/simple",
// "/bar/simple", and "/foo/using-bar" in that order, they would get
// run in that order (since [func@GLib.test_run] would run the first "/foo"
// suite, then the "/bar" suite, then the second "/foo" suite). As of
// 2.36, this bug is fixed, and adding the tests in that order would
// result in a running order of "/foo/simple", "/foo/using-bar",
// "/bar/simple". If this new ordering is sub-optimal (because it puts
// more-complicated tests before simpler ones, making it harder to
// figure out exactly what has failed), you can fix it by changing the
// test paths to group tests by suite in a way that will result in the
// desired running order. Eg, "/simple/foo", "/simple/bar",
// "/complex/foo-using-bar".
//
// However, you should never make the actual result of a test depend
// on the order that tests are run in. If you need to ensure that some
// particular code runs before or after a given test case, use
// [func@GLib.test_add], which lets you specify setup and teardown functions.
//
// If all tests are skipped or marked as incomplete (expected failures),
// this function will return 0 if producing TAP output, or 77 (treated
// as "skip test" by Automake) otherwise.
func TestRun() int {

	cret := xTestRun()
	return cret
}

var xTestRunSuite func(*TestSuite) int

// Executes the tests within @suite and all nested test suites.
//
// The test suites to be executed are filtered according to
// test path arguments (`-p testpath` and `-s testpath`) as parsed by
// [func@GLib.test_init]. See the [func@GLib.test_run] documentation
// for more information on the order that tests are run in.
//
// [func@GLib.test_run_suite] or [func@GLib.test_run] may only be
// called once in a program.
func TestRunSuite(SuiteVar *TestSuite) int {

	cret := xTestRunSuite(SuiteVar)
	return cret
}

var xTestSetNonfatalAssertions func()

// Changes the behaviour of the various assertion macros.
//
// The `g_assert_*()` macros, `g_test_assert_expected_messages()`
// and the various `g_test_trap_assert_*()` macros are changed
// to not abort to program.
//
// Instead, they will call [func@GLib.test_fail] and continue.
// (This also changes the behavior of [func@GLib.test_fail] so that
// it will not cause the test program to abort after completing
// the failed test.)
//
// Note that the [func@GLib.assert_not_reached] and [func@GLib.assert]
// macros are not affected by this.
//
// This function can only be called after [func@GLib.test_init].
func TestSetNonfatalAssertions() {

	xTestSetNonfatalAssertions()

}

var xTestSkip func(string)

// Indicates that a test was skipped.
//
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
//
// If not called from inside a test, this function does nothing.
func TestSkip(MsgVar string) {

	xTestSkip(MsgVar)

}

var xTestSkipPrintf func(string, ...interface{})

// Indicates that a test was skipped.
//
// Equivalent to [func@GLib.test_skip], but the explanation
// is formatted as if by [func@GLib.strdup_printf].
func TestSkipPrintf(FormatVar string, varArgs ...interface{}) {

	xTestSkipPrintf(FormatVar, varArgs...)

}

var xTestSubprocess func() bool

// Returns true if the test program is running under [func@GLib.test_trap_subprocess].
func TestSubprocess() bool {

	cret := xTestSubprocess()
	return cret
}

var xTestSummary func(string)

// Sets the summary for a test.
//
// This may be included in test report output, and is useful documentation for
// anyone reading the source code or modifying a test in future. It must be a
// single line, and it should summarise what the test checks, and how.
//
// This should be called at the top of a test function.
//
// For example:
//
// ```c
// static void
// test_array_sort (void)
//
//	{
//	  g_test_summary ("Test my_array_sort() sorts the array correctly and stably, "
//	                  "including testing zero length and one-element arrays.");
//
//	  // ...
//	}
//
// ```
//
// See also [func@GLib.test_bug].
func TestSummary(SummaryVar string) {

	xTestSummary(SummaryVar)

}

var xTestTimerElapsed func() float64

// Gets the number of seconds since the last start of the timer with
// [func@GLib.test_timer_start].
func TestTimerElapsed() float64 {

	cret := xTestTimerElapsed()
	return cret
}

var xTestTimerLast func() float64

// Reports the last result of [func@GLib.test_timer_elapsed].
func TestTimerLast() float64 {

	cret := xTestTimerLast()
	return cret
}

var xTestTimerStart func()

// Starts a timing test.
//
// Call [func@GLib.test_timer_elapsed] when the task is supposed
// to be done. Call this function again to restart the timer.
func TestTimerStart() {

	xTestTimerStart()

}

var xTestTrapAssertions func(string, string, int, string, uint64, string)

func TestTrapAssertions(DomainVar string, FileVar string, LineVar int, FuncVar string, AssertionFlagsVar uint64, PatternVar string) {

	xTestTrapAssertions(DomainVar, FileVar, LineVar, FuncVar, AssertionFlagsVar, PatternVar)

}

var xTestTrapFork func(uint64, TestTrapFlags) bool

// Forks the current test program to execute a test case that might
// not return or that might abort.
//
// If @usec_timeout is non-0, the forked test case is aborted and
// considered failing if its run time exceeds it.
//
// The forking behavior can be configured with [flags@GLib.TestTrapFlags]
// flags.
//
// In the following example, the test code forks, the forked child
// process produces some sample output and exits successfully.
// The forking parent process then asserts successful child program
// termination and validates child program outputs.
//
// ```c
//
//	static void
//	test_fork_patterns (void)
//	{
//	  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
//	    {
//	      g_print ("some stdout text: somagic17
//
// ");
//
//	g_printerr ("some stderr text: semagic43
//
// ");
//
//	      exit (0); // successful test run
//	    }
//	  g_test_trap_assert_passed ();
//	  g_test_trap_assert_stdout ("*somagic17*");
//	  g_test_trap_assert_stderr ("*semagic43*");
//	}
//
// ```
func TestTrapFork(UsecTimeoutVar uint64, TestTrapFlagsVar TestTrapFlags) bool {

	cret := xTestTrapFork(UsecTimeoutVar, TestTrapFlagsVar)
	return cret
}

var xTestTrapHasPassed func() bool

// Checks the result of the last [func@GLib.test_trap_subprocess] call.
func TestTrapHasPassed() bool {

	cret := xTestTrapHasPassed()
	return cret
}

var xTestTrapReachedTimeout func() bool

// Checks the result of the last [func@GLib.test_trap_subprocess] call.
func TestTrapReachedTimeout() bool {

	cret := xTestTrapReachedTimeout()
	return cret
}

var xTestTrapSubprocess func(string, uint64, TestSubprocessFlags)

// Respawns the test program to run only @test_path in a subprocess.
//
// This is equivalent to calling [func@GLib.test_trap_subprocess_with_envp]
// with `envp` set to `NULL`. See the documentation for that function
// for full details.
func TestTrapSubprocess(TestPathVar string, UsecTimeoutVar uint64, TestFlagsVar TestSubprocessFlags) {

	xTestTrapSubprocess(TestPathVar, UsecTimeoutVar, TestFlagsVar)

}

var xTestTrapSubprocessWithEnvp func(string, []string, uint64, TestSubprocessFlags)

// Respawns the test program to run only @test_path in a subprocess with
// a given environment.
//
// This can be used for a test case that might not return, or that
// might abort.
//
// If @test_path is `NULL` then the same test is re-run in a subprocess.
// You can use [func@GLib.test_subprocess] to determine whether the test
// is in a subprocess or not.
//
// @test_path can also be the name of the parent test, followed by
// "`/subprocess/`" and then a name for the specific subtest (or just
// ending with "`/subprocess`" if the test only has one child test);
// tests with names of this form will automatically be skipped in the
// parent process.
//
// If @envp is `NULL`, the parent process’ environment will be inherited.
//
// If @usec_timeout is non-0, the test subprocess is aborted and
// considered failing if its run time exceeds it.
//
// The subprocess behavior can be configured with [flags@GLib.TestSubprocessFlags]
// flags.
//
// You can use methods such as [func@GLib.test_trap_assert_passed],
// [func@GLib.test_trap_assert_failed], and [func@GLib.test_trap_assert_stderr] to
// check the results of the subprocess. (But note that
// [func@GLib.test_trap_assert_stdout] and [func@GLib.test_trap_assert_stderr]
// cannot be used if @test_flags specifies that the child should
// inherit the parent stdout/stderr.)
//
// If your `main ()` needs to behave differently in the subprocess, you can
// call [func@GLib.test_subprocess] (after calling [func@GLib.test_init])
// to see whether you are in a subprocess.
//
// Internally, this function tracks the child process using
// [func@GLib.child_watch_source_new], so your process must not ignore
// `SIGCHLD`, and must not attempt to watch or wait for the child process
// via another mechanism.
//
// The following example tests that calling `my_object_new(1000000)` will
// abort with an error message.
//
// ```c
//
//	static void
//	test_create_large_object (void)
//	{
//	  if (g_test_subprocess ())
//	    {
//	      my_object_new (1000000);
//	      return;
//	    }
//
//	  // Reruns this same test in a subprocess
//	  g_test_trap_subprocess (NULL, 0, G_TEST_SUBPROCESS_DEFAULT);
//	  g_test_trap_assert_failed ();
//	  g_test_trap_assert_stderr ("*ERROR*too large*");
//	}
//
//	static void
//	test_different_username (void)
//	{
//	  if (g_test_subprocess ())
//	    {
//	      // Code under test goes here
//	      g_message ("Username is now simulated as %s", g_getenv ("USER"));
//	      return;
//	    }
//
//	  // Reruns this same test in a subprocess
//	  g_auto(GStrv) envp = g_get_environ ();
//	  envp = g_environ_setenv (g_steal_pointer (&amp;envp), "USER", "charlie", TRUE);
//	  g_test_trap_subprocess_with_envp (NULL, envp, 0, G_TEST_SUBPROCESS_DEFAULT);
//	  g_test_trap_assert_passed ();
//	  g_test_trap_assert_stdout ("Username is now simulated as charlie");
//	}
//
//	int
//	main (int argc, char **argv)
//	{
//	  g_test_init (&amp;argc, &amp;argv, NULL);
//
//	  g_test_add_func ("/myobject/create-large-object",
//	                   test_create_large_object);
//	  g_test_add_func ("/myobject/different-username",
//	                   test_different_username);
//	  return g_test_run ();
//	}
//
// ```
func TestTrapSubprocessWithEnvp(TestPathVar string, EnvpVar []string, UsecTimeoutVar uint64, TestFlagsVar TestSubprocessFlags) {

	xTestTrapSubprocessWithEnvp(TestPathVar, EnvpVar, UsecTimeoutVar, TestFlagsVar)

}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAssertionMessage, libs, "g_assertion_message")
	core.PuregoSafeRegister(&xAssertionMessageCmpint, libs, "g_assertion_message_cmpint")
	core.PuregoSafeRegister(&xAssertionMessageCmpnum, libs, "g_assertion_message_cmpnum")
	core.PuregoSafeRegister(&xAssertionMessageCmpstr, libs, "g_assertion_message_cmpstr")
	core.PuregoSafeRegister(&xAssertionMessageCmpstrv, libs, "g_assertion_message_cmpstrv")
	core.PuregoSafeRegister(&xAssertionMessageError, libs, "g_assertion_message_error")
	core.PuregoSafeRegister(&xAssertionMessageExpr, libs, "g_assertion_message_expr")
	core.PuregoSafeRegister(&xStrcmp0, libs, "g_strcmp0")
	core.PuregoSafeRegister(&xTestAddDataFunc, libs, "g_test_add_data_func")
	core.PuregoSafeRegister(&xTestAddDataFuncFull, libs, "g_test_add_data_func_full")
	core.PuregoSafeRegister(&xTestAddFunc, libs, "g_test_add_func")
	core.PuregoSafeRegister(&xTestAddVtable, libs, "g_test_add_vtable")
	core.PuregoSafeRegister(&xTestAssertExpectedMessagesInternal, libs, "g_test_assert_expected_messages_internal")
	core.PuregoSafeRegister(&xTestBug, libs, "g_test_bug")
	core.PuregoSafeRegister(&xTestBugBase, libs, "g_test_bug_base")
	core.PuregoSafeRegister(&xTestBuildFilename, libs, "g_test_build_filename")
	core.PuregoSafeRegister(&xTestCreateCase, libs, "g_test_create_case")
	core.PuregoSafeRegister(&xTestCreateSuite, libs, "g_test_create_suite")
	core.PuregoSafeRegister(&xTestDisableCrashReporting, libs, "g_test_disable_crash_reporting")
	core.PuregoSafeRegister(&xTestExpectMessage, libs, "g_test_expect_message")
	core.PuregoSafeRegister(&xTestFail, libs, "g_test_fail")
	core.PuregoSafeRegister(&xTestFailPrintf, libs, "g_test_fail_printf")
	core.PuregoSafeRegister(&xTestFailed, libs, "g_test_failed")
	core.PuregoSafeRegister(&xTestGetDir, libs, "g_test_get_dir")
	core.PuregoSafeRegister(&xTestGetFilename, libs, "g_test_get_filename")
	core.PuregoSafeRegister(&xTestGetPath, libs, "g_test_get_path")
	core.PuregoSafeRegister(&xTestGetRoot, libs, "g_test_get_root")
	core.PuregoSafeRegister(&xTestIncomplete, libs, "g_test_incomplete")
	core.PuregoSafeRegister(&xTestIncompletePrintf, libs, "g_test_incomplete_printf")
	core.PuregoSafeRegister(&xTestInit, libs, "g_test_init")
	core.PuregoSafeRegister(&xTestLogSetFatalHandler, libs, "g_test_log_set_fatal_handler")
	core.PuregoSafeRegister(&xTestLogTypeName, libs, "g_test_log_type_name")
	core.PuregoSafeRegister(&xTestMaximizedResult, libs, "g_test_maximized_result")
	core.PuregoSafeRegister(&xTestMessage, libs, "g_test_message")
	core.PuregoSafeRegister(&xTestMinimizedResult, libs, "g_test_minimized_result")
	core.PuregoSafeRegister(&xTestQueueDestroy, libs, "g_test_queue_destroy")
	core.PuregoSafeRegister(&xTestQueueFree, libs, "g_test_queue_free")
	core.PuregoSafeRegister(&xTestRandDouble, libs, "g_test_rand_double")
	core.PuregoSafeRegister(&xTestRandDoubleRange, libs, "g_test_rand_double_range")
	core.PuregoSafeRegister(&xTestRandInt, libs, "g_test_rand_int")
	core.PuregoSafeRegister(&xTestRandIntRange, libs, "g_test_rand_int_range")
	core.PuregoSafeRegister(&xTestRun, libs, "g_test_run")
	core.PuregoSafeRegister(&xTestRunSuite, libs, "g_test_run_suite")
	core.PuregoSafeRegister(&xTestSetNonfatalAssertions, libs, "g_test_set_nonfatal_assertions")
	core.PuregoSafeRegister(&xTestSkip, libs, "g_test_skip")
	core.PuregoSafeRegister(&xTestSkipPrintf, libs, "g_test_skip_printf")
	core.PuregoSafeRegister(&xTestSubprocess, libs, "g_test_subprocess")
	core.PuregoSafeRegister(&xTestSummary, libs, "g_test_summary")
	core.PuregoSafeRegister(&xTestTimerElapsed, libs, "g_test_timer_elapsed")
	core.PuregoSafeRegister(&xTestTimerLast, libs, "g_test_timer_last")
	core.PuregoSafeRegister(&xTestTimerStart, libs, "g_test_timer_start")
	core.PuregoSafeRegister(&xTestTrapAssertions, libs, "g_test_trap_assertions")
	core.PuregoSafeRegister(&xTestTrapFork, libs, "g_test_trap_fork")
	core.PuregoSafeRegister(&xTestTrapHasPassed, libs, "g_test_trap_has_passed")
	core.PuregoSafeRegister(&xTestTrapReachedTimeout, libs, "g_test_trap_reached_timeout")
	core.PuregoSafeRegister(&xTestTrapSubprocess, libs, "g_test_trap_subprocess")
	core.PuregoSafeRegister(&xTestTrapSubprocessWithEnvp, libs, "g_test_trap_subprocess_with_envp")

	core.PuregoSafeRegister(&xTestCaseFree, libs, "g_test_case_free")

	core.PuregoSafeRegister(&xTestLogBufferFree, libs, "g_test_log_buffer_free")
	core.PuregoSafeRegister(&xTestLogBufferPop, libs, "g_test_log_buffer_pop")
	core.PuregoSafeRegister(&xTestLogBufferPush, libs, "g_test_log_buffer_push")

	core.PuregoSafeRegister(&xTestLogMsgFree, libs, "g_test_log_msg_free")

	core.PuregoSafeRegister(&xTestSuiteAdd, libs, "g_test_suite_add")
	core.PuregoSafeRegister(&xTestSuiteAddSuite, libs, "g_test_suite_add_suite")
	core.PuregoSafeRegister(&xTestSuiteFree, libs, "g_test_suite_free")

}
