// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

// `GTimer` records a start time, and counts microseconds elapsed since
// that time.
//
// This is done somewhat differently on different platforms, and can be
// tricky to get exactly right, so `GTimer` provides a portable/convenient interface.
type Timer struct {
	_ structs.HostLayout
}

func (x *Timer) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTimerContinue func(uintptr)

// Resumes a timer that has previously been stopped with
// g_timer_stop(). g_timer_stop() must be called before using this
// function.
func (x *Timer) Continue() {

	xTimerContinue(x.GoPointer())

}

var xTimerDestroy func(uintptr)

// Destroys a timer, freeing associated resources.
func (x *Timer) Destroy() {

	xTimerDestroy(x.GoPointer())

}

var xTimerElapsed func(uintptr, uint) float64

// If @timer has been started but not stopped, obtains the time since
// the timer was started. If @timer has been stopped, obtains the
// elapsed time between the time it was started and the time it was
// stopped. The return value is the number of seconds elapsed,
// including any fractional part. The @microseconds out parameter is
// essentially useless.
func (x *Timer) Elapsed(MicrosecondsVar uint) float64 {

	cret := xTimerElapsed(x.GoPointer(), MicrosecondsVar)
	return cret
}

var xTimerIsActive func(uintptr) bool

// Exposes whether the timer is currently active.
func (x *Timer) IsActive() bool {

	cret := xTimerIsActive(x.GoPointer())
	return cret
}

var xTimerReset func(uintptr)

// This function is useless; it's fine to call g_timer_start() on an
// already-started timer to reset the start time, so g_timer_reset()
// serves no purpose.
func (x *Timer) Reset() {

	xTimerReset(x.GoPointer())

}

var xTimerStart func(uintptr)

// Marks a start time, so that future calls to g_timer_elapsed() will
// report the time since g_timer_start() was called. g_timer_new()
// automatically marks the start time, so no need to call
// g_timer_start() immediately after creating the timer.
func (x *Timer) Start() {

	xTimerStart(x.GoPointer())

}

var xTimerStop func(uintptr)

// Marks an end time, so calls to g_timer_elapsed() will return the
// difference between this end time and the start time.
func (x *Timer) Stop() {

	xTimerStop(x.GoPointer())

}

const (
	// Number of microseconds in one second (1 million).
	// This macro is provided for code readability.
	USEC_PER_SEC int = 1000000
)

var xTimeValFromIso8601 func(string, *TimeVal) bool

// Converts a string containing an ISO 8601 encoded date and time
// to a #GTimeVal and puts it into @time_.
//
// @iso_date must include year, month, day, hours, minutes, and
// seconds. It can optionally include fractions of a second and a time
// zone indicator. (In the absence of any time zone indication, the
// timestamp is assumed to be in local time.)
//
// Any leading or trailing space in @iso_date is ignored.
//
// This function was deprecated, along with #GTimeVal itself, in GLib 2.62.
// Equivalent functionality is available using code like:
// |[
// GDateTime *dt = g_date_time_new_from_iso8601 (iso8601_string, NULL);
// gint64 time_val = g_date_time_to_unix (dt);
// g_date_time_unref (dt);
// ]|
func TimeValFromIso8601(IsoDateVar string, TimeVar *TimeVal) bool {

	cret := xTimeValFromIso8601(IsoDateVar, TimeVar)
	return cret
}

var xUsleep func(uint)

// Pauses the current thread for the given number of microseconds.
//
// There are 1 million microseconds per second (represented by the
// %G_USEC_PER_SEC macro). g_usleep() may have limited precision,
// depending on hardware and operating system; don't rely on the exact
// length of the sleep.
func Usleep(MicrosecondsVar uint) {

	xUsleep(MicrosecondsVar)

}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTimeValFromIso8601, libs, "g_time_val_from_iso8601")
	core.PuregoSafeRegister(&xUsleep, libs, "g_usleep")

	core.PuregoSafeRegister(&xTimerContinue, libs, "g_timer_continue")
	core.PuregoSafeRegister(&xTimerDestroy, libs, "g_timer_destroy")
	core.PuregoSafeRegister(&xTimerElapsed, libs, "g_timer_elapsed")
	core.PuregoSafeRegister(&xTimerIsActive, libs, "g_timer_is_active")
	core.PuregoSafeRegister(&xTimerReset, libs, "g_timer_reset")
	core.PuregoSafeRegister(&xTimerStart, libs, "g_timer_start")
	core.PuregoSafeRegister(&xTimerStop, libs, "g_timer_stop")

}
