// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `GUri` type and related functions can be used to parse URIs into
// their components, and build valid URIs from individual components.
//
// Since `GUri` only represents absolute URIs, all `GUri`s will have a
// URI scheme, so [method@GLib.Uri.get_scheme] will always return a non-`NULL`
// answer. Likewise, by definition, all URIs have a path component, so
// [method@GLib.Uri.get_path] will always return a non-`NULL` string (which may
// be empty).
//
// If the URI string has an
// [‘authority’ component](https://tools.ietf.org/html/rfc3986#section-3) (that
// is, if the scheme is followed by `://` rather than just `:`), then the
// `GUri` will contain a hostname, and possibly a port and ‘userinfo’.
// Additionally, depending on how the `GUri` was constructed/parsed (for example,
// using the `G_URI_FLAGS_HAS_PASSWORD` and `G_URI_FLAGS_HAS_AUTH_PARAMS` flags),
// the userinfo may be split out into a username, password, and
// additional authorization-related parameters.
//
// Normally, the components of a `GUri` will have all `%`-encoded
// characters decoded. However, if you construct/parse a `GUri` with
// `G_URI_FLAGS_ENCODED`, then the `%`-encoding will be preserved instead in
// the userinfo, path, and query fields (and in the host field if also
// created with `G_URI_FLAGS_NON_DNS`). In particular, this is necessary if
// the URI may contain binary data or non-UTF-8 text, or if decoding
// the components might change the interpretation of the URI.
//
// For example, with the encoded flag:
//
// ```c
// g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue", G_URI_FLAGS_ENCODED, &amp;err);
// g_assert_cmpstr (g_uri_get_query (uri), ==, "query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue");
// ```
//
// While the default `%`-decoding behaviour would give:
//
// ```c
// g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue", G_URI_FLAGS_NONE, &amp;err);
// g_assert_cmpstr (g_uri_get_query (uri), ==, "query=http://host/path?param=value");
// ```
//
// During decoding, if an invalid UTF-8 string is encountered, parsing will fail
// with an error indicating the bad string location:
//
// ```c
// g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fbad%3D%00alue", G_URI_FLAGS_NONE, &amp;err);
// g_assert_error (err, G_URI_ERROR, G_URI_ERROR_BAD_QUERY);
// ```
//
// You should pass `G_URI_FLAGS_ENCODED` or `G_URI_FLAGS_ENCODED_QUERY` if you
// need to handle that case manually. In particular, if the query string
// contains `=` characters that are `%`-encoded, you should let
// [func@GLib.Uri.parse_params] do the decoding once of the query.
//
// `GUri` is immutable once constructed, and can safely be accessed from
// multiple threads. Its reference counting is atomic.
//
// Note that the scope of `GUri` is to help manipulate URIs in various applications,
// following [RFC 3986](https://tools.ietf.org/html/rfc3986). In particular,
// it doesn't intend to cover web browser needs, and doesn’t implement the
// [WHATWG URL](https://url.spec.whatwg.org/) standard. No APIs are provided to
// help prevent
// [homograph attacks](https://en.wikipedia.org/wiki/IDN_homograph_attack), so
// `GUri` is not suitable for formatting URIs for display to the user for making
// security-sensitive decisions.
//
// ## Relative and absolute URIs
//
// As defined in [RFC 3986](https://tools.ietf.org/html/rfc3986#section-4), the
// hierarchical nature of URIs means that they can either be ‘relative
// references’ (sometimes referred to as ‘relative URIs’) or ‘URIs’ (for
// clarity, ‘URIs’ are referred to in this documentation as
// ‘absolute URIs’ — although
// [in contrast to RFC 3986](https://tools.ietf.org/html/rfc3986#section-4.3),
// fragment identifiers are always allowed).
//
// Relative references have one or more components of the URI missing. In
// particular, they have no scheme. Any other component, such as hostname,
// query, etc. may be missing, apart from a path, which has to be specified (but
// may be empty). The path may be relative, starting with `./` rather than `/`.
//
// For example, a valid relative reference is `./path?query`,
// `/?query#fragment` or `//example.com`.
//
// Absolute URIs have a scheme specified. Any other components of the URI which
// are missing are specified as explicitly unset in the URI, rather than being
// resolved relative to a base URI using [method@GLib.Uri.parse_relative].
//
// For example, a valid absolute URI is `file:///home/bob` or
// `https://search.com?query=string`.
//
// A `GUri` instance is always an absolute URI. A string may be an absolute URI
// or a relative reference; see the documentation for individual functions as to
// what forms they accept.
//
// ## Parsing URIs
//
// The most minimalist APIs for parsing URIs are [func@GLib.Uri.split] and
// [func@GLib.Uri.split_with_user]. These split a URI into its component
// parts, and return the parts; the difference between the two is that
// [func@GLib.Uri.split] treats the ‘userinfo’ component of the URI as a
// single element, while [func@GLib.Uri.split_with_user] can (depending on the
// [flags@GLib.UriFlags] you pass) treat it as containing a username, password,
// and authentication parameters. Alternatively, [func@GLib.Uri.split_network]
// can be used when you are only interested in the components that are
// needed to initiate a network connection to the service (scheme,
// host, and port).
//
// [func@GLib.Uri.parse] is similar to [func@GLib.Uri.split], but instead of
// returning individual strings, it returns a `GUri` structure (and it requires
// that the URI be an absolute URI).
//
// [func@GLib.Uri.resolve_relative] and [method@GLib.Uri.parse_relative] allow
// you to resolve a relative URI relative to a base URI.
// [func@GLib.Uri.resolve_relative] takes two strings and returns a string,
// and [method@GLib.Uri.parse_relative] takes a `GUri` and a string and returns a
// `GUri`.
//
// All of the parsing functions take a [flags@GLib.UriFlags] argument describing
// exactly how to parse the URI; see the documentation for that type
// for more details on the specific flags that you can pass. If you
// need to choose different flags based on the type of URI, you can
// use [func@GLib.Uri.peek_scheme] on the URI string to check the scheme
// first, and use that to decide what flags to parse it with.
//
// For example, you might want to use `G_URI_PARAMS_WWW_FORM` when parsing the
// params for a web URI, so compare the result of [func@GLib.Uri.peek_scheme]
// against `http` and `https`.
//
// ## Building URIs
//
// [func@GLib.Uri.join] and [func@GLib.Uri.join_with_user] can be used to construct
// valid URI strings from a set of component strings. They are the
// inverse of [func@GLib.Uri.split] and [func@GLib.Uri.split_with_user].
//
// Similarly, [func@GLib.Uri.build] and [func@GLib.Uri.build_with_user] can be
// used to construct a `GUri` from a set of component strings.
//
// As with the parsing functions, the building functions take a
// [flags@GLib.UriFlags] argument. In particular, it is important to keep in mind
// whether the URI components you are using are already `%`-encoded. If so,
// you must pass the `G_URI_FLAGS_ENCODED` flag.
//
// ## `file://` URIs
//
// Note that Windows and Unix both define special rules for parsing
// `file://` URIs (involving non-UTF-8 character sets on Unix, and the
// interpretation of path separators on Windows). `GUri` does not
// implement these rules. Use [func@GLib.filename_from_uri] and
// [func@GLib.filename_to_uri] if you want to properly convert between
// `file://` URIs and local filenames.
//
// ## URI Equality
//
// Note that there is no `g_uri_equal ()` function, because comparing
// URIs usefully requires scheme-specific knowledge that `GUri` does
// not have. `GUri` can help with normalization if you use the various
// encoded [flags@GLib.UriFlags] as well as `G_URI_FLAGS_SCHEME_NORMALIZE`
// however it is not comprehensive.
// For example, `data:,foo` and `data:;base64,Zm9v` resolve to the same
// thing according to the `data:` URI specification which GLib does not
// handle.
type Uri struct {
	_ structs.HostLayout
}

var xUriGLibType func() types.GType

func UriGLibType() types.GType {
	return xUriGLibType()
}

func (x *Uri) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xUriGetAuthParams func(uintptr) string

// Gets @uri's authentication parameters, which may contain
// `%`-encoding, depending on the flags with which @uri was created.
// (If @uri was not created with %G_URI_FLAGS_HAS_AUTH_PARAMS then this will
// be %NULL.)
//
// Depending on the URI scheme, g_uri_parse_params() may be useful for
// further parsing this information.
func (x *Uri) GetAuthParams() string {

	cret := xUriGetAuthParams(x.GoPointer())
	return cret
}

var xUriGetFlags func(uintptr) UriFlags

// Gets @uri's flags set upon construction.
func (x *Uri) GetFlags() UriFlags {

	cret := xUriGetFlags(x.GoPointer())
	return cret
}

var xUriGetFragment func(uintptr) string

// Gets @uri's fragment, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (x *Uri) GetFragment() string {

	cret := xUriGetFragment(x.GoPointer())
	return cret
}

var xUriGetHost func(uintptr) string

// Gets @uri's host. This will never have `%`-encoded characters,
// unless it is non-UTF-8 (which can only be the case if @uri was
// created with %G_URI_FLAGS_NON_DNS).
//
// If @uri contained an IPv6 address literal, this value will be just
// that address, without the brackets around it that are necessary in
// the string form of the URI. Note that in this case there may also
// be a scope ID attached to the address. Eg, `fe80::1234%“em1` (or
// `fe80::1234%“25em1` if the string is still encoded).
func (x *Uri) GetHost() string {

	cret := xUriGetHost(x.GoPointer())
	return cret
}

var xUriGetPassword func(uintptr) string

// Gets @uri's password, which may contain `%`-encoding, depending on
// the flags with which @uri was created. (If @uri was not created
// with %G_URI_FLAGS_HAS_PASSWORD then this will be %NULL.)
func (x *Uri) GetPassword() string {

	cret := xUriGetPassword(x.GoPointer())
	return cret
}

var xUriGetPath func(uintptr) string

// Gets @uri's path, which may contain `%`-encoding, depending on the
// flags with which @uri was created.
func (x *Uri) GetPath() string {

	cret := xUriGetPath(x.GoPointer())
	return cret
}

var xUriGetPort func(uintptr) int

// Gets @uri's port.
func (x *Uri) GetPort() int {

	cret := xUriGetPort(x.GoPointer())
	return cret
}

var xUriGetQuery func(uintptr) string

// Gets @uri's query, which may contain `%`-encoding, depending on the
// flags with which @uri was created.
//
// For queries consisting of a series of `name=value` parameters,
// #GUriParamsIter or g_uri_parse_params() may be useful.
func (x *Uri) GetQuery() string {

	cret := xUriGetQuery(x.GoPointer())
	return cret
}

var xUriGetScheme func(uintptr) string

// Gets @uri's scheme. Note that this will always be all-lowercase,
// regardless of the string or strings that @uri was created from.
func (x *Uri) GetScheme() string {

	cret := xUriGetScheme(x.GoPointer())
	return cret
}

var xUriGetUser func(uintptr) string

// Gets the ‘username’ component of @uri's userinfo, which may contain
// `%`-encoding, depending on the flags with which @uri was created.
// If @uri was not created with %G_URI_FLAGS_HAS_PASSWORD or
// %G_URI_FLAGS_HAS_AUTH_PARAMS, this is the same as g_uri_get_userinfo().
func (x *Uri) GetUser() string {

	cret := xUriGetUser(x.GoPointer())
	return cret
}

var xUriGetUserinfo func(uintptr) string

// Gets @uri's userinfo, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (x *Uri) GetUserinfo() string {

	cret := xUriGetUserinfo(x.GoPointer())
	return cret
}

var xUriParseRelative func(uintptr, string, UriFlags, **Error) *Uri

// Parses @uri_ref according to @flags and, if it is a
// [relative URI](#relative-and-absolute-uris), resolves it relative to @base_uri.
// If the result is not a valid absolute URI, it will be discarded, and an error
// returned.
func (x *Uri) ParseRelative(UriRefVar string, FlagsVar UriFlags) (*Uri, error) {
	var cerr *Error

	cret := xUriParseRelative(x.GoPointer(), UriRefVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriRef func(uintptr) *Uri

// Increments the reference count of @uri by one.
func (x *Uri) Ref() *Uri {

	cret := xUriRef(x.GoPointer())
	return cret
}

var xUriToString func(uintptr) string

// Returns a string representing @uri.
//
// This is not guaranteed to return a string which is identical to the
// string that @uri was parsed from. However, if the source URI was
// syntactically correct (according to RFC 3986), and it was parsed
// with %G_URI_FLAGS_ENCODED, then g_uri_to_string() is guaranteed to return
// a string which is at least semantically equivalent to the source
// URI (according to RFC 3986).
//
// If @uri might contain sensitive details, such as authentication parameters,
// or private data in its query string, and the returned string is going to be
// logged, then consider using g_uri_to_string_partial() to redact parts.
func (x *Uri) ToString() string {

	cret := xUriToString(x.GoPointer())
	return cret
}

var xUriToStringPartial func(uintptr, UriHideFlags) string

// Returns a string representing @uri, subject to the options in
// @flags. See g_uri_to_string() and #GUriHideFlags for more details.
func (x *Uri) ToStringPartial(FlagsVar UriHideFlags) string {

	cret := xUriToStringPartial(x.GoPointer(), FlagsVar)
	return cret
}

var xUriUnref func(uintptr)

// Atomically decrements the reference count of @uri by one.
//
// When the reference count reaches zero, the resources allocated by
// @uri are freed
func (x *Uri) Unref() {

	xUriUnref(x.GoPointer())

}

// Many URI schemes include one or more attribute/value pairs as part of the URI
// value. For example `scheme://server/path?query=string&amp;is=there` has two
// attributes – `query=string` and `is=there` – in its query part.
//
// A #GUriParamsIter structure represents an iterator that can be used to
// iterate over the attribute/value pairs of a URI query string. #GUriParamsIter
// structures are typically allocated on the stack and then initialized with
// g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
// for a usage example.
type UriParamsIter struct {
	_ structs.HostLayout

	Dummy0 int32

	Dummy1 uintptr

	Dummy2 uintptr

	Dummy3 [256]byte
}

func (x *UriParamsIter) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xUriParamsIterInit func(uintptr, string, int, string, UriParamsFlags)

// Initializes an attribute/value pair iterator.
//
// The iterator keeps pointers to the @params and @separators arguments, those
// variables must thus outlive the iterator and not be modified during the
// iteration.
//
// If %G_URI_PARAMS_WWW_FORM is passed in @flags, `+` characters in the param
// string will be replaced with spaces in the output. For example, `foo=bar+baz`
// will give attribute `foo` with value `bar baz`. This is commonly used on the
// web (the `https` and `http` schemes only), but is deprecated in favour of
// the equivalent of encoding spaces as `%20`.
//
// Unlike with g_uri_parse_params(), %G_URI_PARAMS_CASE_INSENSITIVE has no
// effect if passed to @flags for g_uri_params_iter_init(). The caller is
// responsible for doing their own case-insensitive comparisons.
//
// |[&lt;!-- language="C" --&gt;
// GUriParamsIter iter;
// GError *error = NULL;
// gchar *unowned_attr, *unowned_value;
//
// g_uri_params_iter_init (&amp;iter, "foo=bar&amp;baz=bar&amp;Foo=frob&amp;baz=bar2", -1, "&amp;", G_URI_PARAMS_NONE);
// while (g_uri_params_iter_next (&amp;iter, &amp;unowned_attr, &amp;unowned_value, &amp;error))
//
//	{
//	  g_autofree gchar *attr = g_steal_pointer (&amp;unowned_attr);
//	  g_autofree gchar *value = g_steal_pointer (&amp;unowned_value);
//	  // do something with attr and value; this code will be called 4 times
//	  // for the params string in this example: once with attr=foo and value=bar,
//	  // then with baz/bar, then Foo/frob, then baz/bar2.
//	}
//
// if (error)
//
//	// handle parsing error
//
// ]|
func (x *UriParamsIter) Init(ParamsVar string, LengthVar int, SeparatorsVar string, FlagsVar UriParamsFlags) {

	xUriParamsIterInit(x.GoPointer(), ParamsVar, LengthVar, SeparatorsVar, FlagsVar)

}

var xUriParamsIterNext func(uintptr, *string, *string, **Error) bool

// Advances @iter and retrieves the next attribute/value. %FALSE is returned if
// an error has occurred (in which case @error is set), or if the end of the
// iteration is reached (in which case @attribute and @value are set to %NULL
// and the iterator becomes invalid). If %TRUE is returned,
// g_uri_params_iter_next() may be called again to receive another
// attribute/value pair.
//
// Note that the same @attribute may be returned multiple times, since URIs
// allow repeated attributes.
func (x *UriParamsIter) Next(AttributeVar *string, ValueVar *string) (bool, error) {
	var cerr *Error

	cret := xUriParamsIterNext(x.GoPointer(), AttributeVar, ValueVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

const (
	// Generic delimiters characters as defined in
	// [RFC 3986](https://tools.ietf.org/html/rfc3986). Includes `:/?#[]@`.
	URI_RESERVED_CHARS_GENERIC_DELIMITERS string = ":/?#[]@"
	// Subcomponent delimiter characters as defined in
	// [RFC 3986](https://tools.ietf.org/html/rfc3986). Includes `!$&amp;'()*+,;=`.
	URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS string = "!$&'()*+,;="
)

// Flags that describe a URI.
//
// When parsing a URI, if you need to choose different flags based on
// the type of URI, you can use g_uri_peek_scheme() on the URI string
// to check the scheme first, and use that to decide what flags to
// parse it with.
type UriFlags int

const (

	// No flags set.
	GUriFlagsNoneValue UriFlags = 0
	// Parse the URI more relaxedly than the
	//     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,
	//     fixing up or ignoring common mistakes in URIs coming from external
	//     sources. This is also needed for some obscure URI schemes where `;`
	//     separates the host from the path. Don’t use this flag unless you need to.
	GUriFlagsParseRelaxedValue UriFlags = 1
	// The userinfo field may contain a password,
	//     which will be separated from the username by `:`.
	GUriFlagsHasPasswordValue UriFlags = 2
	// The userinfo may contain additional
	//     authentication-related parameters, which will be separated from
	//     the username and/or password by `;`.
	GUriFlagsHasAuthParamsValue UriFlags = 4
	// When parsing a URI, this indicates that `%`-encoded
	//     characters in the userinfo, path, query, and fragment fields
	//     should not be decoded. (And likewise the host field if
	//     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates
	//     that you have already `%`-encoded the components, and so #GUri
	//     should not do any encoding itself.
	GUriFlagsEncodedValue UriFlags = 8
	// The host component should not be assumed to be a
	//     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS
	//     hostnames).
	GUriFlagsNonDnsValue UriFlags = 16
	// Same as %G_URI_FLAGS_ENCODED, for the query
	//     field only.
	GUriFlagsEncodedQueryValue UriFlags = 32
	// Same as %G_URI_FLAGS_ENCODED, for the path only.
	GUriFlagsEncodedPathValue UriFlags = 64
	// Same as %G_URI_FLAGS_ENCODED, for the
	//     fragment only.
	GUriFlagsEncodedFragmentValue UriFlags = 128
	// A scheme-based normalization will be applied.
	//     For example, when parsing an HTTP URI changing omitted path to `/` and
	//     omitted port to `80`; and when building a URI, changing empty path to `/`
	//     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)
	GUriFlagsSchemeNormalizeValue UriFlags = 256
)

// Flags describing what parts of the URI to hide in
// g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and
// %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with
// the corresponding flags.
type UriHideFlags int

const (

	// No flags set.
	GUriHideNoneValue UriHideFlags = 0
	// Hide the userinfo.
	GUriHideUserinfoValue UriHideFlags = 1
	// Hide the password.
	GUriHidePasswordValue UriHideFlags = 2
	// Hide the auth_params.
	GUriHideAuthParamsValue UriHideFlags = 4
	// Hide the query.
	GUriHideQueryValue UriHideFlags = 8
	// Hide the fragment.
	GUriHideFragmentValue UriHideFlags = 16
)

// Flags modifying the way parameters are handled by g_uri_parse_params() and
// #GUriParamsIter.
type UriParamsFlags int

const (

	// No flags set.
	GUriParamsNoneValue UriParamsFlags = 0
	// Parameter names are case insensitive.
	GUriParamsCaseInsensitiveValue UriParamsFlags = 1
	// Replace `+` with space character. Only useful for
	//     URLs on the web, using the `https` or `http` schemas.
	GUriParamsWwwFormValue UriParamsFlags = 2
	// See %G_URI_FLAGS_PARSE_RELAXED.
	GUriParamsParseRelaxedValue UriParamsFlags = 4
)

// Error codes returned by #GUri methods.
type UriError int

const (

	// Generic error if no more specific error is available.
	//     See the error message for details.
	GUriErrorFailedValue UriError = 0
	// The scheme of a URI could not be parsed.
	GUriErrorBadSchemeValue UriError = 1
	// The user/userinfo of a URI could not be parsed.
	GUriErrorBadUserValue UriError = 2
	// The password of a URI could not be parsed.
	GUriErrorBadPasswordValue UriError = 3
	// The authentication parameters of a URI could not be parsed.
	GUriErrorBadAuthParamsValue UriError = 4
	// The host of a URI could not be parsed.
	GUriErrorBadHostValue UriError = 5
	// The port of a URI could not be parsed.
	GUriErrorBadPortValue UriError = 6
	// The path of a URI could not be parsed.
	GUriErrorBadPathValue UriError = 7
	// The query of a URI could not be parsed.
	GUriErrorBadQueryValue UriError = 8
	// The fragment of a URI could not be parsed.
	GUriErrorBadFragmentValue UriError = 9
)

var xUriBuild func(UriFlags, string, uintptr, uintptr, int, string, uintptr, uintptr) *Uri

// Creates a new #GUri from the given components according to @flags.
//
// See also g_uri_build_with_user(), which allows specifying the
// components of the "userinfo" separately.
func UriBuild(FlagsVar UriFlags, SchemeVar string, UserinfoVar *string, HostVar *string, PortVar int, PathVar string, QueryVar *string, FragmentVar *string) *Uri {

	UserinfoVarPtr := core.GStrdupNullable(UserinfoVar)
	defer core.GFreeNullable(UserinfoVarPtr)

	HostVarPtr := core.GStrdupNullable(HostVar)
	defer core.GFreeNullable(HostVarPtr)

	QueryVarPtr := core.GStrdupNullable(QueryVar)
	defer core.GFreeNullable(QueryVarPtr)

	FragmentVarPtr := core.GStrdupNullable(FragmentVar)
	defer core.GFreeNullable(FragmentVarPtr)

	cret := xUriBuild(FlagsVar, SchemeVar, UserinfoVarPtr, HostVarPtr, PortVar, PathVar, QueryVarPtr, FragmentVarPtr)

	return cret
}

var xUriBuildWithUser func(UriFlags, string, uintptr, uintptr, uintptr, uintptr, int, string, uintptr, uintptr) *Uri

// Creates a new #GUri from the given components according to @flags
// (%G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The @flags must be
// coherent with the passed values, in particular use `%`-encoded values with
// %G_URI_FLAGS_ENCODED.
//
// In contrast to g_uri_build(), this allows specifying the components
// of the ‘userinfo’ field separately. Note that @user must be non-%NULL
// if either @password or @auth_params is non-%NULL.
func UriBuildWithUser(FlagsVar UriFlags, SchemeVar string, UserVar *string, PasswordVar *string, AuthParamsVar *string, HostVar *string, PortVar int, PathVar string, QueryVar *string, FragmentVar *string) *Uri {

	UserVarPtr := core.GStrdupNullable(UserVar)
	defer core.GFreeNullable(UserVarPtr)

	PasswordVarPtr := core.GStrdupNullable(PasswordVar)
	defer core.GFreeNullable(PasswordVarPtr)

	AuthParamsVarPtr := core.GStrdupNullable(AuthParamsVar)
	defer core.GFreeNullable(AuthParamsVarPtr)

	HostVarPtr := core.GStrdupNullable(HostVar)
	defer core.GFreeNullable(HostVarPtr)

	QueryVarPtr := core.GStrdupNullable(QueryVar)
	defer core.GFreeNullable(QueryVarPtr)

	FragmentVarPtr := core.GStrdupNullable(FragmentVar)
	defer core.GFreeNullable(FragmentVarPtr)

	cret := xUriBuildWithUser(FlagsVar, SchemeVar, UserVarPtr, PasswordVarPtr, AuthParamsVarPtr, HostVarPtr, PortVar, PathVar, QueryVarPtr, FragmentVarPtr)

	return cret
}

var xUriEscapeBytes func([]byte, uint, uintptr) string

// Escapes arbitrary data for use in a URI.
//
// Normally all characters that are not ‘unreserved’ (i.e. ASCII
// alphanumerical characters plus dash, dot, underscore and tilde) are
// escaped. But if you specify characters in @reserved_chars_allowed
// they are not escaped. This is useful for the ‘reserved’ characters
// in the URI specification, since those are allowed unescaped in some
// portions of a URI.
//
// Though technically incorrect, this will also allow escaping nul
// bytes as `%“00`.
func UriEscapeBytes(UnescapedVar []byte, LengthVar uint, ReservedCharsAllowedVar *string) string {

	ReservedCharsAllowedVarPtr := core.GStrdupNullable(ReservedCharsAllowedVar)
	defer core.GFreeNullable(ReservedCharsAllowedVarPtr)

	cret := xUriEscapeBytes(UnescapedVar, LengthVar, ReservedCharsAllowedVarPtr)

	return cret
}

var xUriEscapeString func(string, uintptr, bool) string

// Escapes a string for use in a URI.
//
// Normally all characters that are not "unreserved" (i.e. ASCII
// alphanumerical characters plus dash, dot, underscore and tilde) are
// escaped. But if you specify characters in @reserved_chars_allowed
// they are not escaped. This is useful for the "reserved" characters
// in the URI specification, since those are allowed unescaped in some
// portions of a URI.
func UriEscapeString(UnescapedVar string, ReservedCharsAllowedVar *string, AllowUtf8Var bool) string {

	ReservedCharsAllowedVarPtr := core.GStrdupNullable(ReservedCharsAllowedVar)
	defer core.GFreeNullable(ReservedCharsAllowedVarPtr)

	cret := xUriEscapeString(UnescapedVar, ReservedCharsAllowedVarPtr, AllowUtf8Var)

	return cret
}

var xUriIsValid func(string, UriFlags, **Error) bool

// Parses @uri_string according to @flags, to determine whether it is a valid
// [absolute URI](#relative-and-absolute-uris), i.e. it does not need to be resolved
// relative to another URI using g_uri_parse_relative().
//
// If it’s not a valid URI, an error is returned explaining how it’s invalid.
//
// See g_uri_split(), and the definition of #GUriFlags, for more
// information on the effect of @flags.
func UriIsValid(UriStringVar string, FlagsVar UriFlags) (bool, error) {
	var cerr *Error

	cret := xUriIsValid(UriStringVar, FlagsVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriJoin func(UriFlags, uintptr, uintptr, uintptr, int, string, uintptr, uintptr) string

// Joins the given components together according to @flags to create
// an absolute URI string. @path may not be %NULL (though it may be the empty
// string).
//
// When @host is present, @path must either be empty or begin with a slash (`/`)
// character. When @host is not present, @path cannot begin with two slash
// characters (`//`). See
// [RFC 3986, section 3](https://tools.ietf.org/html/rfc3986#section-3).
//
// See also g_uri_join_with_user(), which allows specifying the
// components of the ‘userinfo’ separately.
//
// %G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func UriJoin(FlagsVar UriFlags, SchemeVar *string, UserinfoVar *string, HostVar *string, PortVar int, PathVar string, QueryVar *string, FragmentVar *string) string {

	SchemeVarPtr := core.GStrdupNullable(SchemeVar)
	defer core.GFreeNullable(SchemeVarPtr)

	UserinfoVarPtr := core.GStrdupNullable(UserinfoVar)
	defer core.GFreeNullable(UserinfoVarPtr)

	HostVarPtr := core.GStrdupNullable(HostVar)
	defer core.GFreeNullable(HostVarPtr)

	QueryVarPtr := core.GStrdupNullable(QueryVar)
	defer core.GFreeNullable(QueryVarPtr)

	FragmentVarPtr := core.GStrdupNullable(FragmentVar)
	defer core.GFreeNullable(FragmentVarPtr)

	cret := xUriJoin(FlagsVar, SchemeVarPtr, UserinfoVarPtr, HostVarPtr, PortVar, PathVar, QueryVarPtr, FragmentVarPtr)

	return cret
}

var xUriJoinWithUser func(UriFlags, uintptr, uintptr, uintptr, uintptr, uintptr, int, string, uintptr, uintptr) string

// Joins the given components together according to @flags to create
// an absolute URI string. @path may not be %NULL (though it may be the empty
// string).
//
// In contrast to g_uri_join(), this allows specifying the components
// of the ‘userinfo’ separately. It otherwise behaves the same.
//
// %G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func UriJoinWithUser(FlagsVar UriFlags, SchemeVar *string, UserVar *string, PasswordVar *string, AuthParamsVar *string, HostVar *string, PortVar int, PathVar string, QueryVar *string, FragmentVar *string) string {

	SchemeVarPtr := core.GStrdupNullable(SchemeVar)
	defer core.GFreeNullable(SchemeVarPtr)

	UserVarPtr := core.GStrdupNullable(UserVar)
	defer core.GFreeNullable(UserVarPtr)

	PasswordVarPtr := core.GStrdupNullable(PasswordVar)
	defer core.GFreeNullable(PasswordVarPtr)

	AuthParamsVarPtr := core.GStrdupNullable(AuthParamsVar)
	defer core.GFreeNullable(AuthParamsVarPtr)

	HostVarPtr := core.GStrdupNullable(HostVar)
	defer core.GFreeNullable(HostVarPtr)

	QueryVarPtr := core.GStrdupNullable(QueryVar)
	defer core.GFreeNullable(QueryVarPtr)

	FragmentVarPtr := core.GStrdupNullable(FragmentVar)
	defer core.GFreeNullable(FragmentVarPtr)

	cret := xUriJoinWithUser(FlagsVar, SchemeVarPtr, UserVarPtr, PasswordVarPtr, AuthParamsVarPtr, HostVarPtr, PortVar, PathVar, QueryVarPtr, FragmentVarPtr)

	return cret
}

var xUriParse func(string, UriFlags, **Error) *Uri

// Parses @uri_string according to @flags. If the result is not a
// valid [absolute URI](#relative-and-absolute-uris), it will be discarded, and an
// error returned.
func UriParse(UriStringVar string, FlagsVar UriFlags) (*Uri, error) {
	var cerr *Error

	cret := xUriParse(UriStringVar, FlagsVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriParseParams func(string, int, string, UriParamsFlags, **Error) *HashTable

// Many URI schemes include one or more attribute/value pairs as part of the URI
// value. This method can be used to parse them into a hash table. When an
// attribute has multiple occurrences, the last value is the final returned
// value. If you need to handle repeated attributes differently, use
// #GUriParamsIter.
//
// The @params string is assumed to still be `%`-encoded, but the returned
// values will be fully decoded. (Thus it is possible that the returned values
// may contain `=` or @separators, if the value was encoded in the input.)
// Invalid `%`-encoding is treated as with the %G_URI_FLAGS_PARSE_RELAXED
// rules for g_uri_parse(). (However, if @params is the path or query string
// from a #GUri that was parsed without %G_URI_FLAGS_PARSE_RELAXED and
// %G_URI_FLAGS_ENCODED, then you already know that it does not contain any
// invalid encoding.)
//
// %G_URI_PARAMS_WWW_FORM is handled as documented for g_uri_params_iter_init().
//
// If %G_URI_PARAMS_CASE_INSENSITIVE is passed to @flags, attributes will be
// compared case-insensitively, so a params string `attr=123&amp;Attr=456` will only
// return a single attribute–value pair, `Attr=456`. Case will be preserved in
// the returned attributes.
//
// If @params cannot be parsed (for example, it contains two @separators
// characters in a row), then @error is set and %NULL is returned.
func UriParseParams(ParamsVar string, LengthVar int, SeparatorsVar string, FlagsVar UriParamsFlags) (*HashTable, error) {
	var cerr *Error

	cret := xUriParseParams(ParamsVar, LengthVar, SeparatorsVar, FlagsVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriParseScheme func(string) string

// Gets the scheme portion of a URI string.
// [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
// as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include `file`, `https`, `svn+ssh`, etc.
func UriParseScheme(UriVar string) string {

	cret := xUriParseScheme(UriVar)

	return cret
}

var xUriPeekScheme func(string) string

// Gets the scheme portion of a URI string.
// [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
// as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include `file`, `https`, `svn+ssh`, etc.
//
// Unlike g_uri_parse_scheme(), the returned scheme is normalized to
// all-lowercase and does not need to be freed.
func UriPeekScheme(UriVar string) string {

	cret := xUriPeekScheme(UriVar)

	return cret
}

var xUriResolveRelative func(uintptr, string, UriFlags, **Error) string

// Parses @uri_ref according to @flags and, if it is a
// [relative URI](#relative-and-absolute-uris), resolves it relative to
// @base_uri_string. If the result is not a valid absolute URI, it will be
// discarded, and an error returned.
//
// (If @base_uri_string is %NULL, this just returns @uri_ref, or
// %NULL if @uri_ref is invalid or not absolute.)
func UriResolveRelative(BaseUriStringVar *string, UriRefVar string, FlagsVar UriFlags) (string, error) {
	var cerr *Error

	BaseUriStringVarPtr := core.GStrdupNullable(BaseUriStringVar)
	defer core.GFreeNullable(BaseUriStringVarPtr)

	cret := xUriResolveRelative(BaseUriStringVarPtr, UriRefVar, FlagsVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriSplit func(string, UriFlags, *string, *string, *string, *int, *string, *string, *string, **Error) bool

// Parses @uri_ref (which can be an
// [absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and
// returns the pieces. Any component that doesn't appear in @uri_ref will be
// returned as %NULL (but note that all URIs always have a path component,
// though it may be the empty string).
//
// If @flags contains %G_URI_FLAGS_ENCODED, then `%`-encoded characters in
// @uri_ref will remain encoded in the output strings. (If not,
// then all such characters will be decoded.) Note that decoding will
// only work if the URI components are ASCII or UTF-8, so you will
// need to use %G_URI_FLAGS_ENCODED if they are not.
//
// Note that the %G_URI_FLAGS_HAS_PASSWORD and
// %G_URI_FLAGS_HAS_AUTH_PARAMS @flags are ignored by g_uri_split(),
// since it always returns only the full userinfo; use
// g_uri_split_with_user() if you want it split up.
func UriSplit(UriRefVar string, FlagsVar UriFlags, SchemeVar *string, UserinfoVar *string, HostVar *string, PortVar *int, PathVar *string, QueryVar *string, FragmentVar *string) (bool, error) {
	var cerr *Error

	cret := xUriSplit(UriRefVar, FlagsVar, SchemeVar, UserinfoVar, HostVar, PortVar, PathVar, QueryVar, FragmentVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriSplitNetwork func(string, UriFlags, *string, *string, *int, **Error) bool

// Parses @uri_string (which must be an [absolute URI](#relative-and-absolute-uris))
// according to @flags, and returns the pieces relevant to connecting to a host.
// See the documentation for g_uri_split() for more details; this is
// mostly a wrapper around that function with simpler arguments.
// However, it will return an error if @uri_string is a relative URI,
// or does not contain a hostname component.
func UriSplitNetwork(UriStringVar string, FlagsVar UriFlags, SchemeVar *string, HostVar *string, PortVar *int) (bool, error) {
	var cerr *Error

	cret := xUriSplitNetwork(UriStringVar, FlagsVar, SchemeVar, HostVar, PortVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriSplitWithUser func(string, UriFlags, *string, *string, *string, *string, *string, *int, *string, *string, *string, **Error) bool

// Parses @uri_ref (which can be an
// [absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and
// returns the pieces. Any component that doesn't appear in @uri_ref will be
// returned as %NULL (but note that all URIs always have a path component,
// though it may be the empty string).
//
// See g_uri_split(), and the definition of #GUriFlags, for more
// information on the effect of @flags. Note that @password will only
// be parsed out if @flags contains %G_URI_FLAGS_HAS_PASSWORD, and
// @auth_params will only be parsed out if @flags contains
// %G_URI_FLAGS_HAS_AUTH_PARAMS.
func UriSplitWithUser(UriRefVar string, FlagsVar UriFlags, SchemeVar *string, UserVar *string, PasswordVar *string, AuthParamsVar *string, HostVar *string, PortVar *int, PathVar *string, QueryVar *string, FragmentVar *string) (bool, error) {
	var cerr *Error

	cret := xUriSplitWithUser(UriRefVar, FlagsVar, SchemeVar, UserVar, PasswordVar, AuthParamsVar, HostVar, PortVar, PathVar, QueryVar, FragmentVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriUnescapeBytes func(string, int, uintptr, **Error) *Bytes

// Unescapes a segment of an escaped string as binary data.
//
// Note that in contrast to g_uri_unescape_string(), this does allow
// nul bytes to appear in the output.
//
// If any of the characters in @illegal_characters appears as an escaped
// character in @escaped_string, then that is an error and %NULL will be
// returned. This is useful if you want to avoid for instance having a slash
// being expanded in an escaped path element, which might confuse pathname
// handling.
func UriUnescapeBytes(EscapedStringVar string, LengthVar int, IllegalCharactersVar *string) (*Bytes, error) {
	var cerr *Error

	IllegalCharactersVarPtr := core.GStrdupNullable(IllegalCharactersVar)
	defer core.GFreeNullable(IllegalCharactersVarPtr)

	cret := xUriUnescapeBytes(EscapedStringVar, LengthVar, IllegalCharactersVarPtr, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriUnescapeSegment func(uintptr, uintptr, uintptr) string

// Unescapes a segment of an escaped string.
//
// If any of the characters in @illegal_characters or the NUL
// character appears as an escaped character in @escaped_string, then
// that is an error and %NULL will be returned. This is useful if you
// want to avoid for instance having a slash being expanded in an
// escaped path element, which might confuse pathname handling.
//
// Note: `NUL` byte is not accepted in the output, in contrast to
// g_uri_unescape_bytes().
func UriUnescapeSegment(EscapedStringVar *string, EscapedStringEndVar *string, IllegalCharactersVar *string) string {

	EscapedStringVarPtr := core.GStrdupNullable(EscapedStringVar)
	defer core.GFreeNullable(EscapedStringVarPtr)

	EscapedStringEndVarPtr := core.GStrdupNullable(EscapedStringEndVar)
	defer core.GFreeNullable(EscapedStringEndVarPtr)

	IllegalCharactersVarPtr := core.GStrdupNullable(IllegalCharactersVar)
	defer core.GFreeNullable(IllegalCharactersVarPtr)

	cret := xUriUnescapeSegment(EscapedStringVarPtr, EscapedStringEndVarPtr, IllegalCharactersVarPtr)

	return cret
}

var xUriUnescapeString func(string, uintptr) string

// Unescapes a whole escaped string.
//
// If any of the characters in @illegal_characters or the NUL
// character appears as an escaped character in @escaped_string, then
// that is an error and %NULL will be returned. This is useful if you
// want to avoid for instance having a slash being expanded in an
// escaped path element, which might confuse pathname handling.
func UriUnescapeString(EscapedStringVar string, IllegalCharactersVar *string) string {

	IllegalCharactersVarPtr := core.GStrdupNullable(IllegalCharactersVar)
	defer core.GFreeNullable(IllegalCharactersVarPtr)

	cret := xUriUnescapeString(EscapedStringVar, IllegalCharactersVarPtr)

	return cret
}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xUriBuild, libs, "g_uri_build")
	core.PuregoSafeRegister(&xUriBuildWithUser, libs, "g_uri_build_with_user")
	core.PuregoSafeRegister(&xUriEscapeBytes, libs, "g_uri_escape_bytes")
	core.PuregoSafeRegister(&xUriEscapeString, libs, "g_uri_escape_string")
	core.PuregoSafeRegister(&xUriIsValid, libs, "g_uri_is_valid")
	core.PuregoSafeRegister(&xUriJoin, libs, "g_uri_join")
	core.PuregoSafeRegister(&xUriJoinWithUser, libs, "g_uri_join_with_user")
	core.PuregoSafeRegister(&xUriParse, libs, "g_uri_parse")
	core.PuregoSafeRegister(&xUriParseParams, libs, "g_uri_parse_params")
	core.PuregoSafeRegister(&xUriParseScheme, libs, "g_uri_parse_scheme")
	core.PuregoSafeRegister(&xUriPeekScheme, libs, "g_uri_peek_scheme")
	core.PuregoSafeRegister(&xUriResolveRelative, libs, "g_uri_resolve_relative")
	core.PuregoSafeRegister(&xUriSplit, libs, "g_uri_split")
	core.PuregoSafeRegister(&xUriSplitNetwork, libs, "g_uri_split_network")
	core.PuregoSafeRegister(&xUriSplitWithUser, libs, "g_uri_split_with_user")
	core.PuregoSafeRegister(&xUriUnescapeBytes, libs, "g_uri_unescape_bytes")
	core.PuregoSafeRegister(&xUriUnescapeSegment, libs, "g_uri_unescape_segment")
	core.PuregoSafeRegister(&xUriUnescapeString, libs, "g_uri_unescape_string")

	core.PuregoSafeRegister(&xUriGLibType, libs, "g_uri_get_type")

	core.PuregoSafeRegister(&xUriGetAuthParams, libs, "g_uri_get_auth_params")
	core.PuregoSafeRegister(&xUriGetFlags, libs, "g_uri_get_flags")
	core.PuregoSafeRegister(&xUriGetFragment, libs, "g_uri_get_fragment")
	core.PuregoSafeRegister(&xUriGetHost, libs, "g_uri_get_host")
	core.PuregoSafeRegister(&xUriGetPassword, libs, "g_uri_get_password")
	core.PuregoSafeRegister(&xUriGetPath, libs, "g_uri_get_path")
	core.PuregoSafeRegister(&xUriGetPort, libs, "g_uri_get_port")
	core.PuregoSafeRegister(&xUriGetQuery, libs, "g_uri_get_query")
	core.PuregoSafeRegister(&xUriGetScheme, libs, "g_uri_get_scheme")
	core.PuregoSafeRegister(&xUriGetUser, libs, "g_uri_get_user")
	core.PuregoSafeRegister(&xUriGetUserinfo, libs, "g_uri_get_userinfo")
	core.PuregoSafeRegister(&xUriParseRelative, libs, "g_uri_parse_relative")
	core.PuregoSafeRegister(&xUriRef, libs, "g_uri_ref")
	core.PuregoSafeRegister(&xUriToString, libs, "g_uri_to_string")
	core.PuregoSafeRegister(&xUriToStringPartial, libs, "g_uri_to_string_partial")
	core.PuregoSafeRegister(&xUriUnref, libs, "g_uri_unref")

	core.PuregoSafeRegister(&xUriParamsIterInit, libs, "g_uri_params_iter_init")
	core.PuregoSafeRegister(&xUriParamsIterNext, libs, "g_uri_params_iter_next")

}
