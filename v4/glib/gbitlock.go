// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
)

var xBitLock func(int, int)

// Sets the indicated @lock_bit in @address.  If the bit is already
// set, this call will block until g_bit_unlock() unsets the
// corresponding bit.
//
// Attempting to lock on two different bits within the same integer is
// not supported and will very probably cause deadlocks.
//
// The value of the bit that is set is (1u &lt;&lt; @bit).  If @bit is not
// between 0 and 31 then the result is undefined.
//
// This function accesses @address atomically.  All other accesses to
// @address must be atomic in order for this function to work
// reliably. While @address has a `volatile` qualifier, this is a historical
// artifact and the argument passed to it should not be `volatile`.
func BitLock(AddressVar int, LockBitVar int) {

	xBitLock(AddressVar, LockBitVar)

}

var xBitTrylock func(int, int) bool

// Sets the indicated @lock_bit in @address, returning %TRUE if
// successful.  If the bit is already set, returns %FALSE immediately.
//
// Attempting to lock on two different bits within the same integer is
// not supported.
//
// The value of the bit that is set is (1u &lt;&lt; @bit).  If @bit is not
// between 0 and 31 then the result is undefined.
//
// This function accesses @address atomically.  All other accesses to
// @address must be atomic in order for this function to work
// reliably. While @address has a `volatile` qualifier, this is a historical
// artifact and the argument passed to it should not be `volatile`.
func BitTrylock(AddressVar int, LockBitVar int) bool {

	cret := xBitTrylock(AddressVar, LockBitVar)
	return cret
}

var xBitUnlock func(int, int)

// Clears the indicated @lock_bit in @address.  If another thread is
// currently blocked in g_bit_lock() on this same bit then it will be
// woken up.
//
// This function accesses @address atomically.  All other accesses to
// @address must be atomic in order for this function to work
// reliably. While @address has a `volatile` qualifier, this is a historical
// artifact and the argument passed to it should not be `volatile`.
func BitUnlock(AddressVar int, LockBitVar int) {

	xBitUnlock(AddressVar, LockBitVar)

}

var xPointerBitLock func(uintptr, int)

// This is equivalent to g_bit_lock, but working on pointers (or other
// pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of
// the pointer.
//
// While @address has a `volatile` qualifier, this is a historical
// artifact and the argument passed to it should not be `volatile`.
func PointerBitLock(AddressVar uintptr, LockBitVar int) {

	xPointerBitLock(AddressVar, LockBitVar)

}

var xPointerBitLockAndGet func(uintptr, uint, uintptr)

// This is equivalent to g_bit_lock, but working on pointers (or other
// pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of
// the pointer.
func PointerBitLockAndGet(AddressVar uintptr, LockBitVar uint, OutPtrVar uintptr) {

	xPointerBitLockAndGet(AddressVar, LockBitVar, OutPtrVar)

}

var xPointerBitLockMaskPtr func(uintptr, uint, bool, uintptr, uintptr) uintptr

// This mangles @ptr as g_pointer_bit_lock() and g_pointer_bit_unlock()
// do.
func PointerBitLockMaskPtr(PtrVar uintptr, LockBitVar uint, SetVar bool, PreserveMaskVar uintptr, PreservePtrVar uintptr) uintptr {

	cret := xPointerBitLockMaskPtr(PtrVar, LockBitVar, SetVar, PreserveMaskVar, PreservePtrVar)
	return cret
}

var xPointerBitTrylock func(uintptr, int) bool

// This is equivalent to g_bit_trylock(), but working on pointers (or
// other pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of
// the pointer.
//
// While @address has a `volatile` qualifier, this is a historical
// artifact and the argument passed to it should not be `volatile`.
func PointerBitTrylock(AddressVar uintptr, LockBitVar int) bool {

	cret := xPointerBitTrylock(AddressVar, LockBitVar)
	return cret
}

var xPointerBitUnlock func(uintptr, int)

// This is equivalent to g_bit_unlock, but working on pointers (or other
// pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of
// the pointer.
//
// While @address has a `volatile` qualifier, this is a historical
// artifact and the argument passed to it should not be `volatile`.
func PointerBitUnlock(AddressVar uintptr, LockBitVar int) {

	xPointerBitUnlock(AddressVar, LockBitVar)

}

var xPointerBitUnlockAndSet func(uintptr, uint, uintptr, uintptr)

// This is equivalent to g_pointer_bit_unlock() and atomically setting
// the pointer value.
//
// Note that the lock bit will be cleared from the pointer. If the unlocked
// pointer that was set is not identical to @ptr, an assertion fails. In other
// words, @ptr must have @lock_bit unset. This also means, you usually can
// only use this on the lowest bits.
func PointerBitUnlockAndSet(AddressVar uintptr, LockBitVar uint, PtrVar uintptr, PreserveMaskVar uintptr) {

	xPointerBitUnlockAndSet(AddressVar, LockBitVar, PtrVar, PreserveMaskVar)

}

func init() {
	core.SetPackageName("GLIB", "glib-2.0")
	core.SetSharedLibraries("GLIB", []string{"libgobject-2.0.so.0", "libglib-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GLIB") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xBitLock, libs, "g_bit_lock")
	core.PuregoSafeRegister(&xBitTrylock, libs, "g_bit_trylock")
	core.PuregoSafeRegister(&xBitUnlock, libs, "g_bit_unlock")
	core.PuregoSafeRegister(&xPointerBitLock, libs, "g_pointer_bit_lock")
	core.PuregoSafeRegister(&xPointerBitLockAndGet, libs, "g_pointer_bit_lock_and_get")
	core.PuregoSafeRegister(&xPointerBitLockMaskPtr, libs, "g_pointer_bit_lock_mask_ptr")
	core.PuregoSafeRegister(&xPointerBitTrylock, libs, "g_pointer_bit_trylock")
	core.PuregoSafeRegister(&xPointerBitUnlock, libs, "g_pointer_bit_unlock")
	core.PuregoSafeRegister(&xPointerBitUnlockAndSet, libs, "g_pointer_bit_unlock_and_set")

}
