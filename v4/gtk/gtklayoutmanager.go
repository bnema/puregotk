// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `GtkLayoutManagerClass` structure contains only private data, and
// should only be accessed through the provided API, or when subclassing
// `GtkLayoutManager`.
type LayoutManagerClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xGetRequestMode uintptr

	xMeasure uintptr

	xAllocate uintptr

	LayoutChildType types.GType

	xCreateLayoutChild uintptr

	xRoot uintptr

	xUnroot uintptr

	Padding [16]uintptr
}

func (x *LayoutManagerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetRequestMode sets the "get_request_mode" callback function.
// a virtual function, used to return the preferred
//
//	request mode for the layout manager; for instance, "width for height"
//	or "height for width"; see `GtkSizeRequestMode`
func (x *LayoutManagerClass) OverrideGetRequestMode(cb func(*LayoutManager, *Widget) SizeRequestMode) {
	if cb == nil {
		x.xGetRequestMode = 0
	} else {
		x.xGetRequestMode = purego.NewCallback(func(ManagerVarp uintptr, WidgetVarp uintptr) SizeRequestMode {
			return cb(LayoutManagerNewFromInternalPtr(ManagerVarp), WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetGetRequestMode gets the "get_request_mode" callback function.
// a virtual function, used to return the preferred
//
//	request mode for the layout manager; for instance, "width for height"
//	or "height for width"; see `GtkSizeRequestMode`
func (x *LayoutManagerClass) GetGetRequestMode() func(*LayoutManager, *Widget) SizeRequestMode {
	if x.xGetRequestMode == 0 {
		return nil
	}
	var rawCallback func(ManagerVarp uintptr, WidgetVarp uintptr) SizeRequestMode
	purego.RegisterFunc(&rawCallback, x.xGetRequestMode)
	return func(ManagerVar *LayoutManager, WidgetVar *Widget) SizeRequestMode {
		return rawCallback(ManagerVar.GoPointer(), WidgetVar.GoPointer())
	}
}

// OverrideMeasure sets the "measure" callback function.
// a virtual function, used to measure the minimum and preferred
//
//	sizes of the widget using the layout manager for a given orientation
func (x *LayoutManagerClass) OverrideMeasure(cb func(*LayoutManager, *Widget, Orientation, int, *int, *int, *int, *int)) {
	if cb == nil {
		x.xMeasure = 0
	} else {
		x.xMeasure = purego.NewCallback(func(ManagerVarp uintptr, WidgetVarp uintptr, OrientationVarp Orientation, ForSizeVarp int, MinimumVarp *int, NaturalVarp *int, MinimumBaselineVarp *int, NaturalBaselineVarp *int) {
			cb(LayoutManagerNewFromInternalPtr(ManagerVarp), WidgetNewFromInternalPtr(WidgetVarp), OrientationVarp, ForSizeVarp, MinimumVarp, NaturalVarp, MinimumBaselineVarp, NaturalBaselineVarp)
		})
	}
}

// GetMeasure gets the "measure" callback function.
// a virtual function, used to measure the minimum and preferred
//
//	sizes of the widget using the layout manager for a given orientation
func (x *LayoutManagerClass) GetMeasure() func(*LayoutManager, *Widget, Orientation, int, *int, *int, *int, *int) {
	if x.xMeasure == 0 {
		return nil
	}
	var rawCallback func(ManagerVarp uintptr, WidgetVarp uintptr, OrientationVarp Orientation, ForSizeVarp int, MinimumVarp *int, NaturalVarp *int, MinimumBaselineVarp *int, NaturalBaselineVarp *int)
	purego.RegisterFunc(&rawCallback, x.xMeasure)
	return func(ManagerVar *LayoutManager, WidgetVar *Widget, OrientationVar Orientation, ForSizeVar int, MinimumVar *int, NaturalVar *int, MinimumBaselineVar *int, NaturalBaselineVar *int) {
		rawCallback(ManagerVar.GoPointer(), WidgetVar.GoPointer(), OrientationVar, ForSizeVar, MinimumVar, NaturalVar, MinimumBaselineVar, NaturalBaselineVar)
	}
}

// OverrideAllocate sets the "allocate" callback function.
// a virtual function, used to allocate the size of the widget
//
//	using the layout manager
func (x *LayoutManagerClass) OverrideAllocate(cb func(*LayoutManager, *Widget, int, int, int)) {
	if cb == nil {
		x.xAllocate = 0
	} else {
		x.xAllocate = purego.NewCallback(func(ManagerVarp uintptr, WidgetVarp uintptr, WidthVarp int, HeightVarp int, BaselineVarp int) {
			cb(LayoutManagerNewFromInternalPtr(ManagerVarp), WidgetNewFromInternalPtr(WidgetVarp), WidthVarp, HeightVarp, BaselineVarp)
		})
	}
}

// GetAllocate gets the "allocate" callback function.
// a virtual function, used to allocate the size of the widget
//
//	using the layout manager
func (x *LayoutManagerClass) GetAllocate() func(*LayoutManager, *Widget, int, int, int) {
	if x.xAllocate == 0 {
		return nil
	}
	var rawCallback func(ManagerVarp uintptr, WidgetVarp uintptr, WidthVarp int, HeightVarp int, BaselineVarp int)
	purego.RegisterFunc(&rawCallback, x.xAllocate)
	return func(ManagerVar *LayoutManager, WidgetVar *Widget, WidthVar int, HeightVar int, BaselineVar int) {
		rawCallback(ManagerVar.GoPointer(), WidgetVar.GoPointer(), WidthVar, HeightVar, BaselineVar)
	}
}

// OverrideCreateLayoutChild sets the "create_layout_child" callback function.
// a virtual function, used to create a `GtkLayoutChild`
//
//	meta object for the layout properties
func (x *LayoutManagerClass) OverrideCreateLayoutChild(cb func(*LayoutManager, *Widget, *Widget) *LayoutChild) {
	if cb == nil {
		x.xCreateLayoutChild = 0
	} else {
		x.xCreateLayoutChild = purego.NewCallback(func(ManagerVarp uintptr, WidgetVarp uintptr, ForChildVarp uintptr) uintptr {
			ret := cb(LayoutManagerNewFromInternalPtr(ManagerVarp), WidgetNewFromInternalPtr(WidgetVarp), WidgetNewFromInternalPtr(ForChildVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetCreateLayoutChild gets the "create_layout_child" callback function.
// a virtual function, used to create a `GtkLayoutChild`
//
//	meta object for the layout properties
func (x *LayoutManagerClass) GetCreateLayoutChild() func(*LayoutManager, *Widget, *Widget) *LayoutChild {
	if x.xCreateLayoutChild == 0 {
		return nil
	}
	var rawCallback func(ManagerVarp uintptr, WidgetVarp uintptr, ForChildVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xCreateLayoutChild)
	return func(ManagerVar *LayoutManager, WidgetVar *Widget, ForChildVar *Widget) *LayoutChild {
		rawRet := rawCallback(ManagerVar.GoPointer(), WidgetVar.GoPointer(), ForChildVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &LayoutChild{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideRoot sets the "root" callback function.
// a virtual function, called when the widget using the layout
//
//	manager is attached to a `GtkRoot`
func (x *LayoutManagerClass) OverrideRoot(cb func(*LayoutManager)) {
	if cb == nil {
		x.xRoot = 0
	} else {
		x.xRoot = purego.NewCallback(func(ManagerVarp uintptr) {
			cb(LayoutManagerNewFromInternalPtr(ManagerVarp))
		})
	}
}

// GetRoot gets the "root" callback function.
// a virtual function, called when the widget using the layout
//
//	manager is attached to a `GtkRoot`
func (x *LayoutManagerClass) GetRoot() func(*LayoutManager) {
	if x.xRoot == 0 {
		return nil
	}
	var rawCallback func(ManagerVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRoot)
	return func(ManagerVar *LayoutManager) {
		rawCallback(ManagerVar.GoPointer())
	}
}

// OverrideUnroot sets the "unroot" callback function.
// a virtual function, called when the widget using the layout
//
//	manager is detached from a `GtkRoot`
func (x *LayoutManagerClass) OverrideUnroot(cb func(*LayoutManager)) {
	if cb == nil {
		x.xUnroot = 0
	} else {
		x.xUnroot = purego.NewCallback(func(ManagerVarp uintptr) {
			cb(LayoutManagerNewFromInternalPtr(ManagerVarp))
		})
	}
}

// GetUnroot gets the "unroot" callback function.
// a virtual function, called when the widget using the layout
//
//	manager is detached from a `GtkRoot`
func (x *LayoutManagerClass) GetUnroot() func(*LayoutManager) {
	if x.xUnroot == 0 {
		return nil
	}
	var rawCallback func(ManagerVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnroot)
	return func(ManagerVar *LayoutManager) {
		rawCallback(ManagerVar.GoPointer())
	}
}

// Handles the preferred size and allocation for children of a widget.
//
// You typically subclass `GtkLayoutManager` if you want to implement a
// layout policy for the children of a widget, or if you want to determine
// the size of a widget depending on its contents.
//
// Each `GtkWidget` can only have a `GtkLayoutManager` instance associated
// to it at any given time; it is possible, though, to replace the layout
// manager instance using [method@Gtk.Widget.set_layout_manager].
//
// ## Layout properties
//
// A layout manager can expose properties for controlling the layout of
// each child, by creating an object type derived from [class@Gtk.LayoutChild]
// and installing the properties on it as normal `GObject` properties.
//
// Each `GtkLayoutChild` instance storing the layout properties for a
// specific child is created through the [method@Gtk.LayoutManager.get_layout_child]
// method; a `GtkLayoutManager` controls the creation of its `GtkLayoutChild`
// instances by overriding the GtkLayoutManagerClass.create_layout_child()
// virtual function. The typical implementation should look like:
//
// ```c
// static GtkLayoutChild *
// create_layout_child (GtkLayoutManager *manager,
//
//	GtkWidget        *container,
//	GtkWidget        *child)
//
//	{
//	  return g_object_new (your_layout_child_get_type (),
//	                       "layout-manager", manager,
//	                       "child-widget", child,
//	                       NULL);
//	}
//
// ```
//
// The [property@Gtk.LayoutChild:layout-manager] and
// [property@Gtk.LayoutChild:child-widget] properties
// on the newly created `GtkLayoutChild` instance are mandatory. The
// `GtkLayoutManager` will cache the newly created `GtkLayoutChild` instance
// until the widget is removed from its parent, or the parent removes the
// layout manager.
//
// Each `GtkLayoutManager` instance creating a `GtkLayoutChild` should use
// [method@Gtk.LayoutManager.get_layout_child] every time it needs to query
// the layout properties; each `GtkLayoutChild` instance should call
// [method@Gtk.LayoutManager.layout_changed] every time a property is
// updated, in order to queue a new size measuring and allocation.
type LayoutManager struct {
	gobject.Object
}

var xLayoutManagerGLibType func() types.GType

func LayoutManagerGLibType() types.GType {
	return xLayoutManagerGLibType()
}

func LayoutManagerNewFromInternalPtr(ptr uintptr) *LayoutManager {
	cls := &LayoutManager{}
	cls.Ptr = ptr
	return cls
}

var xLayoutManagerAllocate func(uintptr, uintptr, int, int, int)

// Assigns the given @width, @height, and @baseline to
// a @widget, and computes the position and sizes of the children of
// the @widget using the layout management policy of @manager.
func (x *LayoutManager) Allocate(WidgetVar *Widget, WidthVar int, HeightVar int, BaselineVar int) {

	xLayoutManagerAllocate(x.GoPointer(), WidgetVar.GoPointer(), WidthVar, HeightVar, BaselineVar)

}

var xLayoutManagerGetLayoutChild func(uintptr, uintptr) uintptr

// Retrieves a `GtkLayoutChild` instance for the `GtkLayoutManager`,
// creating one if necessary.
//
// The @child widget must be a child of the widget using @manager.
//
// The `GtkLayoutChild` instance is owned by the `GtkLayoutManager`,
// and is guaranteed to exist as long as @child is a child of the
// `GtkWidget` using the given `GtkLayoutManager`.
func (x *LayoutManager) GetLayoutChild(ChildVar *Widget) *LayoutChild {
	var cls *LayoutChild

	cret := xLayoutManagerGetLayoutChild(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &LayoutChild{}
	cls.Ptr = cret
	return cls
}

var xLayoutManagerGetRequestMode func(uintptr) SizeRequestMode

// Retrieves the request mode of @manager.
func (x *LayoutManager) GetRequestMode() SizeRequestMode {

	cret := xLayoutManagerGetRequestMode(x.GoPointer())

	return cret
}

var xLayoutManagerGetWidget func(uintptr) uintptr

// Retrieves the `GtkWidget` using the given `GtkLayoutManager`.
func (x *LayoutManager) GetWidget() *Widget {
	var cls *Widget

	cret := xLayoutManagerGetWidget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xLayoutManagerLayoutChanged func(uintptr)

// Queues a resize on the `GtkWidget` using @manager, if any.
//
// This function should be called by subclasses of `GtkLayoutManager`
// in response to changes to their layout management policies.
func (x *LayoutManager) LayoutChanged() {

	xLayoutManagerLayoutChanged(x.GoPointer())

}

var xLayoutManagerMeasure func(uintptr, uintptr, Orientation, int, *int, *int, *int, *int)

// Measures the size of the @widget using @manager, for the
// given @orientation and size.
//
// See the [class@Gtk.Widget] documentation on layout management for
// more details.
func (x *LayoutManager) Measure(WidgetVar *Widget, OrientationVar Orientation, ForSizeVar int, MinimumVar *int, NaturalVar *int, MinimumBaselineVar *int, NaturalBaselineVar *int) {

	xLayoutManagerMeasure(x.GoPointer(), WidgetVar.GoPointer(), OrientationVar, ForSizeVar, MinimumVar, NaturalVar, MinimumBaselineVar, NaturalBaselineVar)

}

func (c *LayoutManager) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *LayoutManager) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xLayoutManagerGLibType, libs, "gtk_layout_manager_get_type")

	core.PuregoSafeRegister(&xLayoutManagerAllocate, libs, "gtk_layout_manager_allocate")
	core.PuregoSafeRegister(&xLayoutManagerGetLayoutChild, libs, "gtk_layout_manager_get_layout_child")
	core.PuregoSafeRegister(&xLayoutManagerGetRequestMode, libs, "gtk_layout_manager_get_request_mode")
	core.PuregoSafeRegister(&xLayoutManagerGetWidget, libs, "gtk_layout_manager_get_widget")
	core.PuregoSafeRegister(&xLayoutManagerLayoutChanged, libs, "gtk_layout_manager_layout_changed")
	core.PuregoSafeRegister(&xLayoutManagerMeasure, libs, "gtk_layout_manager_measure")

}
