// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type ComboBoxClass struct {
	_ structs.HostLayout

	ParentClass WidgetClass

	xChanged uintptr

	xFormatEntryText uintptr

	xActivate uintptr

	Padding [7]uintptr
}

func (x *ComboBoxClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideChanged sets the "changed" callback function.
// Signal is emitted when the active item is changed.
func (x *ComboBoxClass) OverrideChanged(cb func(*ComboBox)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(ComboBoxVarp uintptr) {
			cb(ComboBoxNewFromInternalPtr(ComboBoxVarp))
		})
	}
}

// GetChanged gets the "changed" callback function.
// Signal is emitted when the active item is changed.
func (x *ComboBoxClass) GetChanged() func(*ComboBox) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(ComboBoxVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(ComboBoxVar *ComboBox) {
		rawCallback(ComboBoxVar.GoPointer())
	}
}

// OverrideFormatEntryText sets the "format_entry_text" callback function.
// Signal which allows you to change how the text
//
//	displayed in a combo box’s entry is displayed.
func (x *ComboBoxClass) OverrideFormatEntryText(cb func(*ComboBox, string) string) {
	if cb == nil {
		x.xFormatEntryText = 0
	} else {
		x.xFormatEntryText = purego.NewCallback(func(ComboBoxVarp uintptr, PathVarp string) string {
			return cb(ComboBoxNewFromInternalPtr(ComboBoxVarp), PathVarp)
		})
	}
}

// GetFormatEntryText gets the "format_entry_text" callback function.
// Signal which allows you to change how the text
//
//	displayed in a combo box’s entry is displayed.
func (x *ComboBoxClass) GetFormatEntryText() func(*ComboBox, string) string {
	if x.xFormatEntryText == 0 {
		return nil
	}
	var rawCallback func(ComboBoxVarp uintptr, PathVarp string) string
	purego.RegisterFunc(&rawCallback, x.xFormatEntryText)
	return func(ComboBoxVar *ComboBox, PathVar string) string {
		return rawCallback(ComboBoxVar.GoPointer(), PathVar)
	}
}

// OverrideActivate sets the "activate" callback function.
func (x *ComboBoxClass) OverrideActivate(cb func(*ComboBox)) {
	if cb == nil {
		x.xActivate = 0
	} else {
		x.xActivate = purego.NewCallback(func(ComboBoxVarp uintptr) {
			cb(ComboBoxNewFromInternalPtr(ComboBoxVarp))
		})
	}
}

// GetActivate gets the "activate" callback function.
func (x *ComboBoxClass) GetActivate() func(*ComboBox) {
	if x.xActivate == 0 {
		return nil
	}
	var rawCallback func(ComboBoxVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xActivate)
	return func(ComboBoxVar *ComboBox) {
		rawCallback(ComboBoxVar.GoPointer())
	}
}

// A `GtkComboBox` is a widget that allows the user to choose from a list of
// valid choices.
//
// &lt;picture&gt;
//
//	&lt;source srcset="combo-box-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkComboBox" src="combo-box.png"&gt;
//
// &lt;/picture&gt;
//
// The `GtkComboBox` displays the selected choice; when activated, the
// `GtkComboBox` displays a popup which allows the user to make a new choice.
//
// The `GtkComboBox` uses the model-view pattern; the list of valid choices
// is specified in the form of a tree model, and the display of the choices
// can be adapted to the data in the model by using cell renderers, as you
// would in a tree view. This is possible since `GtkComboBox` implements the
// [iface@Gtk.CellLayout] interface. The tree model holding the valid
// choices is not restricted to a flat list, it can be a real tree, and the
// popup will reflect the tree structure.
//
// To allow the user to enter values not in the model, the
// [property@Gtk.ComboBox:has-entry] property allows the `GtkComboBox` to
// contain a [class@Gtk.Entry]. This entry can be accessed by calling
// [method@Gtk.ComboBox.get_child] on the combo box.
//
// For a simple list of textual choices, the model-view API of `GtkComboBox`
// can be a bit overwhelming. In this case, [class@Gtk.ComboBoxText] offers
// a simple alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain
// an entry.
//
// ## CSS nodes
//
// ```
// combobox
// ├── box.linked
// │   ╰── button.combo
// │       ╰── box
// │           ├── cellview
// │           ╰── arrow
// ╰── window.popup
// ```
//
// A normal combobox contains a box with the .linked class, a button
// with the .combo class and inside those buttons, there are a cellview and
// an arrow.
//
// ```
// combobox
// ├── box.linked
// │   ├── entry.combo
// │   ╰── button.combo
// │       ╰── box
// │           ╰── arrow
// ╰── window.popup
// ```
//
// A `GtkComboBox` with an entry has a single CSS node with name combobox.
// It contains a box with the .linked class. That box contains an entry and
// a button, both with the .combo class added. The button also contains another
// node with name arrow.
//
// ## Accessibility
//
// `GtkComboBox` uses the [enum@Gtk.AccessibleRole.combo_box] role.
type ComboBox struct {
	Widget
}

var xComboBoxGLibType func() types.GType

func ComboBoxGLibType() types.GType {
	return xComboBoxGLibType()
}

func ComboBoxNewFromInternalPtr(ptr uintptr) *ComboBox {
	cls := &ComboBox{}
	cls.Ptr = ptr
	return cls
}

var xNewComboBox func() uintptr

// Creates a new empty `GtkComboBox`.
func NewComboBox() *ComboBox {
	var cls *ComboBox

	cret := xNewComboBox()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ComboBox{}
	cls.Ptr = cret
	return cls
}

var xNewComboBoxWithEntry func() uintptr

// Creates a new empty `GtkComboBox` with an entry.
//
// In order to use a combo box with entry, you need to tell it
// which column of the model contains the text for the entry
// by calling [method@Gtk.ComboBox.set_entry_text_column].
func NewComboBoxWithEntry() *ComboBox {
	var cls *ComboBox

	cret := xNewComboBoxWithEntry()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ComboBox{}
	cls.Ptr = cret
	return cls
}

var xNewComboBoxWithModel func(uintptr) uintptr

// Creates a new `GtkComboBox` with a model.
func NewComboBoxWithModel(ModelVar TreeModel) *ComboBox {
	var cls *ComboBox

	cret := xNewComboBoxWithModel(ModelVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ComboBox{}
	cls.Ptr = cret
	return cls
}

var xNewComboBoxWithModelAndEntry func(uintptr) uintptr

// Creates a new empty `GtkComboBox` with an entry and a model.
//
// See also [ctor@Gtk.ComboBox.new_with_entry].
func NewComboBoxWithModelAndEntry(ModelVar TreeModel) *ComboBox {
	var cls *ComboBox

	cret := xNewComboBoxWithModelAndEntry(ModelVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ComboBox{}
	cls.Ptr = cret
	return cls
}

var xComboBoxGetActive func(uintptr) int

// Returns the index of the currently active item.
//
// If the model is a non-flat treemodel, and the active item is not
// an immediate child of the root of the tree, this function returns
// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
// [struct@Gtk.TreePath] of the active item.
func (x *ComboBox) GetActive() int {

	cret := xComboBoxGetActive(x.GoPointer())

	return cret
}

var xComboBoxGetActiveId func(uintptr) string

// Returns the ID of the active row of @combo_box.
//
// This value is taken from the active row and the column specified
// by the [property@Gtk.ComboBox:id-column] property of @combo_box
// (see [method@Gtk.ComboBox.set_id_column]).
//
// The returned value is an interned string which means that you can
// compare the pointer by value to other interned strings and that you
// must not free it.
//
// If the [property@Gtk.ComboBox:id-column] property of @combo_box is
// not set, or if no row is active, or if the active row has a %NULL
// ID value, then %NULL is returned.
func (x *ComboBox) GetActiveId() string {

	cret := xComboBoxGetActiveId(x.GoPointer())

	return cret
}

var xComboBoxGetActiveIter func(uintptr, *TreeIter) bool

// Sets @iter to point to the currently active item.
//
// If no item is active, @iter is left unchanged.
func (x *ComboBox) GetActiveIter(IterVar *TreeIter) bool {

	cret := xComboBoxGetActiveIter(x.GoPointer(), IterVar)

	return cret
}

var xComboBoxGetButtonSensitivity func(uintptr) SensitivityType

// Returns whether the combo box sets the dropdown button
// sensitive or not when there are no items in the model.
func (x *ComboBox) GetButtonSensitivity() SensitivityType {

	cret := xComboBoxGetButtonSensitivity(x.GoPointer())

	return cret
}

var xComboBoxGetChild func(uintptr) uintptr

// Gets the child widget of @combo_box.
func (x *ComboBox) GetChild() *Widget {
	var cls *Widget

	cret := xComboBoxGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xComboBoxGetEntryTextColumn func(uintptr) int

// Returns the column which @combo_box is using to get the strings
// from to display in the internal entry.
func (x *ComboBox) GetEntryTextColumn() int {

	cret := xComboBoxGetEntryTextColumn(x.GoPointer())

	return cret
}

var xComboBoxGetHasEntry func(uintptr) bool

// Returns whether the combo box has an entry.
func (x *ComboBox) GetHasEntry() bool {

	cret := xComboBoxGetHasEntry(x.GoPointer())

	return cret
}

var xComboBoxGetIdColumn func(uintptr) int

// Returns the column which @combo_box is using to get string IDs
// for values from.
func (x *ComboBox) GetIdColumn() int {

	cret := xComboBoxGetIdColumn(x.GoPointer())

	return cret
}

var xComboBoxGetModel func(uintptr) uintptr

// Returns the `GtkTreeModel` of @combo_box.
func (x *ComboBox) GetModel() *TreeModelBase {
	var cls *TreeModelBase

	cret := xComboBoxGetModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeModelBase{}
	cls.Ptr = cret
	return cls
}

var xComboBoxGetPopupFixedWidth func(uintptr) bool

// Gets whether the popup uses a fixed width.
func (x *ComboBox) GetPopupFixedWidth() bool {

	cret := xComboBoxGetPopupFixedWidth(x.GoPointer())

	return cret
}

var xComboBoxGetRowSeparatorFunc func(uintptr) uintptr

// Returns the current row separator function.
func (x *ComboBox) GetRowSeparatorFunc() uintptr {

	cret := xComboBoxGetRowSeparatorFunc(x.GoPointer())

	return cret
}

var xComboBoxPopdown func(uintptr)

// Hides the menu or dropdown list of @combo_box.
//
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
func (x *ComboBox) Popdown() {

	xComboBoxPopdown(x.GoPointer())

}

var xComboBoxPopup func(uintptr)

// Pops up the menu or dropdown list of @combo_box.
//
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
//
// Before calling this, @combo_box must be mapped, or nothing will happen.
func (x *ComboBox) Popup() {

	xComboBoxPopup(x.GoPointer())

}

var xComboBoxPopupForDevice func(uintptr, uintptr)

// Pops up the menu of @combo_box.
//
// Note that currently this does not do anything with the device, as it was
// previously only used for list-mode combo boxes, and those were removed
// in GTK 4. However, it is retained in case similar functionality is added
// back later.
func (x *ComboBox) PopupForDevice(DeviceVar *gdk.Device) {

	xComboBoxPopupForDevice(x.GoPointer(), DeviceVar.GoPointer())

}

var xComboBoxSetActive func(uintptr, int)

// Sets the active item of @combo_box to be the item at @index.
func (x *ComboBox) SetActive(IndexVar int) {

	xComboBoxSetActive(x.GoPointer(), IndexVar)

}

var xComboBoxSetActiveId func(uintptr, uintptr) bool

// Changes the active row of @combo_box to the one that has an ID equal to
// @active_id.
//
// If @active_id is %NULL, the active row is unset. Rows having
// a %NULL ID string cannot be made active by this function.
//
// If the [property@Gtk.ComboBox:id-column] property of @combo_box is
// unset or if no row has the given ID then the function does nothing
// and returns %FALSE.
func (x *ComboBox) SetActiveId(ActiveIdVar *string) bool {

	ActiveIdVarPtr, ActiveIdVarBytes := core.NullableStringToPtr(ActiveIdVar)

	cret := xComboBoxSetActiveId(x.GoPointer(), ActiveIdVarPtr)

	runtime.KeepAlive(ActiveIdVarBytes)

	return cret
}

var xComboBoxSetActiveIter func(uintptr, *TreeIter)

// Sets the current active item to be the one referenced by @iter.
//
// If @iter is %NULL, the active item is unset.
func (x *ComboBox) SetActiveIter(IterVar *TreeIter) {

	xComboBoxSetActiveIter(x.GoPointer(), IterVar)

}

var xComboBoxSetButtonSensitivity func(uintptr, SensitivityType)

// Sets whether the dropdown button of the combo box should update
// its sensitivity depending on the model contents.
func (x *ComboBox) SetButtonSensitivity(SensitivityVar SensitivityType) {

	xComboBoxSetButtonSensitivity(x.GoPointer(), SensitivityVar)

}

var xComboBoxSetChild func(uintptr, uintptr)

// Sets the child widget of @combo_box.
func (x *ComboBox) SetChild(ChildVar *Widget) {

	xComboBoxSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xComboBoxSetEntryTextColumn func(uintptr, int)

// Sets the model column which @combo_box should use to get strings
// from to be @text_column.
//
// For this column no separate
// [class@Gtk.CellRenderer] is needed.
//
// The column @text_column in the model of @combo_box must be of
// type %G_TYPE_STRING.
//
// This is only relevant if @combo_box has been created with
// [property@Gtk.ComboBox:has-entry] as %TRUE.
func (x *ComboBox) SetEntryTextColumn(TextColumnVar int) {

	xComboBoxSetEntryTextColumn(x.GoPointer(), TextColumnVar)

}

var xComboBoxSetIdColumn func(uintptr, int)

// Sets the model column which @combo_box should use to get string IDs
// for values from.
//
// The column @id_column in the model of @combo_box must be of type
// %G_TYPE_STRING.
func (x *ComboBox) SetIdColumn(IdColumnVar int) {

	xComboBoxSetIdColumn(x.GoPointer(), IdColumnVar)

}

var xComboBoxSetModel func(uintptr, uintptr)

// Sets the model used by @combo_box to be @model.
//
// Will unset a previously set model (if applicable). If model is %NULL,
// then it will unset the model.
//
// Note that this function does not clear the cell renderers, you have to
// call [method@Gtk.CellLayout.clear] yourself if you need to set up different
// cell renderers for the new model.
func (x *ComboBox) SetModel(ModelVar TreeModel) {

	xComboBoxSetModel(x.GoPointer(), ModelVar.GoPointer())

}

var xComboBoxSetPopupFixedWidth func(uintptr, bool)

// Specifies whether the popup’s width should be a fixed width.
//
// If @fixed is %TRUE, the popup's width is set to match the
// allocated width of the combo box.
func (x *ComboBox) SetPopupFixedWidth(FixedVar bool) {

	xComboBoxSetPopupFixedWidth(x.GoPointer(), FixedVar)

}

var xComboBoxSetRowSeparatorFunc func(uintptr, uintptr, uintptr, uintptr)

// Sets the row separator function, which is used to determine
// whether a row should be drawn as a separator.
//
// If the row separator function is %NULL, no separators are drawn.
// This is the default value.
func (x *ComboBox) SetRowSeparatorFunc(FuncVar *TreeViewRowSeparatorFunc, DataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := glib.GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 *TreeIter, arg2 uintptr) bool {
				cbFn := *FuncVar
				return cbFn(arg0, arg1, arg2)
			}
			FuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(FuncVarPtr, FuncVarRef, FuncVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	xComboBoxSetRowSeparatorFunc(x.GoPointer(), FuncVarRef, DataVar, DestroyVarRef)

}

func (c *ComboBox) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *ComboBox) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyActive sets the "active" property.
// The item which is currently active.
//
// If the model is a non-flat treemodel, and the active item is not an
// immediate child of the root of the tree, this property has the value
// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
// [struct@Gtk.TreePath] of the active item.
func (x *ComboBox) SetPropertyActive(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("active", &v)
}

// GetPropertyActive gets the "active" property.
// The item which is currently active.
//
// If the model is a non-flat treemodel, and the active item is not an
// immediate child of the root of the tree, this property has the value
// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
// [struct@Gtk.TreePath] of the active item.
func (x *ComboBox) GetPropertyActive() int {
	var v gobject.Value
	x.GetProperty("active", &v)
	return v.GetInt()
}

// SetPropertyActiveId sets the "active-id" property.
// The value of the ID column of the active row.
func (x *ComboBox) SetPropertyActiveId(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("active-id", &v)
}

// GetPropertyActiveId gets the "active-id" property.
// The value of the ID column of the active row.
func (x *ComboBox) GetPropertyActiveId() string {
	var v gobject.Value
	x.GetProperty("active-id", &v)
	return v.GetString()
}

// SetPropertyEntryTextColumn sets the "entry-text-column" property.
// The model column to associate with strings from the entry.
//
// This is property only relevant if the combo was created with
// [property@Gtk.ComboBox:has-entry] is %TRUE.
func (x *ComboBox) SetPropertyEntryTextColumn(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("entry-text-column", &v)
}

// GetPropertyEntryTextColumn gets the "entry-text-column" property.
// The model column to associate with strings from the entry.
//
// This is property only relevant if the combo was created with
// [property@Gtk.ComboBox:has-entry] is %TRUE.
func (x *ComboBox) GetPropertyEntryTextColumn() int {
	var v gobject.Value
	x.GetProperty("entry-text-column", &v)
	return v.GetInt()
}

// SetPropertyHasEntry sets the "has-entry" property.
// Whether the combo box has an entry.
func (x *ComboBox) SetPropertyHasEntry(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("has-entry", &v)
}

// GetPropertyHasEntry gets the "has-entry" property.
// Whether the combo box has an entry.
func (x *ComboBox) GetPropertyHasEntry() bool {
	var v gobject.Value
	x.GetProperty("has-entry", &v)
	return v.GetBoolean()
}

// SetPropertyHasFrame sets the "has-frame" property.
// The `has-frame` property controls whether a frame is drawn around the entry.
func (x *ComboBox) SetPropertyHasFrame(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("has-frame", &v)
}

// GetPropertyHasFrame gets the "has-frame" property.
// The `has-frame` property controls whether a frame is drawn around the entry.
func (x *ComboBox) GetPropertyHasFrame() bool {
	var v gobject.Value
	x.GetProperty("has-frame", &v)
	return v.GetBoolean()
}

// SetPropertyIdColumn sets the "id-column" property.
// The model column that provides string IDs for the values
// in the model, if != -1.
func (x *ComboBox) SetPropertyIdColumn(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("id-column", &v)
}

// GetPropertyIdColumn gets the "id-column" property.
// The model column that provides string IDs for the values
// in the model, if != -1.
func (x *ComboBox) GetPropertyIdColumn() int {
	var v gobject.Value
	x.GetProperty("id-column", &v)
	return v.GetInt()
}

// SetPropertyPopupFixedWidth sets the "popup-fixed-width" property.
// Whether the popup's width should be a fixed width matching the
// allocated width of the combo box.
func (x *ComboBox) SetPropertyPopupFixedWidth(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("popup-fixed-width", &v)
}

// GetPropertyPopupFixedWidth gets the "popup-fixed-width" property.
// Whether the popup's width should be a fixed width matching the
// allocated width of the combo box.
func (x *ComboBox) GetPropertyPopupFixedWidth() bool {
	var v gobject.Value
	x.GetProperty("popup-fixed-width", &v)
	return v.GetBoolean()
}

// GetPropertyPopupShown gets the "popup-shown" property.
// Whether the combo boxes dropdown is popped up.
//
// Note that this property is mainly useful, because
// it allows you to connect to notify::popup-shown.
func (x *ComboBox) GetPropertyPopupShown() bool {
	var v gobject.Value
	x.GetProperty("popup-shown", &v)
	return v.GetBoolean()
}

// Emitted to when the combo box is activated.
//
// The `::activate` signal on `GtkComboBox` is an action signal and
// emitting it causes the combo box to pop up its dropdown.
func (x *ComboBox) ConnectActivate(cb *func(ComboBox)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ComboBox{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// Emitted when the active item is changed.
//
// The can be due to the user selecting a different item from the list,
// or due to a call to [method@Gtk.ComboBox.set_active_iter]. It will
// also be emitted while typing into the entry of a combo box with an entry.
func (x *ComboBox) ConnectChanged(cb *func(ComboBox)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ComboBox{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

// Emitted to allow changing how the text in a combo box's entry is displayed.
//
// See [property@Gtk.ComboBox:has-entry].
//
// Connect a signal handler which returns an allocated string representing
// @path. That string will then be used to set the text in the combo box's
// entry. The default signal handler uses the text from the
// [property@Gtk.ComboBox:entry-text-column] model column.
//
// Here's an example signal handler which fetches data from the model and
// displays it in the entry.
// ```c
// static char *
// format_entry_text_callback (GtkComboBox *combo,
//
//	const char *path,
//	gpointer     user_data)
//
//	{
//	  GtkTreeIter iter;
//	  GtkTreeModel model;
//	  double       value;
//
//	  model = gtk_combo_box_get_model (combo);
//
//	  gtk_tree_model_get_iter_from_string (model, &amp;iter, path);
//	  gtk_tree_model_get (model, &amp;iter,
//	                      THE_DOUBLE_VALUE_COLUMN, &amp;value,
//	                      -1);
//
//	  return g_strdup_printf ("%g", value);
//	}
//
// ```
func (x *ComboBox) ConnectFormatEntryText(cb *func(ComboBox, string) string) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "format-entry-text", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PathVarp string) string {
		fa := ComboBox{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "format-entry-text", cbRefPtr)
}

// Emitted to move the active selection.
//
// This is an [keybinding signal](class.SignalAction.html).
func (x *ComboBox) ConnectMoveActive(cb *func(ComboBox, ScrollType)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-active", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ScrollTypeVarp ScrollType) {
		fa := ComboBox{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ScrollTypeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "move-active", cbRefPtr)
}

// Emitted to popdown the combo box list.
//
// This is an [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are Alt+Up and Escape.
func (x *ComboBox) ConnectPopdown(cb *func(ComboBox) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "popdown", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := ComboBox{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "popdown", cbRefPtr)
}

// Emitted to popup the combo box list.
//
// This is an [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is Alt+Down.
func (x *ComboBox) ConnectPopup(cb *func(ComboBox)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "popup", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ComboBox{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "popup", cbRefPtr)
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *ComboBox) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *ComboBox) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *ComboBox) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())

	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *ComboBox) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *ComboBox) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)

	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *ComboBox) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *ComboBox) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *ComboBox) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)

	return cret
}

// Resets the accessible property to its default value.
func (x *ComboBox) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *ComboBox) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *ComboBox) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *ComboBox) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *ComboBox) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *ComboBox) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *ComboBox) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ComboBox) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *ComboBox) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ComboBox) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *ComboBox) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ComboBox) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *ComboBox) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())

	return cret
}

// Emits the `GtkCellEditable::editing-done` signal.
func (x *ComboBox) EditingDone() {

	XGtkCellEditableEditingDone(x.GoPointer())

}

// Emits the `GtkCellEditable::remove-widget` signal.
func (x *ComboBox) RemoveWidget() {

	XGtkCellEditableRemoveWidget(x.GoPointer())

}

// Begins editing on a @cell_editable.
//
// The `GtkCellRenderer` for the cell creates and returns a `GtkCellEditable` from
// gtk_cell_renderer_start_editing(), configured for the `GtkCellRenderer` type.
//
// gtk_cell_editable_start_editing() can then set up @cell_editable suitably for
// editing a cell, e.g. making the Esc key emit `GtkCellEditable::editing-done`.
//
// Note that the @cell_editable is created on-demand for the current edit; its
// lifetime is temporary and does not persist across other edits and/or cells.
func (x *ComboBox) StartEditing(EventVar *gdk.Event) {

	XGtkCellEditableStartEditing(x.GoPointer(), EventVar.GoPointer())

}

// Adds an attribute mapping to the list in @cell_layout.
//
// The @column is the column of the model to get a value from, and the
// @attribute is the property on @cell to be set from that value. So for
// example if column 2 of the model contains strings, you could have the
// “text” attribute of a `GtkCellRendererText` get its values from column 2.
// In this context "attribute" and "property" are used interchangeably.
func (x *ComboBox) AddAttribute(CellVar *CellRenderer, AttributeVar string, ColumnVar int) {

	XGtkCellLayoutAddAttribute(x.GoPointer(), CellVar.GoPointer(), AttributeVar, ColumnVar)

}

// Unsets all the mappings on all renderers on @cell_layout and
// removes all renderers from @cell_layout.
func (x *ComboBox) Clear() {

	XGtkCellLayoutClear(x.GoPointer())

}

// Clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
func (x *ComboBox) ClearAttributes(CellVar *CellRenderer) {

	XGtkCellLayoutClearAttributes(x.GoPointer(), CellVar.GoPointer())

}

// Returns the underlying `GtkCellArea` which might be @cell_layout
// if called on a `GtkCellArea` or might be %NULL if no `GtkCellArea`
// is used by @cell_layout.
func (x *ComboBox) GetArea() *CellArea {
	var cls *CellArea

	cret := XGtkCellLayoutGetArea(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellArea{}
	cls.Ptr = cret
	return cls
}

// Returns the cell renderers which have been added to @cell_layout.
func (x *ComboBox) GetCells() *glib.List {

	cret := XGtkCellLayoutGetCells(x.GoPointer())

	return cret
}

// Adds the @cell to the end of @cell_layout. If @expand is %FALSE, then the
// @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is %TRUE.
//
// Note that reusing the same cell renderer is not supported.
func (x *ComboBox) PackEnd(CellVar *CellRenderer, ExpandVar bool) {

	XGtkCellLayoutPackEnd(x.GoPointer(), CellVar.GoPointer(), ExpandVar)

}

// Packs the @cell into the beginning of @cell_layout. If @expand is %FALSE,
// then the @cell is allocated no more space than it needs. Any unused space
// is divided evenly between cells for which @expand is %TRUE.
//
// Note that reusing the same cell renderer is not supported.
func (x *ComboBox) PackStart(CellVar *CellRenderer, ExpandVar bool) {

	XGtkCellLayoutPackStart(x.GoPointer(), CellVar.GoPointer(), ExpandVar)

}

// Re-inserts @cell at @position.
//
// Note that @cell has already to be packed into @cell_layout
// for this to function properly.
func (x *ComboBox) Reorder(CellVar *CellRenderer, PositionVar int) {

	XGtkCellLayoutReorder(x.GoPointer(), CellVar.GoPointer(), PositionVar)

}

// Sets the attributes in the parameter list as the attributes
// of @cell_layout.
//
// See [method@Gtk.CellLayout.add_attribute] for more details.
//
// The attributes should be in attribute/column order, as in
// gtk_cell_layout_add_attribute(). All existing attributes are
// removed, and replaced with the new attributes.
func (x *ComboBox) SetAttributes(CellVar *CellRenderer, varArgs ...interface{}) {

	XGtkCellLayoutSetAttributes(x.GoPointer(), CellVar.GoPointer(), varArgs...)

}

// Sets the `GtkCellLayout`DataFunc to use for @cell_layout.
//
// This function is used instead of the standard attributes mapping
// for setting the column value, and should set the value of @cell_layout’s
// cell renderer(s) as appropriate.
//
// @func may be %NULL to remove a previously set function.
func (x *ComboBox) SetCellDataFunc(CellVar *CellRenderer, FuncVar *CellLayoutDataFunc, FuncDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	XGtkCellLayoutSetCellDataFunc(x.GoPointer(), CellVar.GoPointer(), glib.NewCallbackNullable(FuncVar), FuncDataVar, glib.NewCallback(DestroyVar))

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xComboBoxGLibType, libs, "gtk_combo_box_get_type")

	core.PuregoSafeRegister(&xNewComboBox, libs, "gtk_combo_box_new")
	core.PuregoSafeRegister(&xNewComboBoxWithEntry, libs, "gtk_combo_box_new_with_entry")
	core.PuregoSafeRegister(&xNewComboBoxWithModel, libs, "gtk_combo_box_new_with_model")
	core.PuregoSafeRegister(&xNewComboBoxWithModelAndEntry, libs, "gtk_combo_box_new_with_model_and_entry")

	core.PuregoSafeRegister(&xComboBoxGetActive, libs, "gtk_combo_box_get_active")
	core.PuregoSafeRegister(&xComboBoxGetActiveId, libs, "gtk_combo_box_get_active_id")
	core.PuregoSafeRegister(&xComboBoxGetActiveIter, libs, "gtk_combo_box_get_active_iter")
	core.PuregoSafeRegister(&xComboBoxGetButtonSensitivity, libs, "gtk_combo_box_get_button_sensitivity")
	core.PuregoSafeRegister(&xComboBoxGetChild, libs, "gtk_combo_box_get_child")
	core.PuregoSafeRegister(&xComboBoxGetEntryTextColumn, libs, "gtk_combo_box_get_entry_text_column")
	core.PuregoSafeRegister(&xComboBoxGetHasEntry, libs, "gtk_combo_box_get_has_entry")
	core.PuregoSafeRegister(&xComboBoxGetIdColumn, libs, "gtk_combo_box_get_id_column")
	core.PuregoSafeRegister(&xComboBoxGetModel, libs, "gtk_combo_box_get_model")
	core.PuregoSafeRegister(&xComboBoxGetPopupFixedWidth, libs, "gtk_combo_box_get_popup_fixed_width")
	core.PuregoSafeRegister(&xComboBoxGetRowSeparatorFunc, libs, "gtk_combo_box_get_row_separator_func")
	core.PuregoSafeRegister(&xComboBoxPopdown, libs, "gtk_combo_box_popdown")
	core.PuregoSafeRegister(&xComboBoxPopup, libs, "gtk_combo_box_popup")
	core.PuregoSafeRegister(&xComboBoxPopupForDevice, libs, "gtk_combo_box_popup_for_device")
	core.PuregoSafeRegister(&xComboBoxSetActive, libs, "gtk_combo_box_set_active")
	core.PuregoSafeRegister(&xComboBoxSetActiveId, libs, "gtk_combo_box_set_active_id")
	core.PuregoSafeRegister(&xComboBoxSetActiveIter, libs, "gtk_combo_box_set_active_iter")
	core.PuregoSafeRegister(&xComboBoxSetButtonSensitivity, libs, "gtk_combo_box_set_button_sensitivity")
	core.PuregoSafeRegister(&xComboBoxSetChild, libs, "gtk_combo_box_set_child")
	core.PuregoSafeRegister(&xComboBoxSetEntryTextColumn, libs, "gtk_combo_box_set_entry_text_column")
	core.PuregoSafeRegister(&xComboBoxSetIdColumn, libs, "gtk_combo_box_set_id_column")
	core.PuregoSafeRegister(&xComboBoxSetModel, libs, "gtk_combo_box_set_model")
	core.PuregoSafeRegister(&xComboBoxSetPopupFixedWidth, libs, "gtk_combo_box_set_popup_fixed_width")
	core.PuregoSafeRegister(&xComboBoxSetRowSeparatorFunc, libs, "gtk_combo_box_set_row_separator_func")

}
