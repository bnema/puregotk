// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// User function that is called to determine if the @item should be matched.
//
// If the filter matches the item, this function must return true.
// If the item should be filtered out, false must be returned.
type CustomFilterFunc func(uintptr, uintptr) bool

type CustomFilterClass struct {
	_ structs.HostLayout

	ParentClass FilterClass
}

func (x *CustomFilterClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Determines whether to include items with a callback.
type CustomFilter struct {
	Filter
}

var xCustomFilterGLibType func() types.GType

func CustomFilterGLibType() types.GType {
	return xCustomFilterGLibType()
}

func CustomFilterNewFromInternalPtr(ptr uintptr) *CustomFilter {
	cls := &CustomFilter{}
	cls.Ptr = ptr
	return cls
}

var xNewCustomFilter func(uintptr, uintptr, uintptr) uintptr

// Creates a new filter using the given function to filter items.
//
// If @match_func is `NULL`, the filter matches all items.
//
// If the filter func changes its filtering behavior,
// [method@Gtk.Filter.changed] needs to be called.
func NewCustomFilter(MatchFuncVar *CustomFilterFunc, UserDataVar uintptr, UserDestroyVar *glib.DestroyNotify) *CustomFilter {
	var cls *CustomFilter

	var MatchFuncVarRef uintptr
	if MatchFuncVar != nil {
		MatchFuncVarPtr := uintptr(unsafe.Pointer(MatchFuncVar))
		if cbRefPtr, ok := glib.GetCallback(MatchFuncVarPtr); ok {
			MatchFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) bool {
				cbFn := *MatchFuncVar
				return cbFn(arg0, arg1)
			}
			MatchFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(MatchFuncVarPtr, MatchFuncVarRef)
		}
	}

	UserDestroyVarPtr := uintptr(unsafe.Pointer(UserDestroyVar))
	var UserDestroyVarRef uintptr
	if cbRefPtr, ok := glib.GetCallback(UserDestroyVarPtr); ok {
		UserDestroyVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr) {
			cbFn := *UserDestroyVar
			cbFn(arg0)
		}
		UserDestroyVarRef = purego.NewCallback(fcb)
		glib.SaveCallback(UserDestroyVarPtr, UserDestroyVarRef)
	}

	cret := xNewCustomFilter(MatchFuncVarRef, UserDataVar, UserDestroyVarRef)

	if cret == 0 {
		return nil
	}
	cls = &CustomFilter{}
	cls.Ptr = cret
	return cls
}

var xCustomFilterSetFilterFunc func(uintptr, uintptr, uintptr, uintptr)

// Sets the function used for filtering items.
//
// If @match_func is `NULL`, the filter matches all items.
//
// If the filter func changes its filtering behavior,
// [method@Gtk.Filter.changed] needs to be called.
//
// If a previous function was set, its @user_destroy
// will be called.
func (x *CustomFilter) SetFilterFunc(MatchFuncVar *CustomFilterFunc, UserDataVar uintptr, UserDestroyVar *glib.DestroyNotify) {

	var MatchFuncVarRef uintptr
	if MatchFuncVar != nil {
		MatchFuncVarPtr := uintptr(unsafe.Pointer(MatchFuncVar))
		if cbRefPtr, ok := glib.GetCallback(MatchFuncVarPtr); ok {
			MatchFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) bool {
				cbFn := *MatchFuncVar
				return cbFn(arg0, arg1)
			}
			MatchFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(MatchFuncVarPtr, MatchFuncVarRef)
		}
	}

	UserDestroyVarPtr := uintptr(unsafe.Pointer(UserDestroyVar))
	var UserDestroyVarRef uintptr
	if cbRefPtr, ok := glib.GetCallback(UserDestroyVarPtr); ok {
		UserDestroyVarRef = cbRefPtr
	} else {
		fcb := func(arg0 uintptr) {
			cbFn := *UserDestroyVar
			cbFn(arg0)
		}
		UserDestroyVarRef = purego.NewCallback(fcb)
		glib.SaveCallback(UserDestroyVarPtr, UserDestroyVarRef)
	}

	xCustomFilterSetFilterFunc(x.GoPointer(), MatchFuncVarRef, UserDataVar, UserDestroyVarRef)

}

func (c *CustomFilter) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *CustomFilter) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCustomFilterGLibType, libs, "gtk_custom_filter_get_type")

	core.PuregoSafeRegister(&xNewCustomFilter, libs, "gtk_custom_filter_new")

	core.PuregoSafeRegister(&xCustomFilterSetFilterFunc, libs, "gtk_custom_filter_set_filter_func")

}
