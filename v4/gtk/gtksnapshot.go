// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/cairo"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/graphene"
	"github.com/jwijenbergh/puregotk/v4/gsk"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

type SnapshotClass struct {
	_ structs.HostLayout
}

func (x *SnapshotClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Assists in creating [class@Gsk.RenderNode]s for widgets.
//
// It functions in a similar way to a cairo context, and maintains a stack
// of render nodes and their associated transformations.
//
// The node at the top of the stack is the one that `gtk_snapshot_append_…()`
// functions operate on. Use the `gtk_snapshot_push_…()` functions and
// [method@Snapshot.pop] to change the current node.
//
// The typical way to obtain a `GtkSnapshot` object is as an argument to
// the [vfunc@Gtk.Widget.snapshot] vfunc. If you need to create your own
// `GtkSnapshot`, use [ctor@Gtk.Snapshot.new].
type Snapshot struct {
	gdk.Snapshot
}

var xSnapshotGLibType func() types.GType

func SnapshotGLibType() types.GType {
	return xSnapshotGLibType()
}

func SnapshotNewFromInternalPtr(ptr uintptr) *Snapshot {
	cls := &Snapshot{}
	cls.Ptr = ptr
	return cls
}

var xNewSnapshot func() uintptr

// Creates a new `GtkSnapshot`.
func NewSnapshot() *Snapshot {
	var cls *Snapshot

	cret := xNewSnapshot()

	if cret == 0 {
		return nil
	}
	cls = &Snapshot{}
	cls.Ptr = cret
	return cls
}

var xSnapshotAppendBorder func(uintptr, *gsk.RoundedRect, [4]float32, [4]gdk.RGBA)

// Appends a stroked border rectangle inside the given @outline.
//
// The four sides of the border can have different widths and colors.
func (x *Snapshot) AppendBorder(OutlineVar *gsk.RoundedRect, BorderWidthVar [4]float32, BorderColorVar [4]gdk.RGBA) {

	xSnapshotAppendBorder(x.GoPointer(), OutlineVar, BorderWidthVar, BorderColorVar)

}

var xSnapshotAppendCairo func(uintptr, *graphene.Rect) *cairo.Context

// Creates a new [class@Gsk.CairoNode] and appends it to the current
// render node of @snapshot, without changing the current node.
func (x *Snapshot) AppendCairo(BoundsVar *graphene.Rect) *cairo.Context {

	cret := xSnapshotAppendCairo(x.GoPointer(), BoundsVar)
	return cret
}

var xSnapshotAppendColor func(uintptr, *gdk.RGBA, *graphene.Rect)

// Creates a new render node drawing the @color into the
// given @bounds and appends it to the current render node
// of @snapshot.
//
// You should try to avoid calling this function if
// @color is transparent.
func (x *Snapshot) AppendColor(ColorVar *gdk.RGBA, BoundsVar *graphene.Rect) {

	xSnapshotAppendColor(x.GoPointer(), ColorVar, BoundsVar)

}

var xSnapshotAppendConicGradient func(uintptr, *graphene.Rect, *graphene.Point, float32, []gsk.ColorStop, uint)

// Appends a conic gradient node with the given stops to @snapshot.
func (x *Snapshot) AppendConicGradient(BoundsVar *graphene.Rect, CenterVar *graphene.Point, RotationVar float32, StopsVar []gsk.ColorStop, NStopsVar uint) {

	xSnapshotAppendConicGradient(x.GoPointer(), BoundsVar, CenterVar, RotationVar, StopsVar, NStopsVar)

}

var xSnapshotAppendFill func(uintptr, *gsk.Path, gsk.FillRule, *gdk.RGBA)

// A convenience method to fill a path with a color.
//
// See [method@Gtk.Snapshot.push_fill] if you need
// to fill a path with more complex content than
// a color.
func (x *Snapshot) AppendFill(PathVar *gsk.Path, FillRuleVar gsk.FillRule, ColorVar *gdk.RGBA) {

	xSnapshotAppendFill(x.GoPointer(), PathVar, FillRuleVar, ColorVar)

}

var xSnapshotAppendInsetShadow func(uintptr, *gsk.RoundedRect, *gdk.RGBA, float32, float32, float32, float32)

// Appends an inset shadow into the box given by @outline.
func (x *Snapshot) AppendInsetShadow(OutlineVar *gsk.RoundedRect, ColorVar *gdk.RGBA, DxVar float32, DyVar float32, SpreadVar float32, BlurRadiusVar float32) {

	xSnapshotAppendInsetShadow(x.GoPointer(), OutlineVar, ColorVar, DxVar, DyVar, SpreadVar, BlurRadiusVar)

}

var xSnapshotAppendLayout func(uintptr, uintptr, *gdk.RGBA)

// Creates render nodes for rendering @layout in the given foregound @color
// and appends them to the current node of @snapshot without changing the
// current node. The current theme's foreground color for a widget can be
// obtained with [method@Gtk.Widget.get_color].
//
// Note that if the layout does not produce any visible output, then nodes
// may not be added to the @snapshot.
func (x *Snapshot) AppendLayout(LayoutVar *pango.Layout, ColorVar *gdk.RGBA) {

	xSnapshotAppendLayout(x.GoPointer(), LayoutVar.GoPointer(), ColorVar)

}

var xSnapshotAppendLinearGradient func(uintptr, *graphene.Rect, *graphene.Point, *graphene.Point, []gsk.ColorStop, uint)

// Appends a linear gradient node with the given stops to @snapshot.
func (x *Snapshot) AppendLinearGradient(BoundsVar *graphene.Rect, StartPointVar *graphene.Point, EndPointVar *graphene.Point, StopsVar []gsk.ColorStop, NStopsVar uint) {

	xSnapshotAppendLinearGradient(x.GoPointer(), BoundsVar, StartPointVar, EndPointVar, StopsVar, NStopsVar)

}

var xSnapshotAppendNode func(uintptr, uintptr)

// Appends @node to the current render node of @snapshot,
// without changing the current node.
//
// If @snapshot does not have a current node yet, @node
// will become the initial node.
func (x *Snapshot) AppendNode(NodeVar *gsk.RenderNode) {

	xSnapshotAppendNode(x.GoPointer(), NodeVar.GoPointer())

}

var xSnapshotAppendOutsetShadow func(uintptr, *gsk.RoundedRect, *gdk.RGBA, float32, float32, float32, float32)

// Appends an outset shadow node around the box given by @outline.
func (x *Snapshot) AppendOutsetShadow(OutlineVar *gsk.RoundedRect, ColorVar *gdk.RGBA, DxVar float32, DyVar float32, SpreadVar float32, BlurRadiusVar float32) {

	xSnapshotAppendOutsetShadow(x.GoPointer(), OutlineVar, ColorVar, DxVar, DyVar, SpreadVar, BlurRadiusVar)

}

var xSnapshotAppendRadialGradient func(uintptr, *graphene.Rect, *graphene.Point, float32, float32, float32, float32, []gsk.ColorStop, uint)

// Appends a radial gradient node with the given stops to @snapshot.
func (x *Snapshot) AppendRadialGradient(BoundsVar *graphene.Rect, CenterVar *graphene.Point, HradiusVar float32, VradiusVar float32, StartVar float32, EndVar float32, StopsVar []gsk.ColorStop, NStopsVar uint) {

	xSnapshotAppendRadialGradient(x.GoPointer(), BoundsVar, CenterVar, HradiusVar, VradiusVar, StartVar, EndVar, StopsVar, NStopsVar)

}

var xSnapshotAppendRepeatingLinearGradient func(uintptr, *graphene.Rect, *graphene.Point, *graphene.Point, []gsk.ColorStop, uint)

// Appends a repeating linear gradient node with the given stops to @snapshot.
func (x *Snapshot) AppendRepeatingLinearGradient(BoundsVar *graphene.Rect, StartPointVar *graphene.Point, EndPointVar *graphene.Point, StopsVar []gsk.ColorStop, NStopsVar uint) {

	xSnapshotAppendRepeatingLinearGradient(x.GoPointer(), BoundsVar, StartPointVar, EndPointVar, StopsVar, NStopsVar)

}

var xSnapshotAppendRepeatingRadialGradient func(uintptr, *graphene.Rect, *graphene.Point, float32, float32, float32, float32, []gsk.ColorStop, uint)

// Appends a repeating radial gradient node with the given stops to @snapshot.
func (x *Snapshot) AppendRepeatingRadialGradient(BoundsVar *graphene.Rect, CenterVar *graphene.Point, HradiusVar float32, VradiusVar float32, StartVar float32, EndVar float32, StopsVar []gsk.ColorStop, NStopsVar uint) {

	xSnapshotAppendRepeatingRadialGradient(x.GoPointer(), BoundsVar, CenterVar, HradiusVar, VradiusVar, StartVar, EndVar, StopsVar, NStopsVar)

}

var xSnapshotAppendScaledTexture func(uintptr, uintptr, gsk.ScalingFilter, *graphene.Rect)

// Creates a new render node drawing the @texture
// into the given @bounds and appends it to the
// current render node of @snapshot.
//
// In contrast to [method@Gtk.Snapshot.append_texture],
// this function provides control about how the filter
// that is used when scaling.
func (x *Snapshot) AppendScaledTexture(TextureVar *gdk.Texture, FilterVar gsk.ScalingFilter, BoundsVar *graphene.Rect) {

	xSnapshotAppendScaledTexture(x.GoPointer(), TextureVar.GoPointer(), FilterVar, BoundsVar)

}

var xSnapshotAppendStroke func(uintptr, *gsk.Path, *gsk.Stroke, *gdk.RGBA)

// A convenience method to stroke a path with a color.
//
// See [method@Gtk.Snapshot.push_stroke] if you need
// to stroke a path with more complex content than
// a color.
func (x *Snapshot) AppendStroke(PathVar *gsk.Path, StrokeVar *gsk.Stroke, ColorVar *gdk.RGBA) {

	xSnapshotAppendStroke(x.GoPointer(), PathVar, StrokeVar, ColorVar)

}

var xSnapshotAppendTexture func(uintptr, uintptr, *graphene.Rect)

// Creates a new render node drawing the @texture
// into the given @bounds and appends it to the
// current render node of @snapshot.
//
// If the texture needs to be scaled to fill @bounds,
// linear filtering is used. See [method@Gtk.Snapshot.append_scaled_texture]
// if you need other filtering, such as nearest-neighbour.
func (x *Snapshot) AppendTexture(TextureVar *gdk.Texture, BoundsVar *graphene.Rect) {

	xSnapshotAppendTexture(x.GoPointer(), TextureVar.GoPointer(), BoundsVar)

}

var xSnapshotFreeToNode func(uintptr) uintptr

// Returns the node that was constructed by @snapshot
// and frees @snapshot.
//
// See also [method@Gtk.Snapshot.to_node].
func (x *Snapshot) FreeToNode() *gsk.RenderNode {
	var cls *gsk.RenderNode

	cret := xSnapshotFreeToNode(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gsk.RenderNode{}
	cls.Ptr = cret
	return cls
}

var xSnapshotFreeToPaintable func(uintptr, *graphene.Size) uintptr

// Returns a paintable for the node that was
// constructed by @snapshot and frees @snapshot.
func (x *Snapshot) FreeToPaintable(SizeVar *graphene.Size) *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := xSnapshotFreeToPaintable(x.GoPointer(), SizeVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

var xSnapshotGlShaderPopTexture func(uintptr)

// Removes the top element from the stack of render nodes and
// adds it to the nearest [class@Gsk.GLShaderNode] below it.
//
// This must be called the same number of times as the number
// of textures is needed for the shader in
// [method@Gtk.Snapshot.push_gl_shader].
func (x *Snapshot) GlShaderPopTexture() {

	xSnapshotGlShaderPopTexture(x.GoPointer())

}

var xSnapshotPerspective func(uintptr, float32)

// Applies a perspective projection transform.
//
// See [method@Gsk.Transform.perspective] for a discussion on the details.
func (x *Snapshot) Perspective(DepthVar float32) {

	xSnapshotPerspective(x.GoPointer(), DepthVar)

}

var xSnapshotPop func(uintptr)

// Removes the top element from the stack of render nodes,
// and appends it to the node underneath it.
func (x *Snapshot) Pop() {

	xSnapshotPop(x.GoPointer())

}

var xSnapshotPushBlend func(uintptr, gsk.BlendMode)

// Blends together two images with the given blend mode.
//
// Until the first call to [method@Gtk.Snapshot.pop], the
// bottom image for the blend operation will be recorded.
// After that call, the top image to be blended will be
// recorded until the second call to [method@Gtk.Snapshot.pop].
//
// Calling this function requires two subsequent calls
// to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushBlend(BlendModeVar gsk.BlendMode) {

	xSnapshotPushBlend(x.GoPointer(), BlendModeVar)

}

var xSnapshotPushBlur func(uintptr, float64)

// Blurs an image.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushBlur(RadiusVar float64) {

	xSnapshotPushBlur(x.GoPointer(), RadiusVar)

}

var xSnapshotPushClip func(uintptr, *graphene.Rect)

// Clips an image to a rectangle.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushClip(BoundsVar *graphene.Rect) {

	xSnapshotPushClip(x.GoPointer(), BoundsVar)

}

var xSnapshotPushColorMatrix func(uintptr, *graphene.Matrix, *graphene.Vec4)

// Modifies the colors of an image by applying an affine transformation
// in RGB space.
//
// In particular, the colors will be transformed by applying
//
//	pixel = transpose(color_matrix) * pixel + color_offset
//
// for every pixel. The transformation operates on unpremultiplied
// colors, with color components ordered R, G, B, A.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushColorMatrix(ColorMatrixVar *graphene.Matrix, ColorOffsetVar *graphene.Vec4) {

	xSnapshotPushColorMatrix(x.GoPointer(), ColorMatrixVar, ColorOffsetVar)

}

var xSnapshotPushCrossFade func(uintptr, float64)

// Snapshots a cross-fade operation between two images with the
// given @progress.
//
// Until the first call to [method@Gtk.Snapshot.pop], the start image
// will be snapshot. After that call, the end image will be recorded
// until the second call to [method@Gtk.Snapshot.pop].
//
// Calling this function requires two subsequent calls
// to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushCrossFade(ProgressVar float64) {

	xSnapshotPushCrossFade(x.GoPointer(), ProgressVar)

}

var xSnapshotPushDebug func(uintptr, string, ...interface{})

// Inserts a debug node with a message.
//
// Debug nodes don't affect the rendering at all, but can be
// helpful in identifying parts of a render node tree dump,
// for example in the GTK inspector.
func (x *Snapshot) PushDebug(MessageVar string, varArgs ...interface{}) {

	xSnapshotPushDebug(x.GoPointer(), MessageVar, varArgs...)

}

var xSnapshotPushFill func(uintptr, *gsk.Path, gsk.FillRule)

// Fills the area given by @path and @fill_rule with an image and discards everything
// outside of it.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
//
// If you want to fill the path with a color, [method@Gtk.Snapshot.append_fill]
// may be more convenient.
func (x *Snapshot) PushFill(PathVar *gsk.Path, FillRuleVar gsk.FillRule) {

	xSnapshotPushFill(x.GoPointer(), PathVar, FillRuleVar)

}

var xSnapshotPushGlShader func(uintptr, uintptr, *graphene.Rect, *glib.Bytes)

// Push a [class@Gsk.GLShaderNode].
//
// The node uses the given [class@Gsk.GLShader] and uniform values
// Additionally this takes a list of @n_children other nodes
// which will be passed to the [class@Gsk.GLShaderNode].
//
// The @take_args argument is a block of data to use for uniform
// arguments, as per types and offsets defined by the @shader.
// Normally this is generated by [method@Gsk.GLShader.format_args]
// or [struct@Gsk.ShaderArgsBuilder].
//
// The snapshotter takes ownership of @take_args, so the caller should
// not free it after this.
//
// If the renderer doesn't support GL shaders, or if there is any
// problem when compiling the shader, then the node will draw pink.
// You should use [method@Gsk.GLShader.compile] to ensure the @shader
// will work for the renderer before using it.
//
// If the shader requires textures (see [method@Gsk.GLShader.get_n_textures]),
// then it is expected that you call [method@Gtk.Snapshot.gl_shader_pop_texture]
// the number of times that are required. Each of these calls will generate
// a node that is added as a child to the `GskGLShaderNode`, which in turn
// will render these offscreen and pass as a texture to the shader.
//
// Once all textures (if any) are pop:ed, you must call the regular
// [method@Gtk.Snapshot.pop].
//
// If you want to use pre-existing textures as input to the shader rather
// than rendering new ones, use [method@Gtk.Snapshot.append_texture] to
// push a texture node. These will be used directly rather than being
// re-rendered.
//
// For details on how to write shaders, see [class@Gsk.GLShader].
func (x *Snapshot) PushGlShader(ShaderVar *gsk.GLShader, BoundsVar *graphene.Rect, TakeArgsVar *glib.Bytes) {

	xSnapshotPushGlShader(x.GoPointer(), ShaderVar.GoPointer(), BoundsVar, TakeArgsVar)

}

var xSnapshotPushMask func(uintptr, gsk.MaskMode)

// Until the first call to [method@Gtk.Snapshot.pop], the
// mask image for the mask operation will be recorded.
//
// After that call, the source image will be recorded until
// the second call to [method@Gtk.Snapshot.pop].
//
// Calling this function requires 2 subsequent calls to gtk_snapshot_pop().
func (x *Snapshot) PushMask(MaskModeVar gsk.MaskMode) {

	xSnapshotPushMask(x.GoPointer(), MaskModeVar)

}

var xSnapshotPushOpacity func(uintptr, float64)

// Modifies the opacity of an image.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushOpacity(OpacityVar float64) {

	xSnapshotPushOpacity(x.GoPointer(), OpacityVar)

}

var xSnapshotPushRepeat func(uintptr, *graphene.Rect, *graphene.Rect)

// Creates a node that repeats the child node.
//
// The child is recorded until the next call to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushRepeat(BoundsVar *graphene.Rect, ChildBoundsVar *graphene.Rect) {

	xSnapshotPushRepeat(x.GoPointer(), BoundsVar, ChildBoundsVar)

}

var xSnapshotPushRoundedClip func(uintptr, *gsk.RoundedRect)

// Clips an image to a rounded rectangle.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushRoundedClip(BoundsVar *gsk.RoundedRect) {

	xSnapshotPushRoundedClip(x.GoPointer(), BoundsVar)

}

var xSnapshotPushShadow func(uintptr, []gsk.Shadow, uint)

// Applies a shadow to an image.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (x *Snapshot) PushShadow(ShadowVar []gsk.Shadow, NShadowsVar uint) {

	xSnapshotPushShadow(x.GoPointer(), ShadowVar, NShadowsVar)

}

var xSnapshotPushStroke func(uintptr, *gsk.Path, *gsk.Stroke)

// Strokes the given @path with the attributes given by @stroke and
// an image.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
//
// Note that the strokes are subject to the same transformation as
// everything else, so uneven scaling will cause horizontal and vertical
// strokes to have different widths.
//
// If you want to stroke the path with a color, [method@Gtk.Snapshot.append_stroke]
// may be more convenient.
func (x *Snapshot) PushStroke(PathVar *gsk.Path, StrokeVar *gsk.Stroke) {

	xSnapshotPushStroke(x.GoPointer(), PathVar, StrokeVar)

}

var xSnapshotRenderBackground func(uintptr, uintptr, float64, float64, float64, float64)

// Creates a render node for the CSS background according to @context,
// and appends it to the current node of @snapshot, without changing
// the current node.
func (x *Snapshot) RenderBackground(ContextVar *StyleContext, XVar float64, YVar float64, WidthVar float64, HeightVar float64) {

	xSnapshotRenderBackground(x.GoPointer(), ContextVar.GoPointer(), XVar, YVar, WidthVar, HeightVar)

}

var xSnapshotRenderFocus func(uintptr, uintptr, float64, float64, float64, float64)

// Creates a render node for the focus outline according to @context,
// and appends it to the current node of @snapshot, without changing
// the current node.
func (x *Snapshot) RenderFocus(ContextVar *StyleContext, XVar float64, YVar float64, WidthVar float64, HeightVar float64) {

	xSnapshotRenderFocus(x.GoPointer(), ContextVar.GoPointer(), XVar, YVar, WidthVar, HeightVar)

}

var xSnapshotRenderFrame func(uintptr, uintptr, float64, float64, float64, float64)

// Creates a render node for the CSS border according to @context,
// and appends it to the current node of @snapshot, without changing
// the current node.
func (x *Snapshot) RenderFrame(ContextVar *StyleContext, XVar float64, YVar float64, WidthVar float64, HeightVar float64) {

	xSnapshotRenderFrame(x.GoPointer(), ContextVar.GoPointer(), XVar, YVar, WidthVar, HeightVar)

}

var xSnapshotRenderInsertionCursor func(uintptr, uintptr, float64, float64, uintptr, int, pango.Direction)

// Draws a text caret using @snapshot at the specified index of @layout.
func (x *Snapshot) RenderInsertionCursor(ContextVar *StyleContext, XVar float64, YVar float64, LayoutVar *pango.Layout, IndexVar int, DirectionVar pango.Direction) {

	xSnapshotRenderInsertionCursor(x.GoPointer(), ContextVar.GoPointer(), XVar, YVar, LayoutVar.GoPointer(), IndexVar, DirectionVar)

}

var xSnapshotRenderLayout func(uintptr, uintptr, float64, float64, uintptr)

// Creates a render node for rendering @layout according to the style
// information in @context, and appends it to the current node of @snapshot,
// without changing the current node.
func (x *Snapshot) RenderLayout(ContextVar *StyleContext, XVar float64, YVar float64, LayoutVar *pango.Layout) {

	xSnapshotRenderLayout(x.GoPointer(), ContextVar.GoPointer(), XVar, YVar, LayoutVar.GoPointer())

}

var xSnapshotRestore func(uintptr)

// Restores @snapshot to the state saved by a preceding call to
// [method@Snapshot.save] and removes that state from the stack of
// saved states.
func (x *Snapshot) Restore() {

	xSnapshotRestore(x.GoPointer())

}

var xSnapshotRotate func(uintptr, float32)

// Rotates @@snapshot's coordinate system by @angle degrees in 2D space -
// or in 3D speak, rotates around the Z axis. The rotation happens around
// the origin point of (0, 0) in the @snapshot's current coordinate system.
//
// To rotate around axes other than the Z axis, use [method@Gsk.Transform.rotate_3d].
func (x *Snapshot) Rotate(AngleVar float32) {

	xSnapshotRotate(x.GoPointer(), AngleVar)

}

var xSnapshotRotate3d func(uintptr, float32, *graphene.Vec3)

// Rotates @snapshot's coordinate system by @angle degrees around @axis.
//
// For a rotation in 2D space, use [method@Gsk.Transform.rotate].
func (x *Snapshot) Rotate3d(AngleVar float32, AxisVar *graphene.Vec3) {

	xSnapshotRotate3d(x.GoPointer(), AngleVar, AxisVar)

}

var xSnapshotSave func(uintptr)

// Makes a copy of the current state of @snapshot and saves it
// on an internal stack.
//
// When [method@Gtk.Snapshot.restore] is called, @snapshot will
// be restored to the saved state.
//
// Multiple calls to [method@Gtk.Snapshot.save] and [method@Gtk.Snapshot.restore]
// can be nested; each call to `gtk_snapshot_restore()` restores the state from
// the matching paired `gtk_snapshot_save()`.
//
// It is necessary to clear all saved states with corresponding
// calls to `gtk_snapshot_restore()`.
func (x *Snapshot) Save() {

	xSnapshotSave(x.GoPointer())

}

var xSnapshotScale func(uintptr, float32, float32)

// Scales @snapshot's coordinate system in 2-dimensional space by
// the given factors.
//
// Use [method@Gtk.Snapshot.scale_3d] to scale in all 3 dimensions.
func (x *Snapshot) Scale(FactorXVar float32, FactorYVar float32) {

	xSnapshotScale(x.GoPointer(), FactorXVar, FactorYVar)

}

var xSnapshotScale3d func(uintptr, float32, float32, float32)

// Scales @snapshot's coordinate system by the given factors.
func (x *Snapshot) Scale3d(FactorXVar float32, FactorYVar float32, FactorZVar float32) {

	xSnapshotScale3d(x.GoPointer(), FactorXVar, FactorYVar, FactorZVar)

}

var xSnapshotToNode func(uintptr) uintptr

// Returns the render node that was constructed
// by @snapshot.
//
// Note that this function may return %NULL if nothing has been
// added to the snapshot or if its content does not produce pixels
// to be rendered.
//
// After calling this function, it is no longer possible to
// add more nodes to @snapshot. The only function that should
// be called after this is [method@GObject.Object.unref].
func (x *Snapshot) ToNode() *gsk.RenderNode {
	var cls *gsk.RenderNode

	cret := xSnapshotToNode(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gsk.RenderNode{}
	cls.Ptr = cret
	return cls
}

var xSnapshotToPaintable func(uintptr, *graphene.Size) uintptr

// Returns a paintable encapsulating the render node
// that was constructed by @snapshot.
//
// After calling this function, it is no longer possible to
// add more nodes to @snapshot. The only function that should
// be called after this is [method@GObject.Object.unref].
func (x *Snapshot) ToPaintable(SizeVar *graphene.Size) *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := xSnapshotToPaintable(x.GoPointer(), SizeVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

var xSnapshotTransform func(uintptr, *gsk.Transform)

// Transforms @snapshot's coordinate system with the given @transform.
func (x *Snapshot) Transform(TransformVar *gsk.Transform) {

	xSnapshotTransform(x.GoPointer(), TransformVar)

}

var xSnapshotTransformMatrix func(uintptr, *graphene.Matrix)

// Transforms @snapshot's coordinate system with the given @matrix.
func (x *Snapshot) TransformMatrix(MatrixVar *graphene.Matrix) {

	xSnapshotTransformMatrix(x.GoPointer(), MatrixVar)

}

var xSnapshotTranslate func(uintptr, *graphene.Point)

// Translates @snapshot's coordinate system by @point in 2-dimensional space.
func (x *Snapshot) Translate(PointVar *graphene.Point) {

	xSnapshotTranslate(x.GoPointer(), PointVar)

}

var xSnapshotTranslate3d func(uintptr, *graphene.Point3D)

// Translates @snapshot's coordinate system by @point.
func (x *Snapshot) Translate3d(PointVar *graphene.Point3D) {

	xSnapshotTranslate3d(x.GoPointer(), PointVar)

}

func (c *Snapshot) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Snapshot) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibrary("GTK", "libgtk-4.so.1")
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xSnapshotGLibType, lib, "gtk_snapshot_get_type")

	core.PuregoSafeRegister(&xNewSnapshot, lib, "gtk_snapshot_new")

	core.PuregoSafeRegister(&xSnapshotAppendBorder, lib, "gtk_snapshot_append_border")
	core.PuregoSafeRegister(&xSnapshotAppendCairo, lib, "gtk_snapshot_append_cairo")
	core.PuregoSafeRegister(&xSnapshotAppendColor, lib, "gtk_snapshot_append_color")
	core.PuregoSafeRegister(&xSnapshotAppendConicGradient, lib, "gtk_snapshot_append_conic_gradient")
	core.PuregoSafeRegister(&xSnapshotAppendFill, lib, "gtk_snapshot_append_fill")
	core.PuregoSafeRegister(&xSnapshotAppendInsetShadow, lib, "gtk_snapshot_append_inset_shadow")
	core.PuregoSafeRegister(&xSnapshotAppendLayout, lib, "gtk_snapshot_append_layout")
	core.PuregoSafeRegister(&xSnapshotAppendLinearGradient, lib, "gtk_snapshot_append_linear_gradient")
	core.PuregoSafeRegister(&xSnapshotAppendNode, lib, "gtk_snapshot_append_node")
	core.PuregoSafeRegister(&xSnapshotAppendOutsetShadow, lib, "gtk_snapshot_append_outset_shadow")
	core.PuregoSafeRegister(&xSnapshotAppendRadialGradient, lib, "gtk_snapshot_append_radial_gradient")
	core.PuregoSafeRegister(&xSnapshotAppendRepeatingLinearGradient, lib, "gtk_snapshot_append_repeating_linear_gradient")
	core.PuregoSafeRegister(&xSnapshotAppendRepeatingRadialGradient, lib, "gtk_snapshot_append_repeating_radial_gradient")
	core.PuregoSafeRegister(&xSnapshotAppendScaledTexture, lib, "gtk_snapshot_append_scaled_texture")
	core.PuregoSafeRegister(&xSnapshotAppendStroke, lib, "gtk_snapshot_append_stroke")
	core.PuregoSafeRegister(&xSnapshotAppendTexture, lib, "gtk_snapshot_append_texture")
	core.PuregoSafeRegister(&xSnapshotFreeToNode, lib, "gtk_snapshot_free_to_node")
	core.PuregoSafeRegister(&xSnapshotFreeToPaintable, lib, "gtk_snapshot_free_to_paintable")
	core.PuregoSafeRegister(&xSnapshotGlShaderPopTexture, lib, "gtk_snapshot_gl_shader_pop_texture")
	core.PuregoSafeRegister(&xSnapshotPerspective, lib, "gtk_snapshot_perspective")
	core.PuregoSafeRegister(&xSnapshotPop, lib, "gtk_snapshot_pop")
	core.PuregoSafeRegister(&xSnapshotPushBlend, lib, "gtk_snapshot_push_blend")
	core.PuregoSafeRegister(&xSnapshotPushBlur, lib, "gtk_snapshot_push_blur")
	core.PuregoSafeRegister(&xSnapshotPushClip, lib, "gtk_snapshot_push_clip")
	core.PuregoSafeRegister(&xSnapshotPushColorMatrix, lib, "gtk_snapshot_push_color_matrix")
	core.PuregoSafeRegister(&xSnapshotPushCrossFade, lib, "gtk_snapshot_push_cross_fade")
	core.PuregoSafeRegister(&xSnapshotPushDebug, lib, "gtk_snapshot_push_debug")
	core.PuregoSafeRegister(&xSnapshotPushFill, lib, "gtk_snapshot_push_fill")
	core.PuregoSafeRegister(&xSnapshotPushGlShader, lib, "gtk_snapshot_push_gl_shader")
	core.PuregoSafeRegister(&xSnapshotPushMask, lib, "gtk_snapshot_push_mask")
	core.PuregoSafeRegister(&xSnapshotPushOpacity, lib, "gtk_snapshot_push_opacity")
	core.PuregoSafeRegister(&xSnapshotPushRepeat, lib, "gtk_snapshot_push_repeat")
	core.PuregoSafeRegister(&xSnapshotPushRoundedClip, lib, "gtk_snapshot_push_rounded_clip")
	core.PuregoSafeRegister(&xSnapshotPushShadow, lib, "gtk_snapshot_push_shadow")
	core.PuregoSafeRegister(&xSnapshotPushStroke, lib, "gtk_snapshot_push_stroke")
	core.PuregoSafeRegister(&xSnapshotRenderBackground, lib, "gtk_snapshot_render_background")
	core.PuregoSafeRegister(&xSnapshotRenderFocus, lib, "gtk_snapshot_render_focus")
	core.PuregoSafeRegister(&xSnapshotRenderFrame, lib, "gtk_snapshot_render_frame")
	core.PuregoSafeRegister(&xSnapshotRenderInsertionCursor, lib, "gtk_snapshot_render_insertion_cursor")
	core.PuregoSafeRegister(&xSnapshotRenderLayout, lib, "gtk_snapshot_render_layout")
	core.PuregoSafeRegister(&xSnapshotRestore, lib, "gtk_snapshot_restore")
	core.PuregoSafeRegister(&xSnapshotRotate, lib, "gtk_snapshot_rotate")
	core.PuregoSafeRegister(&xSnapshotRotate3d, lib, "gtk_snapshot_rotate_3d")
	core.PuregoSafeRegister(&xSnapshotSave, lib, "gtk_snapshot_save")
	core.PuregoSafeRegister(&xSnapshotScale, lib, "gtk_snapshot_scale")
	core.PuregoSafeRegister(&xSnapshotScale3d, lib, "gtk_snapshot_scale_3d")
	core.PuregoSafeRegister(&xSnapshotToNode, lib, "gtk_snapshot_to_node")
	core.PuregoSafeRegister(&xSnapshotToPaintable, lib, "gtk_snapshot_to_paintable")
	core.PuregoSafeRegister(&xSnapshotTransform, lib, "gtk_snapshot_transform")
	core.PuregoSafeRegister(&xSnapshotTransformMatrix, lib, "gtk_snapshot_transform_matrix")
	core.PuregoSafeRegister(&xSnapshotTranslate, lib, "gtk_snapshot_translate")
	core.PuregoSafeRegister(&xSnapshotTranslate3d, lib, "gtk_snapshot_translate_3d")

}
