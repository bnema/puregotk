// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"runtime"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A single-line text entry widget for use as a search entry.
//
// The main API for interacting with a `GtkSearchEntry` as entry
// is the `GtkEditable` interface.
//
// &lt;picture&gt;
//
//	&lt;source srcset="search-entry-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkSearchEntry" src="search-entry.png"&gt;
//
// &lt;/picture&gt;
//
// It will show an inactive symbolic “find” icon when the search
// entry is empty, and a symbolic “clear” icon when there is text.
// Clicking on the “clear” icon will empty the search entry.
//
// To make filtering appear more reactive, it is a good idea to
// not react to every change in the entry text immediately, but
// only after a short delay. To support this, `GtkSearchEntry`
// emits the [signal@Gtk.SearchEntry::search-changed] signal which
// can be used instead of the [signal@Gtk.Editable::changed] signal.
//
// The [signal@Gtk.SearchEntry::previous-match],
// [signal@Gtk.SearchEntry::next-match] and
// [signal@Gtk.SearchEntry::stop-search] signals can be used to
// implement moving between search results and ending the search.
//
// Often, `GtkSearchEntry` will be fed events by means of being
// placed inside a [class@Gtk.SearchBar]. If that is not the case,
// you can use [method@Gtk.SearchEntry.set_key_capture_widget] to
// let it capture key input from another widget.
//
// `GtkSearchEntry` provides only minimal API and should be used with
// the [iface@Gtk.Editable] API.
//
// ## Shortcuts and Gestures
//
// The following signals have default keybindings:
//
// - [signal@Gtk.SearchEntry::activate]
// - [signal@Gtk.SearchEntry::next-match]
// - [signal@Gtk.SearchEntry::previous-match]
// - [signal@Gtk.SearchEntry::stop-search]
//
// ## CSS Nodes
//
// ```
// entry.search
// ╰── text
// ```
//
// `GtkSearchEntry` has a single CSS node with name entry that carries
// a `.search` style class, and the text node is a child of that.
//
// ## Accessibility
//
// `GtkSearchEntry` uses the [enum@Gtk.AccessibleRole.search_box] role.
type SearchEntry struct {
	Widget
}

var xSearchEntryGLibType func() types.GType

func SearchEntryGLibType() types.GType {
	return xSearchEntryGLibType()
}

func SearchEntryNewFromInternalPtr(ptr uintptr) *SearchEntry {
	cls := &SearchEntry{}
	cls.Ptr = ptr
	return cls
}

var xNewSearchEntry func() uintptr

// Creates a `GtkSearchEntry`.
func NewSearchEntry() *SearchEntry {
	var cls *SearchEntry

	cret := xNewSearchEntry()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &SearchEntry{}
	cls.Ptr = cret
	return cls
}

var xSearchEntryGetInputHints func(uintptr) InputHints

// Gets the input purpose for @entry.
func (x *SearchEntry) GetInputHints() InputHints {

	cret := xSearchEntryGetInputHints(x.GoPointer())

	return cret
}

var xSearchEntryGetInputPurpose func(uintptr) InputPurpose

// Gets the input purpose of @entry.
func (x *SearchEntry) GetInputPurpose() InputPurpose {

	cret := xSearchEntryGetInputPurpose(x.GoPointer())

	return cret
}

var xSearchEntryGetKeyCaptureWidget func(uintptr) uintptr

// Gets the widget that @entry is capturing key events from.
func (x *SearchEntry) GetKeyCaptureWidget() *Widget {
	var cls *Widget

	cret := xSearchEntryGetKeyCaptureWidget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xSearchEntryGetPlaceholderText func(uintptr) string

// Gets the placeholder text associated with @entry.
func (x *SearchEntry) GetPlaceholderText() string {

	cret := xSearchEntryGetPlaceholderText(x.GoPointer())

	return cret
}

var xSearchEntryGetSearchDelay func(uintptr) uint

// Get the delay to be used between the last keypress and the
// [signal@Gtk.SearchEntry::search-changed] signal being emitted.
func (x *SearchEntry) GetSearchDelay() uint {

	cret := xSearchEntryGetSearchDelay(x.GoPointer())

	return cret
}

var xSearchEntrySetInputHints func(uintptr, InputHints)

// Sets the input hints for @entry.
func (x *SearchEntry) SetInputHints(HintsVar InputHints) {

	xSearchEntrySetInputHints(x.GoPointer(), HintsVar)

}

var xSearchEntrySetInputPurpose func(uintptr, InputPurpose)

// Sets the input purpose of @entry.
func (x *SearchEntry) SetInputPurpose(PurposeVar InputPurpose) {

	xSearchEntrySetInputPurpose(x.GoPointer(), PurposeVar)

}

var xSearchEntrySetKeyCaptureWidget func(uintptr, uintptr)

// Sets @widget as the widget that @entry will capture key
// events from.
//
// Key events are consumed by the search entry to start or
// continue a search.
//
// If the entry is part of a `GtkSearchBar`, it is preferable
// to call [method@Gtk.SearchBar.set_key_capture_widget] instead,
// which will reveal the entry in addition to triggering the
// search entry.
//
// Note that despite the name of this function, the events
// are only 'captured' in the bubble phase, which means that
// editable child widgets of @widget will receive text input
// before it gets captured. If that is not desired, you can
// capture and forward the events yourself with
// [method@Gtk.EventControllerKey.forward].
func (x *SearchEntry) SetKeyCaptureWidget(WidgetVar *Widget) {

	xSearchEntrySetKeyCaptureWidget(x.GoPointer(), WidgetVar.GoPointer())

}

var xSearchEntrySetPlaceholderText func(uintptr, uintptr)

// Sets the placeholder text associated with @entry.
func (x *SearchEntry) SetPlaceholderText(TextVar *string) {

	TextVarPtr, TextVarBytes := core.NullableStringToPtr(TextVar)

	xSearchEntrySetPlaceholderText(x.GoPointer(), TextVarPtr)

	runtime.KeepAlive(TextVarBytes)

}

var xSearchEntrySetSearchDelay func(uintptr, uint)

// Set the delay to be used between the last keypress and the
// [signal@Gtk.SearchEntry::search-changed] signal being emitted.
func (x *SearchEntry) SetSearchDelay(DelayVar uint) {

	xSearchEntrySetSearchDelay(x.GoPointer(), DelayVar)

}

func (c *SearchEntry) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *SearchEntry) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyActivatesDefault sets the "activates-default" property.
// Whether to activate the default widget when Enter is pressed.
func (x *SearchEntry) SetPropertyActivatesDefault(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("activates-default", &v)
}

// GetPropertyActivatesDefault gets the "activates-default" property.
// Whether to activate the default widget when Enter is pressed.
func (x *SearchEntry) GetPropertyActivatesDefault() bool {
	var v gobject.Value
	x.GetProperty("activates-default", &v)
	return v.GetBoolean()
}

// SetPropertyPlaceholderText sets the "placeholder-text" property.
// The text that will be displayed in the `GtkSearchEntry`
// when it is empty and unfocused.
func (x *SearchEntry) SetPropertyPlaceholderText(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("placeholder-text", &v)
}

// GetPropertyPlaceholderText gets the "placeholder-text" property.
// The text that will be displayed in the `GtkSearchEntry`
// when it is empty and unfocused.
func (x *SearchEntry) GetPropertyPlaceholderText() string {
	var v gobject.Value
	x.GetProperty("placeholder-text", &v)
	return v.GetString()
}

// SetPropertySearchDelay sets the "search-delay" property.
// The delay in milliseconds from last keypress to the search
// changed signal.
func (x *SearchEntry) SetPropertySearchDelay(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("search-delay", &v)
}

// GetPropertySearchDelay gets the "search-delay" property.
// The delay in milliseconds from last keypress to the search
// changed signal.
func (x *SearchEntry) GetPropertySearchDelay() uint {
	var v gobject.Value
	x.GetProperty("search-delay", &v)
	return v.GetUint()
}

// Emitted when the entry is activated.
//
// The keybindings for this signal are all forms of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
func (x *SearchEntry) ConnectActivate(cb *func(SearchEntry)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := SearchEntry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the user initiates a move to the next match
// for the current search string.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// Applications should connect to it, to implement moving
// between matches.
//
// The default bindings for this signal is &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;g&lt;/kbd&gt;.
func (x *SearchEntry) ConnectNextMatch(cb *func(SearchEntry)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "next-match", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := SearchEntry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "next-match", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the user initiates a move to the previous match
// for the current search string.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// Applications should connect to it, to implement moving
// between matches.
//
// The default bindings for this signal is
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;g&lt;/kbd&gt;.
func (x *SearchEntry) ConnectPreviousMatch(cb *func(SearchEntry)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "previous-match", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := SearchEntry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "previous-match", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted with a delay. The length of the delay can be
// changed with the [property@Gtk.SearchEntry:search-delay]
// property.
func (x *SearchEntry) ConnectSearchChanged(cb *func(SearchEntry)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "search-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := SearchEntry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "search-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the user initiated a search on the entry.
func (x *SearchEntry) ConnectSearchStarted(cb *func(SearchEntry)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "search-started", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := SearchEntry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "search-started", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the user stops a search via keyboard input.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// Applications should connect to it, to implement hiding
// the search entry in this case.
//
// The default bindings for this signal is &lt;kbd&gt;Escape&lt;/kbd&gt;.
func (x *SearchEntry) ConnectStopSearch(cb *func(SearchEntry)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "stop-search", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := SearchEntry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "stop-search", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *SearchEntry) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *SearchEntry) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *SearchEntry) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())

	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *SearchEntry) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *SearchEntry) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)

	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *SearchEntry) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *SearchEntry) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *SearchEntry) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)

	return cret
}

// Resets the accessible property to its default value.
func (x *SearchEntry) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *SearchEntry) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *SearchEntry) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *SearchEntry) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *SearchEntry) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *SearchEntry) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *SearchEntry) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *SearchEntry) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *SearchEntry) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *SearchEntry) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *SearchEntry) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *SearchEntry) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *SearchEntry) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())

	return cret
}

// Retrieves the accessible platform state from the editable delegate.
//
// This is an helper function to retrieve the accessible state for
// `GtkEditable` interface implementations using a delegate pattern.
//
// You should call this function in your editable widget implementation
// of the [vfunc@Gtk.Accessible.get_platform_state] virtual function, for
// instance:
//
// ```c
// static void
// accessible_interface_init (GtkAccessibleInterface *iface)
//
//	{
//	  iface-&gt;get_platform_state = your_editable_get_accessible_platform_state;
//	}
//
// static gboolean
// your_editable_get_accessible_platform_state (GtkAccessible *accessible,
//
//	GtkAccessiblePlatformState state)
//
//	{
//	  return gtk_editable_delegate_get_accessible_platform_state (GTK_EDITABLE (accessible), state);
//	}
//
// ```
//
// Note that the widget which is the delegate *must* be a direct child of
// this widget, otherwise your implementation of [vfunc@Gtk.Accessible.get_platform_state]
// might not even be called, as the platform change will originate from
// the parent of the delegate, and, as a result, will not work properly.
//
// So, if you can't ensure the direct child condition, you should give the
// delegate the %GTK_ACCESSIBLE_ROLE_TEXT_BOX role, or you can
// change your tree to allow this function to work.
func (x *SearchEntry) DelegateGetAccessiblePlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkEditableDelegateGetAccessiblePlatformState(x.GoPointer(), StateVar)

	return cret
}

// Deletes the currently selected text of the editable.
//
// This call doesn’t do anything if there is no selected text.
func (x *SearchEntry) DeleteSelection() {

	XGtkEditableDeleteSelection(x.GoPointer())

}

// Deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters deleted are those from @start_pos to
// the end of the text.
//
// Note that the positions are specified in characters, not bytes.
func (x *SearchEntry) DeleteText(StartPosVar int, EndPosVar int) {

	XGtkEditableDeleteText(x.GoPointer(), StartPosVar, EndPosVar)

}

// Undoes the setup done by [method@Gtk.Editable.init_delegate].
//
// This is a helper function that should be called from dispose,
// before removing the delegate object.
func (x *SearchEntry) FinishDelegate() {

	XGtkEditableFinishDelegate(x.GoPointer())

}

// Gets the alignment of the editable.
func (x *SearchEntry) GetAlignment() float32 {

	cret := XGtkEditableGetAlignment(x.GoPointer())

	return cret
}

// Retrieves a sequence of characters.
//
// The characters that are retrieved are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is negative,
// then the characters retrieved are those characters from @start_pos to
// the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *SearchEntry) GetChars(StartPosVar int, EndPosVar int) string {

	cret := XGtkEditableGetChars(x.GoPointer(), StartPosVar, EndPosVar)

	return cret
}

// Gets the `GtkEditable` that @editable is delegating its
// implementation to.
//
// Typically, the delegate is a [class@Gtk.Text] widget.
func (x *SearchEntry) GetDelegate() *EditableBase {
	var cls *EditableBase

	cret := XGtkEditableGetDelegate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditableBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves whether @editable is editable.
func (x *SearchEntry) GetEditable() bool {

	cret := XGtkEditableGetEditable(x.GoPointer())

	return cret
}

// Gets if undo/redo actions are enabled for @editable
func (x *SearchEntry) GetEnableUndo() bool {

	cret := XGtkEditableGetEnableUndo(x.GoPointer())

	return cret
}

// Retrieves the desired maximum width of @editable, in characters.
func (x *SearchEntry) GetMaxWidthChars() int {

	cret := XGtkEditableGetMaxWidthChars(x.GoPointer())

	return cret
}

// Retrieves the current position of the cursor relative
// to the start of the content of the editable.
//
// Note that this position is in characters, not in bytes.
func (x *SearchEntry) GetPosition() int {

	cret := XGtkEditableGetPosition(x.GoPointer())

	return cret
}

// Retrieves the selection bound of the editable.
//
// @start_pos will be filled with the start of the selection and
// @end_pos with end. If no text was selected both will be identical
// and %FALSE will be returned.
//
// Note that positions are specified in characters, not bytes.
func (x *SearchEntry) GetSelectionBounds(StartPosVar *int, EndPosVar *int) bool {

	cret := XGtkEditableGetSelectionBounds(x.GoPointer(), StartPosVar, EndPosVar)

	return cret
}

// Retrieves the contents of @editable.
//
// The returned string is owned by GTK and must not be modified or freed.
func (x *SearchEntry) GetText() string {

	cret := XGtkEditableGetText(x.GoPointer())

	return cret
}

// Gets the number of characters of space reserved
// for the contents of the editable.
func (x *SearchEntry) GetWidthChars() int {

	cret := XGtkEditableGetWidthChars(x.GoPointer())

	return cret
}

// Sets up a delegate for `GtkEditable`.
//
// This is assuming that the get_delegate vfunc in the `GtkEditable`
// interface has been set up for the @editable's type.
//
// This is a helper function that should be called in instance init,
// after creating the delegate object.
func (x *SearchEntry) InitDelegate() {

	XGtkEditableInitDelegate(x.GoPointer())

}

// Inserts @length bytes of @text into the contents of the
// widget, at position @position.
//
// Note that the position is in characters, not in bytes.
// The function updates @position to point after the newly
// inserted text.
func (x *SearchEntry) InsertText(TextVar string, LengthVar int, PositionVar int) {

	XGtkEditableInsertText(x.GoPointer(), TextVar, LengthVar, PositionVar)

}

// Selects a region of text.
//
// The characters that are selected are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters selected are those characters from
// @start_pos to  the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *SearchEntry) SelectRegion(StartPosVar int, EndPosVar int) {

	XGtkEditableSelectRegion(x.GoPointer(), StartPosVar, EndPosVar)

}

// Sets the alignment for the contents of the editable.
//
// This controls the horizontal positioning of the contents when
// the displayed text is shorter than the width of the editable.
func (x *SearchEntry) SetAlignment(XalignVar float32) {

	XGtkEditableSetAlignment(x.GoPointer(), XalignVar)

}

// Determines if the user can edit the text in the editable widget.
func (x *SearchEntry) SetEditable(IsEditableVar bool) {

	XGtkEditableSetEditable(x.GoPointer(), IsEditableVar)

}

// If enabled, changes to @editable will be saved for undo/redo
// actions.
//
// This results in an additional copy of text changes and are not
// stored in secure memory. As such, undo is forcefully disabled
// when [property@Gtk.Text:visibility] is set to %FALSE.
func (x *SearchEntry) SetEnableUndo(EnableUndoVar bool) {

	XGtkEditableSetEnableUndo(x.GoPointer(), EnableUndoVar)

}

// Sets the desired maximum width in characters of @editable.
func (x *SearchEntry) SetMaxWidthChars(NCharsVar int) {

	XGtkEditableSetMaxWidthChars(x.GoPointer(), NCharsVar)

}

// Sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0)
// index in the contents of the editable. The value must be less than
// or equal to the number of characters in the editable. A value of -1
// indicates that the position should be set after the last character
// of the editable. Note that @position is in characters, not in bytes.
func (x *SearchEntry) SetPosition(PositionVar int) {

	XGtkEditableSetPosition(x.GoPointer(), PositionVar)

}

// Sets the text in the editable to the given value.
//
// This is replacing the current contents.
func (x *SearchEntry) SetText(TextVar string) {

	XGtkEditableSetText(x.GoPointer(), TextVar)

}

// Changes the size request of the editable to be about the
// right size for @n_chars characters.
//
// Note that it changes the size request, the size can still
// be affected by how you pack the widget into containers.
// If @n_chars is -1, the size reverts to the default size.
func (x *SearchEntry) SetWidthChars(NCharsVar int) {

	XGtkEditableSetWidthChars(x.GoPointer(), NCharsVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSearchEntryGLibType, libs, "gtk_search_entry_get_type")

	core.PuregoSafeRegister(&xNewSearchEntry, libs, "gtk_search_entry_new")

	core.PuregoSafeRegister(&xSearchEntryGetInputHints, libs, "gtk_search_entry_get_input_hints")
	core.PuregoSafeRegister(&xSearchEntryGetInputPurpose, libs, "gtk_search_entry_get_input_purpose")
	core.PuregoSafeRegister(&xSearchEntryGetKeyCaptureWidget, libs, "gtk_search_entry_get_key_capture_widget")
	core.PuregoSafeRegister(&xSearchEntryGetPlaceholderText, libs, "gtk_search_entry_get_placeholder_text")
	core.PuregoSafeRegister(&xSearchEntryGetSearchDelay, libs, "gtk_search_entry_get_search_delay")
	core.PuregoSafeRegister(&xSearchEntrySetInputHints, libs, "gtk_search_entry_set_input_hints")
	core.PuregoSafeRegister(&xSearchEntrySetInputPurpose, libs, "gtk_search_entry_set_input_purpose")
	core.PuregoSafeRegister(&xSearchEntrySetKeyCaptureWidget, libs, "gtk_search_entry_set_key_capture_widget")
	core.PuregoSafeRegister(&xSearchEntrySetPlaceholderText, libs, "gtk_search_entry_set_placeholder_text")
	core.PuregoSafeRegister(&xSearchEntrySetSearchDelay, libs, "gtk_search_entry_set_search_delay")

}
