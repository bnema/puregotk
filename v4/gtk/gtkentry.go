// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// Class structure for `GtkEntry`. All virtual functions have a default
// implementation. Derived classes may set the virtual function pointers for the
// signal handlers to %NULL, but must keep @get_text_area_size and
// @get_frame_size non-%NULL; either use the default implementation, or provide
// a custom one.
type EntryClass struct {
	_ structs.HostLayout

	ParentClass WidgetClass

	xActivate uintptr

	Padding [8]uintptr
}

func (x *EntryClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideActivate sets the "activate" callback function.
// Class handler for the `GtkEntry::activate` signal. The default
//
//	implementation activates the gtk.activate-default action.
func (x *EntryClass) OverrideActivate(cb func(*Entry)) {
	if cb == nil {
		x.xActivate = 0
	} else {
		x.xActivate = purego.NewCallback(func(EntryVarp uintptr) {
			cb(EntryNewFromInternalPtr(EntryVarp))
		})
	}
}

// GetActivate gets the "activate" callback function.
// Class handler for the `GtkEntry::activate` signal. The default
//
//	implementation activates the gtk.activate-default action.
func (x *EntryClass) GetActivate() func(*Entry) {
	if x.xActivate == 0 {
		return nil
	}
	var rawCallback func(EntryVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xActivate)
	return func(EntryVar *Entry) {
		rawCallback(EntryVar.GoPointer())
	}
}

// Specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

var xEntryIconPositionGLibType func() types.GType

func EntryIconPositionGLibType() types.GType {
	return xEntryIconPositionGLibType()
}

const (

	// At the beginning of the entry (depending on the text direction).
	EntryIconPrimaryValue EntryIconPosition = 0
	// At the end of the entry (depending on the text direction).
	EntryIconSecondaryValue EntryIconPosition = 1
)

// A single-line text entry widget.
//
// &lt;picture&gt;
//
//	&lt;source srcset="entry-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkEntry" src="entry.png"&gt;
//
// &lt;/picture&gt;
//
// A fairly large set of key bindings are supported by default. If the
// entered text is longer than the allocation of the widget, the widget
// will scroll so that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it
// can be put into “password mode” using [method@Gtk.Entry.set_visibility].
// In this mode, entered text is displayed using a “invisible” character.
// By default, GTK picks the best invisible character that is available
// in the current font, but it can be changed with
// [method@Gtk.Entry.set_invisible_char].
//
// `GtkEntry` has the ability to display progress or activity
// information behind the text. To make an entry display such information,
// use [method@Gtk.Entry.set_progress_fraction] or
// [method@Gtk.Entry.set_progress_pulse_step].
//
// Additionally, `GtkEntry` can show icons at either side of the entry.
// These icons can be activatable by clicking, can be set up as drag source
// and can have tooltips. To add an icon, use
// [method@Gtk.Entry.set_icon_from_gicon] or one of the various other functions
// that set an icon from an icon name or a paintable. To trigger an action when
// the user clicks an icon, connect to the [signal@Gtk.Entry::icon-press] signal.
// To allow DND operations from an icon, use
// [method@Gtk.Entry.set_icon_drag_source]. To set a tooltip on an icon, use
// [method@Gtk.Entry.set_icon_tooltip_text] or the corresponding function
// for markup.
//
// Note that functionality or information that is only available by clicking
// on an icon in an entry may not be accessible at all to users which are not
// able to use a mouse or other pointing device. It is therefore recommended
// that any such functionality should also be available by other means, e.g.
// via the context menu of the entry.
//
// # CSS nodes
//
// ```
// entry[.flat][.warning][.error]
// ├── text[.readonly]
// ├── image.left
// ├── image.right
// ╰── [progress[.pulse]]
// ```
//
// `GtkEntry` has a main node with the name entry. Depending on the properties
// of the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry shows progress, it adds a subnode with the name progress.
// The node has the style class .pulse when the shown progress is pulsing.
//
// For all the subnodes added to the text node in various situations,
// see [class@Gtk.Text].
//
// # GtkEntry as GtkBuildable
//
// The `GtkEntry` implementation of the `GtkBuildable` interface supports a
// custom `&lt;attributes&gt;` element, which supports any number of `&lt;attribute&gt;`
// elements. The `&lt;attribute&gt;` element has attributes named “name“, “value“,
// “start“ and “end“ and allows you to specify `PangoAttribute` values for
// this label.
//
// An example of a UI definition fragment specifying Pango attributes:
// ```xml
// &lt;object class="GtkEntry"&gt;
//
//	&lt;attributes&gt;
//	  &lt;attribute name="weight" value="PANGO_WEIGHT_BOLD"/&gt;
//	  &lt;attribute name="background" value="red" start="5" end="10"/&gt;
//	&lt;/attributes&gt;
//
// &lt;/object&gt;
// ```
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute
// is applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
// # Accessibility
//
// `GtkEntry` uses the [enum@Gtk.AccessibleRole.text_box] role.
type Entry struct {
	Widget
}

var xEntryGLibType func() types.GType

func EntryGLibType() types.GType {
	return xEntryGLibType()
}

func EntryNewFromInternalPtr(ptr uintptr) *Entry {
	cls := &Entry{}
	cls.Ptr = ptr
	return cls
}

var xNewEntry func() uintptr

// Creates a new entry.
func NewEntry() *Entry {
	var cls *Entry

	cret := xNewEntry()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Entry{}
	cls.Ptr = cret
	return cls
}

var xNewEntryWithBuffer func(uintptr) uintptr

// Creates a new entry with the specified text buffer.
func NewEntryWithBuffer(BufferVar *EntryBuffer) *Entry {
	var cls *Entry

	cret := xNewEntryWithBuffer(BufferVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Entry{}
	cls.Ptr = cret
	return cls
}

var xEntryGetActivatesDefault func(uintptr) bool

// Retrieves the value set by gtk_entry_set_activates_default().
func (x *Entry) GetActivatesDefault() bool {

	cret := xEntryGetActivatesDefault(x.GoPointer())
	return cret
}

var xEntryGetAlignment func(uintptr) float32

// Gets the value set by gtk_entry_set_alignment().
//
// See also: [property@Gtk.Editable:xalign]
func (x *Entry) GetAlignment() float32 {

	cret := xEntryGetAlignment(x.GoPointer())
	return cret
}

var xEntryGetAttributes func(uintptr) *pango.AttrList

// Gets the attribute list of the `GtkEntry`.
//
// See [method@Gtk.Entry.set_attributes].
func (x *Entry) GetAttributes() *pango.AttrList {

	cret := xEntryGetAttributes(x.GoPointer())
	return cret
}

var xEntryGetBuffer func(uintptr) uintptr

// Get the `GtkEntryBuffer` object which holds the text for
// this widget.
func (x *Entry) GetBuffer() *EntryBuffer {
	var cls *EntryBuffer

	cret := xEntryGetBuffer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EntryBuffer{}
	cls.Ptr = cret
	return cls
}

var xEntryGetCompletion func(uintptr) uintptr

// Returns the auxiliary completion object currently
// in use by @entry.
func (x *Entry) GetCompletion() *EntryCompletion {
	var cls *EntryCompletion

	cret := xEntryGetCompletion(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EntryCompletion{}
	cls.Ptr = cret
	return cls
}

var xEntryGetCurrentIconDragSource func(uintptr) int

// Returns the index of the icon which is the source of the
// current  DND operation, or -1.
func (x *Entry) GetCurrentIconDragSource() int {

	cret := xEntryGetCurrentIconDragSource(x.GoPointer())
	return cret
}

var xEntryGetExtraMenu func(uintptr) uintptr

// Gets the menu model set with gtk_entry_set_extra_menu().
func (x *Entry) GetExtraMenu() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xEntryGetExtraMenu(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xEntryGetHasFrame func(uintptr) bool

// Gets the value set by gtk_entry_set_has_frame().
func (x *Entry) GetHasFrame() bool {

	cret := xEntryGetHasFrame(x.GoPointer())
	return cret
}

var xEntryGetIconActivatable func(uintptr, EntryIconPosition) bool

// Returns whether the icon is activatable.
func (x *Entry) GetIconActivatable(IconPosVar EntryIconPosition) bool {

	cret := xEntryGetIconActivatable(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconArea func(uintptr, EntryIconPosition, *gdk.Rectangle)

// Gets the area where entry’s icon at @icon_pos is drawn.
//
// This function is useful when drawing something to the
// entry in a draw callback.
//
// If the entry is not realized or has no icon at the given
// position, @icon_area is filled with zeros. Otherwise,
// @icon_area will be filled with the icon's allocation,
// relative to @entry's allocation.
func (x *Entry) GetIconArea(IconPosVar EntryIconPosition, IconAreaVar *gdk.Rectangle) {

	xEntryGetIconArea(x.GoPointer(), IconPosVar, IconAreaVar)

}

var xEntryGetIconAtPos func(uintptr, int, int) int

// Finds the icon at the given position and return its index.
//
// The position’s coordinates are relative to the @entry’s
// top left corner. If @x, @y doesn’t lie inside an icon,
// -1 is returned. This function is intended for use in a
// [signal@Gtk.Widget::query-tooltip] signal handler.
func (x *Entry) GetIconAtPos(XVar int, YVar int) int {

	cret := xEntryGetIconAtPos(x.GoPointer(), XVar, YVar)
	return cret
}

var xEntryGetIconGicon func(uintptr, EntryIconPosition) uintptr

// Retrieves the `GIcon` used for the icon.
//
// %NULL will be returned if there is no icon or if the icon was
// set by some other method (e.g., by `GdkPaintable` or icon name).
func (x *Entry) GetIconGicon(IconPosVar EntryIconPosition) *gio.IconBase {
	var cls *gio.IconBase

	cret := xEntryGetIconGicon(x.GoPointer(), IconPosVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.IconBase{}
	cls.Ptr = cret
	return cls
}

var xEntryGetIconName func(uintptr, EntryIconPosition) string

// Retrieves the icon name used for the icon.
//
// %NULL is returned if there is no icon or if the icon was set
// by some other method (e.g., by `GdkPaintable` or gicon).
func (x *Entry) GetIconName(IconPosVar EntryIconPosition) string {

	cret := xEntryGetIconName(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconPaintable func(uintptr, EntryIconPosition) uintptr

// Retrieves the `GdkPaintable` used for the icon.
//
// If no `GdkPaintable` was used for the icon, %NULL is returned.
func (x *Entry) GetIconPaintable(IconPosVar EntryIconPosition) *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := xEntryGetIconPaintable(x.GoPointer(), IconPosVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

var xEntryGetIconSensitive func(uintptr, EntryIconPosition) bool

// Returns whether the icon appears sensitive or insensitive.
func (x *Entry) GetIconSensitive(IconPosVar EntryIconPosition) bool {

	cret := xEntryGetIconSensitive(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconStorageType func(uintptr, EntryIconPosition) ImageType

// Gets the type of representation being used by the icon
// to store image data.
//
// If the icon has no image data, the return value will
// be %GTK_IMAGE_EMPTY.
func (x *Entry) GetIconStorageType(IconPosVar EntryIconPosition) ImageType {

	cret := xEntryGetIconStorageType(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconTooltipMarkup func(uintptr, EntryIconPosition) string

// Gets the contents of the tooltip on the icon at the specified
// position in @entry.
func (x *Entry) GetIconTooltipMarkup(IconPosVar EntryIconPosition) string {

	cret := xEntryGetIconTooltipMarkup(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconTooltipText func(uintptr, EntryIconPosition) string

// Gets the contents of the tooltip on the icon at the specified
// position in @entry.
func (x *Entry) GetIconTooltipText(IconPosVar EntryIconPosition) string {

	cret := xEntryGetIconTooltipText(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetInputHints func(uintptr) InputHints

// Gets the input hints of this `GtkEntry`.
func (x *Entry) GetInputHints() InputHints {

	cret := xEntryGetInputHints(x.GoPointer())
	return cret
}

var xEntryGetInputPurpose func(uintptr) InputPurpose

// Gets the input purpose of the `GtkEntry`.
func (x *Entry) GetInputPurpose() InputPurpose {

	cret := xEntryGetInputPurpose(x.GoPointer())
	return cret
}

var xEntryGetInvisibleChar func(uintptr) uint32

// Retrieves the character displayed in place of the actual text
// in “password mode”.
func (x *Entry) GetInvisibleChar() uint32 {

	cret := xEntryGetInvisibleChar(x.GoPointer())
	return cret
}

var xEntryGetMaxLength func(uintptr) int

// Retrieves the maximum allowed length of the text in @entry.
//
// See [method@Gtk.Entry.set_max_length].
func (x *Entry) GetMaxLength() int {

	cret := xEntryGetMaxLength(x.GoPointer())
	return cret
}

var xEntryGetMenuEntryIconText func(uintptr, EntryIconPosition) string

// Gets the text that will be used in the context menu of the `GtkEntry`
// when the specified icon is activatable. Selecting this item in the menu
// results, from all aspects, the same than clicking on the specified icon.
// This greatly simplifies making accessible applications, because the icons
// aren't focusable when using keyboard navigation. This is why Gtk recommends
// to add the same action to the context menu.
func (x *Entry) GetMenuEntryIconText(IconPosVar EntryIconPosition) string {

	cret := xEntryGetMenuEntryIconText(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetOverwriteMode func(uintptr) bool

// Gets whether the `GtkEntry` is in overwrite mode.
func (x *Entry) GetOverwriteMode() bool {

	cret := xEntryGetOverwriteMode(x.GoPointer())
	return cret
}

var xEntryGetPlaceholderText func(uintptr) string

// Retrieves the text that will be displayed when @entry
// is empty and unfocused
func (x *Entry) GetPlaceholderText() string {

	cret := xEntryGetPlaceholderText(x.GoPointer())
	return cret
}

var xEntryGetProgressFraction func(uintptr) float64

// Returns the current fraction of the task that’s been completed.
//
// See [method@Gtk.Entry.set_progress_fraction].
func (x *Entry) GetProgressFraction() float64 {

	cret := xEntryGetProgressFraction(x.GoPointer())
	return cret
}

var xEntryGetProgressPulseStep func(uintptr) float64

// Retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
func (x *Entry) GetProgressPulseStep() float64 {

	cret := xEntryGetProgressPulseStep(x.GoPointer())
	return cret
}

var xEntryGetTabs func(uintptr) *pango.TabArray

// Gets the tabstops of the `GtkEntry`.
//
// See [method@Gtk.Entry.set_tabs].
func (x *Entry) GetTabs() *pango.TabArray {

	cret := xEntryGetTabs(x.GoPointer())
	return cret
}

var xEntryGetTextLength func(uintptr) uint16

// Retrieves the current length of the text in @entry.
//
// This is equivalent to getting @entry's `GtkEntryBuffer`
// and calling [method@Gtk.EntryBuffer.get_length] on it.
func (x *Entry) GetTextLength() uint16 {

	cret := xEntryGetTextLength(x.GoPointer())
	return cret
}

var xEntryGetVisibility func(uintptr) bool

// Retrieves whether the text in @entry is visible.
//
// See [method@Gtk.Entry.set_visibility].
func (x *Entry) GetVisibility() bool {

	cret := xEntryGetVisibility(x.GoPointer())
	return cret
}

var xEntryGrabFocusWithoutSelecting func(uintptr) bool

// Causes @entry to have keyboard focus.
//
// It behaves like [method@Gtk.Widget.grab_focus], except that it doesn't
// select the contents of the entry. You only want to call this on some
// special entries which the user usually doesn't want to replace all text
// in, such as search-as-you-type entries.
func (x *Entry) GrabFocusWithoutSelecting() bool {

	cret := xEntryGrabFocusWithoutSelecting(x.GoPointer())
	return cret
}

var xEntryProgressPulse func(uintptr)

// Indicates that some progress is made, but you don’t
// know how much.
//
// Causes the entry’s progress indicator to enter “activity
// mode”, where a block bounces back and forth. Each call to
// gtk_entry_progress_pulse() causes the block to move by a
// little bit (the amount of movement per pulse is determined
// by [method@Gtk.Entry.set_progress_pulse_step]).
func (x *Entry) ProgressPulse() {

	xEntryProgressPulse(x.GoPointer())

}

var xEntryResetImContext func(uintptr)

// Reset the input method context of the entry if needed.
//
// This can be necessary in the case where modifying the buffer
// would confuse on-going input method behavior.
func (x *Entry) ResetImContext() {

	xEntryResetImContext(x.GoPointer())

}

var xEntrySetActivatesDefault func(uintptr, bool)

// Sets whether pressing Enter in the @entry will activate the default
// widget for the window containing the entry.
//
// This usually means that the dialog containing the entry will be closed,
// since the default widget is usually one of the dialog buttons.
func (x *Entry) SetActivatesDefault(SettingVar bool) {

	xEntrySetActivatesDefault(x.GoPointer(), SettingVar)

}

var xEntrySetAlignment func(uintptr, float32)

// Sets the alignment for the contents of the entry.
//
// This controls the horizontal positioning of the contents when
// the displayed text is shorter than the width of the entry.
//
// See also: [property@Gtk.Editable:xalign]
func (x *Entry) SetAlignment(XalignVar float32) {

	xEntrySetAlignment(x.GoPointer(), XalignVar)

}

var xEntrySetAttributes func(uintptr, *pango.AttrList)

// Sets a `PangoAttrList`.
//
// The attributes in the list are applied to the entry text.
//
// Since the attributes will be applied to text that changes
// as the user types, it makes most sense to use attributes
// with unlimited extent.
func (x *Entry) SetAttributes(AttrsVar *pango.AttrList) {

	xEntrySetAttributes(x.GoPointer(), AttrsVar)

}

var xEntrySetBuffer func(uintptr, uintptr)

// Set the `GtkEntryBuffer` object which holds the text for
// this widget.
func (x *Entry) SetBuffer(BufferVar *EntryBuffer) {

	xEntrySetBuffer(x.GoPointer(), BufferVar.GoPointer())

}

var xEntrySetCompletion func(uintptr, uintptr)

// Sets @completion to be the auxiliary completion object
// to use with @entry.
//
// All further configuration of the completion mechanism is
// done on @completion using the `GtkEntryCompletion` API.
// Completion is disabled if @completion is set to %NULL.
func (x *Entry) SetCompletion(CompletionVar *EntryCompletion) {

	xEntrySetCompletion(x.GoPointer(), CompletionVar.GoPointer())

}

var xEntrySetExtraMenu func(uintptr, uintptr)

// Sets a menu model to add when constructing
// the context menu for @entry.
func (x *Entry) SetExtraMenu(ModelVar *gio.MenuModel) {

	xEntrySetExtraMenu(x.GoPointer(), ModelVar.GoPointer())

}

var xEntrySetHasFrame func(uintptr, bool)

// Sets whether the entry has a beveled frame around it.
func (x *Entry) SetHasFrame(SettingVar bool) {

	xEntrySetHasFrame(x.GoPointer(), SettingVar)

}

var xEntrySetIconActivatable func(uintptr, EntryIconPosition, bool)

// Sets whether the icon is activatable.
func (x *Entry) SetIconActivatable(IconPosVar EntryIconPosition, ActivatableVar bool) {

	xEntrySetIconActivatable(x.GoPointer(), IconPosVar, ActivatableVar)

}

var xEntrySetIconDragSource func(uintptr, EntryIconPosition, uintptr, gdk.DragAction)

// Sets up the icon at the given position as drag source.
//
// This makes it so that GTK will start a drag
// operation when the user clicks and drags the icon.
func (x *Entry) SetIconDragSource(IconPosVar EntryIconPosition, ProviderVar *gdk.ContentProvider, ActionsVar gdk.DragAction) {

	xEntrySetIconDragSource(x.GoPointer(), IconPosVar, ProviderVar.GoPointer(), ActionsVar)

}

var xEntrySetIconFromGicon func(uintptr, EntryIconPosition, uintptr)

// Sets the icon shown in the entry at the specified position
// from the current icon theme.
//
// If the icon isn’t known, a “broken image” icon will be
// displayed instead.
//
// If @icon is %NULL, no icon will be shown in the
// specified position.
func (x *Entry) SetIconFromGicon(IconPosVar EntryIconPosition, IconVar gio.Icon) {

	xEntrySetIconFromGicon(x.GoPointer(), IconPosVar, IconVar.GoPointer())

}

var xEntrySetIconFromIconName func(uintptr, EntryIconPosition, uintptr)

// Sets the icon shown in the entry at the specified position
// from the current icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be
// displayed instead.
//
// If @icon_name is %NULL, no icon will be shown in the
// specified position.
func (x *Entry) SetIconFromIconName(IconPosVar EntryIconPosition, IconNameVar *string) {

	IconNameVarPtr := core.GStrdupNullable(IconNameVar)
	defer core.GFreeNullable(IconNameVarPtr)

	xEntrySetIconFromIconName(x.GoPointer(), IconPosVar, IconNameVarPtr)

}

var xEntrySetIconFromPaintable func(uintptr, EntryIconPosition, uintptr)

// Sets the icon shown in the specified position using a `GdkPaintable`.
//
// If @paintable is %NULL, no icon will be shown in the specified position.
func (x *Entry) SetIconFromPaintable(IconPosVar EntryIconPosition, PaintableVar gdk.Paintable) {

	xEntrySetIconFromPaintable(x.GoPointer(), IconPosVar, PaintableVar.GoPointer())

}

var xEntrySetIconSensitive func(uintptr, EntryIconPosition, bool)

// Sets the sensitivity for the specified icon.
func (x *Entry) SetIconSensitive(IconPosVar EntryIconPosition, SensitiveVar bool) {

	xEntrySetIconSensitive(x.GoPointer(), IconPosVar, SensitiveVar)

}

var xEntrySetIconTooltipMarkup func(uintptr, EntryIconPosition, uintptr)

// Sets @tooltip as the contents of the tooltip for the icon at
// the specified position.
//
// @tooltip is assumed to be marked up with Pango Markup.
//
// Use %NULL for @tooltip to remove an existing tooltip.
//
// See also [method@Gtk.Widget.set_tooltip_markup] and
// [method@Gtk.Entry.set_icon_tooltip_text].
func (x *Entry) SetIconTooltipMarkup(IconPosVar EntryIconPosition, TooltipVar *string) {

	TooltipVarPtr := core.GStrdupNullable(TooltipVar)
	defer core.GFreeNullable(TooltipVarPtr)

	xEntrySetIconTooltipMarkup(x.GoPointer(), IconPosVar, TooltipVarPtr)

}

var xEntrySetIconTooltipText func(uintptr, EntryIconPosition, uintptr)

// Sets @tooltip as the contents of the tooltip for the icon
// at the specified position.
//
// Use %NULL for @tooltip to remove an existing tooltip.
//
// See also [method@Gtk.Widget.set_tooltip_text] and
// [method@Gtk.Entry.set_icon_tooltip_markup].
//
// If you unset the widget tooltip via
// [method@Gtk.Widget.set_tooltip_text] or
// [method@Gtk.Widget.set_tooltip_markup], this sets
// [property@Gtk.Widget:has-tooltip] to %FALSE, which suppresses
// icon tooltips too. You can resolve this by then calling
// [method@Gtk.Widget.set_has_tooltip] to set
// [property@Gtk.Widget:has-tooltip] back to %TRUE, or
// setting at least one non-empty tooltip on any icon
// achieves the same result.
func (x *Entry) SetIconTooltipText(IconPosVar EntryIconPosition, TooltipVar *string) {

	TooltipVarPtr := core.GStrdupNullable(TooltipVar)
	defer core.GFreeNullable(TooltipVarPtr)

	xEntrySetIconTooltipText(x.GoPointer(), IconPosVar, TooltipVarPtr)

}

var xEntrySetInputHints func(uintptr, InputHints)

// Set additional hints which allow input methods to
// fine-tune their behavior.
func (x *Entry) SetInputHints(HintsVar InputHints) {

	xEntrySetInputHints(x.GoPointer(), HintsVar)

}

var xEntrySetInputPurpose func(uintptr, InputPurpose)

// Sets the input purpose which can be used by input methods
// to adjust their behavior.
func (x *Entry) SetInputPurpose(PurposeVar InputPurpose) {

	xEntrySetInputPurpose(x.GoPointer(), PurposeVar)

}

var xEntrySetInvisibleChar func(uintptr, uint32)

// Sets the character to use in place of the actual text
// in “password mode”.
//
// See [method@Gtk.Entry.set_visibility] for how to enable
// “password mode”.
//
// By default, GTK picks the best invisible char available in
// the current font. If you set the invisible char to 0, then
// the user will get no feedback at all; there will be no text
// on the screen as they type.
func (x *Entry) SetInvisibleChar(ChVar uint32) {

	xEntrySetInvisibleChar(x.GoPointer(), ChVar)

}

var xEntrySetMaxLength func(uintptr, int)

// Sets the maximum allowed length of the contents of the widget.
//
// If the current contents are longer than the given length, then
// they will be truncated to fit. The length is in characters.
//
// This is equivalent to getting @entry's `GtkEntryBuffer` and
// calling [method@Gtk.EntryBuffer.set_max_length] on it.
func (x *Entry) SetMaxLength(MaxVar int) {

	xEntrySetMaxLength(x.GoPointer(), MaxVar)

}

var xEntrySetMenuEntryIconText func(uintptr, EntryIconPosition, string)

// Sets the text that will be used in the context menu of the `GtkEntry`
// when the specified icon is activatable. Selecting this item in the menu
// results, from all aspects, the same than clicking on the specified icon.
// This greatly simplifies making accessible applications, because the icons
// aren't focusable when using keyboard navigation. This is why Gtk recommends
// to add the same action to the context menu.
func (x *Entry) SetMenuEntryIconText(IconPosVar EntryIconPosition, TextVar string) {

	xEntrySetMenuEntryIconText(x.GoPointer(), IconPosVar, TextVar)

}

var xEntrySetOverwriteMode func(uintptr, bool)

// Sets whether the text is overwritten when typing in the `GtkEntry`.
func (x *Entry) SetOverwriteMode(OverwriteVar bool) {

	xEntrySetOverwriteMode(x.GoPointer(), OverwriteVar)

}

var xEntrySetPlaceholderText func(uintptr, uintptr)

// Sets text to be displayed in @entry when it is empty.
//
// This can be used to give a visual hint of the expected
// contents of the `GtkEntry`.
func (x *Entry) SetPlaceholderText(TextVar *string) {

	TextVarPtr := core.GStrdupNullable(TextVar)
	defer core.GFreeNullable(TextVarPtr)

	xEntrySetPlaceholderText(x.GoPointer(), TextVarPtr)

}

var xEntrySetProgressFraction func(uintptr, float64)

// Causes the entry’s progress indicator to “fill in” the given
// fraction of the bar.
//
// The fraction should be between 0.0 and 1.0, inclusive.
func (x *Entry) SetProgressFraction(FractionVar float64) {

	xEntrySetProgressFraction(x.GoPointer(), FractionVar)

}

var xEntrySetProgressPulseStep func(uintptr, float64)

// Sets the fraction of total entry width to move the progress
// bouncing block for each pulse.
//
// Use [method@Gtk.Entry.progress_pulse] to pulse
// the progress.
func (x *Entry) SetProgressPulseStep(FractionVar float64) {

	xEntrySetProgressPulseStep(x.GoPointer(), FractionVar)

}

var xEntrySetTabs func(uintptr, *pango.TabArray)

// Sets a `PangoTabArray`.
//
// The tabstops in the array are applied to the entry text.
func (x *Entry) SetTabs(TabsVar *pango.TabArray) {

	xEntrySetTabs(x.GoPointer(), TabsVar)

}

var xEntrySetVisibility func(uintptr, bool)

// Sets whether the contents of the entry are visible or not.
//
// When visibility is set to %FALSE, characters are displayed
// as the invisible char, and will also appear that way when
// the text in the entry widget is copied elsewhere.
//
// By default, GTK picks the best invisible character available
// in the current font, but it can be changed with
// [method@Gtk.Entry.set_invisible_char].
//
// Note that you probably want to set [property@Gtk.Entry:input-purpose]
// to %GTK_INPUT_PURPOSE_PASSWORD or %GTK_INPUT_PURPOSE_PIN to
// inform input methods about the purpose of this entry,
// in addition to setting visibility to %FALSE.
func (x *Entry) SetVisibility(VisibleVar bool) {

	xEntrySetVisibility(x.GoPointer(), VisibleVar)

}

var xEntryUnsetInvisibleChar func(uintptr)

// Unsets the invisible char, so that the default invisible char
// is used again. See [method@Gtk.Entry.set_invisible_char].
func (x *Entry) UnsetInvisibleChar() {

	xEntryUnsetInvisibleChar(x.GoPointer())

}

func (c *Entry) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Entry) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyActivatesDefault sets the "activates-default" property.
// Whether to activate the default widget when Enter is pressed.
func (x *Entry) SetPropertyActivatesDefault(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("activates-default", &v)
}

// GetPropertyActivatesDefault gets the "activates-default" property.
// Whether to activate the default widget when Enter is pressed.
func (x *Entry) GetPropertyActivatesDefault() bool {
	var v gobject.Value
	x.GetProperty("activates-default", &v)
	return v.GetBoolean()
}

// SetPropertyAttributes sets the "attributes" property.
// A list of Pango attributes to apply to the text of the entry.
//
// This is mainly useful to change the size or weight of the text.
//
// The `PangoAttribute`'s @start_index and @end_index must refer to the
// [class@Gtk.EntryBuffer] text, i.e. without the preedit string.
func (x *Entry) SetPropertyAttributes(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("attributes", &v)
}

// GetPropertyAttributes gets the "attributes" property.
// A list of Pango attributes to apply to the text of the entry.
//
// This is mainly useful to change the size or weight of the text.
//
// The `PangoAttribute`'s @start_index and @end_index must refer to the
// [class@Gtk.EntryBuffer] text, i.e. without the preedit string.
func (x *Entry) GetPropertyAttributes() uintptr {
	var v gobject.Value
	x.GetProperty("attributes", &v)
	return v.GetPointer()
}

// SetPropertyEnableEmojiCompletion sets the "enable-emoji-completion" property.
// Whether to suggest Emoji replacements for :-delimited names
// like `:heart:`.
func (x *Entry) SetPropertyEnableEmojiCompletion(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("enable-emoji-completion", &v)
}

// GetPropertyEnableEmojiCompletion gets the "enable-emoji-completion" property.
// Whether to suggest Emoji replacements for :-delimited names
// like `:heart:`.
func (x *Entry) GetPropertyEnableEmojiCompletion() bool {
	var v gobject.Value
	x.GetProperty("enable-emoji-completion", &v)
	return v.GetBoolean()
}

// SetPropertyHasFrame sets the "has-frame" property.
// Whether the entry should draw a frame.
func (x *Entry) SetPropertyHasFrame(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("has-frame", &v)
}

// GetPropertyHasFrame gets the "has-frame" property.
// Whether the entry should draw a frame.
func (x *Entry) GetPropertyHasFrame() bool {
	var v gobject.Value
	x.GetProperty("has-frame", &v)
	return v.GetBoolean()
}

// SetPropertyImModule sets the "im-module" property.
// Which IM (input method) module should be used for this entry.
//
// See [class@Gtk.IMContext].
//
// Setting this to a non-%NULL value overrides the system-wide IM
// module setting. See the GtkSettings [property@Gtk.Settings:gtk-im-module]
// property.
func (x *Entry) SetPropertyImModule(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("im-module", &v)
}

// GetPropertyImModule gets the "im-module" property.
// Which IM (input method) module should be used for this entry.
//
// See [class@Gtk.IMContext].
//
// Setting this to a non-%NULL value overrides the system-wide IM
// module setting. See the GtkSettings [property@Gtk.Settings:gtk-im-module]
// property.
func (x *Entry) GetPropertyImModule() string {
	var v gobject.Value
	x.GetProperty("im-module", &v)
	return v.GetString()
}

// SetPropertyInvisibleChar sets the "invisible-char" property.
// The character to use when masking entry contents (“password mode”).
func (x *Entry) SetPropertyInvisibleChar(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("invisible-char", &v)
}

// GetPropertyInvisibleChar gets the "invisible-char" property.
// The character to use when masking entry contents (“password mode”).
func (x *Entry) GetPropertyInvisibleChar() uint {
	var v gobject.Value
	x.GetProperty("invisible-char", &v)
	return v.GetUint()
}

// SetPropertyInvisibleCharSet sets the "invisible-char-set" property.
// Whether the invisible char has been set for the `GtkEntry`.
func (x *Entry) SetPropertyInvisibleCharSet(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("invisible-char-set", &v)
}

// GetPropertyInvisibleCharSet gets the "invisible-char-set" property.
// Whether the invisible char has been set for the `GtkEntry`.
func (x *Entry) GetPropertyInvisibleCharSet() bool {
	var v gobject.Value
	x.GetProperty("invisible-char-set", &v)
	return v.GetBoolean()
}

// SetPropertyMaxLength sets the "max-length" property.
// Maximum number of characters for this entry.
func (x *Entry) SetPropertyMaxLength(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("max-length", &v)
}

// GetPropertyMaxLength gets the "max-length" property.
// Maximum number of characters for this entry.
func (x *Entry) GetPropertyMaxLength() int {
	var v gobject.Value
	x.GetProperty("max-length", &v)
	return v.GetInt()
}

// SetPropertyMenuEntryIconPrimaryText sets the "menu-entry-icon-primary-text" property.
// Text for an item in the context menu to activate the primary icon action.
//
// When the primary icon is activatable and this property has been set, a new entry
// in the context menu of this GtkEntry will appear with this text. Selecting that
// menu entry will result in the primary icon being activated, exactly in the same way
// as it would be activated from a mouse click.
//
// This simplifies adding accessibility support to applications using activatable
// icons. The activatable icons aren't focusable when navigating the interface with
// the keyboard This is why Gtk recommends to also add those actions in the context
// menu. This set of methods greatly simplifies this, by adding a menu item that, when
// enabled, calls the same callback than clicking on the icon.
func (x *Entry) SetPropertyMenuEntryIconPrimaryText(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("menu-entry-icon-primary-text", &v)
}

// GetPropertyMenuEntryIconPrimaryText gets the "menu-entry-icon-primary-text" property.
// Text for an item in the context menu to activate the primary icon action.
//
// When the primary icon is activatable and this property has been set, a new entry
// in the context menu of this GtkEntry will appear with this text. Selecting that
// menu entry will result in the primary icon being activated, exactly in the same way
// as it would be activated from a mouse click.
//
// This simplifies adding accessibility support to applications using activatable
// icons. The activatable icons aren't focusable when navigating the interface with
// the keyboard This is why Gtk recommends to also add those actions in the context
// menu. This set of methods greatly simplifies this, by adding a menu item that, when
// enabled, calls the same callback than clicking on the icon.
func (x *Entry) GetPropertyMenuEntryIconPrimaryText() string {
	var v gobject.Value
	x.GetProperty("menu-entry-icon-primary-text", &v)
	return v.GetString()
}

// SetPropertyMenuEntryIconSecondaryText sets the "menu-entry-icon-secondary-text" property.
// Text for an item in the context menu to activate the secondary icon action.
//
// When the primary icon is activatable and this property has been set, a new entry
// in the context menu of this GtkEntry will appear with this text. Selecting that
// menu entry will result in the primary icon being activated, exactly in the same way
// as it would be activated from a mouse click.
//
// This simplifies adding accessibility support to applications using activatable
// icons. The activatable icons aren't focusable when navigating the interface with
// the keyboard This is why Gtk recommends to also add those actions in the context
// menu. This set of methods greatly simplifies this, by adding a menu item that, when
// enabled, calls the same callback than clicking on the icon.
func (x *Entry) SetPropertyMenuEntryIconSecondaryText(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("menu-entry-icon-secondary-text", &v)
}

// GetPropertyMenuEntryIconSecondaryText gets the "menu-entry-icon-secondary-text" property.
// Text for an item in the context menu to activate the secondary icon action.
//
// When the primary icon is activatable and this property has been set, a new entry
// in the context menu of this GtkEntry will appear with this text. Selecting that
// menu entry will result in the primary icon being activated, exactly in the same way
// as it would be activated from a mouse click.
//
// This simplifies adding accessibility support to applications using activatable
// icons. The activatable icons aren't focusable when navigating the interface with
// the keyboard This is why Gtk recommends to also add those actions in the context
// menu. This set of methods greatly simplifies this, by adding a menu item that, when
// enabled, calls the same callback than clicking on the icon.
func (x *Entry) GetPropertyMenuEntryIconSecondaryText() string {
	var v gobject.Value
	x.GetProperty("menu-entry-icon-secondary-text", &v)
	return v.GetString()
}

// SetPropertyOverwriteMode sets the "overwrite-mode" property.
// If text is overwritten when typing in the `GtkEntry`.
func (x *Entry) SetPropertyOverwriteMode(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("overwrite-mode", &v)
}

// GetPropertyOverwriteMode gets the "overwrite-mode" property.
// If text is overwritten when typing in the `GtkEntry`.
func (x *Entry) GetPropertyOverwriteMode() bool {
	var v gobject.Value
	x.GetProperty("overwrite-mode", &v)
	return v.GetBoolean()
}

// SetPropertyPlaceholderText sets the "placeholder-text" property.
// The text that will be displayed in the `GtkEntry` when it is empty
// and unfocused.
func (x *Entry) SetPropertyPlaceholderText(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("placeholder-text", &v)
}

// GetPropertyPlaceholderText gets the "placeholder-text" property.
// The text that will be displayed in the `GtkEntry` when it is empty
// and unfocused.
func (x *Entry) GetPropertyPlaceholderText() string {
	var v gobject.Value
	x.GetProperty("placeholder-text", &v)
	return v.GetString()
}

// SetPropertyPrimaryIconActivatable sets the "primary-icon-activatable" property.
// Whether the primary icon is activatable.
//
// GTK emits the [signal@Gtk.Entry::icon-press] and
// [signal@Gtk.Entry::icon-release] signals only on sensitive,
// activatable icons.
//
// Sensitive, but non-activatable icons can be used for purely
// informational purposes.
func (x *Entry) SetPropertyPrimaryIconActivatable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("primary-icon-activatable", &v)
}

// GetPropertyPrimaryIconActivatable gets the "primary-icon-activatable" property.
// Whether the primary icon is activatable.
//
// GTK emits the [signal@Gtk.Entry::icon-press] and
// [signal@Gtk.Entry::icon-release] signals only on sensitive,
// activatable icons.
//
// Sensitive, but non-activatable icons can be used for purely
// informational purposes.
func (x *Entry) GetPropertyPrimaryIconActivatable() bool {
	var v gobject.Value
	x.GetProperty("primary-icon-activatable", &v)
	return v.GetBoolean()
}

// SetPropertyPrimaryIconName sets the "primary-icon-name" property.
// The icon name to use for the primary icon for the entry.
func (x *Entry) SetPropertyPrimaryIconName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("primary-icon-name", &v)
}

// GetPropertyPrimaryIconName gets the "primary-icon-name" property.
// The icon name to use for the primary icon for the entry.
func (x *Entry) GetPropertyPrimaryIconName() string {
	var v gobject.Value
	x.GetProperty("primary-icon-name", &v)
	return v.GetString()
}

// SetPropertyPrimaryIconSensitive sets the "primary-icon-sensitive" property.
// Whether the primary icon is sensitive.
//
// An insensitive icon appears grayed out. GTK does not emit the
// [signal@Gtk.Entry::icon-press] and [signal@Gtk.Entry::icon-release]
// signals and does not allow DND from insensitive icons.
//
// An icon should be set insensitive if the action that would trigger
// when clicked is currently not available.
func (x *Entry) SetPropertyPrimaryIconSensitive(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("primary-icon-sensitive", &v)
}

// GetPropertyPrimaryIconSensitive gets the "primary-icon-sensitive" property.
// Whether the primary icon is sensitive.
//
// An insensitive icon appears grayed out. GTK does not emit the
// [signal@Gtk.Entry::icon-press] and [signal@Gtk.Entry::icon-release]
// signals and does not allow DND from insensitive icons.
//
// An icon should be set insensitive if the action that would trigger
// when clicked is currently not available.
func (x *Entry) GetPropertyPrimaryIconSensitive() bool {
	var v gobject.Value
	x.GetProperty("primary-icon-sensitive", &v)
	return v.GetBoolean()
}

// SetPropertyPrimaryIconTooltipMarkup sets the "primary-icon-tooltip-markup" property.
// The contents of the tooltip on the primary icon, with markup.
//
// Also see [method@Gtk.Entry.set_icon_tooltip_markup].
func (x *Entry) SetPropertyPrimaryIconTooltipMarkup(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("primary-icon-tooltip-markup", &v)
}

// GetPropertyPrimaryIconTooltipMarkup gets the "primary-icon-tooltip-markup" property.
// The contents of the tooltip on the primary icon, with markup.
//
// Also see [method@Gtk.Entry.set_icon_tooltip_markup].
func (x *Entry) GetPropertyPrimaryIconTooltipMarkup() string {
	var v gobject.Value
	x.GetProperty("primary-icon-tooltip-markup", &v)
	return v.GetString()
}

// SetPropertyPrimaryIconTooltipText sets the "primary-icon-tooltip-text" property.
// The contents of the tooltip on the primary icon.
//
// Also see [method@Gtk.Entry.set_icon_tooltip_text].
func (x *Entry) SetPropertyPrimaryIconTooltipText(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("primary-icon-tooltip-text", &v)
}

// GetPropertyPrimaryIconTooltipText gets the "primary-icon-tooltip-text" property.
// The contents of the tooltip on the primary icon.
//
// Also see [method@Gtk.Entry.set_icon_tooltip_text].
func (x *Entry) GetPropertyPrimaryIconTooltipText() string {
	var v gobject.Value
	x.GetProperty("primary-icon-tooltip-text", &v)
	return v.GetString()
}

// SetPropertyProgressFraction sets the "progress-fraction" property.
// The current fraction of the task that's been completed.
func (x *Entry) SetPropertyProgressFraction(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("progress-fraction", &v)
}

// GetPropertyProgressFraction gets the "progress-fraction" property.
// The current fraction of the task that's been completed.
func (x *Entry) GetPropertyProgressFraction() float64 {
	var v gobject.Value
	x.GetProperty("progress-fraction", &v)
	return v.GetDouble()
}

// SetPropertyProgressPulseStep sets the "progress-pulse-step" property.
// The fraction of total entry width to move the progress
// bouncing block for each pulse.
//
// See [method@Gtk.Entry.progress_pulse].
func (x *Entry) SetPropertyProgressPulseStep(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("progress-pulse-step", &v)
}

// GetPropertyProgressPulseStep gets the "progress-pulse-step" property.
// The fraction of total entry width to move the progress
// bouncing block for each pulse.
//
// See [method@Gtk.Entry.progress_pulse].
func (x *Entry) GetPropertyProgressPulseStep() float64 {
	var v gobject.Value
	x.GetProperty("progress-pulse-step", &v)
	return v.GetDouble()
}

// GetPropertyScrollOffset gets the "scroll-offset" property.
// Number of pixels of the entry scrolled off the screen to the left.
func (x *Entry) GetPropertyScrollOffset() int {
	var v gobject.Value
	x.GetProperty("scroll-offset", &v)
	return v.GetInt()
}

// SetPropertySecondaryIconActivatable sets the "secondary-icon-activatable" property.
// Whether the secondary icon is activatable.
//
// GTK emits the [signal@Gtk.Entry::icon-press] and
// [signal@Gtk.Entry::icon-release] signals only on sensitive,
// activatable icons.
//
// Sensitive, but non-activatable icons can be used for purely
// informational purposes.
func (x *Entry) SetPropertySecondaryIconActivatable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("secondary-icon-activatable", &v)
}

// GetPropertySecondaryIconActivatable gets the "secondary-icon-activatable" property.
// Whether the secondary icon is activatable.
//
// GTK emits the [signal@Gtk.Entry::icon-press] and
// [signal@Gtk.Entry::icon-release] signals only on sensitive,
// activatable icons.
//
// Sensitive, but non-activatable icons can be used for purely
// informational purposes.
func (x *Entry) GetPropertySecondaryIconActivatable() bool {
	var v gobject.Value
	x.GetProperty("secondary-icon-activatable", &v)
	return v.GetBoolean()
}

// SetPropertySecondaryIconName sets the "secondary-icon-name" property.
// The icon name to use for the secondary icon for the entry.
func (x *Entry) SetPropertySecondaryIconName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("secondary-icon-name", &v)
}

// GetPropertySecondaryIconName gets the "secondary-icon-name" property.
// The icon name to use for the secondary icon for the entry.
func (x *Entry) GetPropertySecondaryIconName() string {
	var v gobject.Value
	x.GetProperty("secondary-icon-name", &v)
	return v.GetString()
}

// SetPropertySecondaryIconSensitive sets the "secondary-icon-sensitive" property.
// Whether the secondary icon is sensitive.
//
// An insensitive icon appears grayed out. GTK does not emit the
// [signal@Gtk.Entry::icon-press[ and [signal@Gtk.Entry::icon-release]
// signals and does not allow DND from insensitive icons.
//
// An icon should be set insensitive if the action that would trigger
// when clicked is currently not available.
func (x *Entry) SetPropertySecondaryIconSensitive(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("secondary-icon-sensitive", &v)
}

// GetPropertySecondaryIconSensitive gets the "secondary-icon-sensitive" property.
// Whether the secondary icon is sensitive.
//
// An insensitive icon appears grayed out. GTK does not emit the
// [signal@Gtk.Entry::icon-press[ and [signal@Gtk.Entry::icon-release]
// signals and does not allow DND from insensitive icons.
//
// An icon should be set insensitive if the action that would trigger
// when clicked is currently not available.
func (x *Entry) GetPropertySecondaryIconSensitive() bool {
	var v gobject.Value
	x.GetProperty("secondary-icon-sensitive", &v)
	return v.GetBoolean()
}

// SetPropertySecondaryIconTooltipMarkup sets the "secondary-icon-tooltip-markup" property.
// The contents of the tooltip on the secondary icon, with markup.
//
// Also see [method@Gtk.Entry.set_icon_tooltip_markup].
func (x *Entry) SetPropertySecondaryIconTooltipMarkup(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("secondary-icon-tooltip-markup", &v)
}

// GetPropertySecondaryIconTooltipMarkup gets the "secondary-icon-tooltip-markup" property.
// The contents of the tooltip on the secondary icon, with markup.
//
// Also see [method@Gtk.Entry.set_icon_tooltip_markup].
func (x *Entry) GetPropertySecondaryIconTooltipMarkup() string {
	var v gobject.Value
	x.GetProperty("secondary-icon-tooltip-markup", &v)
	return v.GetString()
}

// SetPropertySecondaryIconTooltipText sets the "secondary-icon-tooltip-text" property.
// The contents of the tooltip on the secondary icon.
//
// Also see [method@Gtk.Entry.set_icon_tooltip_text].
func (x *Entry) SetPropertySecondaryIconTooltipText(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("secondary-icon-tooltip-text", &v)
}

// GetPropertySecondaryIconTooltipText gets the "secondary-icon-tooltip-text" property.
// The contents of the tooltip on the secondary icon.
//
// Also see [method@Gtk.Entry.set_icon_tooltip_text].
func (x *Entry) GetPropertySecondaryIconTooltipText() string {
	var v gobject.Value
	x.GetProperty("secondary-icon-tooltip-text", &v)
	return v.GetString()
}

// SetPropertyShowEmojiIcon sets the "show-emoji-icon" property.
// Whether the entry will show an Emoji icon in the secondary icon position
// to open the Emoji chooser.
func (x *Entry) SetPropertyShowEmojiIcon(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("show-emoji-icon", &v)
}

// GetPropertyShowEmojiIcon gets the "show-emoji-icon" property.
// Whether the entry will show an Emoji icon in the secondary icon position
// to open the Emoji chooser.
func (x *Entry) GetPropertyShowEmojiIcon() bool {
	var v gobject.Value
	x.GetProperty("show-emoji-icon", &v)
	return v.GetBoolean()
}

// SetPropertyTabs sets the "tabs" property.
// A list of tabstops to apply to the text of the entry.
func (x *Entry) SetPropertyTabs(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("tabs", &v)
}

// GetPropertyTabs gets the "tabs" property.
// A list of tabstops to apply to the text of the entry.
func (x *Entry) GetPropertyTabs() uintptr {
	var v gobject.Value
	x.GetProperty("tabs", &v)
	return v.GetPointer()
}

// GetPropertyTextLength gets the "text-length" property.
// The length of the text in the `GtkEntry`.
func (x *Entry) GetPropertyTextLength() uint {
	var v gobject.Value
	x.GetProperty("text-length", &v)
	return v.GetUint()
}

// SetPropertyTruncateMultiline sets the "truncate-multiline" property.
// When %TRUE, pasted multi-line text is truncated to the first line.
func (x *Entry) SetPropertyTruncateMultiline(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("truncate-multiline", &v)
}

// GetPropertyTruncateMultiline gets the "truncate-multiline" property.
// When %TRUE, pasted multi-line text is truncated to the first line.
func (x *Entry) GetPropertyTruncateMultiline() bool {
	var v gobject.Value
	x.GetProperty("truncate-multiline", &v)
	return v.GetBoolean()
}

// SetPropertyVisibility sets the "visibility" property.
// Whether the entry should show the “invisible char” instead of the
// actual text (“password mode”).
func (x *Entry) SetPropertyVisibility(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("visibility", &v)
}

// GetPropertyVisibility gets the "visibility" property.
// Whether the entry should show the “invisible char” instead of the
// actual text (“password mode”).
func (x *Entry) GetPropertyVisibility() bool {
	var v gobject.Value
	x.GetProperty("visibility", &v)
	return v.GetBoolean()
}

// Emitted when the entry is activated.
//
// The keybindings for this signal are all forms of the Enter key.
func (x *Entry) ConnectActivate(cb *func(Entry)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Entry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when an activatable icon is clicked.
func (x *Entry) ConnectIconPress(cb *func(Entry, EntryIconPosition)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "icon-press", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, IconPosVarp EntryIconPosition) {
		fa := Entry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IconPosVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "icon-press", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted on the button release from a mouse click
// over an activatable icon.
func (x *Entry) ConnectIconRelease(cb *func(Entry, EntryIconPosition)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "icon-release", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, IconPosVarp EntryIconPosition) {
		fa := Entry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IconPosVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "icon-release", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *Entry) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *Entry) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *Entry) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *Entry) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *Entry) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *Entry) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *Entry) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *Entry) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *Entry) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *Entry) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *Entry) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *Entry) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *Entry) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *Entry) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Entry) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Entry) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Entry) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Entry) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Entry) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Entry) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *Entry) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Emits the `GtkCellEditable::editing-done` signal.
func (x *Entry) EditingDone() {

	XGtkCellEditableEditingDone(x.GoPointer())

}

// Emits the `GtkCellEditable::remove-widget` signal.
func (x *Entry) RemoveWidget() {

	XGtkCellEditableRemoveWidget(x.GoPointer())

}

// Begins editing on a @cell_editable.
//
// The `GtkCellRenderer` for the cell creates and returns a `GtkCellEditable` from
// gtk_cell_renderer_start_editing(), configured for the `GtkCellRenderer` type.
//
// gtk_cell_editable_start_editing() can then set up @cell_editable suitably for
// editing a cell, e.g. making the Esc key emit `GtkCellEditable::editing-done`.
//
// Note that the @cell_editable is created on-demand for the current edit; its
// lifetime is temporary and does not persist across other edits and/or cells.
func (x *Entry) StartEditing(EventVar *gdk.Event) {

	XGtkCellEditableStartEditing(x.GoPointer(), EventVar.GoPointer())

}

// Retrieves the accessible platform state from the editable delegate.
//
// This is an helper function to retrieve the accessible state for
// `GtkEditable` interface implementations using a delegate pattern.
//
// You should call this function in your editable widget implementation
// of the [vfunc@Gtk.Accessible.get_platform_state] virtual function, for
// instance:
//
// ```c
// static void
// accessible_interface_init (GtkAccessibleInterface *iface)
//
//	{
//	  iface-&gt;get_platform_state = your_editable_get_accessible_platform_state;
//	}
//
// static gboolean
// your_editable_get_accessible_platform_state (GtkAccessible *accessible,
//
//	GtkAccessiblePlatformState state)
//
//	{
//	  return gtk_editable_delegate_get_accessible_platform_state (GTK_EDITABLE (accessible), state);
//	}
//
// ```
//
// Note that the widget which is the delegate *must* be a direct child of
// this widget, otherwise your implementation of [vfunc@Gtk.Accessible.get_platform_state]
// might not even be called, as the platform change will originate from
// the parent of the delegate, and, as a result, will not work properly.
//
// So, if you can't ensure the direct child condition, you should give the
// delegate the %GTK_ACCESSIBLE_ROLE_TEXT_BOX role, or you can
// change your tree to allow this function to work.
func (x *Entry) DelegateGetAccessiblePlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkEditableDelegateGetAccessiblePlatformState(x.GoPointer(), StateVar)
	return cret
}

// Deletes the currently selected text of the editable.
//
// This call doesn’t do anything if there is no selected text.
func (x *Entry) DeleteSelection() {

	XGtkEditableDeleteSelection(x.GoPointer())

}

// Deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters deleted are those from @start_pos to
// the end of the text.
//
// Note that the positions are specified in characters, not bytes.
func (x *Entry) DeleteText(StartPosVar int, EndPosVar int) {

	XGtkEditableDeleteText(x.GoPointer(), StartPosVar, EndPosVar)

}

// Undoes the setup done by [method@Gtk.Editable.init_delegate].
//
// This is a helper function that should be called from dispose,
// before removing the delegate object.
func (x *Entry) FinishDelegate() {

	XGtkEditableFinishDelegate(x.GoPointer())

}

// Retrieves a sequence of characters.
//
// The characters that are retrieved are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is negative,
// then the characters retrieved are those characters from @start_pos to
// the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *Entry) GetChars(StartPosVar int, EndPosVar int) string {

	cret := XGtkEditableGetChars(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Gets the `GtkEditable` that @editable is delegating its
// implementation to.
//
// Typically, the delegate is a [class@Gtk.Text] widget.
func (x *Entry) GetDelegate() *EditableBase {
	var cls *EditableBase

	cret := XGtkEditableGetDelegate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditableBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves whether @editable is editable.
func (x *Entry) GetEditable() bool {

	cret := XGtkEditableGetEditable(x.GoPointer())
	return cret
}

// Gets if undo/redo actions are enabled for @editable
func (x *Entry) GetEnableUndo() bool {

	cret := XGtkEditableGetEnableUndo(x.GoPointer())
	return cret
}

// Retrieves the desired maximum width of @editable, in characters.
func (x *Entry) GetMaxWidthChars() int {

	cret := XGtkEditableGetMaxWidthChars(x.GoPointer())
	return cret
}

// Retrieves the current position of the cursor relative
// to the start of the content of the editable.
//
// Note that this position is in characters, not in bytes.
func (x *Entry) GetPosition() int {

	cret := XGtkEditableGetPosition(x.GoPointer())
	return cret
}

// Retrieves the selection bound of the editable.
//
// @start_pos will be filled with the start of the selection and
// @end_pos with end. If no text was selected both will be identical
// and %FALSE will be returned.
//
// Note that positions are specified in characters, not bytes.
func (x *Entry) GetSelectionBounds(StartPosVar *int, EndPosVar *int) bool {

	cret := XGtkEditableGetSelectionBounds(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Retrieves the contents of @editable.
//
// The returned string is owned by GTK and must not be modified or freed.
func (x *Entry) GetText() string {

	cret := XGtkEditableGetText(x.GoPointer())
	return cret
}

// Gets the number of characters of space reserved
// for the contents of the editable.
func (x *Entry) GetWidthChars() int {

	cret := XGtkEditableGetWidthChars(x.GoPointer())
	return cret
}

// Sets up a delegate for `GtkEditable`.
//
// This is assuming that the get_delegate vfunc in the `GtkEditable`
// interface has been set up for the @editable's type.
//
// This is a helper function that should be called in instance init,
// after creating the delegate object.
func (x *Entry) InitDelegate() {

	XGtkEditableInitDelegate(x.GoPointer())

}

// Inserts @length bytes of @text into the contents of the
// widget, at position @position.
//
// Note that the position is in characters, not in bytes.
// The function updates @position to point after the newly
// inserted text.
func (x *Entry) InsertText(TextVar string, LengthVar int, PositionVar int) {

	XGtkEditableInsertText(x.GoPointer(), TextVar, LengthVar, PositionVar)

}

// Selects a region of text.
//
// The characters that are selected are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters selected are those characters from
// @start_pos to  the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *Entry) SelectRegion(StartPosVar int, EndPosVar int) {

	XGtkEditableSelectRegion(x.GoPointer(), StartPosVar, EndPosVar)

}

// Determines if the user can edit the text in the editable widget.
func (x *Entry) SetEditable(IsEditableVar bool) {

	XGtkEditableSetEditable(x.GoPointer(), IsEditableVar)

}

// If enabled, changes to @editable will be saved for undo/redo
// actions.
//
// This results in an additional copy of text changes and are not
// stored in secure memory. As such, undo is forcefully disabled
// when [property@Gtk.Text:visibility] is set to %FALSE.
func (x *Entry) SetEnableUndo(EnableUndoVar bool) {

	XGtkEditableSetEnableUndo(x.GoPointer(), EnableUndoVar)

}

// Sets the desired maximum width in characters of @editable.
func (x *Entry) SetMaxWidthChars(NCharsVar int) {

	XGtkEditableSetMaxWidthChars(x.GoPointer(), NCharsVar)

}

// Sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0)
// index in the contents of the editable. The value must be less than
// or equal to the number of characters in the editable. A value of -1
// indicates that the position should be set after the last character
// of the editable. Note that @position is in characters, not in bytes.
func (x *Entry) SetPosition(PositionVar int) {

	XGtkEditableSetPosition(x.GoPointer(), PositionVar)

}

// Sets the text in the editable to the given value.
//
// This is replacing the current contents.
func (x *Entry) SetText(TextVar string) {

	XGtkEditableSetText(x.GoPointer(), TextVar)

}

// Changes the size request of the editable to be about the
// right size for @n_chars characters.
//
// Note that it changes the size request, the size can still
// be affected by how you pack the widget into containers.
// If @n_chars is -1, the size reverts to the default size.
func (x *Entry) SetWidthChars(NCharsVar int) {

	XGtkEditableSetWidthChars(x.GoPointer(), NCharsVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xEntryIconPositionGLibType, libs, "gtk_entry_icon_position_get_type")

	core.PuregoSafeRegister(&xEntryGLibType, libs, "gtk_entry_get_type")

	core.PuregoSafeRegister(&xNewEntry, libs, "gtk_entry_new")
	core.PuregoSafeRegister(&xNewEntryWithBuffer, libs, "gtk_entry_new_with_buffer")

	core.PuregoSafeRegister(&xEntryGetActivatesDefault, libs, "gtk_entry_get_activates_default")
	core.PuregoSafeRegister(&xEntryGetAlignment, libs, "gtk_entry_get_alignment")
	core.PuregoSafeRegister(&xEntryGetAttributes, libs, "gtk_entry_get_attributes")
	core.PuregoSafeRegister(&xEntryGetBuffer, libs, "gtk_entry_get_buffer")
	core.PuregoSafeRegister(&xEntryGetCompletion, libs, "gtk_entry_get_completion")
	core.PuregoSafeRegister(&xEntryGetCurrentIconDragSource, libs, "gtk_entry_get_current_icon_drag_source")
	core.PuregoSafeRegister(&xEntryGetExtraMenu, libs, "gtk_entry_get_extra_menu")
	core.PuregoSafeRegister(&xEntryGetHasFrame, libs, "gtk_entry_get_has_frame")
	core.PuregoSafeRegister(&xEntryGetIconActivatable, libs, "gtk_entry_get_icon_activatable")
	core.PuregoSafeRegister(&xEntryGetIconArea, libs, "gtk_entry_get_icon_area")
	core.PuregoSafeRegister(&xEntryGetIconAtPos, libs, "gtk_entry_get_icon_at_pos")
	core.PuregoSafeRegister(&xEntryGetIconGicon, libs, "gtk_entry_get_icon_gicon")
	core.PuregoSafeRegister(&xEntryGetIconName, libs, "gtk_entry_get_icon_name")
	core.PuregoSafeRegister(&xEntryGetIconPaintable, libs, "gtk_entry_get_icon_paintable")
	core.PuregoSafeRegister(&xEntryGetIconSensitive, libs, "gtk_entry_get_icon_sensitive")
	core.PuregoSafeRegister(&xEntryGetIconStorageType, libs, "gtk_entry_get_icon_storage_type")
	core.PuregoSafeRegister(&xEntryGetIconTooltipMarkup, libs, "gtk_entry_get_icon_tooltip_markup")
	core.PuregoSafeRegister(&xEntryGetIconTooltipText, libs, "gtk_entry_get_icon_tooltip_text")
	core.PuregoSafeRegister(&xEntryGetInputHints, libs, "gtk_entry_get_input_hints")
	core.PuregoSafeRegister(&xEntryGetInputPurpose, libs, "gtk_entry_get_input_purpose")
	core.PuregoSafeRegister(&xEntryGetInvisibleChar, libs, "gtk_entry_get_invisible_char")
	core.PuregoSafeRegister(&xEntryGetMaxLength, libs, "gtk_entry_get_max_length")
	core.PuregoSafeRegister(&xEntryGetMenuEntryIconText, libs, "gtk_entry_get_menu_entry_icon_text")
	core.PuregoSafeRegister(&xEntryGetOverwriteMode, libs, "gtk_entry_get_overwrite_mode")
	core.PuregoSafeRegister(&xEntryGetPlaceholderText, libs, "gtk_entry_get_placeholder_text")
	core.PuregoSafeRegister(&xEntryGetProgressFraction, libs, "gtk_entry_get_progress_fraction")
	core.PuregoSafeRegister(&xEntryGetProgressPulseStep, libs, "gtk_entry_get_progress_pulse_step")
	core.PuregoSafeRegister(&xEntryGetTabs, libs, "gtk_entry_get_tabs")
	core.PuregoSafeRegister(&xEntryGetTextLength, libs, "gtk_entry_get_text_length")
	core.PuregoSafeRegister(&xEntryGetVisibility, libs, "gtk_entry_get_visibility")
	core.PuregoSafeRegister(&xEntryGrabFocusWithoutSelecting, libs, "gtk_entry_grab_focus_without_selecting")
	core.PuregoSafeRegister(&xEntryProgressPulse, libs, "gtk_entry_progress_pulse")
	core.PuregoSafeRegister(&xEntryResetImContext, libs, "gtk_entry_reset_im_context")
	core.PuregoSafeRegister(&xEntrySetActivatesDefault, libs, "gtk_entry_set_activates_default")
	core.PuregoSafeRegister(&xEntrySetAlignment, libs, "gtk_entry_set_alignment")
	core.PuregoSafeRegister(&xEntrySetAttributes, libs, "gtk_entry_set_attributes")
	core.PuregoSafeRegister(&xEntrySetBuffer, libs, "gtk_entry_set_buffer")
	core.PuregoSafeRegister(&xEntrySetCompletion, libs, "gtk_entry_set_completion")
	core.PuregoSafeRegister(&xEntrySetExtraMenu, libs, "gtk_entry_set_extra_menu")
	core.PuregoSafeRegister(&xEntrySetHasFrame, libs, "gtk_entry_set_has_frame")
	core.PuregoSafeRegister(&xEntrySetIconActivatable, libs, "gtk_entry_set_icon_activatable")
	core.PuregoSafeRegister(&xEntrySetIconDragSource, libs, "gtk_entry_set_icon_drag_source")
	core.PuregoSafeRegister(&xEntrySetIconFromGicon, libs, "gtk_entry_set_icon_from_gicon")
	core.PuregoSafeRegister(&xEntrySetIconFromIconName, libs, "gtk_entry_set_icon_from_icon_name")
	core.PuregoSafeRegister(&xEntrySetIconFromPaintable, libs, "gtk_entry_set_icon_from_paintable")
	core.PuregoSafeRegister(&xEntrySetIconSensitive, libs, "gtk_entry_set_icon_sensitive")
	core.PuregoSafeRegister(&xEntrySetIconTooltipMarkup, libs, "gtk_entry_set_icon_tooltip_markup")
	core.PuregoSafeRegister(&xEntrySetIconTooltipText, libs, "gtk_entry_set_icon_tooltip_text")
	core.PuregoSafeRegister(&xEntrySetInputHints, libs, "gtk_entry_set_input_hints")
	core.PuregoSafeRegister(&xEntrySetInputPurpose, libs, "gtk_entry_set_input_purpose")
	core.PuregoSafeRegister(&xEntrySetInvisibleChar, libs, "gtk_entry_set_invisible_char")
	core.PuregoSafeRegister(&xEntrySetMaxLength, libs, "gtk_entry_set_max_length")
	core.PuregoSafeRegister(&xEntrySetMenuEntryIconText, libs, "gtk_entry_set_menu_entry_icon_text")
	core.PuregoSafeRegister(&xEntrySetOverwriteMode, libs, "gtk_entry_set_overwrite_mode")
	core.PuregoSafeRegister(&xEntrySetPlaceholderText, libs, "gtk_entry_set_placeholder_text")
	core.PuregoSafeRegister(&xEntrySetProgressFraction, libs, "gtk_entry_set_progress_fraction")
	core.PuregoSafeRegister(&xEntrySetProgressPulseStep, libs, "gtk_entry_set_progress_pulse_step")
	core.PuregoSafeRegister(&xEntrySetTabs, libs, "gtk_entry_set_tabs")
	core.PuregoSafeRegister(&xEntrySetVisibility, libs, "gtk_entry_set_visibility")
	core.PuregoSafeRegister(&xEntryUnsetInvisibleChar, libs, "gtk_entry_unset_invisible_char")

}
