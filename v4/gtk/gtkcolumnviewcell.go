// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type ColumnViewCellClass struct {
	_ structs.HostLayout
}

func (x *ColumnViewCellClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Represents items in a cell in [class@Gtk.ColumnView].
//
// The `GtkColumnViewCell`s are managed by the [class@Gtk.ColumnView]
// widget (with its factory) and cannot be created by applications, but
// they need to be populated by application code. This is done by calling
// [method@Gtk.ColumnViewCell.set_child].
//
// `GtkColumnViewCell`s exist in 2 stages:
//
//  1. The unbound stage where the listitem is not currently connected to
//     an item in the list. In that case, the [property@Gtk.ColumnViewCell:item]
//     property is set to %NULL.
//
//  2. The bound stage where the listitem references an item from the list.
//     The [property@Gtk.ColumnViewCell:item] property is not %NULL.
type ColumnViewCell struct {
	ListItem
}

var xColumnViewCellGLibType func() types.GType

func ColumnViewCellGLibType() types.GType {
	return xColumnViewCellGLibType()
}

func ColumnViewCellNewFromInternalPtr(ptr uintptr) *ColumnViewCell {
	cls := &ColumnViewCell{}
	cls.Ptr = ptr
	return cls
}

var xColumnViewCellGetChild func(uintptr) uintptr

// Gets the child previously set via gtk_column_view_cell_set_child() or
// %NULL if none was set.
func (x *ColumnViewCell) GetChild() *Widget {
	var cls *Widget

	cret := xColumnViewCellGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xColumnViewCellGetFocusable func(uintptr) bool

// Checks if a list item has been set to be focusable via
// gtk_column_view_cell_set_focusable().
func (x *ColumnViewCell) GetFocusable() bool {

	cret := xColumnViewCellGetFocusable(x.GoPointer())
	return cret
}

var xColumnViewCellGetItem func(uintptr) uintptr

// Gets the model item that associated with @self.
//
// If @self is unbound, this function returns %NULL.
func (x *ColumnViewCell) GetItem() *gobject.Object {
	var cls *gobject.Object

	cret := xColumnViewCellGetItem(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

var xColumnViewCellGetPosition func(uintptr) uint

// Gets the position in the model that @self currently displays.
//
// If @self is unbound, %GTK_INVALID_LIST_POSITION is returned.
func (x *ColumnViewCell) GetPosition() uint {

	cret := xColumnViewCellGetPosition(x.GoPointer())
	return cret
}

var xColumnViewCellGetSelected func(uintptr) bool

// Checks if the item is displayed as selected.
//
// The selected state is maintained by the list widget and its model
// and cannot be set otherwise.
func (x *ColumnViewCell) GetSelected() bool {

	cret := xColumnViewCellGetSelected(x.GoPointer())
	return cret
}

var xColumnViewCellSetChild func(uintptr, uintptr)

// Sets the child to be used for this listitem.
//
// This function is typically called by applications when
// setting up a listitem so that the widget can be reused when
// binding it multiple times.
func (x *ColumnViewCell) SetChild(ChildVar *Widget) {

	xColumnViewCellSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xColumnViewCellSetFocusable func(uintptr, bool)

// Sets @self to be focusable.
//
// If an item is focusable, it can be focused using the keyboard.
// This works similar to [method@Gtk.Widget.set_focusable].
//
// Note that if items are not focusable, the keyboard cannot be used to activate
// them and selecting only works if one of the listitem's children is focusable.
//
// By default, list items are focusable.
func (x *ColumnViewCell) SetFocusable(FocusableVar bool) {

	xColumnViewCellSetFocusable(x.GoPointer(), FocusableVar)

}

func (c *ColumnViewCell) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *ColumnViewCell) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibrary("GTK", "libgtk-4.so.1")
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xColumnViewCellGLibType, lib, "gtk_column_view_cell_get_type")

	core.PuregoSafeRegister(&xColumnViewCellGetChild, lib, "gtk_column_view_cell_get_child")
	core.PuregoSafeRegister(&xColumnViewCellGetFocusable, lib, "gtk_column_view_cell_get_focusable")
	core.PuregoSafeRegister(&xColumnViewCellGetItem, lib, "gtk_column_view_cell_get_item")
	core.PuregoSafeRegister(&xColumnViewCellGetPosition, lib, "gtk_column_view_cell_get_position")
	core.PuregoSafeRegister(&xColumnViewCellGetSelected, lib, "gtk_column_view_cell_get_selected")
	core.PuregoSafeRegister(&xColumnViewCellSetChild, lib, "gtk_column_view_cell_set_child")
	core.PuregoSafeRegister(&xColumnViewCellSetFocusable, lib, "gtk_column_view_cell_set_focusable")

}
