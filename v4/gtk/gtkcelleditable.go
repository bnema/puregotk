// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type CellEditableIface struct {
	_ structs.HostLayout

	GIface uintptr

	xEditingDone uintptr

	xRemoveWidget uintptr

	xStartEditing uintptr
}

func (x *CellEditableIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideEditingDone sets the callback function.
// Signal is a sign for the cell renderer to update its
//
//	value from the cell_editable.
func (x *CellEditableIface) OverrideEditingDone(cb func(CellEditable)) {
	if cb == nil {
		x.xEditingDone = 0
	} else {
		x.xEditingDone = purego.NewCallback(func(CellEditableVarp uintptr) {
			cb(&CellEditableBase{Ptr: CellEditableVarp})
		})
	}
}

// GetEditingDone gets the callback function.
// Signal is a sign for the cell renderer to update its
//
//	value from the cell_editable.
func (x *CellEditableIface) GetEditingDone() func(CellEditable) {
	if x.xEditingDone == 0 {
		return nil
	}
	var rawCallback func(CellEditableVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEditingDone)
	return func(CellEditableVar CellEditable) {
		rawCallback(CellEditableVar.GoPointer())
	}
}

// OverrideRemoveWidget sets the callback function.
// Signal is meant to indicate that the cell is
//
//	finished editing, and the widget may now be destroyed.
func (x *CellEditableIface) OverrideRemoveWidget(cb func(CellEditable)) {
	if cb == nil {
		x.xRemoveWidget = 0
	} else {
		x.xRemoveWidget = purego.NewCallback(func(CellEditableVarp uintptr) {
			cb(&CellEditableBase{Ptr: CellEditableVarp})
		})
	}
}

// GetRemoveWidget gets the callback function.
// Signal is meant to indicate that the cell is
//
//	finished editing, and the widget may now be destroyed.
func (x *CellEditableIface) GetRemoveWidget() func(CellEditable) {
	if x.xRemoveWidget == 0 {
		return nil
	}
	var rawCallback func(CellEditableVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRemoveWidget)
	return func(CellEditableVar CellEditable) {
		rawCallback(CellEditableVar.GoPointer())
	}
}

// OverrideStartEditing sets the callback function.
// Begins editing on a cell_editable.
func (x *CellEditableIface) OverrideStartEditing(cb func(CellEditable, *gdk.Event)) {
	if cb == nil {
		x.xStartEditing = 0
	} else {
		x.xStartEditing = purego.NewCallback(func(CellEditableVarp uintptr, EventVarp uintptr) {
			cb(&CellEditableBase{Ptr: CellEditableVarp}, gdk.EventNewFromInternalPtr(EventVarp))
		})
	}
}

// GetStartEditing gets the callback function.
// Begins editing on a cell_editable.
func (x *CellEditableIface) GetStartEditing() func(CellEditable, *gdk.Event) {
	if x.xStartEditing == 0 {
		return nil
	}
	var rawCallback func(CellEditableVarp uintptr, EventVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xStartEditing)
	return func(CellEditableVar CellEditable, EventVar *gdk.Event) {
		rawCallback(CellEditableVar.GoPointer(), EventVar.GoPointer())
	}
}

// Interface for widgets that can be used for editing cells
//
// The `GtkCellEditable` interface must be implemented for widgets to be usable
// to edit the contents of a `GtkTreeView` cell. It provides a way to specify how
// temporary widgets should be configured for editing, get the new value, etc.
type CellEditable interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	EditingDone()
	RemoveWidget()
	StartEditing(EventVar *gdk.Event)
}

var xCellEditableGLibType func() types.GType

func CellEditableGLibType() types.GType {
	return xCellEditableGLibType()
}

type CellEditableBase struct {
	Ptr uintptr
}

func (x *CellEditableBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *CellEditableBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Emits the `GtkCellEditable::editing-done` signal.
func (x *CellEditableBase) EditingDone() {

	XGtkCellEditableEditingDone(x.GoPointer())

}

// Emits the `GtkCellEditable::remove-widget` signal.
func (x *CellEditableBase) RemoveWidget() {

	XGtkCellEditableRemoveWidget(x.GoPointer())

}

// Begins editing on a @cell_editable.
//
// The `GtkCellRenderer` for the cell creates and returns a `GtkCellEditable` from
// gtk_cell_renderer_start_editing(), configured for the `GtkCellRenderer` type.
//
// gtk_cell_editable_start_editing() can then set up @cell_editable suitably for
// editing a cell, e.g. making the Esc key emit `GtkCellEditable::editing-done`.
//
// Note that the @cell_editable is created on-demand for the current edit; its
// lifetime is temporary and does not persist across other edits and/or cells.
func (x *CellEditableBase) StartEditing(EventVar *gdk.Event) {

	XGtkCellEditableStartEditing(x.GoPointer(), EventVar.GoPointer())

}

var XGtkCellEditableEditingDone func(uintptr)
var XGtkCellEditableRemoveWidget func(uintptr)
var XGtkCellEditableStartEditing func(uintptr, uintptr)

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCellEditableGLibType, libs, "gtk_cell_editable_get_type")

	core.PuregoSafeRegister(&XGtkCellEditableEditingDone, libs, "gtk_cell_editable_editing_done")
	core.PuregoSafeRegister(&XGtkCellEditableRemoveWidget, libs, "gtk_cell_editable_remove_widget")
	core.PuregoSafeRegister(&XGtkCellEditableStartEditing, libs, "gtk_cell_editable_start_editing")

}
