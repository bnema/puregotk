// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A notification callback used by [method@Gtk.TextBuffer.add_commit_notify].
//
// You may not modify the [class@Gtk.TextBuffer] from a
// [callback@Gtk.TextBufferCommitNotify] callback and that is enforced
// by the [class@Gtk.TextBuffer] API.
//
// [callback@Gtk.TextBufferCommitNotify] may be used to be notified about
// changes to the underlying buffer right before-or-after the changes are
// committed to the underlying B-Tree. This is useful if you want to observe
// changes to the buffer without other signal handlers potentially modifying
// state on the way to the default signal handler.
//
// When @flags is `GTK_TEXT_BUFFER_NOTIFY_BEFORE_INSERT`, `position` is set to
// the offset in characters from the start of the buffer where the insertion
// will occur. `length` is set to the number of characters to be inserted.  You
// may not yet retrieve the text until it has been inserted. You may access the
// text from `GTK_TEXT_BUFFER_NOTIFY_AFTER_INSERT` using
// [method@Gtk.TextBuffer.get_slice].
//
// When @flags is `GTK_TEXT_BUFFER_NOTIFY_AFTER_INSERT`, `position` is set to
// offset in characters where the insertion occurred and `length` is set
// to the number of characters inserted.
//
// When @flags is `GTK_TEXT_BUFFER_NOTIFY_BEFORE_DELETE`, `position` is set to
// offset in characters where the deletion will occur and `length` is set
// to the number of characters that will be removed. You may still retrieve
// the text from this handler using `position` and `length`.
//
// When @flags is `GTK_TEXT_BUFFER_NOTIFY_AFTER_DELETE`, `length` is set to
// zero to denote that the delete-range has already been committed to the
// underlying B-Tree. You may no longer retrieve the text that has been
// deleted from the [class@Gtk.TextBuffer].
type TextBufferCommitNotify func(uintptr, TextBufferNotifyFlags, uint, uint, uintptr)

// The class structure for `GtkTextBuffer`.
type TextBufferClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xInsertText uintptr

	xInsertPaintable uintptr

	xInsertChildAnchor uintptr

	xDeleteRange uintptr

	xChanged uintptr

	xModifiedChanged uintptr

	xMarkSet uintptr

	xMarkDeleted uintptr

	xApplyTag uintptr

	xRemoveTag uintptr

	xBeginUserAction uintptr

	xEndUserAction uintptr

	xPasteDone uintptr

	xUndo uintptr

	xRedo uintptr

	xGtkReserved1 uintptr

	xGtkReserved2 uintptr

	xGtkReserved3 uintptr

	xGtkReserved4 uintptr
}

func (x *TextBufferClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideInsertText sets the callback function.
// The class handler for the `GtkTextBuffer::insert-text` signal.
func (x *TextBufferClass) OverrideInsertText(cb func(*TextBuffer, *TextIter, string, int)) {
	if cb == nil {
		x.xInsertText = 0
	} else {
		x.xInsertText = purego.NewCallback(func(BufferVarp uintptr, PosVarp *TextIter, NewTextVarp string, NewTextLengthVarp int) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), PosVarp, NewTextVarp, NewTextLengthVarp)
		})
	}
}

// GetInsertText gets the callback function.
// The class handler for the `GtkTextBuffer::insert-text` signal.
func (x *TextBufferClass) GetInsertText() func(*TextBuffer, *TextIter, string, int) {
	if x.xInsertText == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, PosVarp *TextIter, NewTextVarp string, NewTextLengthVarp int)
	purego.RegisterFunc(&rawCallback, x.xInsertText)
	return func(BufferVar *TextBuffer, PosVar *TextIter, NewTextVar string, NewTextLengthVar int) {
		rawCallback(BufferVar.GoPointer(), PosVar, NewTextVar, NewTextLengthVar)
	}
}

// OverrideInsertPaintable sets the callback function.
// The class handler for the `GtkTextBuffer::insert-paintable` signal.
func (x *TextBufferClass) OverrideInsertPaintable(cb func(*TextBuffer, *TextIter, gdk.Paintable)) {
	if cb == nil {
		x.xInsertPaintable = 0
	} else {
		x.xInsertPaintable = purego.NewCallback(func(BufferVarp uintptr, IterVarp *TextIter, PaintableVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), IterVarp, &gdk.PaintableBase{Ptr: PaintableVarp})
		})
	}
}

// GetInsertPaintable gets the callback function.
// The class handler for the `GtkTextBuffer::insert-paintable` signal.
func (x *TextBufferClass) GetInsertPaintable() func(*TextBuffer, *TextIter, gdk.Paintable) {
	if x.xInsertPaintable == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, IterVarp *TextIter, PaintableVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xInsertPaintable)
	return func(BufferVar *TextBuffer, IterVar *TextIter, PaintableVar gdk.Paintable) {
		rawCallback(BufferVar.GoPointer(), IterVar, PaintableVar.GoPointer())
	}
}

// OverrideInsertChildAnchor sets the callback function.
// The class handler for the `GtkTextBuffer::insert-child-anchor` signal.
func (x *TextBufferClass) OverrideInsertChildAnchor(cb func(*TextBuffer, *TextIter, *TextChildAnchor)) {
	if cb == nil {
		x.xInsertChildAnchor = 0
	} else {
		x.xInsertChildAnchor = purego.NewCallback(func(BufferVarp uintptr, IterVarp *TextIter, AnchorVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), IterVarp, TextChildAnchorNewFromInternalPtr(AnchorVarp))
		})
	}
}

// GetInsertChildAnchor gets the callback function.
// The class handler for the `GtkTextBuffer::insert-child-anchor` signal.
func (x *TextBufferClass) GetInsertChildAnchor() func(*TextBuffer, *TextIter, *TextChildAnchor) {
	if x.xInsertChildAnchor == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, IterVarp *TextIter, AnchorVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xInsertChildAnchor)
	return func(BufferVar *TextBuffer, IterVar *TextIter, AnchorVar *TextChildAnchor) {
		rawCallback(BufferVar.GoPointer(), IterVar, AnchorVar.GoPointer())
	}
}

// OverrideDeleteRange sets the callback function.
// The class handler for the `GtkTextBuffer::delete-range` signal.
func (x *TextBufferClass) OverrideDeleteRange(cb func(*TextBuffer, *TextIter, *TextIter)) {
	if cb == nil {
		x.xDeleteRange = 0
	} else {
		x.xDeleteRange = purego.NewCallback(func(BufferVarp uintptr, StartVarp *TextIter, EndVarp *TextIter) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), StartVarp, EndVarp)
		})
	}
}

// GetDeleteRange gets the callback function.
// The class handler for the `GtkTextBuffer::delete-range` signal.
func (x *TextBufferClass) GetDeleteRange() func(*TextBuffer, *TextIter, *TextIter) {
	if x.xDeleteRange == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, StartVarp *TextIter, EndVarp *TextIter)
	purego.RegisterFunc(&rawCallback, x.xDeleteRange)
	return func(BufferVar *TextBuffer, StartVar *TextIter, EndVar *TextIter) {
		rawCallback(BufferVar.GoPointer(), StartVar, EndVar)
	}
}

// OverrideChanged sets the callback function.
// The class handler for the `GtkTextBuffer::changed` signal.
func (x *TextBufferClass) OverrideChanged(cb func(*TextBuffer)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(BufferVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp))
		})
	}
}

// GetChanged gets the callback function.
// The class handler for the `GtkTextBuffer::changed` signal.
func (x *TextBufferClass) GetChanged() func(*TextBuffer) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(BufferVar *TextBuffer) {
		rawCallback(BufferVar.GoPointer())
	}
}

// OverrideModifiedChanged sets the callback function.
// The class handler for the `GtkTextBuffer::modified-changed` signal.
func (x *TextBufferClass) OverrideModifiedChanged(cb func(*TextBuffer)) {
	if cb == nil {
		x.xModifiedChanged = 0
	} else {
		x.xModifiedChanged = purego.NewCallback(func(BufferVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp))
		})
	}
}

// GetModifiedChanged gets the callback function.
// The class handler for the `GtkTextBuffer::modified-changed` signal.
func (x *TextBufferClass) GetModifiedChanged() func(*TextBuffer) {
	if x.xModifiedChanged == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xModifiedChanged)
	return func(BufferVar *TextBuffer) {
		rawCallback(BufferVar.GoPointer())
	}
}

// OverrideMarkSet sets the callback function.
// The class handler for the `GtkTextBuffer::mark-set` signal.
func (x *TextBufferClass) OverrideMarkSet(cb func(*TextBuffer, *TextIter, *TextMark)) {
	if cb == nil {
		x.xMarkSet = 0
	} else {
		x.xMarkSet = purego.NewCallback(func(BufferVarp uintptr, LocationVarp *TextIter, MarkVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), LocationVarp, TextMarkNewFromInternalPtr(MarkVarp))
		})
	}
}

// GetMarkSet gets the callback function.
// The class handler for the `GtkTextBuffer::mark-set` signal.
func (x *TextBufferClass) GetMarkSet() func(*TextBuffer, *TextIter, *TextMark) {
	if x.xMarkSet == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, LocationVarp *TextIter, MarkVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMarkSet)
	return func(BufferVar *TextBuffer, LocationVar *TextIter, MarkVar *TextMark) {
		rawCallback(BufferVar.GoPointer(), LocationVar, MarkVar.GoPointer())
	}
}

// OverrideMarkDeleted sets the callback function.
// The class handler for the `GtkTextBuffer::mark-deleted` signal.
func (x *TextBufferClass) OverrideMarkDeleted(cb func(*TextBuffer, *TextMark)) {
	if cb == nil {
		x.xMarkDeleted = 0
	} else {
		x.xMarkDeleted = purego.NewCallback(func(BufferVarp uintptr, MarkVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), TextMarkNewFromInternalPtr(MarkVarp))
		})
	}
}

// GetMarkDeleted gets the callback function.
// The class handler for the `GtkTextBuffer::mark-deleted` signal.
func (x *TextBufferClass) GetMarkDeleted() func(*TextBuffer, *TextMark) {
	if x.xMarkDeleted == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, MarkVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMarkDeleted)
	return func(BufferVar *TextBuffer, MarkVar *TextMark) {
		rawCallback(BufferVar.GoPointer(), MarkVar.GoPointer())
	}
}

// OverrideApplyTag sets the callback function.
// The class handler for the `GtkTextBuffer::apply-tag` signal.
func (x *TextBufferClass) OverrideApplyTag(cb func(*TextBuffer, *TextTag, *TextIter, *TextIter)) {
	if cb == nil {
		x.xApplyTag = 0
	} else {
		x.xApplyTag = purego.NewCallback(func(BufferVarp uintptr, TagVarp uintptr, StartVarp *TextIter, EndVarp *TextIter) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), TextTagNewFromInternalPtr(TagVarp), StartVarp, EndVarp)
		})
	}
}

// GetApplyTag gets the callback function.
// The class handler for the `GtkTextBuffer::apply-tag` signal.
func (x *TextBufferClass) GetApplyTag() func(*TextBuffer, *TextTag, *TextIter, *TextIter) {
	if x.xApplyTag == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, TagVarp uintptr, StartVarp *TextIter, EndVarp *TextIter)
	purego.RegisterFunc(&rawCallback, x.xApplyTag)
	return func(BufferVar *TextBuffer, TagVar *TextTag, StartVar *TextIter, EndVar *TextIter) {
		rawCallback(BufferVar.GoPointer(), TagVar.GoPointer(), StartVar, EndVar)
	}
}

// OverrideRemoveTag sets the callback function.
// The class handler for the `GtkTextBuffer::remove-tag` signal.
func (x *TextBufferClass) OverrideRemoveTag(cb func(*TextBuffer, *TextTag, *TextIter, *TextIter)) {
	if cb == nil {
		x.xRemoveTag = 0
	} else {
		x.xRemoveTag = purego.NewCallback(func(BufferVarp uintptr, TagVarp uintptr, StartVarp *TextIter, EndVarp *TextIter) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), TextTagNewFromInternalPtr(TagVarp), StartVarp, EndVarp)
		})
	}
}

// GetRemoveTag gets the callback function.
// The class handler for the `GtkTextBuffer::remove-tag` signal.
func (x *TextBufferClass) GetRemoveTag() func(*TextBuffer, *TextTag, *TextIter, *TextIter) {
	if x.xRemoveTag == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, TagVarp uintptr, StartVarp *TextIter, EndVarp *TextIter)
	purego.RegisterFunc(&rawCallback, x.xRemoveTag)
	return func(BufferVar *TextBuffer, TagVar *TextTag, StartVar *TextIter, EndVar *TextIter) {
		rawCallback(BufferVar.GoPointer(), TagVar.GoPointer(), StartVar, EndVar)
	}
}

// OverrideBeginUserAction sets the callback function.
// The class handler for the `GtkTextBuffer::begin-user-action` signal.
func (x *TextBufferClass) OverrideBeginUserAction(cb func(*TextBuffer)) {
	if cb == nil {
		x.xBeginUserAction = 0
	} else {
		x.xBeginUserAction = purego.NewCallback(func(BufferVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp))
		})
	}
}

// GetBeginUserAction gets the callback function.
// The class handler for the `GtkTextBuffer::begin-user-action` signal.
func (x *TextBufferClass) GetBeginUserAction() func(*TextBuffer) {
	if x.xBeginUserAction == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xBeginUserAction)
	return func(BufferVar *TextBuffer) {
		rawCallback(BufferVar.GoPointer())
	}
}

// OverrideEndUserAction sets the callback function.
// The class handler for the `GtkTextBuffer::end-user-action` signal.
func (x *TextBufferClass) OverrideEndUserAction(cb func(*TextBuffer)) {
	if cb == nil {
		x.xEndUserAction = 0
	} else {
		x.xEndUserAction = purego.NewCallback(func(BufferVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp))
		})
	}
}

// GetEndUserAction gets the callback function.
// The class handler for the `GtkTextBuffer::end-user-action` signal.
func (x *TextBufferClass) GetEndUserAction() func(*TextBuffer) {
	if x.xEndUserAction == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEndUserAction)
	return func(BufferVar *TextBuffer) {
		rawCallback(BufferVar.GoPointer())
	}
}

// OverridePasteDone sets the callback function.
// The class handler for the `GtkTextBuffer::paste-done` signal.
func (x *TextBufferClass) OverridePasteDone(cb func(*TextBuffer, *gdk.Clipboard)) {
	if cb == nil {
		x.xPasteDone = 0
	} else {
		x.xPasteDone = purego.NewCallback(func(BufferVarp uintptr, ClipboardVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp), gdk.ClipboardNewFromInternalPtr(ClipboardVarp))
		})
	}
}

// GetPasteDone gets the callback function.
// The class handler for the `GtkTextBuffer::paste-done` signal.
func (x *TextBufferClass) GetPasteDone() func(*TextBuffer, *gdk.Clipboard) {
	if x.xPasteDone == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr, ClipboardVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPasteDone)
	return func(BufferVar *TextBuffer, ClipboardVar *gdk.Clipboard) {
		rawCallback(BufferVar.GoPointer(), ClipboardVar.GoPointer())
	}
}

// OverrideUndo sets the callback function.
// The class handler for the `GtkTextBuffer::undo` signal
func (x *TextBufferClass) OverrideUndo(cb func(*TextBuffer)) {
	if cb == nil {
		x.xUndo = 0
	} else {
		x.xUndo = purego.NewCallback(func(BufferVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp))
		})
	}
}

// GetUndo gets the callback function.
// The class handler for the `GtkTextBuffer::undo` signal
func (x *TextBufferClass) GetUndo() func(*TextBuffer) {
	if x.xUndo == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUndo)
	return func(BufferVar *TextBuffer) {
		rawCallback(BufferVar.GoPointer())
	}
}

// OverrideRedo sets the callback function.
// The class handler for the `GtkTextBuffer::redo` signal
func (x *TextBufferClass) OverrideRedo(cb func(*TextBuffer)) {
	if cb == nil {
		x.xRedo = 0
	} else {
		x.xRedo = purego.NewCallback(func(BufferVarp uintptr) {
			cb(TextBufferNewFromInternalPtr(BufferVarp))
		})
	}
}

// GetRedo gets the callback function.
// The class handler for the `GtkTextBuffer::redo` signal
func (x *TextBufferClass) GetRedo() func(*TextBuffer) {
	if x.xRedo == 0 {
		return nil
	}
	var rawCallback func(BufferVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRedo)
	return func(BufferVar *TextBuffer) {
		rawCallback(BufferVar.GoPointer())
	}
}

// OverrideGtkReserved1 sets the callback function.
func (x *TextBufferClass) OverrideGtkReserved1(cb func()) {
	if cb == nil {
		x.xGtkReserved1 = 0
	} else {
		x.xGtkReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved1 gets the callback function.
func (x *TextBufferClass) GetGtkReserved1() func() {
	if x.xGtkReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved2 sets the callback function.
func (x *TextBufferClass) OverrideGtkReserved2(cb func()) {
	if cb == nil {
		x.xGtkReserved2 = 0
	} else {
		x.xGtkReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved2 gets the callback function.
func (x *TextBufferClass) GetGtkReserved2() func() {
	if x.xGtkReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved3 sets the callback function.
func (x *TextBufferClass) OverrideGtkReserved3(cb func()) {
	if cb == nil {
		x.xGtkReserved3 = 0
	} else {
		x.xGtkReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved3 gets the callback function.
func (x *TextBufferClass) GetGtkReserved3() func() {
	if x.xGtkReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved4 sets the callback function.
func (x *TextBufferClass) OverrideGtkReserved4(cb func()) {
	if cb == nil {
		x.xGtkReserved4 = 0
	} else {
		x.xGtkReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved4 gets the callback function.
func (x *TextBufferClass) GetGtkReserved4() func() {
	if x.xGtkReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved4)
	return func() {
		rawCallback()
	}
}

type TextBufferPrivate struct {
	_ structs.HostLayout
}

func (x *TextBufferPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Stores text and attributes for display in a `GtkTextView`.
//
// You may wish to begin by reading the
// [text widget conceptual overview](section-text-widget.html),
// which gives an overview of all the objects and data types
// related to the text widget and how they work together.
//
// GtkTextBuffer can support undoing changes to the buffer
// content, see [method@Gtk.TextBuffer.set_enable_undo].
type TextBuffer struct {
	gobject.Object
}

var xTextBufferGLibType func() types.GType

func TextBufferGLibType() types.GType {
	return xTextBufferGLibType()
}

func TextBufferNewFromInternalPtr(ptr uintptr) *TextBuffer {
	cls := &TextBuffer{}
	cls.Ptr = ptr
	return cls
}

var xNewTextBuffer func(uintptr) uintptr

// Creates a new text buffer.
func NewTextBuffer(TableVar *TextTagTable) *TextBuffer {
	var cls *TextBuffer

	cret := xNewTextBuffer(TableVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &TextBuffer{}
	cls.Ptr = cret
	return cls
}

var xTextBufferAddCommitNotify func(uintptr, TextBufferNotifyFlags, uintptr, uintptr, uintptr) uint

// Adds a [callback@Gtk.TextBufferCommitNotify] to be called when a change
// is to be made to the [type@Gtk.TextBuffer].
//
// Functions are explicitly forbidden from making changes to the
// [type@Gtk.TextBuffer] from this callback. It is intended for tracking
// changes to the buffer only.
//
// It may be advantageous to use [callback@Gtk.TextBufferCommitNotify] over
// connecting to the [signal@Gtk.TextBuffer::insert-text] or
// [signal@Gtk.TextBuffer::delete-range] signals to avoid ordering issues with
// other signal handlers which may further modify the [type@Gtk.TextBuffer].
func (x *TextBuffer) AddCommitNotify(FlagsVar TextBufferNotifyFlags, CommitNotifyVar *TextBufferCommitNotify, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) uint {

	cret := xTextBufferAddCommitNotify(x.GoPointer(), FlagsVar, glib.NewCallback(CommitNotifyVar), UserDataVar, glib.NewCallback(DestroyVar))
	return cret
}

var xTextBufferAddMark func(uintptr, uintptr, *TextIter)

// Adds the mark at position @where.
//
// The mark must not be added to another buffer, and if its name
// is not %NULL then there must not be another mark in the buffer
// with the same name.
//
// Emits the [signal@Gtk.TextBuffer::mark-set] signal as notification
// of the mark's initial placement.
func (x *TextBuffer) AddMark(MarkVar *TextMark, WhereVar *TextIter) {

	xTextBufferAddMark(x.GoPointer(), MarkVar.GoPointer(), WhereVar)

}

var xTextBufferAddSelectionClipboard func(uintptr, uintptr)

// Adds @clipboard to the list of clipboards in which the selection
// contents of @buffer are available.
//
// In most cases, @clipboard will be the `GdkClipboard` returned by
// [method@Gtk.Widget.get_primary_clipboard] for a view of @buffer.
func (x *TextBuffer) AddSelectionClipboard(ClipboardVar *gdk.Clipboard) {

	xTextBufferAddSelectionClipboard(x.GoPointer(), ClipboardVar.GoPointer())

}

var xTextBufferApplyTag func(uintptr, uintptr, *TextIter, *TextIter)

// Emits the “apply-tag” signal on @buffer.
//
// The default handler for the signal applies
// @tag to the given range. @start and @end do
// not have to be in order.
func (x *TextBuffer) ApplyTag(TagVar *TextTag, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferApplyTag(x.GoPointer(), TagVar.GoPointer(), StartVar, EndVar)

}

var xTextBufferApplyTagByName func(uintptr, string, *TextIter, *TextIter)

// Emits the “apply-tag” signal on @buffer.
//
// Calls [method@Gtk.TextTagTable.lookup] on the buffer’s
// tag table to get a `GtkTextTag`, then calls
// [method@Gtk.TextBuffer.apply_tag].
func (x *TextBuffer) ApplyTagByName(NameVar string, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferApplyTagByName(x.GoPointer(), NameVar, StartVar, EndVar)

}

var xTextBufferBackspace func(uintptr, *TextIter, bool, bool) bool

// Performs the appropriate action as if the user hit the delete
// key with the cursor at the position specified by @iter.
//
// In the normal case a single character will be deleted, but when
// combining accents are involved, more than one character can
// be deleted, and when precomposed character and accent combinations
// are involved, less than one character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become
// invalid after calling this function; however, the @iter will be
// re-initialized to point to the location where text was deleted.
func (x *TextBuffer) Backspace(IterVar *TextIter, InteractiveVar bool, DefaultEditableVar bool) bool {

	cret := xTextBufferBackspace(x.GoPointer(), IterVar, InteractiveVar, DefaultEditableVar)
	return cret
}

var xTextBufferBeginIrreversibleAction func(uintptr)

// Denotes the beginning of an action that may not be undone.
//
// This will cause any previous operations in the undo/redo queue
// to be cleared.
//
// This should be paired with a call to
// [method@Gtk.TextBuffer.end_irreversible_action] after the irreversible
// action has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action()
// and gtk_text_buffer_end_irreversible_action() pairs.
func (x *TextBuffer) BeginIrreversibleAction() {

	xTextBufferBeginIrreversibleAction(x.GoPointer())

}

var xTextBufferBeginUserAction func(uintptr)

// Called to indicate that the buffer operations between here and a
// call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when creating
// an undo stack. `GtkTextBuffer` maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with
// a call to gtk_text_buffer_end_user_action(), and emits the
// “begin-user-action” and “end-user-action” signals only for the
// outermost pair of calls. This allows you to build user actions
// from other user actions.
//
// The “interactive” buffer mutation functions, such as
// [method@Gtk.TextBuffer.insert_interactive], automatically call
// begin/end user action around the buffer operations they perform,
// so there's no need to add extra calls if you user action consists
// solely of a single call to one of those functions.
func (x *TextBuffer) BeginUserAction() {

	xTextBufferBeginUserAction(x.GoPointer())

}

var xTextBufferCopyClipboard func(uintptr, uintptr)

// Copies the currently-selected text to a clipboard.
func (x *TextBuffer) CopyClipboard(ClipboardVar *gdk.Clipboard) {

	xTextBufferCopyClipboard(x.GoPointer(), ClipboardVar.GoPointer())

}

var xTextBufferCreateChildAnchor func(uintptr, *TextIter) uintptr

// Creates and inserts a child anchor.
//
// This is a convenience function which simply creates a child anchor
// with [ctor@Gtk.TextChildAnchor.new] and inserts it into the buffer
// with [method@Gtk.TextBuffer.insert_child_anchor].
//
// The new anchor is owned by the buffer; no reference count is
// returned to the caller of this function.
func (x *TextBuffer) CreateChildAnchor(IterVar *TextIter) *TextChildAnchor {
	var cls *TextChildAnchor

	cret := xTextBufferCreateChildAnchor(x.GoPointer(), IterVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextChildAnchor{}
	cls.Ptr = cret
	return cls
}

var xTextBufferCreateMark func(uintptr, string, *TextIter, bool) uintptr

// Creates a mark at position @where.
//
// If @mark_name is %NULL, the mark is anonymous; otherwise, the mark
// can be retrieved by name using [method@Gtk.TextBuffer.get_mark].
// If a mark has left gravity, and text is inserted at the mark’s
// current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity
// (@left_gravity = %FALSE), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark
// with right gravity (when you type, the cursor stays on the right
// side of the text you’re typing).
//
// The caller of this function does not own a
// reference to the returned `GtkTextMark`, so you can ignore the
// return value if you like. Marks are owned by the buffer and go
// away when the buffer does.
//
// Emits the [signal@Gtk.TextBuffer::mark-set] signal as notification
// of the mark's initial placement.
func (x *TextBuffer) CreateMark(MarkNameVar string, WhereVar *TextIter, LeftGravityVar bool) *TextMark {
	var cls *TextMark

	cret := xTextBufferCreateMark(x.GoPointer(), MarkNameVar, WhereVar, LeftGravityVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextMark{}
	cls.Ptr = cret
	return cls
}

var xTextBufferCreateTag func(uintptr, string, string, ...interface{}) uintptr

// Creates a tag and adds it to the tag table for @buffer.
//
// Equivalent to calling [ctor@Gtk.TextTag.new] and then adding the
// tag to the buffer’s tag table. The returned tag is owned by
// the buffer’s tag table, so the ref count will be equal to one.
//
// If @tag_name is %NULL, the tag is anonymous.
//
// If @tag_name is non-%NULL, a tag called @tag_name must not already
// exist in the tag table for this buffer.
//
// The @first_property_name argument and subsequent arguments are a list
// of properties to set on the tag, as with g_object_set().
func (x *TextBuffer) CreateTag(TagNameVar string, FirstPropertyNameVar string, varArgs ...interface{}) *TextTag {
	var cls *TextTag

	cret := xTextBufferCreateTag(x.GoPointer(), TagNameVar, FirstPropertyNameVar, varArgs...)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextTag{}
	cls.Ptr = cret
	return cls
}

var xTextBufferCutClipboard func(uintptr, uintptr, bool)

// Copies the currently-selected text to a clipboard,
// then deletes said text if it’s editable.
func (x *TextBuffer) CutClipboard(ClipboardVar *gdk.Clipboard, DefaultEditableVar bool) {

	xTextBufferCutClipboard(x.GoPointer(), ClipboardVar.GoPointer(), DefaultEditableVar)

}

var xTextBufferDelete func(uintptr, *TextIter, *TextIter)

// Deletes text between @start and @end.
//
// The order of @start and @end is not actually relevant;
// gtk_text_buffer_delete() will reorder them.
//
// This function actually emits the “delete-range” signal, and
// the default handler of that signal deletes the text. Because the
// buffer is modified, all outstanding iterators become invalid after
// calling this function; however, the @start and @end will be
// re-initialized to point to the location where text was deleted.
func (x *TextBuffer) Delete(StartVar *TextIter, EndVar *TextIter) {

	xTextBufferDelete(x.GoPointer(), StartVar, EndVar)

}

var xTextBufferDeleteInteractive func(uintptr, *TextIter, *TextIter, bool) bool

// Deletes all editable text in the given range.
//
// Calls [method@Gtk.TextBuffer.delete] for each editable
// sub-range of [@start,@end). @start and @end are revalidated
// to point to the location of the last deleted range, or left
// untouched if no text was deleted.
func (x *TextBuffer) DeleteInteractive(StartIterVar *TextIter, EndIterVar *TextIter, DefaultEditableVar bool) bool {

	cret := xTextBufferDeleteInteractive(x.GoPointer(), StartIterVar, EndIterVar, DefaultEditableVar)
	return cret
}

var xTextBufferDeleteMark func(uintptr, uintptr)

// Deletes @mark, so that it’s no longer located anywhere in the
// buffer.
//
// Removes the reference the buffer holds to the mark, so if
// you haven’t called g_object_ref() on the mark, it will be freed.
// Even if the mark isn’t freed, most operations on @mark become
// invalid, until it gets added to a buffer again with
// [method@Gtk.TextBuffer.add_mark]. Use [method@Gtk.TextMark.get_deleted]
// to find out if a mark has been removed from its buffer.
//
// The [signal@Gtk.TextBuffer::mark-deleted] signal will be emitted as
// notification after the mark is deleted.
func (x *TextBuffer) DeleteMark(MarkVar *TextMark) {

	xTextBufferDeleteMark(x.GoPointer(), MarkVar.GoPointer())

}

var xTextBufferDeleteMarkByName func(uintptr, string)

// Deletes the mark named @name; the mark must exist.
//
// See [method@Gtk.TextBuffer.delete_mark] for details.
func (x *TextBuffer) DeleteMarkByName(NameVar string) {

	xTextBufferDeleteMarkByName(x.GoPointer(), NameVar)

}

var xTextBufferDeleteSelection func(uintptr, bool, bool) bool

// Deletes the range between the “insert” and “selection_bound” marks,
// that is, the currently-selected text.
//
// If @interactive is %TRUE, the editability of the selection will be
// considered (users can’t delete uneditable text).
func (x *TextBuffer) DeleteSelection(InteractiveVar bool, DefaultEditableVar bool) bool {

	cret := xTextBufferDeleteSelection(x.GoPointer(), InteractiveVar, DefaultEditableVar)
	return cret
}

var xTextBufferEndIrreversibleAction func(uintptr)

// Denotes the end of an action that may not be undone.
//
// This will cause any previous operations in the undo/redo
// queue to be cleared.
//
// This should be called after completing modifications to the
// text buffer after [method@Gtk.TextBuffer.begin_irreversible_action]
// was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action()
// and gtk_text_buffer_end_irreversible_action() pairs.
func (x *TextBuffer) EndIrreversibleAction() {

	xTextBufferEndIrreversibleAction(x.GoPointer())

}

var xTextBufferEndUserAction func(uintptr)

// Ends a user-visible operation.
//
// Should be paired with a call to
// [method@Gtk.TextBuffer.begin_user_action].
// See that function for a full explanation.
func (x *TextBuffer) EndUserAction() {

	xTextBufferEndUserAction(x.GoPointer())

}

var xTextBufferGetBounds func(uintptr, *TextIter, *TextIter)

// Retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
func (x *TextBuffer) GetBounds(StartVar *TextIter, EndVar *TextIter) {

	xTextBufferGetBounds(x.GoPointer(), StartVar, EndVar)

}

var xTextBufferGetCanRedo func(uintptr) bool

// Gets whether there is a redoable action in the history.
func (x *TextBuffer) GetCanRedo() bool {

	cret := xTextBufferGetCanRedo(x.GoPointer())
	return cret
}

var xTextBufferGetCanUndo func(uintptr) bool

// Gets whether there is an undoable action in the history.
func (x *TextBuffer) GetCanUndo() bool {

	cret := xTextBufferGetCanUndo(x.GoPointer())
	return cret
}

var xTextBufferGetCharCount func(uintptr) int

// Gets the number of characters in the buffer.
//
// Note that characters and bytes are not the same, you can’t e.g.
// expect the contents of the buffer in string form to be this
// many bytes long.
//
// The character count is cached, so this function is very fast.
func (x *TextBuffer) GetCharCount() int {

	cret := xTextBufferGetCharCount(x.GoPointer())
	return cret
}

var xTextBufferGetEnableUndo func(uintptr) bool

// Gets whether the buffer is saving modifications to the buffer
// to allow for undo and redo actions.
//
// See [method@Gtk.TextBuffer.begin_irreversible_action] and
// [method@Gtk.TextBuffer.end_irreversible_action] to create
// changes to the buffer that cannot be undone.
func (x *TextBuffer) GetEnableUndo() bool {

	cret := xTextBufferGetEnableUndo(x.GoPointer())
	return cret
}

var xTextBufferGetEndIter func(uintptr, *TextIter)

// Initializes @iter with the “end iterator,” one past the last valid
// character in the text buffer.
//
// If dereferenced with [method@Gtk.TextIter.get_char], the end
// iterator has a character value of 0.
// The entire buffer lies in the range from the first position in
// the buffer (call [method@Gtk.TextBuffer.get_start_iter] to get
// character position 0) to the end iterator.
func (x *TextBuffer) GetEndIter(IterVar *TextIter) {

	xTextBufferGetEndIter(x.GoPointer(), IterVar)

}

var xTextBufferGetHasSelection func(uintptr) bool

// Indicates whether the buffer has some text currently selected.
func (x *TextBuffer) GetHasSelection() bool {

	cret := xTextBufferGetHasSelection(x.GoPointer())
	return cret
}

var xTextBufferGetInsert func(uintptr) uintptr

// Returns the mark that represents the cursor (insertion point).
//
// Equivalent to calling [method@Gtk.TextBuffer.get_mark]
// to get the mark named “insert”, but very slightly more
// efficient, and involves less typing.
func (x *TextBuffer) GetInsert() *TextMark {
	var cls *TextMark

	cret := xTextBufferGetInsert(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextMark{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetIterAtChildAnchor func(uintptr, *TextIter, uintptr)

// Obtains the location of @anchor within @buffer.
func (x *TextBuffer) GetIterAtChildAnchor(IterVar *TextIter, AnchorVar *TextChildAnchor) {

	xTextBufferGetIterAtChildAnchor(x.GoPointer(), IterVar, AnchorVar.GoPointer())

}

var xTextBufferGetIterAtLine func(uintptr, *TextIter, int) bool

// Initializes @iter to the start of the given line.
//
// If @line_number is greater than or equal to the number of lines
// in the @buffer, the end iterator is returned.
func (x *TextBuffer) GetIterAtLine(IterVar *TextIter, LineNumberVar int) bool {

	cret := xTextBufferGetIterAtLine(x.GoPointer(), IterVar, LineNumberVar)
	return cret
}

var xTextBufferGetIterAtLineIndex func(uintptr, *TextIter, int, int) bool

// Obtains an iterator pointing to @byte_index within the given line.
//
// @byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// If @line_number is greater than or equal to the number of lines in the @buffer,
// the end iterator is returned. And if @byte_index is off the
// end of the line, the iterator at the end of the line is returned.
func (x *TextBuffer) GetIterAtLineIndex(IterVar *TextIter, LineNumberVar int, ByteIndexVar int) bool {

	cret := xTextBufferGetIterAtLineIndex(x.GoPointer(), IterVar, LineNumberVar, ByteIndexVar)
	return cret
}

var xTextBufferGetIterAtLineOffset func(uintptr, *TextIter, int, int) bool

// Obtains an iterator pointing to @char_offset within the given line.
//
// Note characters, not bytes; UTF-8 may encode one character as multiple
// bytes.
//
// If @line_number is greater than or equal to the number of lines in the @buffer,
// the end iterator is returned. And if @char_offset is off the
// end of the line, the iterator at the end of the line is returned.
func (x *TextBuffer) GetIterAtLineOffset(IterVar *TextIter, LineNumberVar int, CharOffsetVar int) bool {

	cret := xTextBufferGetIterAtLineOffset(x.GoPointer(), IterVar, LineNumberVar, CharOffsetVar)
	return cret
}

var xTextBufferGetIterAtMark func(uintptr, *TextIter, uintptr)

// Initializes @iter with the current position of @mark.
func (x *TextBuffer) GetIterAtMark(IterVar *TextIter, MarkVar *TextMark) {

	xTextBufferGetIterAtMark(x.GoPointer(), IterVar, MarkVar.GoPointer())

}

var xTextBufferGetIterAtOffset func(uintptr, *TextIter, int)

// Initializes @iter to a position @char_offset chars from the start
// of the entire buffer.
//
// If @char_offset is -1 or greater than the number
// of characters in the buffer, @iter is initialized to the end iterator,
// the iterator one past the last valid character in the buffer.
func (x *TextBuffer) GetIterAtOffset(IterVar *TextIter, CharOffsetVar int) {

	xTextBufferGetIterAtOffset(x.GoPointer(), IterVar, CharOffsetVar)

}

var xTextBufferGetLineCount func(uintptr) int

// Obtains the number of lines in the buffer.
//
// This value is cached, so the function is very fast.
func (x *TextBuffer) GetLineCount() int {

	cret := xTextBufferGetLineCount(x.GoPointer())
	return cret
}

var xTextBufferGetMark func(uintptr, string) uintptr

// Returns the mark named @name in buffer @buffer, or %NULL if no such
// mark exists in the buffer.
func (x *TextBuffer) GetMark(NameVar string) *TextMark {
	var cls *TextMark

	cret := xTextBufferGetMark(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextMark{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetMaxUndoLevels func(uintptr) uint

// Gets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may
// have a memory usage impact as it requires storing an additional
// copy of the inserted or removed text within the text buffer.
func (x *TextBuffer) GetMaxUndoLevels() uint {

	cret := xTextBufferGetMaxUndoLevels(x.GoPointer())
	return cret
}

var xTextBufferGetModified func(uintptr) bool

// Indicates whether the buffer has been modified since the last call
// to [method@Gtk.TextBuffer.set_modified] set the modification flag to
// %FALSE.
//
// Used for example to enable a “save” function in a text editor.
func (x *TextBuffer) GetModified() bool {

	cret := xTextBufferGetModified(x.GoPointer())
	return cret
}

var xTextBufferGetSelectionBound func(uintptr) uintptr

// Returns the mark that represents the selection bound.
//
// Equivalent to calling [method@Gtk.TextBuffer.get_mark]
// to get the mark named “selection_bound”, but very slightly
// more efficient, and involves less typing.
//
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and
// “insert” are in the same place, then there is no current selection.
// [method@Gtk.TextBuffer.get_selection_bounds] is another convenient
// function for handling the selection, if you just want to know whether
// there’s a selection and what its bounds are.
func (x *TextBuffer) GetSelectionBound() *TextMark {
	var cls *TextMark

	cret := xTextBufferGetSelectionBound(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextMark{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetSelectionBounds func(uintptr, *TextIter, *TextIter) bool

// Returns %TRUE if some text is selected; places the bounds
// of the selection in @start and @end.
//
// If the selection has length 0, then @start and @end are filled
// in with the same value. @start and @end will be in ascending order.
// If @start and @end are %NULL, then they are not filled in, but the
// return value still indicates whether text is selected.
func (x *TextBuffer) GetSelectionBounds(StartVar *TextIter, EndVar *TextIter) bool {

	cret := xTextBufferGetSelectionBounds(x.GoPointer(), StartVar, EndVar)
	return cret
}

var xTextBufferGetSelectionContent func(uintptr) uintptr

// Get a content provider for this buffer.
//
// It can be used to make the content of @buffer available
// in a `GdkClipboard`, see [method@Gdk.Clipboard.set_content].
func (x *TextBuffer) GetSelectionContent() *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := xTextBufferGetSelectionContent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetSlice func(uintptr, *TextIter, *TextIter, bool) string

// Returns the text in the range [@start,@end).
//
// Excludes undisplayed text (text marked with tags that set the
// invisibility attribute) if @include_hidden_chars is %FALSE.
// The returned string includes a 0xFFFC character whenever the
// buffer contains embedded images, so byte and character indexes
// into the returned string do correspond to byte and character
// indexes into the buffer. Contrast with [method@Gtk.TextBuffer.get_text].
// Note that 0xFFFC can occur in normal text as well, so it is not a
// reliable indicator that a paintable or widget is in the buffer.
func (x *TextBuffer) GetSlice(StartVar *TextIter, EndVar *TextIter, IncludeHiddenCharsVar bool) string {

	cret := xTextBufferGetSlice(x.GoPointer(), StartVar, EndVar, IncludeHiddenCharsVar)
	return cret
}

var xTextBufferGetStartIter func(uintptr, *TextIter)

// Initialized @iter with the first position in the text buffer.
//
// This is the same as using [method@Gtk.TextBuffer.get_iter_at_offset]
// to get the iter at character offset 0.
func (x *TextBuffer) GetStartIter(IterVar *TextIter) {

	xTextBufferGetStartIter(x.GoPointer(), IterVar)

}

var xTextBufferGetTagTable func(uintptr) uintptr

// Get the `GtkTextTagTable` associated with this buffer.
func (x *TextBuffer) GetTagTable() *TextTagTable {
	var cls *TextTagTable

	cret := xTextBufferGetTagTable(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextTagTable{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetText func(uintptr, *TextIter, *TextIter, bool) string

// Returns the text in the range [@start,@end).
//
// Excludes undisplayed text (text marked with tags that set the
// invisibility attribute) if @include_hidden_chars is %FALSE.
// Does not include characters representing embedded images, so
// byte and character indexes into the returned string do not
// correspond to byte and character indexes into the buffer.
// Contrast with [method@Gtk.TextBuffer.get_slice].
func (x *TextBuffer) GetText(StartVar *TextIter, EndVar *TextIter, IncludeHiddenCharsVar bool) string {

	cret := xTextBufferGetText(x.GoPointer(), StartVar, EndVar, IncludeHiddenCharsVar)
	return cret
}

var xTextBufferInsert func(uintptr, *TextIter, string, int)

// Inserts @len bytes of @text at position @iter.
//
// If @len is -1, @text must be nul-terminated and will be inserted in its
// entirety. Emits the “insert-text” signal; insertion actually occurs
// in the default handler for the signal. @iter is invalidated when
// insertion occurs (because the buffer contents change), but the
// default signal handler revalidates it to point to the end of the
// inserted text.
func (x *TextBuffer) Insert(IterVar *TextIter, TextVar string, LenVar int) {

	xTextBufferInsert(x.GoPointer(), IterVar, TextVar, LenVar)

}

var xTextBufferInsertAtCursor func(uintptr, string, int)

// Inserts @text in @buffer.
//
// Simply calls [method@Gtk.TextBuffer.insert],
// using the current cursor position as the insertion point.
func (x *TextBuffer) InsertAtCursor(TextVar string, LenVar int) {

	xTextBufferInsertAtCursor(x.GoPointer(), TextVar, LenVar)

}

var xTextBufferInsertChildAnchor func(uintptr, *TextIter, uintptr)

// Inserts a child widget anchor into the text buffer at @iter.
//
// The anchor will be counted as one character in character counts, and
// when obtaining the buffer contents as a string, will be represented
// by the Unicode “object replacement character” 0xFFFC. Note that the
// “slice” variants for obtaining portions of the buffer as a string
// include this character for child anchors, but the “text” variants do
// not. E.g. see [method@Gtk.TextBuffer.get_slice] and
// [method@Gtk.TextBuffer.get_text].
//
// Consider [method@Gtk.TextBuffer.create_child_anchor] as a more
// convenient alternative to this function. The buffer will add a
// reference to the anchor, so you can unref it after insertion.
func (x *TextBuffer) InsertChildAnchor(IterVar *TextIter, AnchorVar *TextChildAnchor) {

	xTextBufferInsertChildAnchor(x.GoPointer(), IterVar, AnchorVar.GoPointer())

}

var xTextBufferInsertInteractive func(uintptr, *TextIter, string, int, bool) bool

// Inserts @text in @buffer.
//
// Like [method@Gtk.TextBuffer.insert], but the insertion will not occur
// if @iter is at a non-editable location in the buffer. Usually you
// want to prevent insertions at ineditable locations if the insertion
// results from a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't
// have a tag affecting editability applied to it. Typically the
// result of [method@Gtk.TextView.get_editable] is appropriate here.
func (x *TextBuffer) InsertInteractive(IterVar *TextIter, TextVar string, LenVar int, DefaultEditableVar bool) bool {

	cret := xTextBufferInsertInteractive(x.GoPointer(), IterVar, TextVar, LenVar, DefaultEditableVar)
	return cret
}

var xTextBufferInsertInteractiveAtCursor func(uintptr, string, int, bool) bool

// Inserts @text in @buffer.
//
// Calls [method@Gtk.TextBuffer.insert_interactive]
// at the cursor position.
//
// @default_editable indicates the editability of text that doesn't
// have a tag affecting editability applied to it. Typically the
// result of [method@Gtk.TextView.get_editable] is appropriate here.
func (x *TextBuffer) InsertInteractiveAtCursor(TextVar string, LenVar int, DefaultEditableVar bool) bool {

	cret := xTextBufferInsertInteractiveAtCursor(x.GoPointer(), TextVar, LenVar, DefaultEditableVar)
	return cret
}

var xTextBufferInsertMarkup func(uintptr, *TextIter, string, int)

// Inserts the text in @markup at position @iter.
//
// @markup will be inserted in its entirety and must be nul-terminated
// and valid UTF-8. Emits the [signal@Gtk.TextBuffer::insert-text] signal,
// possibly multiple times; insertion actually occurs in the default handler
// for the signal. @iter will point to the end of the inserted text on return.
func (x *TextBuffer) InsertMarkup(IterVar *TextIter, MarkupVar string, LenVar int) {

	xTextBufferInsertMarkup(x.GoPointer(), IterVar, MarkupVar, LenVar)

}

var xTextBufferInsertPaintable func(uintptr, *TextIter, uintptr)

// Inserts an image into the text buffer at @iter.
//
// The image will be counted as one character in character counts,
// and when obtaining the buffer contents as a string, will be
// represented by the Unicode “object replacement character” 0xFFFC.
// Note that the “slice” variants for obtaining portions of the buffer
// as a string include this character for paintable, but the “text”
// variants do not. e.g. see [method@Gtk.TextBuffer.get_slice] and
// [method@Gtk.TextBuffer.get_text].
func (x *TextBuffer) InsertPaintable(IterVar *TextIter, PaintableVar gdk.Paintable) {

	xTextBufferInsertPaintable(x.GoPointer(), IterVar, PaintableVar.GoPointer())

}

var xTextBufferInsertRange func(uintptr, *TextIter, *TextIter, *TextIter)

// Copies text, tags, and paintables between @start and @end
// and inserts the copy at @iter.
//
// The order of @start and @end doesn’t matter.
//
// Used instead of simply getting/inserting text because it preserves
// images and tags. If @start and @end are in a different buffer from
// @buffer, the two buffers must share the same tag table.
//
// Implemented via emissions of the ::insert-text and ::apply-tag signals,
// so expect those.
func (x *TextBuffer) InsertRange(IterVar *TextIter, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferInsertRange(x.GoPointer(), IterVar, StartVar, EndVar)

}

var xTextBufferInsertRangeInteractive func(uintptr, *TextIter, *TextIter, *TextIter, bool) bool

// Copies text, tags, and paintables between @start and @end
// and inserts the copy at @iter.
//
// Same as [method@Gtk.TextBuffer.insert_range], but does nothing
// if the insertion point isn’t editable. The @default_editable
// parameter indicates whether the text is editable at @iter if
// no tags enclosing @iter affect editability. Typically the result
// of [method@Gtk.TextView.get_editable] is appropriate here.
func (x *TextBuffer) InsertRangeInteractive(IterVar *TextIter, StartVar *TextIter, EndVar *TextIter, DefaultEditableVar bool) bool {

	cret := xTextBufferInsertRangeInteractive(x.GoPointer(), IterVar, StartVar, EndVar, DefaultEditableVar)
	return cret
}

var xTextBufferInsertWithTags func(uintptr, *TextIter, string, int, uintptr, ...interface{})

// Inserts @text into @buffer at @iter, applying the list of tags to
// the newly-inserted text.
//
// The last tag specified must be %NULL to terminate the list.
// Equivalent to calling [method@Gtk.TextBuffer.insert],
// then [method@Gtk.TextBuffer.apply_tag] on the inserted text;
// this is just a convenience function.
func (x *TextBuffer) InsertWithTags(IterVar *TextIter, TextVar string, LenVar int, FirstTagVar *TextTag, varArgs ...interface{}) {

	xTextBufferInsertWithTags(x.GoPointer(), IterVar, TextVar, LenVar, FirstTagVar.GoPointer(), varArgs...)

}

var xTextBufferInsertWithTagsByName func(uintptr, *TextIter, string, int, string, ...interface{})

// Inserts @text into @buffer at @iter, applying the list of tags to
// the newly-inserted text.
//
// Same as [method@Gtk.TextBuffer.insert_with_tags], but allows you
// to pass in tag names instead of tag objects.
func (x *TextBuffer) InsertWithTagsByName(IterVar *TextIter, TextVar string, LenVar int, FirstTagNameVar string, varArgs ...interface{}) {

	xTextBufferInsertWithTagsByName(x.GoPointer(), IterVar, TextVar, LenVar, FirstTagNameVar, varArgs...)

}

var xTextBufferMoveMark func(uintptr, uintptr, *TextIter)

// Moves @mark to the new location @where.
//
// Emits the [signal@Gtk.TextBuffer::mark-set] signal
// as notification of the move.
func (x *TextBuffer) MoveMark(MarkVar *TextMark, WhereVar *TextIter) {

	xTextBufferMoveMark(x.GoPointer(), MarkVar.GoPointer(), WhereVar)

}

var xTextBufferMoveMarkByName func(uintptr, string, *TextIter)

// Moves the mark named @name (which must exist) to location @where.
//
// See [method@Gtk.TextBuffer.move_mark] for details.
func (x *TextBuffer) MoveMarkByName(NameVar string, WhereVar *TextIter) {

	xTextBufferMoveMarkByName(x.GoPointer(), NameVar, WhereVar)

}

var xTextBufferPasteClipboard func(uintptr, uintptr, *TextIter, bool)

// Pastes the contents of a clipboard.
//
// If @override_location is %NULL, the pasted text will be inserted
// at the cursor position, or the buffer selection will be replaced
// if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data
// and return, and at some point later after the main loop runs, the paste
// data will be inserted.
func (x *TextBuffer) PasteClipboard(ClipboardVar *gdk.Clipboard, OverrideLocationVar *TextIter, DefaultEditableVar bool) {

	xTextBufferPasteClipboard(x.GoPointer(), ClipboardVar.GoPointer(), OverrideLocationVar, DefaultEditableVar)

}

var xTextBufferPlaceCursor func(uintptr, *TextIter)

// This function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them to the same place in two steps with
// [method@Gtk.TextBuffer.move_mark], you will temporarily select a
// region in between their old and new locations, which can be pretty
// inefficient since the temporarily-selected region will force stuff
// to be recalculated. This function moves them as a unit, which can
// be optimized.
func (x *TextBuffer) PlaceCursor(WhereVar *TextIter) {

	xTextBufferPlaceCursor(x.GoPointer(), WhereVar)

}

var xTextBufferRedo func(uintptr)

// Redoes the next redoable action on the buffer, if there is one.
func (x *TextBuffer) Redo() {

	xTextBufferRedo(x.GoPointer())

}

var xTextBufferRemoveAllTags func(uintptr, *TextIter, *TextIter)

// Removes all tags in the range between @start and @end.
//
// Be careful with this function; it could remove tags added in code
// unrelated to the code you’re currently writing. That is, using this
// function is probably a bad idea if you have two or more unrelated
// code sections that add tags.
func (x *TextBuffer) RemoveAllTags(StartVar *TextIter, EndVar *TextIter) {

	xTextBufferRemoveAllTags(x.GoPointer(), StartVar, EndVar)

}

var xTextBufferRemoveCommitNotify func(uintptr, uint)

// Removes the `GtkTextBufferCommitNotify` handler previously registered
// with [method@Gtk.TextBuffer.add_commit_notify].
//
// This may result in the `user_data_destroy` being called that was passed when registering
// the commit notify functions.
func (x *TextBuffer) RemoveCommitNotify(CommitNotifyHandlerVar uint) {

	xTextBufferRemoveCommitNotify(x.GoPointer(), CommitNotifyHandlerVar)

}

var xTextBufferRemoveSelectionClipboard func(uintptr, uintptr)

// Removes a `GdkClipboard` added with
// [method@Gtk.TextBuffer.add_selection_clipboard]
func (x *TextBuffer) RemoveSelectionClipboard(ClipboardVar *gdk.Clipboard) {

	xTextBufferRemoveSelectionClipboard(x.GoPointer(), ClipboardVar.GoPointer())

}

var xTextBufferRemoveTag func(uintptr, uintptr, *TextIter, *TextIter)

// Emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences
// of @tag from the given range. @start and @end don’t have
// to be in order.
func (x *TextBuffer) RemoveTag(TagVar *TextTag, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferRemoveTag(x.GoPointer(), TagVar.GoPointer(), StartVar, EndVar)

}

var xTextBufferRemoveTagByName func(uintptr, string, *TextIter, *TextIter)

// Emits the “remove-tag” signal.
//
// Calls [method@Gtk.TextTagTable.lookup] on the buffer’s
// tag table to get a `GtkTextTag`, then calls
// [method@Gtk.TextBuffer.remove_tag].
func (x *TextBuffer) RemoveTagByName(NameVar string, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferRemoveTagByName(x.GoPointer(), NameVar, StartVar, EndVar)

}

var xTextBufferSelectRange func(uintptr, *TextIter, *TextIter)

// This function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them in two steps with
// [method@Gtk.TextBuffer.move_mark], you will temporarily select a
// region in between their old and new locations, which can be pretty
// inefficient since the temporarily-selected region will force stuff
// to be recalculated. This function moves them as a unit, which can
// be optimized.
func (x *TextBuffer) SelectRange(InsVar *TextIter, BoundVar *TextIter) {

	xTextBufferSelectRange(x.GoPointer(), InsVar, BoundVar)

}

var xTextBufferSetEnableUndo func(uintptr, bool)

// Sets whether or not to enable undoable actions in the text buffer.
//
// Undoable actions in this context are changes to the text content of
// the buffer. Changes to tags and marks are not tracked.
//
// If enabled, the user will be able to undo the last number of actions
// up to [method@Gtk.TextBuffer.get_max_undo_levels].
//
// See [method@Gtk.TextBuffer.begin_irreversible_action] and
// [method@Gtk.TextBuffer.end_irreversible_action] to create
// changes to the buffer that cannot be undone.
func (x *TextBuffer) SetEnableUndo(EnableUndoVar bool) {

	xTextBufferSetEnableUndo(x.GoPointer(), EnableUndoVar)

}

var xTextBufferSetMaxUndoLevels func(uintptr, uint)

// Sets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may
// have a memory usage impact as it requires storing an additional
// copy of the inserted or removed text within the text buffer.
func (x *TextBuffer) SetMaxUndoLevels(MaxUndoLevelsVar uint) {

	xTextBufferSetMaxUndoLevels(x.GoPointer(), MaxUndoLevelsVar)

}

var xTextBufferSetModified func(uintptr, bool)

// Used to keep track of whether the buffer has been
// modified since the last time it was saved.
//
// Whenever the buffer is saved to disk, call
// `gtk_text_buffer_set_modified (@buffer, FALSE)`.
// When the buffer is modified, it will automatically
// toggle on the modified bit again. When the modified
// bit flips, the buffer emits the
// [signal@Gtk.TextBuffer::modified-changed] signal.
func (x *TextBuffer) SetModified(SettingVar bool) {

	xTextBufferSetModified(x.GoPointer(), SettingVar)

}

var xTextBufferSetText func(uintptr, string, int)

// Deletes current contents of @buffer, and inserts @text instead. This is
// automatically marked as an irreversible action in the undo stack. If you
// wish to mark this action as part of a larger undo operation, call
// [method@TextBuffer.delete] and [method@TextBuffer.insert] directly instead.
//
// If @len is -1, @text must be nul-terminated.
// @text must be valid UTF-8.
func (x *TextBuffer) SetText(TextVar string, LenVar int) {

	xTextBufferSetText(x.GoPointer(), TextVar, LenVar)

}

var xTextBufferUndo func(uintptr)

// Undoes the last undoable action on the buffer, if there is one.
func (x *TextBuffer) Undo() {

	xTextBufferUndo(x.GoPointer())

}

func (c *TextBuffer) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *TextBuffer) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted to apply a tag to a range of text in a `GtkTextBuffer`.
//
// Applying actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @start and @end iters (or has to
// revalidate them).
//
// See also:
// [method@Gtk.TextBuffer.apply_tag],
// [method@Gtk.TextBuffer.insert_with_tags],
// [method@Gtk.TextBuffer.insert_range].
func (x *TextBuffer) ConnectApplyTag(cb *func(TextBuffer, uintptr, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "apply-tag", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TagVarp uintptr, StartVarp uintptr, EndVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TagVarp, StartVarp, EndVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "apply-tag", cbRefPtr)
}

// Emitted at the beginning of a single user-visible
// operation on a `GtkTextBuffer`.
//
// See also:
// [method@Gtk.TextBuffer.begin_user_action],
// [method@Gtk.TextBuffer.insert_interactive],
// [method@Gtk.TextBuffer.insert_range_interactive],
// [method@Gtk.TextBuffer.delete_interactive],
// [method@Gtk.TextBuffer.backspace],
// [method@Gtk.TextBuffer.delete_selection].
func (x *TextBuffer) ConnectBeginUserAction(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "begin-user-action", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "begin-user-action", cbRefPtr)
}

// Emitted when the content of a `GtkTextBuffer` has changed.
func (x *TextBuffer) ConnectChanged(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

// Emitted to delete a range from a `GtkTextBuffer`.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @start and @end iters (or has
// to revalidate them). The default signal handler revalidates
// the @start and @end iters to both point to the location
// where text was deleted. Handlers which run after the default
// handler (see g_signal_connect_after()) do not have access to
// the deleted text.
//
// See also: [method@Gtk.TextBuffer.delete].
func (x *TextBuffer) ConnectDeleteRange(cb *func(TextBuffer, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "delete-range", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StartVarp uintptr, EndVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StartVarp, EndVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "delete-range", cbRefPtr)
}

// Emitted at the end of a single user-visible
// operation on the `GtkTextBuffer`.
//
// See also:
// [method@Gtk.TextBuffer.end_user_action],
// [method@Gtk.TextBuffer.insert_interactive],
// [method@Gtk.TextBuffer.insert_range_interactive],
// [method@Gtk.TextBuffer.delete_interactive],
// [method@Gtk.TextBuffer.backspace],
// [method@Gtk.TextBuffer.delete_selection],
// [method@Gtk.TextBuffer.backspace].
func (x *TextBuffer) ConnectEndUserAction(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "end-user-action", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "end-user-action", cbRefPtr)
}

// Emitted to insert a `GtkTextChildAnchor` in a `GtkTextBuffer`.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @location iter (or has to
// revalidate it). The default signal handler revalidates
// it to be placed after the inserted @anchor.
//
// See also: [method@Gtk.TextBuffer.insert_child_anchor].
func (x *TextBuffer) ConnectInsertChildAnchor(cb *func(TextBuffer, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-child-anchor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, LocationVarp uintptr, AnchorVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LocationVarp, AnchorVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-child-anchor", cbRefPtr)
}

// Emitted to insert a `GdkPaintable` in a `GtkTextBuffer`.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @location iter (or has to
// revalidate it). The default signal handler revalidates
// it to be placed after the inserted @paintable.
//
// See also: [method@Gtk.TextBuffer.insert_paintable].
func (x *TextBuffer) ConnectInsertPaintable(cb *func(TextBuffer, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-paintable", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, LocationVarp uintptr, PaintableVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LocationVarp, PaintableVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-paintable", cbRefPtr)
}

// Emitted to insert text in a `GtkTextBuffer`.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @location iter (or has to
// revalidate it). The default signal handler revalidates
// it to point to the end of the inserted text.
//
// See also: [method@Gtk.TextBuffer.insert],
// [method@Gtk.TextBuffer.insert_range].
func (x *TextBuffer) ConnectInsertText(cb *func(TextBuffer, uintptr, string, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-text", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, LocationVarp uintptr, TextVarp string, LenVarp int) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LocationVarp, TextVarp, LenVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-text", cbRefPtr)
}

// Emitted as notification after a `GtkTextMark` is deleted.
//
// See also: [method@Gtk.TextBuffer.delete_mark].
func (x *TextBuffer) ConnectMarkDeleted(cb *func(TextBuffer, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "mark-deleted", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MarkVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MarkVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "mark-deleted", cbRefPtr)
}

// Emitted as notification after a `GtkTextMark` is set.
//
// See also:
// [method@Gtk.TextBuffer.create_mark],
// [method@Gtk.TextBuffer.move_mark].
func (x *TextBuffer) ConnectMarkSet(cb *func(TextBuffer, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "mark-set", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, LocationVarp uintptr, MarkVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LocationVarp, MarkVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "mark-set", cbRefPtr)
}

// Emitted when the modified bit of a `GtkTextBuffer` flips.
//
// See also: [method@Gtk.TextBuffer.set_modified].
func (x *TextBuffer) ConnectModifiedChanged(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "modified-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "modified-changed", cbRefPtr)
}

// Emitted after paste operation has been completed.
//
// This is useful to properly scroll the view to the end
// of the pasted text. See [method@Gtk.TextBuffer.paste_clipboard]
// for more details.
func (x *TextBuffer) ConnectPasteDone(cb *func(TextBuffer, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "paste-done", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ClipboardVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ClipboardVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "paste-done", cbRefPtr)
}

// Emitted when a request has been made to redo the
// previously undone operation.
func (x *TextBuffer) ConnectRedo(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "redo", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "redo", cbRefPtr)
}

// Emitted to remove all occurrences of @tag from a range
// of text in a `GtkTextBuffer`.
//
// Removal actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @start and @end iters (or has
// to revalidate them).
//
// See also: [method@Gtk.TextBuffer.remove_tag].
func (x *TextBuffer) ConnectRemoveTag(cb *func(TextBuffer, uintptr, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "remove-tag", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TagVarp uintptr, StartVarp uintptr, EndVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TagVarp, StartVarp, EndVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "remove-tag", cbRefPtr)
}

// Emitted when a request has been made to undo the
// previous operation or set of operations that have
// been grouped together.
func (x *TextBuffer) ConnectUndo(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "undo", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "undo", cbRefPtr)
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTextBufferGLibType, libs, "gtk_text_buffer_get_type")

	core.PuregoSafeRegister(&xNewTextBuffer, libs, "gtk_text_buffer_new")

	core.PuregoSafeRegister(&xTextBufferAddCommitNotify, libs, "gtk_text_buffer_add_commit_notify")
	core.PuregoSafeRegister(&xTextBufferAddMark, libs, "gtk_text_buffer_add_mark")
	core.PuregoSafeRegister(&xTextBufferAddSelectionClipboard, libs, "gtk_text_buffer_add_selection_clipboard")
	core.PuregoSafeRegister(&xTextBufferApplyTag, libs, "gtk_text_buffer_apply_tag")
	core.PuregoSafeRegister(&xTextBufferApplyTagByName, libs, "gtk_text_buffer_apply_tag_by_name")
	core.PuregoSafeRegister(&xTextBufferBackspace, libs, "gtk_text_buffer_backspace")
	core.PuregoSafeRegister(&xTextBufferBeginIrreversibleAction, libs, "gtk_text_buffer_begin_irreversible_action")
	core.PuregoSafeRegister(&xTextBufferBeginUserAction, libs, "gtk_text_buffer_begin_user_action")
	core.PuregoSafeRegister(&xTextBufferCopyClipboard, libs, "gtk_text_buffer_copy_clipboard")
	core.PuregoSafeRegister(&xTextBufferCreateChildAnchor, libs, "gtk_text_buffer_create_child_anchor")
	core.PuregoSafeRegister(&xTextBufferCreateMark, libs, "gtk_text_buffer_create_mark")
	core.PuregoSafeRegister(&xTextBufferCreateTag, libs, "gtk_text_buffer_create_tag")
	core.PuregoSafeRegister(&xTextBufferCutClipboard, libs, "gtk_text_buffer_cut_clipboard")
	core.PuregoSafeRegister(&xTextBufferDelete, libs, "gtk_text_buffer_delete")
	core.PuregoSafeRegister(&xTextBufferDeleteInteractive, libs, "gtk_text_buffer_delete_interactive")
	core.PuregoSafeRegister(&xTextBufferDeleteMark, libs, "gtk_text_buffer_delete_mark")
	core.PuregoSafeRegister(&xTextBufferDeleteMarkByName, libs, "gtk_text_buffer_delete_mark_by_name")
	core.PuregoSafeRegister(&xTextBufferDeleteSelection, libs, "gtk_text_buffer_delete_selection")
	core.PuregoSafeRegister(&xTextBufferEndIrreversibleAction, libs, "gtk_text_buffer_end_irreversible_action")
	core.PuregoSafeRegister(&xTextBufferEndUserAction, libs, "gtk_text_buffer_end_user_action")
	core.PuregoSafeRegister(&xTextBufferGetBounds, libs, "gtk_text_buffer_get_bounds")
	core.PuregoSafeRegister(&xTextBufferGetCanRedo, libs, "gtk_text_buffer_get_can_redo")
	core.PuregoSafeRegister(&xTextBufferGetCanUndo, libs, "gtk_text_buffer_get_can_undo")
	core.PuregoSafeRegister(&xTextBufferGetCharCount, libs, "gtk_text_buffer_get_char_count")
	core.PuregoSafeRegister(&xTextBufferGetEnableUndo, libs, "gtk_text_buffer_get_enable_undo")
	core.PuregoSafeRegister(&xTextBufferGetEndIter, libs, "gtk_text_buffer_get_end_iter")
	core.PuregoSafeRegister(&xTextBufferGetHasSelection, libs, "gtk_text_buffer_get_has_selection")
	core.PuregoSafeRegister(&xTextBufferGetInsert, libs, "gtk_text_buffer_get_insert")
	core.PuregoSafeRegister(&xTextBufferGetIterAtChildAnchor, libs, "gtk_text_buffer_get_iter_at_child_anchor")
	core.PuregoSafeRegister(&xTextBufferGetIterAtLine, libs, "gtk_text_buffer_get_iter_at_line")
	core.PuregoSafeRegister(&xTextBufferGetIterAtLineIndex, libs, "gtk_text_buffer_get_iter_at_line_index")
	core.PuregoSafeRegister(&xTextBufferGetIterAtLineOffset, libs, "gtk_text_buffer_get_iter_at_line_offset")
	core.PuregoSafeRegister(&xTextBufferGetIterAtMark, libs, "gtk_text_buffer_get_iter_at_mark")
	core.PuregoSafeRegister(&xTextBufferGetIterAtOffset, libs, "gtk_text_buffer_get_iter_at_offset")
	core.PuregoSafeRegister(&xTextBufferGetLineCount, libs, "gtk_text_buffer_get_line_count")
	core.PuregoSafeRegister(&xTextBufferGetMark, libs, "gtk_text_buffer_get_mark")
	core.PuregoSafeRegister(&xTextBufferGetMaxUndoLevels, libs, "gtk_text_buffer_get_max_undo_levels")
	core.PuregoSafeRegister(&xTextBufferGetModified, libs, "gtk_text_buffer_get_modified")
	core.PuregoSafeRegister(&xTextBufferGetSelectionBound, libs, "gtk_text_buffer_get_selection_bound")
	core.PuregoSafeRegister(&xTextBufferGetSelectionBounds, libs, "gtk_text_buffer_get_selection_bounds")
	core.PuregoSafeRegister(&xTextBufferGetSelectionContent, libs, "gtk_text_buffer_get_selection_content")
	core.PuregoSafeRegister(&xTextBufferGetSlice, libs, "gtk_text_buffer_get_slice")
	core.PuregoSafeRegister(&xTextBufferGetStartIter, libs, "gtk_text_buffer_get_start_iter")
	core.PuregoSafeRegister(&xTextBufferGetTagTable, libs, "gtk_text_buffer_get_tag_table")
	core.PuregoSafeRegister(&xTextBufferGetText, libs, "gtk_text_buffer_get_text")
	core.PuregoSafeRegister(&xTextBufferInsert, libs, "gtk_text_buffer_insert")
	core.PuregoSafeRegister(&xTextBufferInsertAtCursor, libs, "gtk_text_buffer_insert_at_cursor")
	core.PuregoSafeRegister(&xTextBufferInsertChildAnchor, libs, "gtk_text_buffer_insert_child_anchor")
	core.PuregoSafeRegister(&xTextBufferInsertInteractive, libs, "gtk_text_buffer_insert_interactive")
	core.PuregoSafeRegister(&xTextBufferInsertInteractiveAtCursor, libs, "gtk_text_buffer_insert_interactive_at_cursor")
	core.PuregoSafeRegister(&xTextBufferInsertMarkup, libs, "gtk_text_buffer_insert_markup")
	core.PuregoSafeRegister(&xTextBufferInsertPaintable, libs, "gtk_text_buffer_insert_paintable")
	core.PuregoSafeRegister(&xTextBufferInsertRange, libs, "gtk_text_buffer_insert_range")
	core.PuregoSafeRegister(&xTextBufferInsertRangeInteractive, libs, "gtk_text_buffer_insert_range_interactive")
	core.PuregoSafeRegister(&xTextBufferInsertWithTags, libs, "gtk_text_buffer_insert_with_tags")
	core.PuregoSafeRegister(&xTextBufferInsertWithTagsByName, libs, "gtk_text_buffer_insert_with_tags_by_name")
	core.PuregoSafeRegister(&xTextBufferMoveMark, libs, "gtk_text_buffer_move_mark")
	core.PuregoSafeRegister(&xTextBufferMoveMarkByName, libs, "gtk_text_buffer_move_mark_by_name")
	core.PuregoSafeRegister(&xTextBufferPasteClipboard, libs, "gtk_text_buffer_paste_clipboard")
	core.PuregoSafeRegister(&xTextBufferPlaceCursor, libs, "gtk_text_buffer_place_cursor")
	core.PuregoSafeRegister(&xTextBufferRedo, libs, "gtk_text_buffer_redo")
	core.PuregoSafeRegister(&xTextBufferRemoveAllTags, libs, "gtk_text_buffer_remove_all_tags")
	core.PuregoSafeRegister(&xTextBufferRemoveCommitNotify, libs, "gtk_text_buffer_remove_commit_notify")
	core.PuregoSafeRegister(&xTextBufferRemoveSelectionClipboard, libs, "gtk_text_buffer_remove_selection_clipboard")
	core.PuregoSafeRegister(&xTextBufferRemoveTag, libs, "gtk_text_buffer_remove_tag")
	core.PuregoSafeRegister(&xTextBufferRemoveTagByName, libs, "gtk_text_buffer_remove_tag_by_name")
	core.PuregoSafeRegister(&xTextBufferSelectRange, libs, "gtk_text_buffer_select_range")
	core.PuregoSafeRegister(&xTextBufferSetEnableUndo, libs, "gtk_text_buffer_set_enable_undo")
	core.PuregoSafeRegister(&xTextBufferSetMaxUndoLevels, libs, "gtk_text_buffer_set_max_undo_levels")
	core.PuregoSafeRegister(&xTextBufferSetModified, libs, "gtk_text_buffer_set_modified")
	core.PuregoSafeRegister(&xTextBufferSetText, libs, "gtk_text_buffer_set_text")
	core.PuregoSafeRegister(&xTextBufferUndo, libs, "gtk_text_buffer_undo")

}
