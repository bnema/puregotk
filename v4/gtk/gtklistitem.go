// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type ListItemClass struct {
	_ structs.HostLayout
}

func (x *ListItemClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Used by list widgets to represent items in a [iface@Gio.ListModel].
//
// `GtkListItem` objects are managed by the list widget (with its factory)
// and cannot be created by applications, but they need to be populated
// by application code. This is done by calling [method@Gtk.ListItem.set_child].
//
// `GtkListItem` objects exist in 2 stages:
//
//  1. The unbound stage where the listitem is not currently connected to
//     an item in the list. In that case, the [property@Gtk.ListItem:item]
//     property is set to `NULL`.
//
//  2. The bound stage where the listitem references an item from the list.
//     The [property@Gtk.ListItem:item] property is not `NULL`.
type ListItem struct {
	gobject.Object
}

var xListItemGLibType func() types.GType

func ListItemGLibType() types.GType {
	return xListItemGLibType()
}

func ListItemNewFromInternalPtr(ptr uintptr) *ListItem {
	cls := &ListItem{}
	cls.Ptr = ptr
	return cls
}

var xListItemGetAccessibleDescription func(uintptr) string

// Gets the accessible description of @self.
func (x *ListItem) GetAccessibleDescription() string {

	cret := xListItemGetAccessibleDescription(x.GoPointer())

	return cret
}

var xListItemGetAccessibleLabel func(uintptr) string

// Gets the accessible label of @self.
func (x *ListItem) GetAccessibleLabel() string {

	cret := xListItemGetAccessibleLabel(x.GoPointer())

	return cret
}

var xListItemGetActivatable func(uintptr) bool

// Checks if a listitem has been set to be activatable via
// [method@Gtk.ListItem.set_activatable].
func (x *ListItem) GetActivatable() bool {

	cret := xListItemGetActivatable(x.GoPointer())

	return cret
}

var xListItemGetChild func(uintptr) uintptr

// Gets the child previously set via [method@Gtk.ListItem.set_child]
// or `NULL` if none was set.
func (x *ListItem) GetChild() *Widget {
	var cls *Widget

	cret := xListItemGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xListItemGetFocusable func(uintptr) bool

// Checks if a listitem has been set to be focusable via
// [method@Gtk.ListItem.set_focusable].
func (x *ListItem) GetFocusable() bool {

	cret := xListItemGetFocusable(x.GoPointer())

	return cret
}

var xListItemGetItem func(uintptr) uintptr

// Gets the model item that associated with @self.
//
// If @self is unbound, this function returns `NULL`.
func (x *ListItem) GetItem() *gobject.Object {
	var cls *gobject.Object

	cret := xListItemGetItem(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

var xListItemGetPosition func(uintptr) uint

// Gets the position in the model that @self currently displays.
//
// If @self is unbound, `GTK_INVALID_LIST_POSITION` is returned.
func (x *ListItem) GetPosition() uint {

	cret := xListItemGetPosition(x.GoPointer())

	return cret
}

var xListItemGetSelectable func(uintptr) bool

// Checks if a listitem has been set to be selectable via
// [method@Gtk.ListItem.set_selectable].
//
// Do not confuse this function with [method@Gtk.ListItem.get_selected].
func (x *ListItem) GetSelectable() bool {

	cret := xListItemGetSelectable(x.GoPointer())

	return cret
}

var xListItemGetSelected func(uintptr) bool

// Checks if the item is displayed as selected.
//
// The selected state is maintained by the list widget and its model
// and cannot be set otherwise.
func (x *ListItem) GetSelected() bool {

	cret := xListItemGetSelected(x.GoPointer())

	return cret
}

var xListItemSetAccessibleDescription func(uintptr, string)

// Sets the accessible description for the listitem.
//
// The accessible description may be used by e.g. screen readers.
func (x *ListItem) SetAccessibleDescription(DescriptionVar string) {

	xListItemSetAccessibleDescription(x.GoPointer(), DescriptionVar)

}

var xListItemSetAccessibleLabel func(uintptr, string)

// Sets the accessible label for the listitem.
//
// The accessible label may be used by e.g. screen readers.
func (x *ListItem) SetAccessibleLabel(LabelVar string) {

	xListItemSetAccessibleLabel(x.GoPointer(), LabelVar)

}

var xListItemSetActivatable func(uintptr, bool)

// Sets @self to be activatable.
//
// If an item is activatable, double-clicking on the item, using
// the Return key or calling [method@Gtk.Widget.activate] will activate
// the item. Activating instructs the containing view to handle
// activation. `GtkListView` for example will be emitting the
// [signal@Gtk.ListView::activate] signal.
//
// By default, listitems are activatable.
func (x *ListItem) SetActivatable(ActivatableVar bool) {

	xListItemSetActivatable(x.GoPointer(), ActivatableVar)

}

var xListItemSetChild func(uintptr, uintptr)

// Sets the child to be used for this listitem.
//
// This function is typically called by applications when
// setting up a listitem so that the widget can be reused when
// binding it multiple times.
func (x *ListItem) SetChild(ChildVar *Widget) {

	xListItemSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xListItemSetFocusable func(uintptr, bool)

// Sets @self to be focusable.
//
// If an item is focusable, it can be focused using the keyboard.
// This works similar to [method@Gtk.Widget.set_focusable].
//
// Note that if items are not focusable, the keyboard cannot be used to activate
// them and selecting only works if one of the listitem's children is focusable.
//
// By default, listitems are focusable.
func (x *ListItem) SetFocusable(FocusableVar bool) {

	xListItemSetFocusable(x.GoPointer(), FocusableVar)

}

var xListItemSetSelectable func(uintptr, bool)

// Sets @self to be selectable.
//
// If an item is selectable, clicking on the item or using the keyboard
// will try to select or unselect the item. If this succeeds is up to
// the model to determine, as it is managing the selected state.
//
// Note that this means that making an item non-selectable has no
// influence on the selected state at all. A non-selectable item
// may still be selected.
//
// By default, listitems are selectable. When rebinding them to
// a new item, they will also be reset to be selectable by GTK.
func (x *ListItem) SetSelectable(SelectableVar bool) {

	xListItemSetSelectable(x.GoPointer(), SelectableVar)

}

func (c *ListItem) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *ListItem) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAccessibleDescription sets the "accessible-description" property.
// The accessible description to set on the listitem.
func (x *ListItem) SetPropertyAccessibleDescription(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("accessible-description", &v)
}

// GetPropertyAccessibleDescription gets the "accessible-description" property.
// The accessible description to set on the listitem.
func (x *ListItem) GetPropertyAccessibleDescription() string {
	var v gobject.Value
	x.GetProperty("accessible-description", &v)
	return v.GetString()
}

// SetPropertyAccessibleLabel sets the "accessible-label" property.
// The accessible label to set on the listitem.
func (x *ListItem) SetPropertyAccessibleLabel(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("accessible-label", &v)
}

// GetPropertyAccessibleLabel gets the "accessible-label" property.
// The accessible label to set on the listitem.
func (x *ListItem) GetPropertyAccessibleLabel() string {
	var v gobject.Value
	x.GetProperty("accessible-label", &v)
	return v.GetString()
}

// SetPropertyActivatable sets the "activatable" property.
// If the item can be activated by the user.
func (x *ListItem) SetPropertyActivatable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("activatable", &v)
}

// GetPropertyActivatable gets the "activatable" property.
// If the item can be activated by the user.
func (x *ListItem) GetPropertyActivatable() bool {
	var v gobject.Value
	x.GetProperty("activatable", &v)
	return v.GetBoolean()
}

// SetPropertyFocusable sets the "focusable" property.
// If the item can be focused with the keyboard.
func (x *ListItem) SetPropertyFocusable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("focusable", &v)
}

// GetPropertyFocusable gets the "focusable" property.
// If the item can be focused with the keyboard.
func (x *ListItem) GetPropertyFocusable() bool {
	var v gobject.Value
	x.GetProperty("focusable", &v)
	return v.GetBoolean()
}

// GetPropertyPosition gets the "position" property.
// Position of the item.
func (x *ListItem) GetPropertyPosition() uint {
	var v gobject.Value
	x.GetProperty("position", &v)
	return v.GetUint()
}

// SetPropertySelectable sets the "selectable" property.
// If the item can be selected by the user.
func (x *ListItem) SetPropertySelectable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("selectable", &v)
}

// GetPropertySelectable gets the "selectable" property.
// If the item can be selected by the user.
func (x *ListItem) GetPropertySelectable() bool {
	var v gobject.Value
	x.GetProperty("selectable", &v)
	return v.GetBoolean()
}

// GetPropertySelected gets the "selected" property.
// If the item is currently selected.
func (x *ListItem) GetPropertySelected() bool {
	var v gobject.Value
	x.GetProperty("selected", &v)
	return v.GetBoolean()
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xListItemGLibType, libs, "gtk_list_item_get_type")

	core.PuregoSafeRegister(&xListItemGetAccessibleDescription, libs, "gtk_list_item_get_accessible_description")
	core.PuregoSafeRegister(&xListItemGetAccessibleLabel, libs, "gtk_list_item_get_accessible_label")
	core.PuregoSafeRegister(&xListItemGetActivatable, libs, "gtk_list_item_get_activatable")
	core.PuregoSafeRegister(&xListItemGetChild, libs, "gtk_list_item_get_child")
	core.PuregoSafeRegister(&xListItemGetFocusable, libs, "gtk_list_item_get_focusable")
	core.PuregoSafeRegister(&xListItemGetItem, libs, "gtk_list_item_get_item")
	core.PuregoSafeRegister(&xListItemGetPosition, libs, "gtk_list_item_get_position")
	core.PuregoSafeRegister(&xListItemGetSelectable, libs, "gtk_list_item_get_selectable")
	core.PuregoSafeRegister(&xListItemGetSelected, libs, "gtk_list_item_get_selected")
	core.PuregoSafeRegister(&xListItemSetAccessibleDescription, libs, "gtk_list_item_set_accessible_description")
	core.PuregoSafeRegister(&xListItemSetAccessibleLabel, libs, "gtk_list_item_set_accessible_label")
	core.PuregoSafeRegister(&xListItemSetActivatable, libs, "gtk_list_item_set_activatable")
	core.PuregoSafeRegister(&xListItemSetChild, libs, "gtk_list_item_set_child")
	core.PuregoSafeRegister(&xListItemSetFocusable, libs, "gtk_list_item_set_focusable")
	core.PuregoSafeRegister(&xListItemSetSelectable, libs, "gtk_list_item_set_selectable")

}
