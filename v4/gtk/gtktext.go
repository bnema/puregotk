// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/graphene"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// A single-line text entry.
//
// `GtkText` is the common implementation of single-line text editing
// that is shared between [class@Gtk.Entry], [class@Gtk.PasswordEntry],
// [class@Gtk.SpinButton], and other widgets. In all of these, a `GtkText`
// instance is used as the delegate for the [iface@Gtk.Editable] implementation.
//
// A large number of key bindings s supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll
// so that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information,
// it can be put into “password mode” using [method@Gtk.Text.set_visibility].
// In this mode, entered text is displayed using an “invisible” character.
// By default, GTK picks the best invisible character that is available
// in the current font, but it can be changed with
// [method@Gtk.Text.set_invisible_char].
//
// If you want to add icons or progress display in an entry, look at
// [class@Gtk.Entry]. There are other alternatives for more specialized
// use cases, such as [class@Gtk.SearchEntry].
//
// If you need multi-line editable text, use [class@Gtk.TextView].
//
// # Shortcuts and Gestures
//
// `GtkText` supports the following keyboard shortcuts:
//
//   - &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;F10&lt;/kbd&gt; or &lt;kbd&gt;Menu&lt;/kbd&gt; opens the context menu.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;A&lt;/kbd&gt; or &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;&amp;sol;&lt;/kbd&gt;
//     selects all the text.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;A&lt;/kbd&gt; or
//     &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;&amp;bsol;&lt;/kbd&gt; unselects all.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Z&lt;/kbd&gt; undoes the last modification.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Y&lt;/kbd&gt; or &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Z&lt;/kbd&gt;
//     redoes the last undone modification.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;T&lt;/kbd&gt; toggles the text direction.
//
// Additionally, the following signals have default keybindings:
//
// - [signal@Gtk.Text::activate]
// - [signal@Gtk.Text::backspace]
// - [signal@Gtk.Text::copy-clipboard]
// - [signal@Gtk.Text::cut-clipboard]
// - [signal@Gtk.Text::delete-from-cursor]
// - [signal@Gtk.Text::insert-emoji]
// - [signal@Gtk.Text::move-cursor]
// - [signal@Gtk.Text::paste-clipboard]
// - [signal@Gtk.Text::toggle-overwrite]
//
// # Actions
//
// `GtkText` defines a set of built-in actions:
//
//   - `clipboard.copy` copies the contents to the clipboard.
//   - `clipboard.cut` copies the contents to the clipboard and deletes it from
//     the widget.
//   - `clipboard.paste` inserts the contents of the clipboard into the widget.
//   - `menu.popup` opens the context menu.
//   - `misc.insert-emoji` opens the Emoji chooser.
//   - `misc.toggle-visibility` toggles the `GtkText`:visibility property.
//   - `misc.toggle-direction` toggles the text direction.
//   - `selection.delete` deletes the current selection.
//   - `selection.select-all` selects all of the widgets content.
//   - `text.redo` redoes the last change to the contents.
//   - `text.undo` undoes the last change to the contents.
//
// # CSS nodes
//
// ```
// text[.read-only]
// ├── placeholder
// ├── undershoot.left
// ├── undershoot.right
// ├── [selection]
// ├── [cursor-handle[.top]
// ├── [cursor-handle.bottom]
// ├── [block-cursor]
// ├── [cursor-handle[.top/.bottom][.insertion-cursor]]
// ╰── [window.popup]
// ```
//
// `GtkText` has a main node with the name `text`. Depending on the properties
// of the widget, the `.read-only` style class may appear.
//
// When the entry has a selection, it adds a subnode with the name `selection`.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// `block-cursor` that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode with the name `popup`.
//
// The `undershoot` nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the `.left` or `.right` style class
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using
// CSS nodes with name `cursor-handle`. They get the `.top` or `.bottom` style
// class depending on where they are shown in relation to the selection. If
// there is just a single handle for the text cursor, it gets the style class
// `.insertion-cursor`.
//
// # Accessibility
//
// `GtkText` uses the [enum@Gtk.AccessibleRole.none] role, which causes it to be
// skipped for accessibility. This is because `GtkText` is expected to be used
// as a delegate for a `GtkEditable` implementation that will be represented
// to accessibility.
type Text struct {
	Widget
}

var xTextGLibType func() types.GType

func TextGLibType() types.GType {
	return xTextGLibType()
}

func TextNewFromInternalPtr(ptr uintptr) *Text {
	cls := &Text{}
	cls.Ptr = ptr
	return cls
}

var xNewText func() uintptr

// Creates a new `GtkText`.
func NewText() *Text {
	var cls *Text

	cret := xNewText()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Text{}
	cls.Ptr = cret
	return cls
}

var xNewTextWithBuffer func(uintptr) uintptr

// Creates a new `GtkText` with the specified buffer.
func NewTextWithBuffer(BufferVar *EntryBuffer) *Text {
	var cls *Text

	cret := xNewTextWithBuffer(BufferVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Text{}
	cls.Ptr = cret
	return cls
}

var xTextComputeCursorExtents func(uintptr, uint, *graphene.Rect, *graphene.Rect)

// Determines the positions of the strong and weak cursors for a
// given character position.
//
// The position of each cursor is stored as a zero-width rectangle.
// The strong cursor location is the location where characters of
// the directionality equal to the base direction are inserted.
// The weak cursor location is the location where characters of
// the directionality opposite to the base direction are inserted.
//
// The rectangle positions are in widget coordinates.
func (x *Text) ComputeCursorExtents(PositionVar uint, StrongVar *graphene.Rect, WeakVar *graphene.Rect) {

	xTextComputeCursorExtents(x.GoPointer(), PositionVar, StrongVar, WeakVar)

}

var xTextGetActivatesDefault func(uintptr) bool

// Returns whether pressing &lt;kbd&gt;Enter&lt;/kbd&gt; will activate
// the default widget for the window containing the widget.
//
// See [method@Gtk.Text.set_activates_default].
func (x *Text) GetActivatesDefault() bool {

	cret := xTextGetActivatesDefault(x.GoPointer())
	return cret
}

var xTextGetAttributes func(uintptr) *pango.AttrList

// Gets the attribute list that was set on the text widget.
//
// See [method@Gtk.Text.set_attributes].
func (x *Text) GetAttributes() *pango.AttrList {

	cret := xTextGetAttributes(x.GoPointer())
	return cret
}

var xTextGetBuffer func(uintptr) uintptr

// Get the entry buffer object which holds the text for
// this widget.
func (x *Text) GetBuffer() *EntryBuffer {
	var cls *EntryBuffer

	cret := xTextGetBuffer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EntryBuffer{}
	cls.Ptr = cret
	return cls
}

var xTextGetEnableEmojiCompletion func(uintptr) bool

// Returns whether Emoji completion is enabled.
func (x *Text) GetEnableEmojiCompletion() bool {

	cret := xTextGetEnableEmojiCompletion(x.GoPointer())
	return cret
}

var xTextGetExtraMenu func(uintptr) uintptr

// Gets the extra menu model of the text widget.
//
// See [method@Gtk.Text.set_extra_menu].
func (x *Text) GetExtraMenu() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xTextGetExtraMenu(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xTextGetInputHints func(uintptr) InputHints

// Gets the input hints of the text widget.
func (x *Text) GetInputHints() InputHints {

	cret := xTextGetInputHints(x.GoPointer())
	return cret
}

var xTextGetInputPurpose func(uintptr) InputPurpose

// Gets the input purpose of the text widget.
func (x *Text) GetInputPurpose() InputPurpose {

	cret := xTextGetInputPurpose(x.GoPointer())
	return cret
}

var xTextGetInvisibleChar func(uintptr) uint32

// Retrieves the character displayed when visibility is set to false.
//
// Note that GTK does not compute this value unless it needs it,
// so the value returned by this function is not very useful unless
// it has been explicitly set with [method@Gtk.Text.set_invisible_char].
func (x *Text) GetInvisibleChar() uint32 {

	cret := xTextGetInvisibleChar(x.GoPointer())
	return cret
}

var xTextGetMaxLength func(uintptr) int

// Retrieves the maximum allowed length of the contents.
//
// See [method@Gtk.Text.set_max_length].
//
// This is equivalent to getting @self's `GtkEntryBuffer` and
// calling [method@Gtk.EntryBuffer.get_max_length] on it.
func (x *Text) GetMaxLength() int {

	cret := xTextGetMaxLength(x.GoPointer())
	return cret
}

var xTextGetOverwriteMode func(uintptr) bool

// Gets whether text is overwritten when typing.
//
// See [method@Gtk.Text.set_overwrite_mode].
func (x *Text) GetOverwriteMode() bool {

	cret := xTextGetOverwriteMode(x.GoPointer())
	return cret
}

var xTextGetPlaceholderText func(uintptr) string

// Retrieves the text that will be displayed when the text widget
// is empty and unfocused
//
// See [method@Gtk.Text.set_placeholder_text].
func (x *Text) GetPlaceholderText() string {

	cret := xTextGetPlaceholderText(x.GoPointer())
	return cret
}

var xTextGetPropagateTextWidth func(uintptr) bool

// Returns whether the text widget will grow and shrink
// with the content.
func (x *Text) GetPropagateTextWidth() bool {

	cret := xTextGetPropagateTextWidth(x.GoPointer())
	return cret
}

var xTextGetTabs func(uintptr) *pango.TabArray

// Gets the tab stops for the text widget.
//
// See [method@Gtk.Text.set_tabs].
func (x *Text) GetTabs() *pango.TabArray {

	cret := xTextGetTabs(x.GoPointer())
	return cret
}

var xTextGetTextLength func(uintptr) uint16

// Retrieves the length of the contents.
//
// This is equivalent to getting @self's `GtkEntryBuffer`
// and calling [method@Gtk.EntryBuffer.get_length] on it.
func (x *Text) GetTextLength() uint16 {

	cret := xTextGetTextLength(x.GoPointer())
	return cret
}

var xTextGetTruncateMultiline func(uintptr) bool

// Returns whether pasted text will be truncated to the first line.
func (x *Text) GetTruncateMultiline() bool {

	cret := xTextGetTruncateMultiline(x.GoPointer())
	return cret
}

var xTextGetVisibility func(uintptr) bool

// Retrieves whether the text is visible.
func (x *Text) GetVisibility() bool {

	cret := xTextGetVisibility(x.GoPointer())
	return cret
}

var xTextGrabFocusWithoutSelecting func(uintptr) bool

// Causes the text widget to have the keyboard focus.
//
// It behaves like [method@Gtk.Widget.grab_focus],
// except that it does not select the contents of @self.
//
// You only want to call this on some special entries
// which the user usually doesn't want to replace all
// text in, such as search-as-you-type entries.
func (x *Text) GrabFocusWithoutSelecting() bool {

	cret := xTextGrabFocusWithoutSelecting(x.GoPointer())
	return cret
}

var xTextSetActivatesDefault func(uintptr, bool)

// Sets whether pressing &lt;kbd&gt;Enter&lt;/kbd&gt; will activate
// the default widget.
//
// This usually means that the dialog containing @self will
// be closed, since the default widget is usually one of
// the dialog buttons.
func (x *Text) SetActivatesDefault(ActivatesVar bool) {

	xTextSetActivatesDefault(x.GoPointer(), ActivatesVar)

}

var xTextSetAttributes func(uintptr, *pango.AttrList)

// Apply attributes to the contents of the text widget.
func (x *Text) SetAttributes(AttrsVar *pango.AttrList) {

	xTextSetAttributes(x.GoPointer(), AttrsVar)

}

var xTextSetBuffer func(uintptr, uintptr)

// Set the entry buffer object which holds the text for
// this widget.
func (x *Text) SetBuffer(BufferVar *EntryBuffer) {

	xTextSetBuffer(x.GoPointer(), BufferVar.GoPointer())

}

var xTextSetEnableEmojiCompletion func(uintptr, bool)

// Sets whether Emoji completion is enabled.
//
// If it is, typing ':', followed by a recognized keyword,
// will pop up a window with suggested Emojis matching the
// keyword.
func (x *Text) SetEnableEmojiCompletion(EnableEmojiCompletionVar bool) {

	xTextSetEnableEmojiCompletion(x.GoPointer(), EnableEmojiCompletionVar)

}

var xTextSetExtraMenu func(uintptr, uintptr)

// Sets a menu model to add to the context menu of the text widget.
func (x *Text) SetExtraMenu(ModelVar *gio.MenuModel) {

	xTextSetExtraMenu(x.GoPointer(), ModelVar.GoPointer())

}

var xTextSetInputHints func(uintptr, InputHints)

// Sets hints that allow input methods to fine-tune their behaviour.
func (x *Text) SetInputHints(HintsVar InputHints) {

	xTextSetInputHints(x.GoPointer(), HintsVar)

}

var xTextSetInputPurpose func(uintptr, InputPurpose)

// Sets the input purpose of the text widget.
//
// The input purpose can be used by on-screen keyboards
// and other input methods to adjust their behaviour.
func (x *Text) SetInputPurpose(PurposeVar InputPurpose) {

	xTextSetInputPurpose(x.GoPointer(), PurposeVar)

}

var xTextSetInvisibleChar func(uintptr, uint32)

// Sets the character to use when in “password mode”.
//
// By default, GTK picks the best invisible char available in the
// current font. If you set the invisible char to 0, then the user
// will get no feedback at all; there will be no text on the screen
// as they type.
func (x *Text) SetInvisibleChar(ChVar uint32) {

	xTextSetInvisibleChar(x.GoPointer(), ChVar)

}

var xTextSetMaxLength func(uintptr, int)

// Sets the maximum allowed length of the contents.
//
// If the current contents are longer than the given length,
// they will be truncated to fit.
//
// This is equivalent to getting @self's `GtkEntryBuffer` and
// calling [method@Gtk.EntryBuffer.set_max_length] on it.
func (x *Text) SetMaxLength(LengthVar int) {

	xTextSetMaxLength(x.GoPointer(), LengthVar)

}

var xTextSetOverwriteMode func(uintptr, bool)

// Sets whether the text is overwritten when typing.
func (x *Text) SetOverwriteMode(OverwriteVar bool) {

	xTextSetOverwriteMode(x.GoPointer(), OverwriteVar)

}

var xTextSetPlaceholderText func(uintptr, string)

// Sets the text to be displayed when the text widget is
// empty and unfocused.
//
// This can be used to give a visual hint of the expected
// contents of the text widget.
func (x *Text) SetPlaceholderText(TextVar string) {

	xTextSetPlaceholderText(x.GoPointer(), TextVar)

}

var xTextSetPropagateTextWidth func(uintptr, bool)

// Sets whether the text widget should grow and shrink with the content.
func (x *Text) SetPropagateTextWidth(PropagateTextWidthVar bool) {

	xTextSetPropagateTextWidth(x.GoPointer(), PropagateTextWidthVar)

}

var xTextSetTabs func(uintptr, *pango.TabArray)

// Sets tab stops for the text widget.
func (x *Text) SetTabs(TabsVar *pango.TabArray) {

	xTextSetTabs(x.GoPointer(), TabsVar)

}

var xTextSetTruncateMultiline func(uintptr, bool)

// Sets whether pasted text should be truncated to the first line.
func (x *Text) SetTruncateMultiline(TruncateMultilineVar bool) {

	xTextSetTruncateMultiline(x.GoPointer(), TruncateMultilineVar)

}

var xTextSetVisibility func(uintptr, bool)

// Sets whether the contents of the text widget are visible or not.
//
// When visibility is set to false, characters are displayed
// as the invisible char, and it will also appear that way when
// the text in the widget is copied to the clipboard.
//
// By default, GTK picks the best invisible character available
// in the current font, but it can be changed with
// [method@Gtk.Text.set_invisible_char].
//
// Note that you probably want to set [property@Gtk.Text:input-purpose]
// to [enum@Gtk.InputPurpose.password] or [enum@Gtk.InputPurpose.pin]
// to inform input methods about the purpose of this widget, in addition
// to setting visibility to false.
func (x *Text) SetVisibility(VisibleVar bool) {

	xTextSetVisibility(x.GoPointer(), VisibleVar)

}

var xTextUnsetInvisibleChar func(uintptr)

// Unsets the invisible char.
//
// After calling this, the default invisible char is used again.
func (x *Text) UnsetInvisibleChar() {

	xTextUnsetInvisibleChar(x.GoPointer())

}

func (c *Text) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Text) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the user hits the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
//
// The default bindings for this signal are all forms
// of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
func (x *Text) ConnectActivate(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Backspace&lt;/kbd&gt;.
func (x *Text) ConnectBackspace(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "backspace", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "backspace", cbRefPtr)
}

// Emitted to copy the selection to the clipboard.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;c&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *Text) ConnectCopyClipboard(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "copy-clipboard", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "copy-clipboard", cbRefPtr)
}

// Emitted to cut the selection to the clipboard.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;x&lt;/kbd&gt; and
// &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Delete&lt;/kbd&gt;.
func (x *Text) ConnectCutClipboard(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "cut-clipboard", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "cut-clipboard", cbRefPtr)
}

// Emitted when the user initiates a text deletion.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// If the @type is [enum@Gtk.DeleteType.chars], GTK deletes the
// selection if there is one, otherwise it deletes the requested
// number of characters.
//
// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt;
// for deleting a character and &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Delete&lt;/kbd&gt;
// for deleting a word.
func (x *Text) ConnectDeleteFromCursor(cb *func(Text, DeleteType, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "delete-from-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TypeVarp DeleteType, CountVarp int) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TypeVarp, CountVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "delete-from-cursor", cbRefPtr)
}

// Emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This signal has no default bindings.
func (x *Text) ConnectInsertAtCursor(cb *func(Text, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-at-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StringVarp string) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StringVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-at-cursor", cbRefPtr)
}

// Emitted to present the Emoji chooser.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;.&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;;&lt;/kbd&gt;
func (x *Text) ConnectInsertEmoji(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-emoji", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-emoji", cbRefPtr)
}

// Emitted when the user initiates a cursor movement.
//
// If the cursor is not visible in @self, this signal causes
// the viewport to be moved instead.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// Applications should not connect to it, but may emit it with
// [func@GObject.signal_emit_by_name] if they need to control
// the cursor programmatically.
//
// The default bindings for this signal come in two variants,
// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
// selection, the variant without it does not.
// There are too many key combinations to list them all here.
//
//   - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
//     move by individual characters/lines
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;←&lt;/kbd&gt;, etc. move by words/paragraphs
//   - &lt;kbd&gt;Home&lt;/kbd&gt; and &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
func (x *Text) ConnectMoveCursor(cb *func(Text, MovementStep, int, bool)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StepVarp MovementStep, CountVarp int, ExtendVarp bool) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StepVarp, CountVarp, ExtendVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
}

// Emitted to paste the contents of the clipboard.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;v&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *Text) ConnectPasteClipboard(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "paste-clipboard", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "paste-clipboard", cbRefPtr)
}

// Emitted when the preedit text changes.
//
// If an input method is used, the typed text will not immediately
// be committed to the buffer. So if you are interested in the text,
// connect to this signal.
func (x *Text) ConnectPreeditChanged(cb *func(Text, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PreeditVarp string) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PreeditVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
}

// Emitted to toggle the overwrite mode.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *Text) ConnectToggleOverwrite(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "toggle-overwrite", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "toggle-overwrite", cbRefPtr)
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *Text) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *Text) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *Text) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *Text) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *Text) GetBounds(XVar int, YVar int, WidthVar int, HeightVar int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *Text) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *Text) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *Text) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *Text) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *Text) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *Text) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *Text) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *Text) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *Text) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Text) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Text) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Text) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Text) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Text) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Text) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Updates the position of the caret.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time the caret has moved, in order to notify assistive
// technologies.
func (x *Text) UpdateCaretPosition() {

	XGtkAccessibleTextUpdateCaretPosition(x.GoPointer())

}

// Notifies assistive technologies of a change in contents.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time their contents change as the result of an operation,
// like an insertion or a removal.
//
// Note: If the change is a deletion, this function must be called *before*
// removing the contents, if it is an insertion, it must be called *after*
// inserting the new contents.
func (x *Text) UpdateContents(ChangeVar AccessibleTextContentChange, StartVar uint, EndVar uint) {

	XGtkAccessibleTextUpdateContents(x.GoPointer(), ChangeVar, StartVar, EndVar)

}

// Updates the boundary of the selection.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time the selection has moved, in order to notify assistive
// technologies.
func (x *Text) UpdateSelectionBound() {

	XGtkAccessibleTextUpdateSelectionBound(x.GoPointer())

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *Text) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Retrieves the accessible platform state from the editable delegate.
//
// This is an helper function to retrieve the accessible state for
// `GtkEditable` interface implementations using a delegate pattern.
//
// You should call this function in your editable widget implementation
// of the [vfunc@Gtk.Accessible.get_platform_state] virtual function, for
// instance:
//
// ```c
// static void
// accessible_interface_init (GtkAccessibleInterface *iface)
//
//	{
//	  iface-&gt;get_platform_state = your_editable_get_accessible_platform_state;
//	}
//
// static gboolean
// your_editable_get_accessible_platform_state (GtkAccessible *accessible,
//
//	GtkAccessiblePlatformState state)
//
//	{
//	  return gtk_editable_delegate_get_accessible_platform_state (GTK_EDITABLE (accessible), state);
//	}
//
// ```
//
// Note that the widget which is the delegate *must* be a direct child of
// this widget, otherwise your implementation of [vfunc@Gtk.Accessible.get_platform_state]
// might not even be called, as the platform change will originate from
// the parent of the delegate, and, as a result, will not work properly.
//
// So, if you can't ensure the direct child condition, you should give the
// delegate the %GTK_ACCESSIBLE_ROLE_TEXT_BOX role, or you can
// change your tree to allow this function to work.
func (x *Text) DelegateGetAccessiblePlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkEditableDelegateGetAccessiblePlatformState(x.GoPointer(), StateVar)
	return cret
}

// Deletes the currently selected text of the editable.
//
// This call doesn’t do anything if there is no selected text.
func (x *Text) DeleteSelection() {

	XGtkEditableDeleteSelection(x.GoPointer())

}

// Deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters deleted are those from @start_pos to
// the end of the text.
//
// Note that the positions are specified in characters, not bytes.
func (x *Text) DeleteText(StartPosVar int, EndPosVar int) {

	XGtkEditableDeleteText(x.GoPointer(), StartPosVar, EndPosVar)

}

// Undoes the setup done by [method@Gtk.Editable.init_delegate].
//
// This is a helper function that should be called from dispose,
// before removing the delegate object.
func (x *Text) FinishDelegate() {

	XGtkEditableFinishDelegate(x.GoPointer())

}

// Gets the alignment of the editable.
func (x *Text) GetAlignment() float32 {

	cret := XGtkEditableGetAlignment(x.GoPointer())
	return cret
}

// Retrieves a sequence of characters.
//
// The characters that are retrieved are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is negative,
// then the characters retrieved are those characters from @start_pos to
// the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *Text) GetChars(StartPosVar int, EndPosVar int) string {

	cret := XGtkEditableGetChars(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Gets the `GtkEditable` that @editable is delegating its
// implementation to.
//
// Typically, the delegate is a [class@Gtk.Text] widget.
func (x *Text) GetDelegate() *EditableBase {
	var cls *EditableBase

	cret := XGtkEditableGetDelegate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditableBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves whether @editable is editable.
func (x *Text) GetEditable() bool {

	cret := XGtkEditableGetEditable(x.GoPointer())
	return cret
}

// Gets if undo/redo actions are enabled for @editable
func (x *Text) GetEnableUndo() bool {

	cret := XGtkEditableGetEnableUndo(x.GoPointer())
	return cret
}

// Retrieves the desired maximum width of @editable, in characters.
func (x *Text) GetMaxWidthChars() int {

	cret := XGtkEditableGetMaxWidthChars(x.GoPointer())
	return cret
}

// Retrieves the current position of the cursor relative
// to the start of the content of the editable.
//
// Note that this position is in characters, not in bytes.
func (x *Text) GetPosition() int {

	cret := XGtkEditableGetPosition(x.GoPointer())
	return cret
}

// Retrieves the selection bound of the editable.
//
// @start_pos will be filled with the start of the selection and
// @end_pos with end. If no text was selected both will be identical
// and %FALSE will be returned.
//
// Note that positions are specified in characters, not bytes.
func (x *Text) GetSelectionBounds(StartPosVar int, EndPosVar int) bool {

	cret := XGtkEditableGetSelectionBounds(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Retrieves the contents of @editable.
//
// The returned string is owned by GTK and must not be modified or freed.
func (x *Text) GetText() string {

	cret := XGtkEditableGetText(x.GoPointer())
	return cret
}

// Gets the number of characters of space reserved
// for the contents of the editable.
func (x *Text) GetWidthChars() int {

	cret := XGtkEditableGetWidthChars(x.GoPointer())
	return cret
}

// Sets up a delegate for `GtkEditable`.
//
// This is assuming that the get_delegate vfunc in the `GtkEditable`
// interface has been set up for the @editable's type.
//
// This is a helper function that should be called in instance init,
// after creating the delegate object.
func (x *Text) InitDelegate() {

	XGtkEditableInitDelegate(x.GoPointer())

}

// Inserts @length bytes of @text into the contents of the
// widget, at position @position.
//
// Note that the position is in characters, not in bytes.
// The function updates @position to point after the newly
// inserted text.
func (x *Text) InsertText(TextVar string, LengthVar int, PositionVar int) {

	XGtkEditableInsertText(x.GoPointer(), TextVar, LengthVar, PositionVar)

}

// Selects a region of text.
//
// The characters that are selected are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters selected are those characters from
// @start_pos to  the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *Text) SelectRegion(StartPosVar int, EndPosVar int) {

	XGtkEditableSelectRegion(x.GoPointer(), StartPosVar, EndPosVar)

}

// Sets the alignment for the contents of the editable.
//
// This controls the horizontal positioning of the contents when
// the displayed text is shorter than the width of the editable.
func (x *Text) SetAlignment(XalignVar float32) {

	XGtkEditableSetAlignment(x.GoPointer(), XalignVar)

}

// Determines if the user can edit the text in the editable widget.
func (x *Text) SetEditable(IsEditableVar bool) {

	XGtkEditableSetEditable(x.GoPointer(), IsEditableVar)

}

// If enabled, changes to @editable will be saved for undo/redo
// actions.
//
// This results in an additional copy of text changes and are not
// stored in secure memory. As such, undo is forcefully disabled
// when [property@Gtk.Text:visibility] is set to %FALSE.
func (x *Text) SetEnableUndo(EnableUndoVar bool) {

	XGtkEditableSetEnableUndo(x.GoPointer(), EnableUndoVar)

}

// Sets the desired maximum width in characters of @editable.
func (x *Text) SetMaxWidthChars(NCharsVar int) {

	XGtkEditableSetMaxWidthChars(x.GoPointer(), NCharsVar)

}

// Sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0)
// index in the contents of the editable. The value must be less than
// or equal to the number of characters in the editable. A value of -1
// indicates that the position should be set after the last character
// of the editable. Note that @position is in characters, not in bytes.
func (x *Text) SetPosition(PositionVar int) {

	XGtkEditableSetPosition(x.GoPointer(), PositionVar)

}

// Sets the text in the editable to the given value.
//
// This is replacing the current contents.
func (x *Text) SetText(TextVar string) {

	XGtkEditableSetText(x.GoPointer(), TextVar)

}

// Changes the size request of the editable to be about the
// right size for @n_chars characters.
//
// Note that it changes the size request, the size can still
// be affected by how you pack the widget into containers.
// If @n_chars is -1, the size reverts to the default size.
func (x *Text) SetWidthChars(NCharsVar int) {

	XGtkEditableSetWidthChars(x.GoPointer(), NCharsVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTextGLibType, libs, "gtk_text_get_type")

	core.PuregoSafeRegister(&xNewText, libs, "gtk_text_new")
	core.PuregoSafeRegister(&xNewTextWithBuffer, libs, "gtk_text_new_with_buffer")

	core.PuregoSafeRegister(&xTextComputeCursorExtents, libs, "gtk_text_compute_cursor_extents")
	core.PuregoSafeRegister(&xTextGetActivatesDefault, libs, "gtk_text_get_activates_default")
	core.PuregoSafeRegister(&xTextGetAttributes, libs, "gtk_text_get_attributes")
	core.PuregoSafeRegister(&xTextGetBuffer, libs, "gtk_text_get_buffer")
	core.PuregoSafeRegister(&xTextGetEnableEmojiCompletion, libs, "gtk_text_get_enable_emoji_completion")
	core.PuregoSafeRegister(&xTextGetExtraMenu, libs, "gtk_text_get_extra_menu")
	core.PuregoSafeRegister(&xTextGetInputHints, libs, "gtk_text_get_input_hints")
	core.PuregoSafeRegister(&xTextGetInputPurpose, libs, "gtk_text_get_input_purpose")
	core.PuregoSafeRegister(&xTextGetInvisibleChar, libs, "gtk_text_get_invisible_char")
	core.PuregoSafeRegister(&xTextGetMaxLength, libs, "gtk_text_get_max_length")
	core.PuregoSafeRegister(&xTextGetOverwriteMode, libs, "gtk_text_get_overwrite_mode")
	core.PuregoSafeRegister(&xTextGetPlaceholderText, libs, "gtk_text_get_placeholder_text")
	core.PuregoSafeRegister(&xTextGetPropagateTextWidth, libs, "gtk_text_get_propagate_text_width")
	core.PuregoSafeRegister(&xTextGetTabs, libs, "gtk_text_get_tabs")
	core.PuregoSafeRegister(&xTextGetTextLength, libs, "gtk_text_get_text_length")
	core.PuregoSafeRegister(&xTextGetTruncateMultiline, libs, "gtk_text_get_truncate_multiline")
	core.PuregoSafeRegister(&xTextGetVisibility, libs, "gtk_text_get_visibility")
	core.PuregoSafeRegister(&xTextGrabFocusWithoutSelecting, libs, "gtk_text_grab_focus_without_selecting")
	core.PuregoSafeRegister(&xTextSetActivatesDefault, libs, "gtk_text_set_activates_default")
	core.PuregoSafeRegister(&xTextSetAttributes, libs, "gtk_text_set_attributes")
	core.PuregoSafeRegister(&xTextSetBuffer, libs, "gtk_text_set_buffer")
	core.PuregoSafeRegister(&xTextSetEnableEmojiCompletion, libs, "gtk_text_set_enable_emoji_completion")
	core.PuregoSafeRegister(&xTextSetExtraMenu, libs, "gtk_text_set_extra_menu")
	core.PuregoSafeRegister(&xTextSetInputHints, libs, "gtk_text_set_input_hints")
	core.PuregoSafeRegister(&xTextSetInputPurpose, libs, "gtk_text_set_input_purpose")
	core.PuregoSafeRegister(&xTextSetInvisibleChar, libs, "gtk_text_set_invisible_char")
	core.PuregoSafeRegister(&xTextSetMaxLength, libs, "gtk_text_set_max_length")
	core.PuregoSafeRegister(&xTextSetOverwriteMode, libs, "gtk_text_set_overwrite_mode")
	core.PuregoSafeRegister(&xTextSetPlaceholderText, libs, "gtk_text_set_placeholder_text")
	core.PuregoSafeRegister(&xTextSetPropagateTextWidth, libs, "gtk_text_set_propagate_text_width")
	core.PuregoSafeRegister(&xTextSetTabs, libs, "gtk_text_set_tabs")
	core.PuregoSafeRegister(&xTextSetTruncateMultiline, libs, "gtk_text_set_truncate_multiline")
	core.PuregoSafeRegister(&xTextSetVisibility, libs, "gtk_text_set_visibility")
	core.PuregoSafeRegister(&xTextUnsetInvisibleChar, libs, "gtk_text_unset_invisible_char")

}
