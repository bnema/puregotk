// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

type IMContextClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xPreeditStart uintptr

	xPreeditEnd uintptr

	xPreeditChanged uintptr

	xCommit uintptr

	xRetrieveSurrounding uintptr

	xDeleteSurrounding uintptr

	xSetClientWidget uintptr

	xGetPreeditString uintptr

	xFilterKeypress uintptr

	xFocusIn uintptr

	xFocusOut uintptr

	xReset uintptr

	xSetCursorLocation uintptr

	xSetUsePreedit uintptr

	xSetSurrounding uintptr

	xGetSurrounding uintptr

	xSetSurroundingWithSelection uintptr

	xGetSurroundingWithSelection uintptr

	xActivateOsk uintptr

	xActivateOskWithEvent uintptr

	xGtkReserved2 uintptr

	xGtkReserved3 uintptr

	xGtkReserved4 uintptr
}

func (x *IMContextClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverridePreeditStart sets the "preedit_start" callback function.
// Default handler of the [signal@Gtk.IMContext::preedit-start] signal.
func (x *IMContextClass) OverridePreeditStart(cb func(*IMContext)) {
	if cb == nil {
		x.xPreeditStart = 0
	} else {
		x.xPreeditStart = purego.NewCallback(func(ContextVarp uintptr) {
			cb(IMContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetPreeditStart gets the "preedit_start" callback function.
// Default handler of the [signal@Gtk.IMContext::preedit-start] signal.
func (x *IMContextClass) GetPreeditStart() func(*IMContext) {
	if x.xPreeditStart == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPreeditStart)
	return func(ContextVar *IMContext) {
		rawCallback(ContextVar.GoPointer())
	}
}

// OverridePreeditEnd sets the "preedit_end" callback function.
// Default handler of the [signal@Gtk.IMContext::preedit-end] signal.
func (x *IMContextClass) OverridePreeditEnd(cb func(*IMContext)) {
	if cb == nil {
		x.xPreeditEnd = 0
	} else {
		x.xPreeditEnd = purego.NewCallback(func(ContextVarp uintptr) {
			cb(IMContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetPreeditEnd gets the "preedit_end" callback function.
// Default handler of the [signal@Gtk.IMContext::preedit-end] signal.
func (x *IMContextClass) GetPreeditEnd() func(*IMContext) {
	if x.xPreeditEnd == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPreeditEnd)
	return func(ContextVar *IMContext) {
		rawCallback(ContextVar.GoPointer())
	}
}

// OverridePreeditChanged sets the "preedit_changed" callback function.
// Default handler of the [signal@Gtk.IMContext::preedit-changed]
//
//	signal.
func (x *IMContextClass) OverridePreeditChanged(cb func(*IMContext)) {
	if cb == nil {
		x.xPreeditChanged = 0
	} else {
		x.xPreeditChanged = purego.NewCallback(func(ContextVarp uintptr) {
			cb(IMContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetPreeditChanged gets the "preedit_changed" callback function.
// Default handler of the [signal@Gtk.IMContext::preedit-changed]
//
//	signal.
func (x *IMContextClass) GetPreeditChanged() func(*IMContext) {
	if x.xPreeditChanged == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPreeditChanged)
	return func(ContextVar *IMContext) {
		rawCallback(ContextVar.GoPointer())
	}
}

// OverrideCommit sets the "commit" callback function.
// Default handler of the [signal@Gtk.IMContext::commit] signal.
func (x *IMContextClass) OverrideCommit(cb func(*IMContext, string)) {
	if cb == nil {
		x.xCommit = 0
	} else {
		x.xCommit = purego.NewCallback(func(ContextVarp uintptr, StrVarp string) {
			cb(IMContextNewFromInternalPtr(ContextVarp), StrVarp)
		})
	}
}

// GetCommit gets the "commit" callback function.
// Default handler of the [signal@Gtk.IMContext::commit] signal.
func (x *IMContextClass) GetCommit() func(*IMContext, string) {
	if x.xCommit == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, StrVarp string)
	purego.RegisterFunc(&rawCallback, x.xCommit)
	return func(ContextVar *IMContext, StrVar string) {
		rawCallback(ContextVar.GoPointer(), StrVar)
	}
}

// OverrideRetrieveSurrounding sets the "retrieve_surrounding" callback function.
// Default handler of the
//
//	[signal@Gtk.IMContext::retrieve-surrounding] signal.
func (x *IMContextClass) OverrideRetrieveSurrounding(cb func(*IMContext) bool) {
	if cb == nil {
		x.xRetrieveSurrounding = 0
	} else {
		x.xRetrieveSurrounding = purego.NewCallback(func(ContextVarp uintptr) bool {
			return cb(IMContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetRetrieveSurrounding gets the "retrieve_surrounding" callback function.
// Default handler of the
//
//	[signal@Gtk.IMContext::retrieve-surrounding] signal.
func (x *IMContextClass) GetRetrieveSurrounding() func(*IMContext) bool {
	if x.xRetrieveSurrounding == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xRetrieveSurrounding)
	return func(ContextVar *IMContext) bool {
		return rawCallback(ContextVar.GoPointer())
	}
}

// OverrideDeleteSurrounding sets the "delete_surrounding" callback function.
// Default handler of the
//
//	[signal@Gtk.IMContext::delete-surrounding] signal.
func (x *IMContextClass) OverrideDeleteSurrounding(cb func(*IMContext, int, int) bool) {
	if cb == nil {
		x.xDeleteSurrounding = 0
	} else {
		x.xDeleteSurrounding = purego.NewCallback(func(ContextVarp uintptr, OffsetVarp int, NCharsVarp int) bool {
			return cb(IMContextNewFromInternalPtr(ContextVarp), OffsetVarp, NCharsVarp)
		})
	}
}

// GetDeleteSurrounding gets the "delete_surrounding" callback function.
// Default handler of the
//
//	[signal@Gtk.IMContext::delete-surrounding] signal.
func (x *IMContextClass) GetDeleteSurrounding() func(*IMContext, int, int) bool {
	if x.xDeleteSurrounding == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, OffsetVarp int, NCharsVarp int) bool
	purego.RegisterFunc(&rawCallback, x.xDeleteSurrounding)
	return func(ContextVar *IMContext, OffsetVar int, NCharsVar int) bool {
		return rawCallback(ContextVar.GoPointer(), OffsetVar, NCharsVar)
	}
}

// OverrideSetClientWidget sets the "set_client_widget" callback function.
// Called via [method@Gtk.IMContext.set_client_widget] when
//
//	the input window where the entered text will appear changes. Override this
//	to keep track of the current input window, for instance for the purpose of
//	positioning a status display of your input method.
func (x *IMContextClass) OverrideSetClientWidget(cb func(*IMContext, *Widget)) {
	if cb == nil {
		x.xSetClientWidget = 0
	} else {
		x.xSetClientWidget = purego.NewCallback(func(ContextVarp uintptr, WidgetVarp uintptr) {
			cb(IMContextNewFromInternalPtr(ContextVarp), WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetSetClientWidget gets the "set_client_widget" callback function.
// Called via [method@Gtk.IMContext.set_client_widget] when
//
//	the input window where the entered text will appear changes. Override this
//	to keep track of the current input window, for instance for the purpose of
//	positioning a status display of your input method.
func (x *IMContextClass) GetSetClientWidget() func(*IMContext, *Widget) {
	if x.xSetClientWidget == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSetClientWidget)
	return func(ContextVar *IMContext, WidgetVar *Widget) {
		rawCallback(ContextVar.GoPointer(), WidgetVar.GoPointer())
	}
}

// OverrideGetPreeditString sets the "get_preedit_string" callback function.
// Called via [method@Gtk.IMContext.get_preedit_string]
//
//	to retrieve the text currently being preedited for display at the cursor
//	position. Any input method which composes complex characters or any
//	other compositions from multiple sequential key presses should override
//	this method to provide feedback.
func (x *IMContextClass) OverrideGetPreeditString(cb func(*IMContext, *string, **pango.AttrList, *int)) {
	if cb == nil {
		x.xGetPreeditString = 0
	} else {
		x.xGetPreeditString = purego.NewCallback(func(ContextVarp uintptr, StrVarp *string, AttrsVarp **pango.AttrList, CursorPosVarp *int) {
			cb(IMContextNewFromInternalPtr(ContextVarp), StrVarp, AttrsVarp, CursorPosVarp)
		})
	}
}

// GetGetPreeditString gets the "get_preedit_string" callback function.
// Called via [method@Gtk.IMContext.get_preedit_string]
//
//	to retrieve the text currently being preedited for display at the cursor
//	position. Any input method which composes complex characters or any
//	other compositions from multiple sequential key presses should override
//	this method to provide feedback.
func (x *IMContextClass) GetGetPreeditString() func(*IMContext, *string, **pango.AttrList, *int) {
	if x.xGetPreeditString == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, StrVarp *string, AttrsVarp **pango.AttrList, CursorPosVarp *int)
	purego.RegisterFunc(&rawCallback, x.xGetPreeditString)
	return func(ContextVar *IMContext, StrVar *string, AttrsVar **pango.AttrList, CursorPosVar *int) {
		rawCallback(ContextVar.GoPointer(), StrVar, AttrsVar, CursorPosVar)
	}
}

// OverrideFilterKeypress sets the "filter_keypress" callback function.
// Called via [method@Gtk.IMContext.filter_keypress] on every
//
//	key press or release event. Every non-trivial input method needs to
//	override this in order to implement the mapping from key events to text.
//	A return value of %TRUE indicates to the caller that the event was
//	consumed by the input method. In that case, the [signal@Gtk.IMContext::commit]
//	signal should be emitted upon completion of a key sequence to pass the
//	resulting text back to the input widget. Alternatively, %FALSE may be
//	returned to indicate that the event wasn’t handled by the input method.
//	If a builtin mapping exists for the key, it is used to produce a
//	character.
func (x *IMContextClass) OverrideFilterKeypress(cb func(*IMContext, *gdk.Event) bool) {
	if cb == nil {
		x.xFilterKeypress = 0
	} else {
		x.xFilterKeypress = purego.NewCallback(func(ContextVarp uintptr, EventVarp uintptr) bool {
			return cb(IMContextNewFromInternalPtr(ContextVarp), gdk.EventNewFromInternalPtr(EventVarp))
		})
	}
}

// GetFilterKeypress gets the "filter_keypress" callback function.
// Called via [method@Gtk.IMContext.filter_keypress] on every
//
//	key press or release event. Every non-trivial input method needs to
//	override this in order to implement the mapping from key events to text.
//	A return value of %TRUE indicates to the caller that the event was
//	consumed by the input method. In that case, the [signal@Gtk.IMContext::commit]
//	signal should be emitted upon completion of a key sequence to pass the
//	resulting text back to the input widget. Alternatively, %FALSE may be
//	returned to indicate that the event wasn’t handled by the input method.
//	If a builtin mapping exists for the key, it is used to produce a
//	character.
func (x *IMContextClass) GetFilterKeypress() func(*IMContext, *gdk.Event) bool {
	if x.xFilterKeypress == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, EventVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xFilterKeypress)
	return func(ContextVar *IMContext, EventVar *gdk.Event) bool {
		return rawCallback(ContextVar.GoPointer(), EventVar.GoPointer())
	}
}

// OverrideFocusIn sets the "focus_in" callback function.
// Called via [method@Gtk.IMContext.focus_in] when the input widget
//
//	has gained focus. May be overridden to keep track of the current focus.
func (x *IMContextClass) OverrideFocusIn(cb func(*IMContext)) {
	if cb == nil {
		x.xFocusIn = 0
	} else {
		x.xFocusIn = purego.NewCallback(func(ContextVarp uintptr) {
			cb(IMContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetFocusIn gets the "focus_in" callback function.
// Called via [method@Gtk.IMContext.focus_in] when the input widget
//
//	has gained focus. May be overridden to keep track of the current focus.
func (x *IMContextClass) GetFocusIn() func(*IMContext) {
	if x.xFocusIn == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xFocusIn)
	return func(ContextVar *IMContext) {
		rawCallback(ContextVar.GoPointer())
	}
}

// OverrideFocusOut sets the "focus_out" callback function.
// Called via [method@Gtk.IMContext.focus_out] when the input widget
//
//	has lost focus. May be overridden to keep track of the current focus.
func (x *IMContextClass) OverrideFocusOut(cb func(*IMContext)) {
	if cb == nil {
		x.xFocusOut = 0
	} else {
		x.xFocusOut = purego.NewCallback(func(ContextVarp uintptr) {
			cb(IMContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetFocusOut gets the "focus_out" callback function.
// Called via [method@Gtk.IMContext.focus_out] when the input widget
//
//	has lost focus. May be overridden to keep track of the current focus.
func (x *IMContextClass) GetFocusOut() func(*IMContext) {
	if x.xFocusOut == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xFocusOut)
	return func(ContextVar *IMContext) {
		rawCallback(ContextVar.GoPointer())
	}
}

// OverrideReset sets the "reset" callback function.
// Called via [method@Gtk.IMContext.reset] to signal a change such as a
//
//	change in cursor position. An input method that implements preediting
//	should override this method to clear the preedit state on reset.
func (x *IMContextClass) OverrideReset(cb func(*IMContext)) {
	if cb == nil {
		x.xReset = 0
	} else {
		x.xReset = purego.NewCallback(func(ContextVarp uintptr) {
			cb(IMContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetReset gets the "reset" callback function.
// Called via [method@Gtk.IMContext.reset] to signal a change such as a
//
//	change in cursor position. An input method that implements preediting
//	should override this method to clear the preedit state on reset.
func (x *IMContextClass) GetReset() func(*IMContext) {
	if x.xReset == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xReset)
	return func(ContextVar *IMContext) {
		rawCallback(ContextVar.GoPointer())
	}
}

// OverrideSetCursorLocation sets the "set_cursor_location" callback function.
// Called via [method@Gtk.IMContext.set_cursor_location]
//
//	to inform the input method of the current cursor location relative to
//	the client window. May be overridden to implement the display of popup
//	windows at the cursor position.
func (x *IMContextClass) OverrideSetCursorLocation(cb func(*IMContext, *gdk.Rectangle)) {
	if cb == nil {
		x.xSetCursorLocation = 0
	} else {
		x.xSetCursorLocation = purego.NewCallback(func(ContextVarp uintptr, AreaVarp *gdk.Rectangle) {
			cb(IMContextNewFromInternalPtr(ContextVarp), AreaVarp)
		})
	}
}

// GetSetCursorLocation gets the "set_cursor_location" callback function.
// Called via [method@Gtk.IMContext.set_cursor_location]
//
//	to inform the input method of the current cursor location relative to
//	the client window. May be overridden to implement the display of popup
//	windows at the cursor position.
func (x *IMContextClass) GetSetCursorLocation() func(*IMContext, *gdk.Rectangle) {
	if x.xSetCursorLocation == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, AreaVarp *gdk.Rectangle)
	purego.RegisterFunc(&rawCallback, x.xSetCursorLocation)
	return func(ContextVar *IMContext, AreaVar *gdk.Rectangle) {
		rawCallback(ContextVar.GoPointer(), AreaVar)
	}
}

// OverrideSetUsePreedit sets the "set_use_preedit" callback function.
// Called via [method@Gtk.IMContext.set_use_preedit] to control
//
//	the use of the preedit string. Override this to display feedback by some
//	other means if turned off.
func (x *IMContextClass) OverrideSetUsePreedit(cb func(*IMContext, bool)) {
	if cb == nil {
		x.xSetUsePreedit = 0
	} else {
		x.xSetUsePreedit = purego.NewCallback(func(ContextVarp uintptr, UsePreeditVarp bool) {
			cb(IMContextNewFromInternalPtr(ContextVarp), UsePreeditVarp)
		})
	}
}

// GetSetUsePreedit gets the "set_use_preedit" callback function.
// Called via [method@Gtk.IMContext.set_use_preedit] to control
//
//	the use of the preedit string. Override this to display feedback by some
//	other means if turned off.
func (x *IMContextClass) GetSetUsePreedit() func(*IMContext, bool) {
	if x.xSetUsePreedit == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, UsePreeditVarp bool)
	purego.RegisterFunc(&rawCallback, x.xSetUsePreedit)
	return func(ContextVar *IMContext, UsePreeditVar bool) {
		rawCallback(ContextVar.GoPointer(), UsePreeditVar)
	}
}

// OverrideSetSurrounding sets the "set_surrounding" callback function.
// Called via [method@Gtk.IMContext.set_surrounding] in
//
//	response to [signal@Gtk.IMContext::retrieve-surrounding] signal to update
//	the input method’s idea of the context around the cursor. It is not necessary
//	to override this method even with input methods which implement
//	context-dependent behavior. The base implementation is sufficient for
//	[method@Gtk.IMContext.get_surrounding] to work.
func (x *IMContextClass) OverrideSetSurrounding(cb func(*IMContext, string, int, int)) {
	if cb == nil {
		x.xSetSurrounding = 0
	} else {
		x.xSetSurrounding = purego.NewCallback(func(ContextVarp uintptr, TextVarp string, LenVarp int, CursorIndexVarp int) {
			cb(IMContextNewFromInternalPtr(ContextVarp), TextVarp, LenVarp, CursorIndexVarp)
		})
	}
}

// GetSetSurrounding gets the "set_surrounding" callback function.
// Called via [method@Gtk.IMContext.set_surrounding] in
//
//	response to [signal@Gtk.IMContext::retrieve-surrounding] signal to update
//	the input method’s idea of the context around the cursor. It is not necessary
//	to override this method even with input methods which implement
//	context-dependent behavior. The base implementation is sufficient for
//	[method@Gtk.IMContext.get_surrounding] to work.
func (x *IMContextClass) GetSetSurrounding() func(*IMContext, string, int, int) {
	if x.xSetSurrounding == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, TextVarp string, LenVarp int, CursorIndexVarp int)
	purego.RegisterFunc(&rawCallback, x.xSetSurrounding)
	return func(ContextVar *IMContext, TextVar string, LenVar int, CursorIndexVar int) {
		rawCallback(ContextVar.GoPointer(), TextVar, LenVar, CursorIndexVar)
	}
}

// OverrideGetSurrounding sets the "get_surrounding" callback function.
// Called via [method@Gtk.IMContext.get_surrounding] to update
//
//	the context around the cursor location. It is not necessary to override this
//	method even with input methods which implement context-dependent behavior.
//	The base implementation emits [signal@Gtk.IMContext::retrieve-surrounding]
//	and records the context received by the subsequent invocation of
//	[vfunc@Gtk.IMContext.get_surrounding].
func (x *IMContextClass) OverrideGetSurrounding(cb func(*IMContext, *string, *int) bool) {
	if cb == nil {
		x.xGetSurrounding = 0
	} else {
		x.xGetSurrounding = purego.NewCallback(func(ContextVarp uintptr, TextVarp *string, CursorIndexVarp *int) bool {
			return cb(IMContextNewFromInternalPtr(ContextVarp), TextVarp, CursorIndexVarp)
		})
	}
}

// GetGetSurrounding gets the "get_surrounding" callback function.
// Called via [method@Gtk.IMContext.get_surrounding] to update
//
//	the context around the cursor location. It is not necessary to override this
//	method even with input methods which implement context-dependent behavior.
//	The base implementation emits [signal@Gtk.IMContext::retrieve-surrounding]
//	and records the context received by the subsequent invocation of
//	[vfunc@Gtk.IMContext.get_surrounding].
func (x *IMContextClass) GetGetSurrounding() func(*IMContext, *string, *int) bool {
	if x.xGetSurrounding == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, TextVarp *string, CursorIndexVarp *int) bool
	purego.RegisterFunc(&rawCallback, x.xGetSurrounding)
	return func(ContextVar *IMContext, TextVar *string, CursorIndexVar *int) bool {
		return rawCallback(ContextVar.GoPointer(), TextVar, CursorIndexVar)
	}
}

// OverrideSetSurroundingWithSelection sets the "set_surrounding_with_selection" callback function.
// Called via
//
//	[method@Gtk.IMContext.set_surrounding_with_selection] in response to the
//	[signal@Gtk.IMContext::retrieve-surrounding] signal to update the input
//	method’s idea of the context around the cursor. It is not necessary to
//	override this method even with input methods which implement
//	context-dependent behavior. The base implementation is sufficient for
//	[method@Gtk.IMContext.get_surrounding] to work.
func (x *IMContextClass) OverrideSetSurroundingWithSelection(cb func(*IMContext, string, int, int, int)) {
	if cb == nil {
		x.xSetSurroundingWithSelection = 0
	} else {
		x.xSetSurroundingWithSelection = purego.NewCallback(func(ContextVarp uintptr, TextVarp string, LenVarp int, CursorIndexVarp int, AnchorIndexVarp int) {
			cb(IMContextNewFromInternalPtr(ContextVarp), TextVarp, LenVarp, CursorIndexVarp, AnchorIndexVarp)
		})
	}
}

// GetSetSurroundingWithSelection gets the "set_surrounding_with_selection" callback function.
// Called via
//
//	[method@Gtk.IMContext.set_surrounding_with_selection] in response to the
//	[signal@Gtk.IMContext::retrieve-surrounding] signal to update the input
//	method’s idea of the context around the cursor. It is not necessary to
//	override this method even with input methods which implement
//	context-dependent behavior. The base implementation is sufficient for
//	[method@Gtk.IMContext.get_surrounding] to work.
func (x *IMContextClass) GetSetSurroundingWithSelection() func(*IMContext, string, int, int, int) {
	if x.xSetSurroundingWithSelection == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, TextVarp string, LenVarp int, CursorIndexVarp int, AnchorIndexVarp int)
	purego.RegisterFunc(&rawCallback, x.xSetSurroundingWithSelection)
	return func(ContextVar *IMContext, TextVar string, LenVar int, CursorIndexVar int, AnchorIndexVar int) {
		rawCallback(ContextVar.GoPointer(), TextVar, LenVar, CursorIndexVar, AnchorIndexVar)
	}
}

// OverrideGetSurroundingWithSelection sets the "get_surrounding_with_selection" callback function.
// Called via
//
//	[method@Gtk.IMContext.get_surrounding_with_selection] to update the
//	context around the cursor location. It is not necessary to override
//	this method even with input methods which implement context-dependent
//	behavior. The base implementation emits
//	[signal@Gtk.IMContext::retrieve-surrounding] and records the context
//	received by the subsequent invocation of [vfunc@Gtk.IMContext.get_surrounding].
func (x *IMContextClass) OverrideGetSurroundingWithSelection(cb func(*IMContext, *string, *int, *int) bool) {
	if cb == nil {
		x.xGetSurroundingWithSelection = 0
	} else {
		x.xGetSurroundingWithSelection = purego.NewCallback(func(ContextVarp uintptr, TextVarp *string, CursorIndexVarp *int, AnchorIndexVarp *int) bool {
			return cb(IMContextNewFromInternalPtr(ContextVarp), TextVarp, CursorIndexVarp, AnchorIndexVarp)
		})
	}
}

// GetGetSurroundingWithSelection gets the "get_surrounding_with_selection" callback function.
// Called via
//
//	[method@Gtk.IMContext.get_surrounding_with_selection] to update the
//	context around the cursor location. It is not necessary to override
//	this method even with input methods which implement context-dependent
//	behavior. The base implementation emits
//	[signal@Gtk.IMContext::retrieve-surrounding] and records the context
//	received by the subsequent invocation of [vfunc@Gtk.IMContext.get_surrounding].
func (x *IMContextClass) GetGetSurroundingWithSelection() func(*IMContext, *string, *int, *int) bool {
	if x.xGetSurroundingWithSelection == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, TextVarp *string, CursorIndexVarp *int, AnchorIndexVarp *int) bool
	purego.RegisterFunc(&rawCallback, x.xGetSurroundingWithSelection)
	return func(ContextVar *IMContext, TextVar *string, CursorIndexVar *int, AnchorIndexVar *int) bool {
		return rawCallback(ContextVar.GoPointer(), TextVar, CursorIndexVar, AnchorIndexVar)
	}
}

// OverrideActivateOsk sets the "activate_osk" callback function.
func (x *IMContextClass) OverrideActivateOsk(cb func(*IMContext)) {
	if cb == nil {
		x.xActivateOsk = 0
	} else {
		x.xActivateOsk = purego.NewCallback(func(ContextVarp uintptr) {
			cb(IMContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetActivateOsk gets the "activate_osk" callback function.
func (x *IMContextClass) GetActivateOsk() func(*IMContext) {
	if x.xActivateOsk == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xActivateOsk)
	return func(ContextVar *IMContext) {
		rawCallback(ContextVar.GoPointer())
	}
}

// OverrideActivateOskWithEvent sets the "activate_osk_with_event" callback function.
func (x *IMContextClass) OverrideActivateOskWithEvent(cb func(*IMContext, *gdk.Event) bool) {
	if cb == nil {
		x.xActivateOskWithEvent = 0
	} else {
		x.xActivateOskWithEvent = purego.NewCallback(func(ContextVarp uintptr, EventVarp uintptr) bool {
			return cb(IMContextNewFromInternalPtr(ContextVarp), gdk.EventNewFromInternalPtr(EventVarp))
		})
	}
}

// GetActivateOskWithEvent gets the "activate_osk_with_event" callback function.
func (x *IMContextClass) GetActivateOskWithEvent() func(*IMContext, *gdk.Event) bool {
	if x.xActivateOskWithEvent == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, EventVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xActivateOskWithEvent)
	return func(ContextVar *IMContext, EventVar *gdk.Event) bool {
		return rawCallback(ContextVar.GoPointer(), EventVar.GoPointer())
	}
}

// OverrideGtkReserved2 sets the "_gtk_reserved2" callback function.
func (x *IMContextClass) OverrideGtkReserved2(cb func()) {
	if cb == nil {
		x.xGtkReserved2 = 0
	} else {
		x.xGtkReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved2 gets the "_gtk_reserved2" callback function.
func (x *IMContextClass) GetGtkReserved2() func() {
	if x.xGtkReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved3 sets the "_gtk_reserved3" callback function.
func (x *IMContextClass) OverrideGtkReserved3(cb func()) {
	if cb == nil {
		x.xGtkReserved3 = 0
	} else {
		x.xGtkReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved3 gets the "_gtk_reserved3" callback function.
func (x *IMContextClass) GetGtkReserved3() func() {
	if x.xGtkReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved4 sets the "_gtk_reserved4" callback function.
func (x *IMContextClass) OverrideGtkReserved4(cb func()) {
	if cb == nil {
		x.xGtkReserved4 = 0
	} else {
		x.xGtkReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved4 gets the "_gtk_reserved4" callback function.
func (x *IMContextClass) GetGtkReserved4() func() {
	if x.xGtkReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved4)
	return func() {
		rawCallback()
	}
}

// The interface for GTK input methods.
//
// `GtkIMContext` is used by GTK text input widgets like `GtkText`
// to map from key events to Unicode character strings.
//
// An input method may consume multiple key events in sequence before finally
// outputting the composed result. This is called *preediting*, and an input
// method may provide feedback about this process by displaying the intermediate
// composition states as preedit text. To do so, the `GtkIMContext` will emit
// [signal@Gtk.IMContext::preedit-start], [signal@Gtk.IMContext::preedit-changed]
// and [signal@Gtk.IMContext::preedit-end] signals.
//
// For instance, the built-in GTK input method [class@Gtk.IMContextSimple]
// implements the input of arbitrary Unicode code points by holding down the
// &lt;kbd&gt;Control&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt; keys and then typing &lt;kbd&gt;u&lt;/kbd&gt;
// followed by the hexadecimal digits of the code point. When releasing the
// &lt;kbd&gt;Control&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt; keys, preediting ends and the
// character is inserted as text. For example,
//
//	Ctrl+Shift+u 2 0 A C
//
// results in the € sign.
//
// Additional input methods can be made available for use by GTK widgets as
// loadable modules. An input method module is a small shared library which
// provides a `GIOExtension` for the extension point named "gtk-im-module".
//
// To connect a widget to the users preferred input method, you should use
// [class@Gtk.IMMulticontext].
type IMContext struct {
	gobject.Object
}

var xIMContextGLibType func() types.GType

func IMContextGLibType() types.GType {
	return xIMContextGLibType()
}

func IMContextNewFromInternalPtr(ptr uintptr) *IMContext {
	cls := &IMContext{}
	cls.Ptr = ptr
	return cls
}

var xIMContextActivateOsk func(uintptr, uintptr) bool

// Requests the platform to show an on-screen keyboard for user input.
//
// This method will return %TRUE if this request was actually performed
// to the platform, other environmental factors may result in an on-screen
// keyboard effectively not showing up.
func (x *IMContext) ActivateOsk(EventVar *gdk.Event) bool {

	cret := xIMContextActivateOsk(x.GoPointer(), EventVar.GoPointer())

	return cret
}

var xIMContextDeleteSurrounding func(uintptr, int, int) bool

// Asks the widget that the input context is attached to delete
// characters around the cursor position by emitting the
// `::delete_surrounding` signal.
//
// Note that @offset and @n_chars are in characters not in bytes
// which differs from the usage other places in `GtkIMContext`.
//
// In order to use this function, you should first call
// [method@Gtk.IMContext.get_surrounding] to get the current context,
// and call this function immediately afterwards to make sure that you
// know what you are deleting. You should also account for the fact
// that even if the signal was handled, the input context might not
// have deleted all the characters that were requested to be deleted.
//
// This function is used by an input method that wants to make
// substitutions in the existing text in response to new input.
// It is not useful for applications.
func (x *IMContext) DeleteSurrounding(OffsetVar int, NCharsVar int) bool {

	cret := xIMContextDeleteSurrounding(x.GoPointer(), OffsetVar, NCharsVar)

	return cret
}

var xIMContextFilterKey func(uintptr, bool, uintptr, uintptr, uint32, uint, gdk.ModifierType, int) bool

// Allow an input method to forward key press and release events
// to another input method without necessarily having a `GdkEvent`
// available.
func (x *IMContext) FilterKey(PressVar bool, SurfaceVar *gdk.Surface, DeviceVar *gdk.Device, TimeVar uint32, KeycodeVar uint, StateVar gdk.ModifierType, GroupVar int) bool {

	cret := xIMContextFilterKey(x.GoPointer(), PressVar, SurfaceVar.GoPointer(), DeviceVar.GoPointer(), TimeVar, KeycodeVar, StateVar, GroupVar)

	return cret
}

var xIMContextFilterKeypress func(uintptr, uintptr) bool

// Allow an input method to internally handle key press and release
// events.
//
// If this function returns %TRUE, then no further processing
// should be done for this key event.
func (x *IMContext) FilterKeypress(EventVar *gdk.Event) bool {

	cret := xIMContextFilterKeypress(x.GoPointer(), EventVar.GoPointer())

	return cret
}

var xIMContextFocusIn func(uintptr)

// Notify the input method that the widget to which this
// input context corresponds has gained focus.
//
// The input method may, for example, change the displayed
// feedback to reflect this change.
func (x *IMContext) FocusIn() {

	xIMContextFocusIn(x.GoPointer())

}

var xIMContextFocusOut func(uintptr)

// Notify the input method that the widget to which this
// input context corresponds has lost focus.
//
// The input method may, for example, change the displayed
// feedback or reset the contexts state to reflect this change.
func (x *IMContext) FocusOut() {

	xIMContextFocusOut(x.GoPointer())

}

var xIMContextGetPreeditString func(uintptr, *string, **pango.AttrList, *int)

// Retrieve the current preedit string for the input context,
// and a list of attributes to apply to the string.
//
// This string should be displayed inserted at the insertion point.
func (x *IMContext) GetPreeditString(StrVar *string, AttrsVar **pango.AttrList, CursorPosVar *int) {

	xIMContextGetPreeditString(x.GoPointer(), StrVar, AttrsVar, CursorPosVar)

}

var xIMContextGetSurrounding func(uintptr, *string, *int) bool

// Retrieves context around the insertion point.
//
// Input methods typically want context in order to constrain input text
// based on existing text; this is important for languages such as Thai
// where only some sequences of characters are allowed.
//
// This function is implemented by emitting the
// [signal@Gtk.IMContext::retrieve-surrounding] signal on the input method;
// in response to this signal, a widget should provide as much context as
// is available, up to an entire paragraph, by calling
// [method@Gtk.IMContext.set_surrounding].
//
// Note that there is no obligation for a widget to respond to the
// `::retrieve-surrounding` signal, so input methods must be prepared to
// function without context.
func (x *IMContext) GetSurrounding(TextVar *string, CursorIndexVar *int) bool {

	cret := xIMContextGetSurrounding(x.GoPointer(), TextVar, CursorIndexVar)

	return cret
}

var xIMContextGetSurroundingWithSelection func(uintptr, *string, *int, *int) bool

// Retrieves context around the insertion point.
//
// Input methods typically want context in order to constrain input
// text based on existing text; this is important for languages such
// as Thai where only some sequences of characters are allowed.
//
// This function is implemented by emitting the
// [signal@Gtk.IMContext::retrieve-surrounding] signal on the input method;
// in response to this signal, a widget should provide as much context as
// is available, up to an entire paragraph, by calling
// [method@Gtk.IMContext.set_surrounding_with_selection].
//
// Note that there is no obligation for a widget to respond to the
// `::retrieve-surrounding` signal, so input methods must be prepared to
// function without context.
func (x *IMContext) GetSurroundingWithSelection(TextVar *string, CursorIndexVar *int, AnchorIndexVar *int) bool {

	cret := xIMContextGetSurroundingWithSelection(x.GoPointer(), TextVar, CursorIndexVar, AnchorIndexVar)

	return cret
}

var xIMContextReset func(uintptr)

// Notify the input method that a change such as a change in cursor
// position has been made.
//
// This will typically cause the input method to clear the preedit state.
func (x *IMContext) Reset() {

	xIMContextReset(x.GoPointer())

}

var xIMContextSetClientWidget func(uintptr, uintptr)

// Set the client widget for the input context.
//
// This is the `GtkWidget` holding the input focus. This widget is
// used in order to correctly position status windows, and may
// also be used for purposes internal to the input method.
func (x *IMContext) SetClientWidget(WidgetVar *Widget) {

	xIMContextSetClientWidget(x.GoPointer(), WidgetVar.GoPointer())

}

var xIMContextSetCursorLocation func(uintptr, *gdk.Rectangle)

// Notify the input method that a change in cursor
// position has been made.
//
// The location is relative to the client widget.
func (x *IMContext) SetCursorLocation(AreaVar *gdk.Rectangle) {

	xIMContextSetCursorLocation(x.GoPointer(), AreaVar)

}

var xIMContextSetSurrounding func(uintptr, string, int, int)

// Sets surrounding context around the insertion point and preedit
// string.
//
// This function is expected to be called in response to the
// [signal@Gtk.IMContext::retrieve-surrounding] signal, and will
// likely have no effect if called at other times.
func (x *IMContext) SetSurrounding(TextVar string, LenVar int, CursorIndexVar int) {

	xIMContextSetSurrounding(x.GoPointer(), TextVar, LenVar, CursorIndexVar)

}

var xIMContextSetSurroundingWithSelection func(uintptr, string, int, int, int)

// Sets surrounding context around the insertion point and preedit
// string. This function is expected to be called in response to the
// [signal@Gtk.IMContext::retrieve_surrounding] signal, and will likely
// have no effect if called at other times.
func (x *IMContext) SetSurroundingWithSelection(TextVar string, LenVar int, CursorIndexVar int, AnchorIndexVar int) {

	xIMContextSetSurroundingWithSelection(x.GoPointer(), TextVar, LenVar, CursorIndexVar, AnchorIndexVar)

}

var xIMContextSetUsePreedit func(uintptr, bool)

// Sets whether the IM context should use the preedit string
// to display feedback.
//
// If @use_preedit is %FALSE (default is %TRUE), then the IM context
// may use some other method to display feedback, such as displaying
// it in a child of the root window.
func (x *IMContext) SetUsePreedit(UsePreeditVar bool) {

	xIMContextSetUsePreedit(x.GoPointer(), UsePreeditVar)

}

func (c *IMContext) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *IMContext) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The ::commit signal is emitted when a complete input sequence
// has been entered by the user.
//
// If the commit comes after a preediting sequence, the
// ::commit signal is emitted after ::preedit-end.
//
// This can be a single character immediately after a key press or
// the final result of preediting.
func (x *IMContext) ConnectCommit(cb *func(IMContext, string)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "commit", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, StrVarp string) {
		fa := IMContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StrVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "commit", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The ::delete-surrounding signal is emitted when the input method
// needs to delete all or part of the context surrounding the cursor.
func (x *IMContext) ConnectDeleteSurrounding(cb *func(IMContext, int, int) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "delete-surrounding", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, OffsetVarp int, NCharsVarp int) bool {
		fa := IMContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, OffsetVarp, NCharsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "delete-surrounding", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The ::preedit-changed signal is emitted whenever the preedit sequence
// currently being entered has changed.
//
// It is also emitted at the end of a preedit sequence, in which case
// [method@Gtk.IMContext.get_preedit_string] returns the empty string.
func (x *IMContext) ConnectPreeditChanged(cb *func(IMContext)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := IMContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The ::preedit-end signal is emitted when a preediting sequence
// has been completed or canceled.
func (x *IMContext) ConnectPreeditEnd(cb *func(IMContext)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "preedit-end", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := IMContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "preedit-end", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The ::preedit-start signal is emitted when a new preediting sequence
// starts.
func (x *IMContext) ConnectPreeditStart(cb *func(IMContext)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "preedit-start", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := IMContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "preedit-start", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The ::retrieve-surrounding signal is emitted when the input method
// requires the context surrounding the cursor.
//
// The callback should set the input method surrounding context by
// calling the [method@Gtk.IMContext.set_surrounding] method.
func (x *IMContext) ConnectRetrieveSurrounding(cb *func(IMContext) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "retrieve-surrounding", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) bool {
		fa := IMContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "retrieve-surrounding", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xIMContextGLibType, libs, "gtk_im_context_get_type")

	core.PuregoSafeRegister(&xIMContextActivateOsk, libs, "gtk_im_context_activate_osk")
	core.PuregoSafeRegister(&xIMContextDeleteSurrounding, libs, "gtk_im_context_delete_surrounding")
	core.PuregoSafeRegister(&xIMContextFilterKey, libs, "gtk_im_context_filter_key")
	core.PuregoSafeRegister(&xIMContextFilterKeypress, libs, "gtk_im_context_filter_keypress")
	core.PuregoSafeRegister(&xIMContextFocusIn, libs, "gtk_im_context_focus_in")
	core.PuregoSafeRegister(&xIMContextFocusOut, libs, "gtk_im_context_focus_out")
	core.PuregoSafeRegister(&xIMContextGetPreeditString, libs, "gtk_im_context_get_preedit_string")
	core.PuregoSafeRegister(&xIMContextGetSurrounding, libs, "gtk_im_context_get_surrounding")
	core.PuregoSafeRegister(&xIMContextGetSurroundingWithSelection, libs, "gtk_im_context_get_surrounding_with_selection")
	core.PuregoSafeRegister(&xIMContextReset, libs, "gtk_im_context_reset")
	core.PuregoSafeRegister(&xIMContextSetClientWidget, libs, "gtk_im_context_set_client_widget")
	core.PuregoSafeRegister(&xIMContextSetCursorLocation, libs, "gtk_im_context_set_cursor_location")
	core.PuregoSafeRegister(&xIMContextSetSurrounding, libs, "gtk_im_context_set_surrounding")
	core.PuregoSafeRegister(&xIMContextSetSurroundingWithSelection, libs, "gtk_im_context_set_surrounding_with_selection")
	core.PuregoSafeRegister(&xIMContextSetUsePreedit, libs, "gtk_im_context_set_use_preedit")

}
