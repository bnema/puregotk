// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

type TextViewClass struct {
	_ structs.HostLayout

	ParentClass WidgetClass

	xMoveCursor uintptr

	xSetAnchor uintptr

	xInsertAtCursor uintptr

	xDeleteFromCursor uintptr

	xBackspace uintptr

	xCutClipboard uintptr

	xCopyClipboard uintptr

	xPasteClipboard uintptr

	xToggleOverwrite uintptr

	xCreateBuffer uintptr

	xSnapshotLayer uintptr

	xExtendSelection uintptr

	xInsertEmoji uintptr

	Padding [8]uintptr
}

func (x *TextViewClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideMoveCursor sets the "move_cursor" callback function.
// The class handler for the `GtkTextView::move-cursor`
//
//	keybinding signal.
func (x *TextViewClass) OverrideMoveCursor(cb func(*TextView, MovementStep, int, bool)) {
	if cb == nil {
		x.xMoveCursor = 0
	} else {
		x.xMoveCursor = purego.NewCallback(func(TextViewVarp uintptr, StepVarp MovementStep, CountVarp int, ExtendSelectionVarp bool) {
			cb(TextViewNewFromInternalPtr(TextViewVarp), StepVarp, CountVarp, ExtendSelectionVarp)
		})
	}
}

// GetMoveCursor gets the "move_cursor" callback function.
// The class handler for the `GtkTextView::move-cursor`
//
//	keybinding signal.
func (x *TextViewClass) GetMoveCursor() func(*TextView, MovementStep, int, bool) {
	if x.xMoveCursor == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr, StepVarp MovementStep, CountVarp int, ExtendSelectionVarp bool)
	purego.RegisterFunc(&rawCallback, x.xMoveCursor)
	return func(TextViewVar *TextView, StepVar MovementStep, CountVar int, ExtendSelectionVar bool) {
		rawCallback(TextViewVar.GoPointer(), StepVar, CountVar, ExtendSelectionVar)
	}
}

// OverrideSetAnchor sets the "set_anchor" callback function.
// The class handler for the `GtkTextView::set-anchor`
//
//	keybinding signal.
func (x *TextViewClass) OverrideSetAnchor(cb func(*TextView)) {
	if cb == nil {
		x.xSetAnchor = 0
	} else {
		x.xSetAnchor = purego.NewCallback(func(TextViewVarp uintptr) {
			cb(TextViewNewFromInternalPtr(TextViewVarp))
		})
	}
}

// GetSetAnchor gets the "set_anchor" callback function.
// The class handler for the `GtkTextView::set-anchor`
//
//	keybinding signal.
func (x *TextViewClass) GetSetAnchor() func(*TextView) {
	if x.xSetAnchor == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSetAnchor)
	return func(TextViewVar *TextView) {
		rawCallback(TextViewVar.GoPointer())
	}
}

// OverrideInsertAtCursor sets the "insert_at_cursor" callback function.
// The class handler for the `GtkTextView::insert-at-cursor`
//
//	keybinding signal.
func (x *TextViewClass) OverrideInsertAtCursor(cb func(*TextView, string)) {
	if cb == nil {
		x.xInsertAtCursor = 0
	} else {
		x.xInsertAtCursor = purego.NewCallback(func(TextViewVarp uintptr, StrVarp string) {
			cb(TextViewNewFromInternalPtr(TextViewVarp), StrVarp)
		})
	}
}

// GetInsertAtCursor gets the "insert_at_cursor" callback function.
// The class handler for the `GtkTextView::insert-at-cursor`
//
//	keybinding signal.
func (x *TextViewClass) GetInsertAtCursor() func(*TextView, string) {
	if x.xInsertAtCursor == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr, StrVarp string)
	purego.RegisterFunc(&rawCallback, x.xInsertAtCursor)
	return func(TextViewVar *TextView, StrVar string) {
		rawCallback(TextViewVar.GoPointer(), StrVar)
	}
}

// OverrideDeleteFromCursor sets the "delete_from_cursor" callback function.
// The class handler for the `GtkTextView::delete-from-cursor`
//
//	keybinding signal.
func (x *TextViewClass) OverrideDeleteFromCursor(cb func(*TextView, DeleteType, int)) {
	if cb == nil {
		x.xDeleteFromCursor = 0
	} else {
		x.xDeleteFromCursor = purego.NewCallback(func(TextViewVarp uintptr, TypeVarp DeleteType, CountVarp int) {
			cb(TextViewNewFromInternalPtr(TextViewVarp), TypeVarp, CountVarp)
		})
	}
}

// GetDeleteFromCursor gets the "delete_from_cursor" callback function.
// The class handler for the `GtkTextView::delete-from-cursor`
//
//	keybinding signal.
func (x *TextViewClass) GetDeleteFromCursor() func(*TextView, DeleteType, int) {
	if x.xDeleteFromCursor == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr, TypeVarp DeleteType, CountVarp int)
	purego.RegisterFunc(&rawCallback, x.xDeleteFromCursor)
	return func(TextViewVar *TextView, TypeVar DeleteType, CountVar int) {
		rawCallback(TextViewVar.GoPointer(), TypeVar, CountVar)
	}
}

// OverrideBackspace sets the "backspace" callback function.
// The class handler for the `GtkTextView::backspace`
//
//	keybinding signal.
func (x *TextViewClass) OverrideBackspace(cb func(*TextView)) {
	if cb == nil {
		x.xBackspace = 0
	} else {
		x.xBackspace = purego.NewCallback(func(TextViewVarp uintptr) {
			cb(TextViewNewFromInternalPtr(TextViewVarp))
		})
	}
}

// GetBackspace gets the "backspace" callback function.
// The class handler for the `GtkTextView::backspace`
//
//	keybinding signal.
func (x *TextViewClass) GetBackspace() func(*TextView) {
	if x.xBackspace == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xBackspace)
	return func(TextViewVar *TextView) {
		rawCallback(TextViewVar.GoPointer())
	}
}

// OverrideCutClipboard sets the "cut_clipboard" callback function.
// The class handler for the `GtkTextView::cut-clipboard`
//
//	keybinding signal
func (x *TextViewClass) OverrideCutClipboard(cb func(*TextView)) {
	if cb == nil {
		x.xCutClipboard = 0
	} else {
		x.xCutClipboard = purego.NewCallback(func(TextViewVarp uintptr) {
			cb(TextViewNewFromInternalPtr(TextViewVarp))
		})
	}
}

// GetCutClipboard gets the "cut_clipboard" callback function.
// The class handler for the `GtkTextView::cut-clipboard`
//
//	keybinding signal
func (x *TextViewClass) GetCutClipboard() func(*TextView) {
	if x.xCutClipboard == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCutClipboard)
	return func(TextViewVar *TextView) {
		rawCallback(TextViewVar.GoPointer())
	}
}

// OverrideCopyClipboard sets the "copy_clipboard" callback function.
// The class handler for the `GtkTextView::copy-clipboard`
//
//	keybinding signal.
func (x *TextViewClass) OverrideCopyClipboard(cb func(*TextView)) {
	if cb == nil {
		x.xCopyClipboard = 0
	} else {
		x.xCopyClipboard = purego.NewCallback(func(TextViewVarp uintptr) {
			cb(TextViewNewFromInternalPtr(TextViewVarp))
		})
	}
}

// GetCopyClipboard gets the "copy_clipboard" callback function.
// The class handler for the `GtkTextView::copy-clipboard`
//
//	keybinding signal.
func (x *TextViewClass) GetCopyClipboard() func(*TextView) {
	if x.xCopyClipboard == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCopyClipboard)
	return func(TextViewVar *TextView) {
		rawCallback(TextViewVar.GoPointer())
	}
}

// OverridePasteClipboard sets the "paste_clipboard" callback function.
// The class handler for the `GtkTextView::paste-clipboard`
//
//	keybinding signal.
func (x *TextViewClass) OverridePasteClipboard(cb func(*TextView)) {
	if cb == nil {
		x.xPasteClipboard = 0
	} else {
		x.xPasteClipboard = purego.NewCallback(func(TextViewVarp uintptr) {
			cb(TextViewNewFromInternalPtr(TextViewVarp))
		})
	}
}

// GetPasteClipboard gets the "paste_clipboard" callback function.
// The class handler for the `GtkTextView::paste-clipboard`
//
//	keybinding signal.
func (x *TextViewClass) GetPasteClipboard() func(*TextView) {
	if x.xPasteClipboard == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPasteClipboard)
	return func(TextViewVar *TextView) {
		rawCallback(TextViewVar.GoPointer())
	}
}

// OverrideToggleOverwrite sets the "toggle_overwrite" callback function.
// The class handler for the `GtkTextView::toggle-overwrite`
//
//	keybinding signal.
func (x *TextViewClass) OverrideToggleOverwrite(cb func(*TextView)) {
	if cb == nil {
		x.xToggleOverwrite = 0
	} else {
		x.xToggleOverwrite = purego.NewCallback(func(TextViewVarp uintptr) {
			cb(TextViewNewFromInternalPtr(TextViewVarp))
		})
	}
}

// GetToggleOverwrite gets the "toggle_overwrite" callback function.
// The class handler for the `GtkTextView::toggle-overwrite`
//
//	keybinding signal.
func (x *TextViewClass) GetToggleOverwrite() func(*TextView) {
	if x.xToggleOverwrite == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xToggleOverwrite)
	return func(TextViewVar *TextView) {
		rawCallback(TextViewVar.GoPointer())
	}
}

// OverrideCreateBuffer sets the "create_buffer" callback function.
// The create_buffer vfunc is called to create a `GtkTextBuffer`
//
//	for the text view. The default implementation is to just call
//	gtk_text_buffer_new().
func (x *TextViewClass) OverrideCreateBuffer(cb func(*TextView) *TextBuffer) {
	if cb == nil {
		x.xCreateBuffer = 0
	} else {
		x.xCreateBuffer = purego.NewCallback(func(TextViewVarp uintptr) uintptr {
			ret := cb(TextViewNewFromInternalPtr(TextViewVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetCreateBuffer gets the "create_buffer" callback function.
// The create_buffer vfunc is called to create a `GtkTextBuffer`
//
//	for the text view. The default implementation is to just call
//	gtk_text_buffer_new().
func (x *TextViewClass) GetCreateBuffer() func(*TextView) *TextBuffer {
	if x.xCreateBuffer == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xCreateBuffer)
	return func(TextViewVar *TextView) *TextBuffer {
		rawRet := rawCallback(TextViewVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &TextBuffer{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideSnapshotLayer sets the "snapshot_layer" callback function.
// The snapshot_layer vfunc is called before and after the text
//
//	view is drawing its own text. Applications can override this vfunc
//	in a subclass to draw customized content underneath or above the
//	text. In the %GTK_TEXT_VIEW_LAYER_BELOW_TEXT and %GTK_TEXT_VIEW_LAYER_ABOVE_TEXT
//	layers the drawing is done in the buffer coordinate space.
func (x *TextViewClass) OverrideSnapshotLayer(cb func(*TextView, TextViewLayer, *Snapshot)) {
	if cb == nil {
		x.xSnapshotLayer = 0
	} else {
		x.xSnapshotLayer = purego.NewCallback(func(TextViewVarp uintptr, LayerVarp TextViewLayer, SnapshotVarp uintptr) {
			cb(TextViewNewFromInternalPtr(TextViewVarp), LayerVarp, SnapshotNewFromInternalPtr(SnapshotVarp))
		})
	}
}

// GetSnapshotLayer gets the "snapshot_layer" callback function.
// The snapshot_layer vfunc is called before and after the text
//
//	view is drawing its own text. Applications can override this vfunc
//	in a subclass to draw customized content underneath or above the
//	text. In the %GTK_TEXT_VIEW_LAYER_BELOW_TEXT and %GTK_TEXT_VIEW_LAYER_ABOVE_TEXT
//	layers the drawing is done in the buffer coordinate space.
func (x *TextViewClass) GetSnapshotLayer() func(*TextView, TextViewLayer, *Snapshot) {
	if x.xSnapshotLayer == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr, LayerVarp TextViewLayer, SnapshotVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSnapshotLayer)
	return func(TextViewVar *TextView, LayerVar TextViewLayer, SnapshotVar *Snapshot) {
		rawCallback(TextViewVar.GoPointer(), LayerVar, SnapshotVar.GoPointer())
	}
}

// OverrideExtendSelection sets the "extend_selection" callback function.
// The class handler for the `GtkTextView::extend-selection` signal.
func (x *TextViewClass) OverrideExtendSelection(cb func(*TextView, TextExtendSelection, *TextIter, *TextIter, *TextIter) bool) {
	if cb == nil {
		x.xExtendSelection = 0
	} else {
		x.xExtendSelection = purego.NewCallback(func(TextViewVarp uintptr, GranularityVarp TextExtendSelection, LocationVarp *TextIter, StartVarp *TextIter, EndVarp *TextIter) bool {
			return cb(TextViewNewFromInternalPtr(TextViewVarp), GranularityVarp, LocationVarp, StartVarp, EndVarp)
		})
	}
}

// GetExtendSelection gets the "extend_selection" callback function.
// The class handler for the `GtkTextView::extend-selection` signal.
func (x *TextViewClass) GetExtendSelection() func(*TextView, TextExtendSelection, *TextIter, *TextIter, *TextIter) bool {
	if x.xExtendSelection == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr, GranularityVarp TextExtendSelection, LocationVarp *TextIter, StartVarp *TextIter, EndVarp *TextIter) bool
	purego.RegisterFunc(&rawCallback, x.xExtendSelection)
	return func(TextViewVar *TextView, GranularityVar TextExtendSelection, LocationVar *TextIter, StartVar *TextIter, EndVar *TextIter) bool {
		return rawCallback(TextViewVar.GoPointer(), GranularityVar, LocationVar, StartVar, EndVar)
	}
}

// OverrideInsertEmoji sets the "insert_emoji" callback function.
// The class handler for the `GtkTextView::insert-emoji` signal.
func (x *TextViewClass) OverrideInsertEmoji(cb func(*TextView)) {
	if cb == nil {
		x.xInsertEmoji = 0
	} else {
		x.xInsertEmoji = purego.NewCallback(func(TextViewVarp uintptr) {
			cb(TextViewNewFromInternalPtr(TextViewVarp))
		})
	}
}

// GetInsertEmoji gets the "insert_emoji" callback function.
// The class handler for the `GtkTextView::insert-emoji` signal.
func (x *TextViewClass) GetInsertEmoji() func(*TextView) {
	if x.xInsertEmoji == 0 {
		return nil
	}
	var rawCallback func(TextViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xInsertEmoji)
	return func(TextViewVar *TextView) {
		rawCallback(TextViewVar.GoPointer())
	}
}

type TextViewPrivate struct {
	_ structs.HostLayout
}

func (x *TextViewPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

const (
	// The priority at which the text view validates onscreen lines
	// in an idle job in the background.
	TEXT_VIEW_PRIORITY_VALIDATE int = 125
)

// Granularity types that extend the text selection. Use the
// `GtkTextView::extend-selection` signal to customize the selection.
type TextExtendSelection int

var xTextExtendSelectionGLibType func() types.GType

func TextExtendSelectionGLibType() types.GType {
	return xTextExtendSelectionGLibType()
}

const (

	// Selects the current word. It is triggered by
	//   a double-click for example.
	TextExtendSelectionWordValue TextExtendSelection = 0
	// Selects the current line. It is triggered by
	//   a triple-click for example.
	TextExtendSelectionLineValue TextExtendSelection = 1
)

// Used to reference the layers of `GtkTextView` for the purpose of customized
// drawing with the ::snapshot_layer vfunc.
type TextViewLayer int

var xTextViewLayerGLibType func() types.GType

func TextViewLayerGLibType() types.GType {
	return xTextViewLayerGLibType()
}

const (

	// The layer rendered below the text (but above the background).
	TextViewLayerBelowTextValue TextViewLayer = 0
	// The layer rendered above the text.
	TextViewLayerAboveTextValue TextViewLayer = 1
)

// Used to reference the parts of `GtkTextView`.
type TextWindowType int

var xTextWindowTypeGLibType func() types.GType

func TextWindowTypeGLibType() types.GType {
	return xTextWindowTypeGLibType()
}

const (

	// Window that floats over scrolling areas.
	TextWindowWidgetValue TextWindowType = 1
	// Scrollable text window.
	TextWindowTextValue TextWindowType = 2
	// Left side border window.
	TextWindowLeftValue TextWindowType = 3
	// Right side border window.
	TextWindowRightValue TextWindowType = 4
	// Top border window.
	TextWindowTopValue TextWindowType = 5
	// Bottom border window.
	TextWindowBottomValue TextWindowType = 6
)

// Displays the contents of a [class@Gtk.TextBuffer].
//
// &lt;picture&gt;
//
//	&lt;source srcset="multiline-text-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkTextView" src="multiline-text.png"&gt;
//
// &lt;/picture&gt;
//
// You may wish to begin by reading the [conceptual overview](section-text-widget.html),
// which gives an overview of all the objects and data types related to the
// text widget and how they work together.
//
// ## Shortcuts and Gestures
//
// `GtkTextView` supports the following keyboard shortcuts:
//
//   - &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;F10&lt;/kbd&gt; or &lt;kbd&gt;Menu&lt;/kbd&gt; opens the context menu.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Z&lt;/kbd&gt; undoes the last modification.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Y&lt;/kbd&gt; or &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Z&lt;/kbd&gt;
//     redoes the last undone modification.
//   - &lt;kbd&gt;Clear&lt;/kbd&gt; clears the content.
//
// Additionally, the following signals have default keybindings:
//
// - [signal@Gtk.TextView::backspace]
// - [signal@Gtk.TextView::copy-clipboard]
// - [signal@Gtk.TextView::cut-clipboard]
// - [signal@Gtk.TextView::delete-from-cursor]
// - [signal@Gtk.TextView::insert-emoji]
// - [signal@Gtk.TextView::move-cursor]
// - [signal@Gtk.TextView::paste-clipboard]
// - [signal@Gtk.TextView::select-all]
// - [signal@Gtk.TextView::toggle-cursor-visible]
// - [signal@Gtk.TextView::toggle-overwrite]
//
// ## Actions
//
// `GtkTextView` defines a set of built-in actions:
//
//   - `clipboard.copy` copies the contents to the clipboard.
//   - `clipboard.cut` copies the contents to the clipboard and deletes it from
//     the widget.
//   - `clipboard.paste` inserts the contents of the clipboard into the widget.
//   - `menu.popup` opens the context menu.
//   - `misc.insert-emoji` opens the Emoji chooser.
//   - `selection.delete` deletes the current selection.
//   - `selection.select-all` selects all of the widgets content.
//   - `text.redo` redoes the last change to the contents.
//   - `text.undo` undoes the last change to the contents.
//   - `text.clear` clears the content.
//
// ## CSS nodes
//
// ```
// textview.view
// ├── border.top
// ├── border.left
// ├── text
// │   ╰── [selection]
// ├── border.right
// ├── border.bottom
// ╰── [window.popup]
// ```
//
// `GtkTextView` has a main css node with name textview and style class .view,
// and subnodes for each of the border windows, and the main text area,
// with names border and text, respectively. The border nodes each get
// one of the style classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode
// of the main node.
//
// ## Accessibility
//
// `GtkTextView` uses the [enum@Gtk.AccessibleRole.text_box] role.
type TextView struct {
	Widget
}

var xTextViewGLibType func() types.GType

func TextViewGLibType() types.GType {
	return xTextViewGLibType()
}

func TextViewNewFromInternalPtr(ptr uintptr) *TextView {
	cls := &TextView{}
	cls.Ptr = ptr
	return cls
}

var xNewTextView func() uintptr

// Creates a new `GtkTextView`.
//
// If you don’t call [method@Gtk.TextView.set_buffer] before using the
// text view, an empty default buffer will be created for you. Get the
// buffer with [method@Gtk.TextView.get_buffer]. If you want to specify
// your own buffer, consider [ctor@Gtk.TextView.new_with_buffer].
func NewTextView() *TextView {
	var cls *TextView

	cret := xNewTextView()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextView{}
	cls.Ptr = cret
	return cls
}

var xNewTextViewWithBuffer func(uintptr) uintptr

// Creates a new `GtkTextView` widget displaying the buffer @buffer.
//
// One buffer can be shared among many widgets. @buffer may be %NULL
// to create a default buffer, in which case this function is equivalent
// to [ctor@Gtk.TextView.new]. The text view adds its own reference count
// to the buffer; it does not take over an existing reference.
func NewTextViewWithBuffer(BufferVar *TextBuffer) *TextView {
	var cls *TextView

	cret := xNewTextViewWithBuffer(BufferVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextView{}
	cls.Ptr = cret
	return cls
}

var xTextViewAddChildAtAnchor func(uintptr, uintptr, uintptr)

// Adds a child widget in the text buffer, at the given @anchor.
func (x *TextView) AddChildAtAnchor(ChildVar *Widget, AnchorVar *TextChildAnchor) {

	xTextViewAddChildAtAnchor(x.GoPointer(), ChildVar.GoPointer(), AnchorVar.GoPointer())

}

var xTextViewAddOverlay func(uintptr, uintptr, int, int)

// Adds @child at a fixed coordinate in the `GtkTextView`'s text window.
//
// The @xpos and @ypos must be in buffer coordinates (see
// [method@Gtk.TextView.get_iter_location] to convert to
// buffer coordinates).
//
// @child will scroll with the text view.
//
// If instead you want a widget that will not move with the
// `GtkTextView` contents see `GtkOverlay`.
func (x *TextView) AddOverlay(ChildVar *Widget, XposVar int, YposVar int) {

	xTextViewAddOverlay(x.GoPointer(), ChildVar.GoPointer(), XposVar, YposVar)

}

var xTextViewBackwardDisplayLine func(uintptr, *TextIter) bool

// Moves the given @iter backward by one display (wrapped) line.
//
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the `GtkTextBuffer`.
func (x *TextView) BackwardDisplayLine(IterVar *TextIter) bool {

	cret := xTextViewBackwardDisplayLine(x.GoPointer(), IterVar)
	return cret
}

var xTextViewBackwardDisplayLineStart func(uintptr, *TextIter) bool

// Moves the given @iter backward to the next display line start.
//
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the `GtkTextBuffer`.
func (x *TextView) BackwardDisplayLineStart(IterVar *TextIter) bool {

	cret := xTextViewBackwardDisplayLineStart(x.GoPointer(), IterVar)
	return cret
}

var xTextViewBufferToWindowCoords func(uintptr, TextWindowType, int, int, *int, *int)

// Converts buffer coordinates to window coordinates.
func (x *TextView) BufferToWindowCoords(WinVar TextWindowType, BufferXVar int, BufferYVar int, WindowXVar *int, WindowYVar *int) {

	xTextViewBufferToWindowCoords(x.GoPointer(), WinVar, BufferXVar, BufferYVar, WindowXVar, WindowYVar)

}

var xTextViewForwardDisplayLine func(uintptr, *TextIter) bool

// Moves the given @iter forward by one display (wrapped) line.
//
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the `GtkTextBuffer`.
func (x *TextView) ForwardDisplayLine(IterVar *TextIter) bool {

	cret := xTextViewForwardDisplayLine(x.GoPointer(), IterVar)
	return cret
}

var xTextViewForwardDisplayLineEnd func(uintptr, *TextIter) bool

// Moves the given @iter forward to the next display line end.
//
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the `GtkTextBuffer`.
func (x *TextView) ForwardDisplayLineEnd(IterVar *TextIter) bool {

	cret := xTextViewForwardDisplayLineEnd(x.GoPointer(), IterVar)
	return cret
}

var xTextViewGetAcceptsTab func(uintptr) bool

// Returns whether pressing the &lt;kbd&gt;Tab&lt;/kbd&gt; key inserts a tab characters.
//
// See [method@Gtk.TextView.set_accepts_tab].
func (x *TextView) GetAcceptsTab() bool {

	cret := xTextViewGetAcceptsTab(x.GoPointer())
	return cret
}

var xTextViewGetBottomMargin func(uintptr) int

// Gets the bottom margin for text in the @text_view.
func (x *TextView) GetBottomMargin() int {

	cret := xTextViewGetBottomMargin(x.GoPointer())
	return cret
}

var xTextViewGetBuffer func(uintptr) uintptr

// Returns the `GtkTextBuffer` being displayed by this text view.
//
// The reference count on the buffer is not incremented; the caller
// of this function won’t own a new reference.
func (x *TextView) GetBuffer() *TextBuffer {
	var cls *TextBuffer

	cret := xTextViewGetBuffer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextBuffer{}
	cls.Ptr = cret
	return cls
}

var xTextViewGetCursorLocations func(uintptr, *TextIter, *gdk.Rectangle, *gdk.Rectangle)

// Determine the positions of the strong and weak cursors if the
// insertion point is at @iter.
//
// The position of each cursor is stored as a zero-width rectangle.
// The strong cursor location is the location where characters of
// the directionality equal to the base direction of the paragraph
// are inserted. The weak cursor location is the location where
// characters of the directionality opposite to the base direction
// of the paragraph are inserted.
//
// If @iter is %NULL, the actual cursor position is used.
//
// Note that if @iter happens to be the actual cursor position, and
// there is currently an IM preedit sequence being entered, the
// returned locations will be adjusted to account for the preedit
// cursor’s offset within the preedit sequence.
//
// The rectangle position is in buffer coordinates; use
// [method@Gtk.TextView.buffer_to_window_coords] to convert these
// coordinates to coordinates for one of the windows in the text view.
func (x *TextView) GetCursorLocations(IterVar *TextIter, StrongVar *gdk.Rectangle, WeakVar *gdk.Rectangle) {

	xTextViewGetCursorLocations(x.GoPointer(), IterVar, StrongVar, WeakVar)

}

var xTextViewGetCursorVisible func(uintptr) bool

// Find out whether the cursor should be displayed.
func (x *TextView) GetCursorVisible() bool {

	cret := xTextViewGetCursorVisible(x.GoPointer())
	return cret
}

var xTextViewGetEditable func(uintptr) bool

// Returns the default editability of the `GtkTextView`.
//
// Tags in the buffer may override this setting for some ranges of text.
func (x *TextView) GetEditable() bool {

	cret := xTextViewGetEditable(x.GoPointer())
	return cret
}

var xTextViewGetExtraMenu func(uintptr) uintptr

// Gets the menu model that gets added to the context menu
// or %NULL if none has been set.
func (x *TextView) GetExtraMenu() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xTextViewGetExtraMenu(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xTextViewGetGutter func(uintptr, TextWindowType) uintptr

// Gets a `GtkWidget` that has previously been set as gutter.
//
// See [method@Gtk.TextView.set_gutter].
//
// @win must be one of %GTK_TEXT_WINDOW_LEFT, %GTK_TEXT_WINDOW_RIGHT,
// %GTK_TEXT_WINDOW_TOP, or %GTK_TEXT_WINDOW_BOTTOM.
func (x *TextView) GetGutter(WinVar TextWindowType) *Widget {
	var cls *Widget

	cret := xTextViewGetGutter(x.GoPointer(), WinVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xTextViewGetIndent func(uintptr) int

// Gets the default indentation of paragraphs in @text_view.
//
// Tags in the view’s buffer may override the default.
// The indentation may be negative.
func (x *TextView) GetIndent() int {

	cret := xTextViewGetIndent(x.GoPointer())
	return cret
}

var xTextViewGetInputHints func(uintptr) InputHints

// Gets the `input-hints` of the `GtkTextView`.
func (x *TextView) GetInputHints() InputHints {

	cret := xTextViewGetInputHints(x.GoPointer())
	return cret
}

var xTextViewGetInputPurpose func(uintptr) InputPurpose

// Gets the `input-purpose` of the `GtkTextView`.
func (x *TextView) GetInputPurpose() InputPurpose {

	cret := xTextViewGetInputPurpose(x.GoPointer())
	return cret
}

var xTextViewGetIterAtLocation func(uintptr, *TextIter, int, int) bool

// Retrieves the iterator at buffer coordinates @x and @y.
//
// Buffer coordinates are coordinates for the entire buffer, not just
// the currently-displayed portion. If you have coordinates from an
// event, you have to convert those to buffer coordinates with
// [method@Gtk.TextView.window_to_buffer_coords].
func (x *TextView) GetIterAtLocation(IterVar *TextIter, XVar int, YVar int) bool {

	cret := xTextViewGetIterAtLocation(x.GoPointer(), IterVar, XVar, YVar)
	return cret
}

var xTextViewGetIterAtPosition func(uintptr, *TextIter, *int, int, int) bool

// Retrieves the iterator pointing to the character at buffer
// coordinates @x and @y.
//
// Buffer coordinates are coordinates for the entire buffer, not just
// the currently-displayed portion. If you have coordinates from an event,
// you have to convert those to buffer coordinates with
// [method@Gtk.TextView.window_to_buffer_coords].
//
// Note that this is different from [method@Gtk.TextView.get_iter_at_location],
// which returns cursor locations, i.e. positions between characters.
func (x *TextView) GetIterAtPosition(IterVar *TextIter, TrailingVar *int, XVar int, YVar int) bool {

	cret := xTextViewGetIterAtPosition(x.GoPointer(), IterVar, TrailingVar, XVar, YVar)
	return cret
}

var xTextViewGetIterLocation func(uintptr, *TextIter, *gdk.Rectangle)

// Gets a rectangle which roughly contains the character at @iter.
//
// The rectangle position is in buffer coordinates; use
// [method@Gtk.TextView.buffer_to_window_coords] to convert these
// coordinates to coordinates for one of the windows in the text view.
func (x *TextView) GetIterLocation(IterVar *TextIter, LocationVar *gdk.Rectangle) {

	xTextViewGetIterLocation(x.GoPointer(), IterVar, LocationVar)

}

var xTextViewGetJustification func(uintptr) Justification

// Gets the default justification of paragraphs in @text_view.
//
// Tags in the buffer may override the default.
func (x *TextView) GetJustification() Justification {

	cret := xTextViewGetJustification(x.GoPointer())
	return cret
}

var xTextViewGetLeftMargin func(uintptr) int

// Gets the default left margin size of paragraphs in the @text_view.
//
// Tags in the buffer may override the default.
func (x *TextView) GetLeftMargin() int {

	cret := xTextViewGetLeftMargin(x.GoPointer())
	return cret
}

var xTextViewGetLineAtY func(uintptr, *TextIter, int, *int)

// Gets the `GtkTextIter` at the start of the line containing
// the coordinate @y.
//
// @y is in buffer coordinates, convert from window coordinates with
// [method@Gtk.TextView.window_to_buffer_coords]. If non-%NULL,
// @line_top will be filled with the coordinate of the top edge
// of the line.
func (x *TextView) GetLineAtY(TargetIterVar *TextIter, YVar int, LineTopVar *int) {

	xTextViewGetLineAtY(x.GoPointer(), TargetIterVar, YVar, LineTopVar)

}

var xTextViewGetLineYrange func(uintptr, *TextIter, *int, *int)

// Gets the y coordinate of the top of the line containing @iter,
// and the height of the line.
//
// The coordinate is a buffer coordinate; convert to window
// coordinates with [method@Gtk.TextView.buffer_to_window_coords].
func (x *TextView) GetLineYrange(IterVar *TextIter, YVar *int, HeightVar *int) {

	xTextViewGetLineYrange(x.GoPointer(), IterVar, YVar, HeightVar)

}

var xTextViewGetLtrContext func(uintptr) uintptr

// Gets the `PangoContext` that is used for rendering LTR directed
// text layouts.
//
// The context may be replaced when CSS changes occur.
func (x *TextView) GetLtrContext() *pango.Context {
	var cls *pango.Context

	cret := xTextViewGetLtrContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &pango.Context{}
	cls.Ptr = cret
	return cls
}

var xTextViewGetMonospace func(uintptr) bool

// Gets whether the `GtkTextView` uses monospace styling.
func (x *TextView) GetMonospace() bool {

	cret := xTextViewGetMonospace(x.GoPointer())
	return cret
}

var xTextViewGetOverwrite func(uintptr) bool

// Returns whether the `GtkTextView` is in overwrite mode or not.
func (x *TextView) GetOverwrite() bool {

	cret := xTextViewGetOverwrite(x.GoPointer())
	return cret
}

var xTextViewGetPixelsAboveLines func(uintptr) int

// Gets the default number of pixels to put above paragraphs.
//
// Adding this function with [method@Gtk.TextView.get_pixels_below_lines]
// is equal to the line space between each paragraph.
func (x *TextView) GetPixelsAboveLines() int {

	cret := xTextViewGetPixelsAboveLines(x.GoPointer())
	return cret
}

var xTextViewGetPixelsBelowLines func(uintptr) int

// Gets the default number of pixels to put below paragraphs.
//
// The line space is the sum of the value returned by this function and
// the value returned by [method@Gtk.TextView.get_pixels_above_lines].
func (x *TextView) GetPixelsBelowLines() int {

	cret := xTextViewGetPixelsBelowLines(x.GoPointer())
	return cret
}

var xTextViewGetPixelsInsideWrap func(uintptr) int

// Gets the default number of pixels to put between wrapped lines
// inside a paragraph.
func (x *TextView) GetPixelsInsideWrap() int {

	cret := xTextViewGetPixelsInsideWrap(x.GoPointer())
	return cret
}

var xTextViewGetRightMargin func(uintptr) int

// Gets the default right margin for text in @text_view.
//
// Tags in the buffer may override the default.
func (x *TextView) GetRightMargin() int {

	cret := xTextViewGetRightMargin(x.GoPointer())
	return cret
}

var xTextViewGetRtlContext func(uintptr) uintptr

// Gets the `PangoContext` that is used for rendering RTL directed
// text layouts.
//
// The context may be replaced when CSS changes occur.
func (x *TextView) GetRtlContext() *pango.Context {
	var cls *pango.Context

	cret := xTextViewGetRtlContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &pango.Context{}
	cls.Ptr = cret
	return cls
}

var xTextViewGetTabs func(uintptr) *pango.TabArray

// Gets the default tabs for @text_view.
//
// Tags in the buffer may override the defaults. The returned array
// will be %NULL if “standard” (8-space) tabs are used. Free the
// return value with [method@Pango.TabArray.free].
func (x *TextView) GetTabs() *pango.TabArray {

	cret := xTextViewGetTabs(x.GoPointer())
	return cret
}

var xTextViewGetTopMargin func(uintptr) int

// Gets the top margin for text in the @text_view.
func (x *TextView) GetTopMargin() int {

	cret := xTextViewGetTopMargin(x.GoPointer())
	return cret
}

var xTextViewGetVisibleOffset func(uintptr, *float64, *float64)

// Gets the X,Y offset in buffer coordinates of the top-left corner of
// the textview's text contents.
//
// This allows for more-precise positioning than what is provided by
// [method@Gtk.TextView.get_visible_rect] as you can discover what
// device pixel is being quantized for text positioning.
//
// You might want this when making ulterior widgets align with quantized
// device pixels of the textview contents such as line numbers.
func (x *TextView) GetVisibleOffset(XOffsetVar *float64, YOffsetVar *float64) {

	xTextViewGetVisibleOffset(x.GoPointer(), XOffsetVar, YOffsetVar)

}

var xTextViewGetVisibleRect func(uintptr, *gdk.Rectangle)

// Fills @visible_rect with the currently-visible
// region of the buffer, in buffer coordinates.
//
// Convert to window coordinates with
// [method@Gtk.TextView.buffer_to_window_coords].
func (x *TextView) GetVisibleRect(VisibleRectVar *gdk.Rectangle) {

	xTextViewGetVisibleRect(x.GoPointer(), VisibleRectVar)

}

var xTextViewGetWrapMode func(uintptr) WrapMode

// Gets the line wrapping for the view.
func (x *TextView) GetWrapMode() WrapMode {

	cret := xTextViewGetWrapMode(x.GoPointer())
	return cret
}

var xTextViewImContextFilterKeypress func(uintptr, uintptr) bool

// Allow the `GtkTextView` input method to internally handle key press
// and release events.
//
// If this function returns %TRUE, then no further processing should be
// done for this key event. See [method@Gtk.IMContext.filter_keypress].
//
// Note that you are expected to call this function from your handler
// when overriding key event handling. This is needed in the case when
// you need to insert your own key handling between the input method
// and the default key event handling of the `GtkTextView`.
//
// ```c
// static gboolean
// gtk_foo_bar_key_press_event (GtkWidget *widget,
//
//	GdkEvent  *event)
//
//	{
//	  guint keyval;
//
//	  gdk_event_get_keyval ((GdkEvent*)event, &amp;keyval);
//
//	  if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//	    {
//	      if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//	        return TRUE;
//	    }
//
//	  // Do some stuff
//
//	  return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)-&gt;key_press_event (widget, event);
//	}
//
// ```
func (x *TextView) ImContextFilterKeypress(EventVar *gdk.Event) bool {

	cret := xTextViewImContextFilterKeypress(x.GoPointer(), EventVar.GoPointer())
	return cret
}

var xTextViewMoveMarkOnscreen func(uintptr, uintptr) bool

// Moves a mark within the buffer so that it's
// located within the currently-visible text area.
func (x *TextView) MoveMarkOnscreen(MarkVar *TextMark) bool {

	cret := xTextViewMoveMarkOnscreen(x.GoPointer(), MarkVar.GoPointer())
	return cret
}

var xTextViewMoveOverlay func(uintptr, uintptr, int, int)

// Updates the position of a child.
//
// See [method@Gtk.TextView.add_overlay].
func (x *TextView) MoveOverlay(ChildVar *Widget, XposVar int, YposVar int) {

	xTextViewMoveOverlay(x.GoPointer(), ChildVar.GoPointer(), XposVar, YposVar)

}

var xTextViewMoveVisually func(uintptr, *TextIter, int) bool

// Move the iterator a given number of characters visually, treating
// it as the strong cursor position.
//
// If @count is positive, then the new strong cursor position will
// be @count positions to the right of the old cursor position.
// If @count is negative then the new strong cursor position will
// be @count positions to the left of the old cursor position.
//
// In the presence of bi-directional text, the correspondence
// between logical and visual order will depend on the direction
// of the current run, and there may be jumps when the cursor
// is moved off of the end of a run.
func (x *TextView) MoveVisually(IterVar *TextIter, CountVar int) bool {

	cret := xTextViewMoveVisually(x.GoPointer(), IterVar, CountVar)
	return cret
}

var xTextViewPlaceCursorOnscreen func(uintptr) bool

// Moves the cursor to the currently visible region of the
// buffer.
func (x *TextView) PlaceCursorOnscreen() bool {

	cret := xTextViewPlaceCursorOnscreen(x.GoPointer())
	return cret
}

var xTextViewRemove func(uintptr, uintptr)

// Removes a child widget from @text_view.
func (x *TextView) Remove(ChildVar *Widget) {

	xTextViewRemove(x.GoPointer(), ChildVar.GoPointer())

}

var xTextViewResetCursorBlink func(uintptr)

// Ensures that the cursor is shown.
//
// This also resets the time that it will stay blinking (or
// visible, in case blinking is disabled).
//
// This function should be called in response to user input
// (e.g. from derived classes that override the textview's
// event handlers).
func (x *TextView) ResetCursorBlink() {

	xTextViewResetCursorBlink(x.GoPointer())

}

var xTextViewResetImContext func(uintptr)

// Reset the input method context of the text view if needed.
//
// This can be necessary in the case where modifying the buffer
// would confuse on-going input method behavior.
func (x *TextView) ResetImContext() {

	xTextViewResetImContext(x.GoPointer())

}

var xTextViewScrollMarkOnscreen func(uintptr, uintptr)

// Scrolls @text_view the minimum distance such that @mark is contained
// within the visible area of the widget.
func (x *TextView) ScrollMarkOnscreen(MarkVar *TextMark) {

	xTextViewScrollMarkOnscreen(x.GoPointer(), MarkVar.GoPointer())

}

var xTextViewScrollToIter func(uintptr, *TextIter, float64, bool, float64, float64) bool

// Scrolls @text_view so that @iter is on the screen in the position
// indicated by @xalign and @yalign.
//
// An alignment of 0.0 indicates left or top, 1.0 indicates right or
// bottom, 0.5 means center. If @use_align is %FALSE, the text scrolls
// the minimal distance to get the mark onscreen, possibly not scrolling
// at all. The effective screen for purposes of this function is reduced
// by a margin of size @within_margin.
//
// Note that this function uses the currently-computed height of the
// lines in the text buffer. Line heights are computed in an idle
// handler; so this function may not have the desired effect if it’s
// called before the height computations. To avoid oddness, consider
// using [method@Gtk.TextView.scroll_to_mark] which saves a point to be
// scrolled to after line validation.
func (x *TextView) ScrollToIter(IterVar *TextIter, WithinMarginVar float64, UseAlignVar bool, XalignVar float64, YalignVar float64) bool {

	cret := xTextViewScrollToIter(x.GoPointer(), IterVar, WithinMarginVar, UseAlignVar, XalignVar, YalignVar)
	return cret
}

var xTextViewScrollToMark func(uintptr, uintptr, float64, bool, float64, float64)

// Scrolls @text_view so that @mark is on the screen in the position
// indicated by @xalign and @yalign.
//
// An alignment of 0.0 indicates left or top, 1.0 indicates right or
// bottom, 0.5 means center. If @use_align is %FALSE, the text scrolls
// the minimal distance to get the mark onscreen, possibly not scrolling
// at all. The effective screen for purposes of this function is reduced
// by a margin of size @within_margin.
func (x *TextView) ScrollToMark(MarkVar *TextMark, WithinMarginVar float64, UseAlignVar bool, XalignVar float64, YalignVar float64) {

	xTextViewScrollToMark(x.GoPointer(), MarkVar.GoPointer(), WithinMarginVar, UseAlignVar, XalignVar, YalignVar)

}

var xTextViewSetAcceptsTab func(uintptr, bool)

// Sets the behavior of the text widget when the &lt;kbd&gt;Tab&lt;/kbd&gt; key is pressed.
//
// If @accepts_tab is %TRUE, a tab character is inserted. If @accepts_tab
// is %FALSE the keyboard focus is moved to the next widget in the focus
// chain.
//
// Focus can always be moved using &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Tab&lt;/kbd&gt;.
func (x *TextView) SetAcceptsTab(AcceptsTabVar bool) {

	xTextViewSetAcceptsTab(x.GoPointer(), AcceptsTabVar)

}

var xTextViewSetBottomMargin func(uintptr, int)

// Sets the bottom margin for text in @text_view.
//
// Note that this function is confusingly named.
// In CSS terms, the value set here is padding.
func (x *TextView) SetBottomMargin(BottomMarginVar int) {

	xTextViewSetBottomMargin(x.GoPointer(), BottomMarginVar)

}

var xTextViewSetBuffer func(uintptr, uintptr)

// Sets @buffer as the buffer being displayed by @text_view.
//
// The previous buffer displayed by the text view is unreferenced, and
// a reference is added to @buffer. If you owned a reference to @buffer
// before passing it to this function, you must remove that reference
// yourself; `GtkTextView` will not “adopt” it.
func (x *TextView) SetBuffer(BufferVar *TextBuffer) {

	xTextViewSetBuffer(x.GoPointer(), BufferVar.GoPointer())

}

var xTextViewSetCursorVisible func(uintptr, bool)

// Toggles whether the insertion point should be displayed.
//
// A buffer with no editable text probably shouldn’t have a visible
// cursor, so you may want to turn the cursor off.
//
// Note that this property may be overridden by the
// [property@Gtk.Settings:gtk-keynav-use-caret] setting.
func (x *TextView) SetCursorVisible(SettingVar bool) {

	xTextViewSetCursorVisible(x.GoPointer(), SettingVar)

}

var xTextViewSetEditable func(uintptr, bool)

// Sets the default editability of the `GtkTextView`.
//
// You can override this default setting with tags in the buffer,
// using the “editable” attribute of tags.
func (x *TextView) SetEditable(SettingVar bool) {

	xTextViewSetEditable(x.GoPointer(), SettingVar)

}

var xTextViewSetExtraMenu func(uintptr, uintptr)

// Sets a menu model to add when constructing the context
// menu for @text_view.
//
// You can pass %NULL to remove a previously set extra menu.
func (x *TextView) SetExtraMenu(ModelVar *gio.MenuModel) {

	xTextViewSetExtraMenu(x.GoPointer(), ModelVar.GoPointer())

}

var xTextViewSetGutter func(uintptr, TextWindowType, uintptr)

// Places @widget into the gutter specified by @win.
//
// @win must be one of %GTK_TEXT_WINDOW_LEFT, %GTK_TEXT_WINDOW_RIGHT,
// %GTK_TEXT_WINDOW_TOP, or %GTK_TEXT_WINDOW_BOTTOM.
func (x *TextView) SetGutter(WinVar TextWindowType, WidgetVar *Widget) {

	xTextViewSetGutter(x.GoPointer(), WinVar, WidgetVar.GoPointer())

}

var xTextViewSetIndent func(uintptr, int)

// Sets the default indentation for paragraphs in @text_view.
//
// Tags in the buffer may override the default.
func (x *TextView) SetIndent(IndentVar int) {

	xTextViewSetIndent(x.GoPointer(), IndentVar)

}

var xTextViewSetInputHints func(uintptr, InputHints)

// Sets the `input-hints` of the `GtkTextView`.
//
// The `input-hints` allow input methods to fine-tune
// their behaviour.
func (x *TextView) SetInputHints(HintsVar InputHints) {

	xTextViewSetInputHints(x.GoPointer(), HintsVar)

}

var xTextViewSetInputPurpose func(uintptr, InputPurpose)

// Sets the `input-purpose` of the `GtkTextView`.
//
// The `input-purpose` can be used by on-screen keyboards
// and other input methods to adjust their behaviour.
func (x *TextView) SetInputPurpose(PurposeVar InputPurpose) {

	xTextViewSetInputPurpose(x.GoPointer(), PurposeVar)

}

var xTextViewSetJustification func(uintptr, Justification)

// Sets the default justification of text in @text_view.
//
// Tags in the view’s buffer may override the default.
func (x *TextView) SetJustification(JustificationVar Justification) {

	xTextViewSetJustification(x.GoPointer(), JustificationVar)

}

var xTextViewSetLeftMargin func(uintptr, int)

// Sets the default left margin for text in @text_view.
//
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named.
// In CSS terms, the value set here is padding.
func (x *TextView) SetLeftMargin(LeftMarginVar int) {

	xTextViewSetLeftMargin(x.GoPointer(), LeftMarginVar)

}

var xTextViewSetMonospace func(uintptr, bool)

// Sets whether the `GtkTextView` should display text in
// monospace styling.
func (x *TextView) SetMonospace(MonospaceVar bool) {

	xTextViewSetMonospace(x.GoPointer(), MonospaceVar)

}

var xTextViewSetOverwrite func(uintptr, bool)

// Changes the `GtkTextView` overwrite mode.
func (x *TextView) SetOverwrite(OverwriteVar bool) {

	xTextViewSetOverwrite(x.GoPointer(), OverwriteVar)

}

var xTextViewSetPixelsAboveLines func(uintptr, int)

// Sets the default number of blank pixels above paragraphs in @text_view.
//
// Tags in the buffer for @text_view may override the defaults.
func (x *TextView) SetPixelsAboveLines(PixelsAboveLinesVar int) {

	xTextViewSetPixelsAboveLines(x.GoPointer(), PixelsAboveLinesVar)

}

var xTextViewSetPixelsBelowLines func(uintptr, int)

// Sets the default number of pixels of blank space
// to put below paragraphs in @text_view.
//
// May be overridden by tags applied to @text_view’s buffer.
func (x *TextView) SetPixelsBelowLines(PixelsBelowLinesVar int) {

	xTextViewSetPixelsBelowLines(x.GoPointer(), PixelsBelowLinesVar)

}

var xTextViewSetPixelsInsideWrap func(uintptr, int)

// Sets the default number of pixels of blank space to leave between
// display/wrapped lines within a paragraph.
//
// May be overridden by tags in @text_view’s buffer.
func (x *TextView) SetPixelsInsideWrap(PixelsInsideWrapVar int) {

	xTextViewSetPixelsInsideWrap(x.GoPointer(), PixelsInsideWrapVar)

}

var xTextViewSetRightMargin func(uintptr, int)

// Sets the default right margin for text in the text view.
//
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named.
// In CSS terms, the value set here is padding.
func (x *TextView) SetRightMargin(RightMarginVar int) {

	xTextViewSetRightMargin(x.GoPointer(), RightMarginVar)

}

var xTextViewSetTabs func(uintptr, *pango.TabArray)

// Sets the default tab stops for paragraphs in @text_view.
//
// Tags in the buffer may override the default.
func (x *TextView) SetTabs(TabsVar *pango.TabArray) {

	xTextViewSetTabs(x.GoPointer(), TabsVar)

}

var xTextViewSetTopMargin func(uintptr, int)

// Sets the top margin for text in @text_view.
//
// Note that this function is confusingly named.
// In CSS terms, the value set here is padding.
func (x *TextView) SetTopMargin(TopMarginVar int) {

	xTextViewSetTopMargin(x.GoPointer(), TopMarginVar)

}

var xTextViewSetWrapMode func(uintptr, WrapMode)

// Sets the line wrapping for the view.
func (x *TextView) SetWrapMode(WrapModeVar WrapMode) {

	xTextViewSetWrapMode(x.GoPointer(), WrapModeVar)

}

var xTextViewStartsDisplayLine func(uintptr, *TextIter) bool

// Determines whether @iter is at the start of a display line.
//
// See [method@Gtk.TextView.forward_display_line] for an
// explanation of display lines vs. paragraphs.
func (x *TextView) StartsDisplayLine(IterVar *TextIter) bool {

	cret := xTextViewStartsDisplayLine(x.GoPointer(), IterVar)
	return cret
}

var xTextViewWindowToBufferCoords func(uintptr, TextWindowType, int, int, *int, *int)

// Converts coordinates on the window identified by @win to buffer
// coordinates.
func (x *TextView) WindowToBufferCoords(WinVar TextWindowType, WindowXVar int, WindowYVar int, BufferXVar *int, BufferYVar *int) {

	xTextViewWindowToBufferCoords(x.GoPointer(), WinVar, WindowXVar, WindowYVar, BufferXVar, BufferYVar)

}

func (c *TextView) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *TextView) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAcceptsTab sets the "accepts-tab" property.
// Whether Tab will result in a tab character being entered.
func (x *TextView) SetPropertyAcceptsTab(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("accepts-tab", &v)
}

// GetPropertyAcceptsTab gets the "accepts-tab" property.
// Whether Tab will result in a tab character being entered.
func (x *TextView) GetPropertyAcceptsTab() bool {
	var v gobject.Value
	x.GetProperty("accepts-tab", &v)
	return v.GetBoolean()
}

// SetPropertyBottomMargin sets the "bottom-margin" property.
// The bottom margin for text in the text view.
//
// Note that this property is confusingly named. In CSS terms,
// the value set here is padding, and it is applied in addition
// to the padding from the theme.
//
// Don't confuse this property with [property@Gtk.Widget:margin-bottom].
func (x *TextView) SetPropertyBottomMargin(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("bottom-margin", &v)
}

// GetPropertyBottomMargin gets the "bottom-margin" property.
// The bottom margin for text in the text view.
//
// Note that this property is confusingly named. In CSS terms,
// the value set here is padding, and it is applied in addition
// to the padding from the theme.
//
// Don't confuse this property with [property@Gtk.Widget:margin-bottom].
func (x *TextView) GetPropertyBottomMargin() int {
	var v gobject.Value
	x.GetProperty("bottom-margin", &v)
	return v.GetInt()
}

// SetPropertyCursorVisible sets the "cursor-visible" property.
// If the insertion cursor is shown.
func (x *TextView) SetPropertyCursorVisible(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("cursor-visible", &v)
}

// GetPropertyCursorVisible gets the "cursor-visible" property.
// If the insertion cursor is shown.
func (x *TextView) GetPropertyCursorVisible() bool {
	var v gobject.Value
	x.GetProperty("cursor-visible", &v)
	return v.GetBoolean()
}

// SetPropertyEditable sets the "editable" property.
// Whether the text can be modified by the user.
func (x *TextView) SetPropertyEditable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("editable", &v)
}

// GetPropertyEditable gets the "editable" property.
// Whether the text can be modified by the user.
func (x *TextView) GetPropertyEditable() bool {
	var v gobject.Value
	x.GetProperty("editable", &v)
	return v.GetBoolean()
}

// SetPropertyImModule sets the "im-module" property.
// Which IM (input method) module should be used for this text_view.
//
// See [class@Gtk.IMMulticontext].
//
// Setting this to a non-%NULL value overrides the system-wide IM module
// setting. See the GtkSettings [property@Gtk.Settings:gtk-im-module] property.
func (x *TextView) SetPropertyImModule(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("im-module", &v)
}

// GetPropertyImModule gets the "im-module" property.
// Which IM (input method) module should be used for this text_view.
//
// See [class@Gtk.IMMulticontext].
//
// Setting this to a non-%NULL value overrides the system-wide IM module
// setting. See the GtkSettings [property@Gtk.Settings:gtk-im-module] property.
func (x *TextView) GetPropertyImModule() string {
	var v gobject.Value
	x.GetProperty("im-module", &v)
	return v.GetString()
}

// SetPropertyIndent sets the "indent" property.
// Amount to indent the paragraph, in pixels.
//
// A negative value of indent will produce a hanging indentation.
// That is, the first line will have the full width, and subsequent
// lines will be indented by the absolute value of indent.
func (x *TextView) SetPropertyIndent(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("indent", &v)
}

// GetPropertyIndent gets the "indent" property.
// Amount to indent the paragraph, in pixels.
//
// A negative value of indent will produce a hanging indentation.
// That is, the first line will have the full width, and subsequent
// lines will be indented by the absolute value of indent.
func (x *TextView) GetPropertyIndent() int {
	var v gobject.Value
	x.GetProperty("indent", &v)
	return v.GetInt()
}

// SetPropertyLeftMargin sets the "left-margin" property.
// The default left margin for text in the text view.
//
// Tags in the buffer may override the default.
//
// Note that this property is confusingly named. In CSS terms,
// the value set here is padding, and it is applied in addition
// to the padding from the theme.
func (x *TextView) SetPropertyLeftMargin(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("left-margin", &v)
}

// GetPropertyLeftMargin gets the "left-margin" property.
// The default left margin for text in the text view.
//
// Tags in the buffer may override the default.
//
// Note that this property is confusingly named. In CSS terms,
// the value set here is padding, and it is applied in addition
// to the padding from the theme.
func (x *TextView) GetPropertyLeftMargin() int {
	var v gobject.Value
	x.GetProperty("left-margin", &v)
	return v.GetInt()
}

// SetPropertyMonospace sets the "monospace" property.
// Whether text should be displayed in a monospace font.
//
// If %TRUE, set the .monospace style class on the
// text view to indicate that a monospace font is desired.
func (x *TextView) SetPropertyMonospace(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("monospace", &v)
}

// GetPropertyMonospace gets the "monospace" property.
// Whether text should be displayed in a monospace font.
//
// If %TRUE, set the .monospace style class on the
// text view to indicate that a monospace font is desired.
func (x *TextView) GetPropertyMonospace() bool {
	var v gobject.Value
	x.GetProperty("monospace", &v)
	return v.GetBoolean()
}

// SetPropertyOverwrite sets the "overwrite" property.
// Whether entered text overwrites existing contents.
func (x *TextView) SetPropertyOverwrite(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("overwrite", &v)
}

// GetPropertyOverwrite gets the "overwrite" property.
// Whether entered text overwrites existing contents.
func (x *TextView) GetPropertyOverwrite() bool {
	var v gobject.Value
	x.GetProperty("overwrite", &v)
	return v.GetBoolean()
}

// SetPropertyPixelsAboveLines sets the "pixels-above-lines" property.
// Pixels of blank space above paragraphs.
func (x *TextView) SetPropertyPixelsAboveLines(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("pixels-above-lines", &v)
}

// GetPropertyPixelsAboveLines gets the "pixels-above-lines" property.
// Pixels of blank space above paragraphs.
func (x *TextView) GetPropertyPixelsAboveLines() int {
	var v gobject.Value
	x.GetProperty("pixels-above-lines", &v)
	return v.GetInt()
}

// SetPropertyPixelsBelowLines sets the "pixels-below-lines" property.
// Pixels of blank space below paragraphs.
func (x *TextView) SetPropertyPixelsBelowLines(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("pixels-below-lines", &v)
}

// GetPropertyPixelsBelowLines gets the "pixels-below-lines" property.
// Pixels of blank space below paragraphs.
func (x *TextView) GetPropertyPixelsBelowLines() int {
	var v gobject.Value
	x.GetProperty("pixels-below-lines", &v)
	return v.GetInt()
}

// SetPropertyPixelsInsideWrap sets the "pixels-inside-wrap" property.
// Pixels of blank space between wrapped lines in a paragraph.
func (x *TextView) SetPropertyPixelsInsideWrap(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("pixels-inside-wrap", &v)
}

// GetPropertyPixelsInsideWrap gets the "pixels-inside-wrap" property.
// Pixels of blank space between wrapped lines in a paragraph.
func (x *TextView) GetPropertyPixelsInsideWrap() int {
	var v gobject.Value
	x.GetProperty("pixels-inside-wrap", &v)
	return v.GetInt()
}

// SetPropertyRightMargin sets the "right-margin" property.
// The default right margin for text in the text view.
//
// Tags in the buffer may override the default.
//
// Note that this property is confusingly named. In CSS terms,
// the value set here is padding, and it is applied in addition
// to the padding from the theme.
func (x *TextView) SetPropertyRightMargin(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("right-margin", &v)
}

// GetPropertyRightMargin gets the "right-margin" property.
// The default right margin for text in the text view.
//
// Tags in the buffer may override the default.
//
// Note that this property is confusingly named. In CSS terms,
// the value set here is padding, and it is applied in addition
// to the padding from the theme.
func (x *TextView) GetPropertyRightMargin() int {
	var v gobject.Value
	x.GetProperty("right-margin", &v)
	return v.GetInt()
}

// SetPropertyTabs sets the "tabs" property.
// Custom tabs for this text.
func (x *TextView) SetPropertyTabs(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("tabs", &v)
}

// GetPropertyTabs gets the "tabs" property.
// Custom tabs for this text.
func (x *TextView) GetPropertyTabs() uintptr {
	var v gobject.Value
	x.GetProperty("tabs", &v)
	return v.GetPointer()
}

// SetPropertyTopMargin sets the "top-margin" property.
// The top margin for text in the text view.
//
// Note that this property is confusingly named. In CSS terms,
// the value set here is padding, and it is applied in addition
// to the padding from the theme.
//
// Don't confuse this property with [property@Gtk.Widget:margin-top].
func (x *TextView) SetPropertyTopMargin(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("top-margin", &v)
}

// GetPropertyTopMargin gets the "top-margin" property.
// The top margin for text in the text view.
//
// Note that this property is confusingly named. In CSS terms,
// the value set here is padding, and it is applied in addition
// to the padding from the theme.
//
// Don't confuse this property with [property@Gtk.Widget:margin-top].
func (x *TextView) GetPropertyTopMargin() int {
	var v gobject.Value
	x.GetProperty("top-margin", &v)
	return v.GetInt()
}

// Gets emitted when the user asks for it.
//
// The ::backspace signal is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Backspace&lt;/kbd&gt;.
func (x *TextView) ConnectBackspace(cb *func(TextView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "backspace", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "backspace", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted to copy the selection to the clipboard.
//
// The ::copy-clipboard signal is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;c&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *TextView) ConnectCopyClipboard(cb *func(TextView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "copy-clipboard", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "copy-clipboard", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted to cut the selection to the clipboard.
//
// The ::cut-clipboard signal is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;x&lt;/kbd&gt; and
// &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Delete&lt;/kbd&gt;.
func (x *TextView) ConnectCutClipboard(cb *func(TextView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "cut-clipboard", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "cut-clipboard", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted when the user initiates a text deletion.
//
// The ::delete-from-cursor signal is a [keybinding signal](class.SignalAction.html).
//
// If the @type is %GTK_DELETE_CHARS, GTK deletes the selection
// if there is one, otherwise it deletes the requested number
// of characters.
//
// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt; for
// deleting a character, &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Delete&lt;/kbd&gt; for
// deleting a word and &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Backspace&lt;/kbd&gt; for
// deleting a word backwards.
func (x *TextView) ConnectDeleteFromCursor(cb *func(TextView, DeleteType, int)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "delete-from-cursor", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, TypeVarp DeleteType, CountVarp int) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TypeVarp, CountVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "delete-from-cursor", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the selection needs to be extended at @location.
func (x *TextView) ConnectExtendSelection(cb *func(TextView, TextExtendSelection, uintptr, uintptr, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "extend-selection", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, GranularityVarp TextExtendSelection, LocationVarp uintptr, StartVarp uintptr, EndVarp uintptr) bool {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, GranularityVarp, LocationVarp, StartVarp, EndVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "extend-selection", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// The ::insert-at-cursor signal is a [keybinding signal](class.SignalAction.html).
//
// This signal has no default bindings.
func (x *TextView) ConnectInsertAtCursor(cb *func(TextView, string)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "insert-at-cursor", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, StringVarp string) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StringVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "insert-at-cursor", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted to present the Emoji chooser for the @text_view.
//
// The ::insert-emoji signal is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;.&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;;&lt;/kbd&gt;
func (x *TextView) ConnectInsertEmoji(cb *func(TextView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "insert-emoji", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "insert-emoji", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted when the user initiates a cursor movement.
//
// The ::move-cursor signal is a [keybinding signal](class.SignalAction.html).
// If the cursor is not visible in @text_view, this signal causes
// the viewport to be moved instead.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor
// programmatically.
//
// The default bindings for this signal come in two variants,
// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
// selection, the variant without it does not.
// There are too many key combinations to list them all here.
//
//   - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
//     move by individual characters/lines
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;←&lt;/kbd&gt;, etc. move by words/paragraphs
//   - &lt;kbd&gt;Home&lt;/kbd&gt; and &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
//   - &lt;kbd&gt;PgUp&lt;/kbd&gt; and &lt;kbd&gt;PgDn&lt;/kbd&gt; move vertically by pages
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;PgUp&lt;/kbd&gt; and &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;PgDn&lt;/kbd&gt;
//     move horizontally by pages
func (x *TextView) ConnectMoveCursor(cb *func(TextView, MovementStep, int, bool)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, StepVarp MovementStep, CountVarp int, ExtendSelectionVarp bool) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StepVarp, CountVarp, ExtendSelectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted to move the viewport.
//
// The ::move-viewport signal is a [keybinding signal](class.SignalAction.html),
// which can be bound to key combinations to allow the user to move the viewport,
// i.e. change what part of the text view is visible in a containing scrolled
// window.
//
// There are no default bindings for this signal.
func (x *TextView) ConnectMoveViewport(cb *func(TextView, ScrollStep, int)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "move-viewport", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, StepVarp ScrollStep, CountVarp int) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StepVarp, CountVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "move-viewport", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted to paste the contents of the clipboard
// into the text view.
//
// The ::paste-clipboard signal is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;v&lt;/kbd&gt; and
// &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *TextView) ConnectPasteClipboard(cb *func(TextView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "paste-clipboard", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "paste-clipboard", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when preedit text of the active IM changes.
//
// If an input method is used, the typed text will not immediately
// be committed to the buffer. So if you are interested in the text,
// connect to this signal.
//
// This signal is only emitted if the text at the given position
// is actually editable.
func (x *TextView) ConnectPreeditChanged(cb *func(TextView, string)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, PreeditVarp string) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PreeditVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted to select or unselect the complete contents of the text view.
//
// The ::select-all signal is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;a&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;/&lt;/kbd&gt; for selecting and
// &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;a&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;\&lt;/kbd&gt; for unselecting.
func (x *TextView) ConnectSelectAll(cb *func(TextView, bool)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "select-all", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, SelectVarp bool) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SelectVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "select-all", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted when the user initiates settings the "anchor" mark.
//
// The ::set-anchor signal is a [keybinding signal](class.SignalAction.html)
// which gets emitted when the user initiates setting the "anchor"
// mark. The "anchor" mark gets placed at the same position as the
// "insert" mark.
//
// This signal has no default bindings.
func (x *TextView) ConnectSetAnchor(cb *func(TextView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "set-anchor", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "set-anchor", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted to toggle the `cursor-visible` property.
//
// The ::toggle-cursor-visible signal is a
// [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is &lt;kbd&gt;F7&lt;/kbd&gt;.
func (x *TextView) ConnectToggleCursorVisible(cb *func(TextView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "toggle-cursor-visible", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "toggle-cursor-visible", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Gets emitted to toggle the overwrite mode of the text view.
//
// The ::toggle-overwrite signal is a [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *TextView) ConnectToggleOverwrite(cb *func(TextView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "toggle-overwrite", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TextView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "toggle-overwrite", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *TextView) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *TextView) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *TextView) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *TextView) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *TextView) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *TextView) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *TextView) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *TextView) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *TextView) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *TextView) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *TextView) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *TextView) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *TextView) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *TextView) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *TextView) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TextView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *TextView) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TextView) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *TextView) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TextView) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Updates the position of the caret.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time the caret has moved, in order to notify assistive
// technologies.
func (x *TextView) UpdateCaretPosition() {

	XGtkAccessibleTextUpdateCaretPosition(x.GoPointer())

}

// Notifies assistive technologies of a change in contents.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time their contents change as the result of an operation,
// like an insertion or a removal.
//
// Note: If the change is a deletion, this function must be called *before*
// removing the contents, if it is an insertion, it must be called *after*
// inserting the new contents.
func (x *TextView) UpdateContents(ChangeVar AccessibleTextContentChange, StartVar uint, EndVar uint) {

	XGtkAccessibleTextUpdateContents(x.GoPointer(), ChangeVar, StartVar, EndVar)

}

// Updates the boundary of the selection.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time the selection has moved, in order to notify assistive
// technologies.
func (x *TextView) UpdateSelectionBound() {

	XGtkAccessibleTextUpdateSelectionBound(x.GoPointer())

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *TextView) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Returns the size of a non-scrolling border around the
// outside of the scrollable.
//
// An example for this would be treeview headers. GTK can use
// this information to display overlaid graphics, like the
// overshoot indication, at the right position.
func (x *TextView) GetBorder(BorderVar *Border) bool {

	cret := XGtkScrollableGetBorder(x.GoPointer(), BorderVar)
	return cret
}

// Retrieves the `GtkAdjustment` used for horizontal scrolling.
func (x *TextView) GetHadjustment() *Adjustment {
	var cls *Adjustment

	cret := XGtkScrollableGetHadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

// Gets the horizontal `GtkScrollablePolicy`.
func (x *TextView) GetHscrollPolicy() ScrollablePolicy {

	cret := XGtkScrollableGetHscrollPolicy(x.GoPointer())
	return cret
}

// Retrieves the `GtkAdjustment` used for vertical scrolling.
func (x *TextView) GetVadjustment() *Adjustment {
	var cls *Adjustment

	cret := XGtkScrollableGetVadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

// Gets the vertical `GtkScrollablePolicy`.
func (x *TextView) GetVscrollPolicy() ScrollablePolicy {

	cret := XGtkScrollableGetVscrollPolicy(x.GoPointer())
	return cret
}

// Sets the horizontal adjustment of the `GtkScrollable`.
func (x *TextView) SetHadjustment(HadjustmentVar *Adjustment) {

	XGtkScrollableSetHadjustment(x.GoPointer(), HadjustmentVar.GoPointer())

}

// Sets the `GtkScrollablePolicy`.
//
// The policy determines whether horizontal scrolling should start
// below the minimum width or below the natural width.
func (x *TextView) SetHscrollPolicy(PolicyVar ScrollablePolicy) {

	XGtkScrollableSetHscrollPolicy(x.GoPointer(), PolicyVar)

}

// Sets the vertical adjustment of the `GtkScrollable`.
func (x *TextView) SetVadjustment(VadjustmentVar *Adjustment) {

	XGtkScrollableSetVadjustment(x.GoPointer(), VadjustmentVar.GoPointer())

}

// Sets the `GtkScrollablePolicy`.
//
// The policy determines whether vertical scrolling should start
// below the minimum height or below the natural height.
func (x *TextView) SetVscrollPolicy(PolicyVar ScrollablePolicy) {

	XGtkScrollableSetVscrollPolicy(x.GoPointer(), PolicyVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTextExtendSelectionGLibType, libs, "gtk_text_extend_selection_get_type")

	core.PuregoSafeRegister(&xTextViewLayerGLibType, libs, "gtk_text_view_layer_get_type")

	core.PuregoSafeRegister(&xTextWindowTypeGLibType, libs, "gtk_text_window_type_get_type")

	core.PuregoSafeRegister(&xTextViewGLibType, libs, "gtk_text_view_get_type")

	core.PuregoSafeRegister(&xNewTextView, libs, "gtk_text_view_new")
	core.PuregoSafeRegister(&xNewTextViewWithBuffer, libs, "gtk_text_view_new_with_buffer")

	core.PuregoSafeRegister(&xTextViewAddChildAtAnchor, libs, "gtk_text_view_add_child_at_anchor")
	core.PuregoSafeRegister(&xTextViewAddOverlay, libs, "gtk_text_view_add_overlay")
	core.PuregoSafeRegister(&xTextViewBackwardDisplayLine, libs, "gtk_text_view_backward_display_line")
	core.PuregoSafeRegister(&xTextViewBackwardDisplayLineStart, libs, "gtk_text_view_backward_display_line_start")
	core.PuregoSafeRegister(&xTextViewBufferToWindowCoords, libs, "gtk_text_view_buffer_to_window_coords")
	core.PuregoSafeRegister(&xTextViewForwardDisplayLine, libs, "gtk_text_view_forward_display_line")
	core.PuregoSafeRegister(&xTextViewForwardDisplayLineEnd, libs, "gtk_text_view_forward_display_line_end")
	core.PuregoSafeRegister(&xTextViewGetAcceptsTab, libs, "gtk_text_view_get_accepts_tab")
	core.PuregoSafeRegister(&xTextViewGetBottomMargin, libs, "gtk_text_view_get_bottom_margin")
	core.PuregoSafeRegister(&xTextViewGetBuffer, libs, "gtk_text_view_get_buffer")
	core.PuregoSafeRegister(&xTextViewGetCursorLocations, libs, "gtk_text_view_get_cursor_locations")
	core.PuregoSafeRegister(&xTextViewGetCursorVisible, libs, "gtk_text_view_get_cursor_visible")
	core.PuregoSafeRegister(&xTextViewGetEditable, libs, "gtk_text_view_get_editable")
	core.PuregoSafeRegister(&xTextViewGetExtraMenu, libs, "gtk_text_view_get_extra_menu")
	core.PuregoSafeRegister(&xTextViewGetGutter, libs, "gtk_text_view_get_gutter")
	core.PuregoSafeRegister(&xTextViewGetIndent, libs, "gtk_text_view_get_indent")
	core.PuregoSafeRegister(&xTextViewGetInputHints, libs, "gtk_text_view_get_input_hints")
	core.PuregoSafeRegister(&xTextViewGetInputPurpose, libs, "gtk_text_view_get_input_purpose")
	core.PuregoSafeRegister(&xTextViewGetIterAtLocation, libs, "gtk_text_view_get_iter_at_location")
	core.PuregoSafeRegister(&xTextViewGetIterAtPosition, libs, "gtk_text_view_get_iter_at_position")
	core.PuregoSafeRegister(&xTextViewGetIterLocation, libs, "gtk_text_view_get_iter_location")
	core.PuregoSafeRegister(&xTextViewGetJustification, libs, "gtk_text_view_get_justification")
	core.PuregoSafeRegister(&xTextViewGetLeftMargin, libs, "gtk_text_view_get_left_margin")
	core.PuregoSafeRegister(&xTextViewGetLineAtY, libs, "gtk_text_view_get_line_at_y")
	core.PuregoSafeRegister(&xTextViewGetLineYrange, libs, "gtk_text_view_get_line_yrange")
	core.PuregoSafeRegister(&xTextViewGetLtrContext, libs, "gtk_text_view_get_ltr_context")
	core.PuregoSafeRegister(&xTextViewGetMonospace, libs, "gtk_text_view_get_monospace")
	core.PuregoSafeRegister(&xTextViewGetOverwrite, libs, "gtk_text_view_get_overwrite")
	core.PuregoSafeRegister(&xTextViewGetPixelsAboveLines, libs, "gtk_text_view_get_pixels_above_lines")
	core.PuregoSafeRegister(&xTextViewGetPixelsBelowLines, libs, "gtk_text_view_get_pixels_below_lines")
	core.PuregoSafeRegister(&xTextViewGetPixelsInsideWrap, libs, "gtk_text_view_get_pixels_inside_wrap")
	core.PuregoSafeRegister(&xTextViewGetRightMargin, libs, "gtk_text_view_get_right_margin")
	core.PuregoSafeRegister(&xTextViewGetRtlContext, libs, "gtk_text_view_get_rtl_context")
	core.PuregoSafeRegister(&xTextViewGetTabs, libs, "gtk_text_view_get_tabs")
	core.PuregoSafeRegister(&xTextViewGetTopMargin, libs, "gtk_text_view_get_top_margin")
	core.PuregoSafeRegister(&xTextViewGetVisibleOffset, libs, "gtk_text_view_get_visible_offset")
	core.PuregoSafeRegister(&xTextViewGetVisibleRect, libs, "gtk_text_view_get_visible_rect")
	core.PuregoSafeRegister(&xTextViewGetWrapMode, libs, "gtk_text_view_get_wrap_mode")
	core.PuregoSafeRegister(&xTextViewImContextFilterKeypress, libs, "gtk_text_view_im_context_filter_keypress")
	core.PuregoSafeRegister(&xTextViewMoveMarkOnscreen, libs, "gtk_text_view_move_mark_onscreen")
	core.PuregoSafeRegister(&xTextViewMoveOverlay, libs, "gtk_text_view_move_overlay")
	core.PuregoSafeRegister(&xTextViewMoveVisually, libs, "gtk_text_view_move_visually")
	core.PuregoSafeRegister(&xTextViewPlaceCursorOnscreen, libs, "gtk_text_view_place_cursor_onscreen")
	core.PuregoSafeRegister(&xTextViewRemove, libs, "gtk_text_view_remove")
	core.PuregoSafeRegister(&xTextViewResetCursorBlink, libs, "gtk_text_view_reset_cursor_blink")
	core.PuregoSafeRegister(&xTextViewResetImContext, libs, "gtk_text_view_reset_im_context")
	core.PuregoSafeRegister(&xTextViewScrollMarkOnscreen, libs, "gtk_text_view_scroll_mark_onscreen")
	core.PuregoSafeRegister(&xTextViewScrollToIter, libs, "gtk_text_view_scroll_to_iter")
	core.PuregoSafeRegister(&xTextViewScrollToMark, libs, "gtk_text_view_scroll_to_mark")
	core.PuregoSafeRegister(&xTextViewSetAcceptsTab, libs, "gtk_text_view_set_accepts_tab")
	core.PuregoSafeRegister(&xTextViewSetBottomMargin, libs, "gtk_text_view_set_bottom_margin")
	core.PuregoSafeRegister(&xTextViewSetBuffer, libs, "gtk_text_view_set_buffer")
	core.PuregoSafeRegister(&xTextViewSetCursorVisible, libs, "gtk_text_view_set_cursor_visible")
	core.PuregoSafeRegister(&xTextViewSetEditable, libs, "gtk_text_view_set_editable")
	core.PuregoSafeRegister(&xTextViewSetExtraMenu, libs, "gtk_text_view_set_extra_menu")
	core.PuregoSafeRegister(&xTextViewSetGutter, libs, "gtk_text_view_set_gutter")
	core.PuregoSafeRegister(&xTextViewSetIndent, libs, "gtk_text_view_set_indent")
	core.PuregoSafeRegister(&xTextViewSetInputHints, libs, "gtk_text_view_set_input_hints")
	core.PuregoSafeRegister(&xTextViewSetInputPurpose, libs, "gtk_text_view_set_input_purpose")
	core.PuregoSafeRegister(&xTextViewSetJustification, libs, "gtk_text_view_set_justification")
	core.PuregoSafeRegister(&xTextViewSetLeftMargin, libs, "gtk_text_view_set_left_margin")
	core.PuregoSafeRegister(&xTextViewSetMonospace, libs, "gtk_text_view_set_monospace")
	core.PuregoSafeRegister(&xTextViewSetOverwrite, libs, "gtk_text_view_set_overwrite")
	core.PuregoSafeRegister(&xTextViewSetPixelsAboveLines, libs, "gtk_text_view_set_pixels_above_lines")
	core.PuregoSafeRegister(&xTextViewSetPixelsBelowLines, libs, "gtk_text_view_set_pixels_below_lines")
	core.PuregoSafeRegister(&xTextViewSetPixelsInsideWrap, libs, "gtk_text_view_set_pixels_inside_wrap")
	core.PuregoSafeRegister(&xTextViewSetRightMargin, libs, "gtk_text_view_set_right_margin")
	core.PuregoSafeRegister(&xTextViewSetTabs, libs, "gtk_text_view_set_tabs")
	core.PuregoSafeRegister(&xTextViewSetTopMargin, libs, "gtk_text_view_set_top_margin")
	core.PuregoSafeRegister(&xTextViewSetWrapMode, libs, "gtk_text_view_set_wrap_mode")
	core.PuregoSafeRegister(&xTextViewStartsDisplayLine, libs, "gtk_text_view_starts_display_line")
	core.PuregoSafeRegister(&xTextViewWindowToBufferCoords, libs, "gtk_text_view_window_to_buffer_coords")

}
