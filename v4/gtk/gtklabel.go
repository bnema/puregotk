// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// Displays a small amount of text.
//
// Most labels are used to label another widget (such as an [class@Entry]).
//
// &lt;picture&gt;
//
//	&lt;source srcset="label-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkLabel" src="label.png"&gt;
//
// &lt;/picture&gt;
//
// ## Shortcuts and Gestures
//
// `GtkLabel` supports the following keyboard shortcuts, when the cursor is
// visible:
//
//   - &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;F10&lt;/kbd&gt; or &lt;kbd&gt;Menu&lt;/kbd&gt; opens the context menu.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;A&lt;/kbd&gt; or &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;&amp;sol;&lt;/kbd&gt;
//     selects all.
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;A&lt;/kbd&gt; or
//     &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;&amp;bsol;&lt;/kbd&gt; unselects all.
//
// Additionally, the following signals have default keybindings:
//
// - [signal@Gtk.Label::activate-current-link]
// - [signal@Gtk.Label::copy-clipboard]
// - [signal@Gtk.Label::move-cursor]
//
// ## Actions
//
// `GtkLabel` defines a set of built-in actions:
//
//   - `clipboard.copy` copies the text to the clipboard.
//   - `clipboard.cut` doesn't do anything, since text in labels can't be deleted.
//   - `clipboard.paste` doesn't do anything, since text in labels can't be
//     edited.
//   - `link.open` opens the link, when activated on a link inside the label.
//   - `link.copy` copies the link to the clipboard, when activated on a link
//     inside the label.
//   - `menu.popup` opens the context menu.
//   - `selection.delete` doesn't do anything, since text in labels can't be
//     deleted.
//   - `selection.select-all` selects all of the text, if the label allows
//     selection.
//
// ## CSS nodes
//
// ```
// label
// ├── [selection]
// ├── [link]
// ┊
// ╰── [link]
// ```
//
// `GtkLabel` has a single CSS node with the name label. A wide variety
// of style classes may be applied to labels, such as .title, .subtitle,
// .dim-label, etc. In the `GtkShortcutsWindow`, labels are used with the
// .keycap style class.
//
// If the label has a selection, it gets a subnode with name selection.
//
// If the label has links, there is one subnode per link. These subnodes
// carry the link or visited state depending on whether they have been
// visited. In this case, label node also gets a .link style class.
//
// ## GtkLabel as GtkBuildable
//
// The GtkLabel implementation of the GtkBuildable interface supports a
// custom `&lt;attributes&gt;` element, which supports any number of `&lt;attribute&gt;`
// elements. The `&lt;attribute&gt;` element has attributes named “name“, “value“,
// “start“ and “end“ and allows you to specify [struct@Pango.Attribute]
// values for this label.
//
// An example of a UI definition fragment specifying Pango attributes:
//
// ```xml
// &lt;object class="GtkLabel"&gt;
//
//	&lt;attributes&gt;
//	  &lt;attribute name="weight" value="PANGO_WEIGHT_BOLD"/&gt;
//	  &lt;attribute name="background" value="red" start="5" end="10"/&gt;
//	&lt;/attributes&gt;
//
// &lt;/object&gt;
// ```
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
// ## Accessibility
//
// `GtkLabel` uses the [enum@Gtk.AccessibleRole.label] role.
//
// ## Mnemonics
//
// Labels may contain “mnemonics”. Mnemonics are underlined characters in the
// label, used for keyboard navigation. Mnemonics are created by providing a
// string with an underscore before the mnemonic character, such as `"_File"`,
// to the functions [ctor@Gtk.Label.new_with_mnemonic] or
// [method@Gtk.Label.set_text_with_mnemonic].
//
// Mnemonics automatically activate any activatable widget the label is
// inside, such as a [class@Gtk.Button]; if the label is not inside the
// mnemonic’s target widget, you have to tell the label about the target
// using [method@Gtk.Label.set_mnemonic_widget].
//
// Here’s a simple example where the label is inside a button:
//
// ```c
// // Pressing Alt+H will activate this button
// GtkWidget *button = gtk_button_new ();
// GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_button_set_child (GTK_BUTTON (button), label);
// ```
//
// There’s a convenience function to create buttons with a mnemonic label
// already inside:
//
// ```c
// // Pressing Alt+H will activate this button
// GtkWidget *button = gtk_button_new_with_mnemonic ("_Hello");
// ```
//
// To create a mnemonic for a widget alongside the label, such as a
// [class@Gtk.Entry], you have to point the label at the entry with
// [method@Gtk.Label.set_mnemonic_widget]:
//
// ```c
// // Pressing Alt+H will focus the entry
// GtkWidget *entry = gtk_entry_new ();
// GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry);
// ```
//
// ## Markup (styled text)
//
// To make it easy to format text in a label (changing colors, fonts, etc.),
// label text can be provided in a simple markup format:
//
// Here’s how to create a label with a small font:
// ```c
// GtkWidget *label = gtk_label_new (NULL);
// gtk_label_set_markup (GTK_LABEL (label), "&lt;small&gt;Small text&lt;/small&gt;");
// ```
//
// (See the Pango manual for complete documentation] of available
// tags, [func@Pango.parse_markup])
//
// The markup passed to [method@Gtk.Label.set_markup] must be valid XML; for example,
// literal `&lt;`, `&gt;` and `&amp;` characters must be escaped as `&amp;lt;`, `&amp;gt;`, and `&amp;amp;`.
// If you pass text obtained from the user, file, or a network to
// [method@Gtk.Label.set_markup], you’ll want to escape it with
// [func@GLib.markup_escape_text] or [func@GLib.markup_printf_escaped].
//
// Markup strings are just a convenient way to set the [struct@Pango.AttrList]
// on a label; [method@Gtk.Label.set_attributes] may be a simpler way to set
// attributes in some cases. Be careful though; [struct@Pango.AttrList] tends
// to cause internationalization problems, unless you’re applying attributes
// to the entire string (i.e. unless you set the range of each attribute
// to [0, `G_MAXINT`)). The reason is that specifying the `start_index` and
// `end_index` for a [struct@Pango.Attribute] requires knowledge of the exact
// string being displayed, so translations will cause problems.
//
// ## Selectable labels
//
// Labels can be made selectable with [method@Gtk.Label.set_selectable].
// Selectable labels allow the user to copy the label contents to the
// clipboard. Only labels that contain useful-to-copy information — such
// as error messages — should be made selectable.
//
// ## Text layout
//
// A label can contain any number of paragraphs, but will have
// performance problems if it contains more than a small number.
// Paragraphs are separated by newlines or other paragraph separators
// understood by Pango.
//
// Labels can automatically wrap text if you call [method@Gtk.Label.set_wrap].
//
// [method@Gtk.Label.set_justify] sets how the lines in a label align
// with one another. If you want to set how the label as a whole aligns
// in its available space, see the [property@Gtk.Widget:halign] and
// [property@Gtk.Widget:valign] properties.
//
// The [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
// properties can be used to control the size allocation of ellipsized or
// wrapped labels. For ellipsizing labels, if either is specified (and less
// than the actual text size), it is used as the minimum width, and the actual
// text size is used as the natural width of the label. For wrapping labels,
// width-chars is used as the minimum width, if specified, and max-width-chars
// is used as the natural width. Even if max-width-chars specified, wrapping
// labels will be rewrapped to use all of the available width.
//
// ## Links
//
// GTK supports markup for clickable hyperlinks in addition to regular Pango
// markup. The markup for links is borrowed from HTML, using the `&lt;a&gt;` tag
// with “href“, “title“ and “class“ attributes. GTK renders links similar to
// the way they appear in web browsers, with colored, underlined text. The
// “title“ attribute is displayed as a tooltip on the link. The “class“
// attribute is used as style class on the CSS node for the link.
//
// An example of inline links looks like this:
//
// ```c
// const char *text =
// "Go to the "
// "&lt;a href=\"https://www.gtk.org\" title=\"&amp;lt;i&amp;gt;Our&amp;lt;/i&amp;gt; website\"&gt;"
// "GTK website&lt;/a&gt; for more...";
// GtkWidget *label = gtk_label_new (NULL);
// gtk_label_set_markup (GTK_LABEL (label), text);
// ```
//
// It is possible to implement custom handling for links and their tooltips
// with the [signal@Gtk.Label::activate-link] signal and the
// [method@Gtk.Label.get_current_uri] function.
type Label struct {
	Widget
}

var xLabelGLibType func() types.GType

func LabelGLibType() types.GType {
	return xLabelGLibType()
}

func LabelNewFromInternalPtr(ptr uintptr) *Label {
	cls := &Label{}
	cls.Ptr = ptr
	return cls
}

var xNewLabel func(uintptr) uintptr

// Creates a new label with the given text inside it.
//
// You can pass `NULL` to get an empty label widget.
func NewLabel(StrVar *string) *Label {
	var cls *Label

	cret := xNewLabel(core.NullableStringToPtr(StrVar))

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Label{}
	cls.Ptr = cret
	return cls
}

var xNewLabelWithMnemonic func(uintptr) uintptr

// Creates a new label with the given text inside it, and a mnemonic.
//
// If characters in @str are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use
// '__' (two underscores). The first underlined character represents a
// keyboard accelerator called a mnemonic. The mnemonic key can be used
// to activate another widget, chosen automatically, or explicitly using
// [method@Gtk.Label.set_mnemonic_widget].
//
// If [method@Gtk.Label.set_mnemonic_widget] is not called, then the first
// activatable ancestor of the label will be chosen as the mnemonic
// widget. For instance, if the label is inside a button or menu item,
// the button or menu item will automatically become the mnemonic widget
// and be activated by the mnemonic.
func NewLabelWithMnemonic(StrVar *string) *Label {
	var cls *Label

	cret := xNewLabelWithMnemonic(core.NullableStringToPtr(StrVar))

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Label{}
	cls.Ptr = cret
	return cls
}

var xLabelGetAttributes func(uintptr) *pango.AttrList

// Gets the label's attribute list.
//
// This is the [struct@Pango.AttrList] that was set on the label using
// [method@Gtk.Label.set_attributes], if any. This function does not
// reflect attributes that come from the label's markup (see
// [method@Gtk.Label.set_markup]). If you want to get the effective
// attributes for the label, use
// `pango_layout_get_attributes (gtk_label_get_layout (self))`.
func (x *Label) GetAttributes() *pango.AttrList {

	cret := xLabelGetAttributes(x.GoPointer())
	return cret
}

var xLabelGetCurrentUri func(uintptr) string

// Returns the URI for the active link in the label.
//
// The active link is the one under the mouse pointer or, in a
// selectable label, the link in which the text cursor is currently
// positioned.
//
// This function is intended for use in a [signal@Gtk.Label::activate-link]
// handler or for use in a [signal@Gtk.Widget::query-tooltip] handler.
func (x *Label) GetCurrentUri() string {

	cret := xLabelGetCurrentUri(x.GoPointer())
	return cret
}

var xLabelGetEllipsize func(uintptr) pango.EllipsizeMode

// Returns the ellipsization mode of the label.
//
// See [method@Gtk.Label.set_ellipsize].
func (x *Label) GetEllipsize() pango.EllipsizeMode {

	cret := xLabelGetEllipsize(x.GoPointer())
	return cret
}

var xLabelGetExtraMenu func(uintptr) uintptr

// Gets the extra menu model of the label.
//
// See [method@Gtk.Label.set_extra_menu].
func (x *Label) GetExtraMenu() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xLabelGetExtraMenu(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xLabelGetJustify func(uintptr) Justification

// Returns the justification of the label.
//
// See [method@Gtk.Label.set_justify].
func (x *Label) GetJustify() Justification {

	cret := xLabelGetJustify(x.GoPointer())
	return cret
}

var xLabelGetLabel func(uintptr) string

// Fetches the text from a label.
//
// The returned text includes any embedded underlines indicating
// mnemonics and Pango markup. (See [method@Gtk.Label.get_text]).
func (x *Label) GetLabel() string {

	cret := xLabelGetLabel(x.GoPointer())
	return cret
}

var xLabelGetLayout func(uintptr) uintptr

// Gets the Pango layout used to display the label.
//
// The layout is useful to e.g. convert text positions to pixel
// positions, in combination with [method@Gtk.Label.get_layout_offsets].
// The returned layout is owned by the @label so need not be
// freed by the caller. The @label is free to recreate its layout
// at any time, so it should be considered read-only.
func (x *Label) GetLayout() *pango.Layout {
	var cls *pango.Layout

	cret := xLabelGetLayout(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &pango.Layout{}
	cls.Ptr = cret
	return cls
}

var xLabelGetLayoutOffsets func(uintptr, *int, *int)

// Obtains the coordinates where the label will draw its Pango layout.
//
// The coordinates are useful to convert mouse events into coordinates
// inside the [class@Pango.Layout], e.g. to take some action if some part
// of the label is clicked. Remember when using the [class@Pango.Layout]
// functions you need to convert to and from pixels using `PANGO_PIXELS()`
// or [const@Pango.SCALE].
func (x *Label) GetLayoutOffsets(XVar *int, YVar *int) {

	xLabelGetLayoutOffsets(x.GoPointer(), XVar, YVar)

}

var xLabelGetLines func(uintptr) int

// Gets the number of lines to which an ellipsized, wrapping
// label should be limited.
//
// See [method@Gtk.Label.set_lines].
func (x *Label) GetLines() int {

	cret := xLabelGetLines(x.GoPointer())
	return cret
}

var xLabelGetMaxWidthChars func(uintptr) int

// Retrieves the maximum width of the label in characters.
//
// See [method@Gtk.Label.set_width_chars].
func (x *Label) GetMaxWidthChars() int {

	cret := xLabelGetMaxWidthChars(x.GoPointer())
	return cret
}

var xLabelGetMnemonicKeyval func(uintptr) uint

// Return the mnemonic accelerator.
//
// If the label has been set so that it has a mnemonic key this function
// returns the keyval used for the mnemonic accelerator. If there is no
// mnemonic set up it returns `GDK_KEY_VoidSymbol`.
func (x *Label) GetMnemonicKeyval() uint {

	cret := xLabelGetMnemonicKeyval(x.GoPointer())
	return cret
}

var xLabelGetMnemonicWidget func(uintptr) uintptr

// Retrieves the mnemonic target of this label.
//
// See [method@Gtk.Label.set_mnemonic_widget].
func (x *Label) GetMnemonicWidget() *Widget {
	var cls *Widget

	cret := xLabelGetMnemonicWidget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xLabelGetNaturalWrapMode func(uintptr) NaturalWrapMode

// Returns natural line wrap mode used by the label.
//
// See [method@Gtk.Label.set_natural_wrap_mode].
func (x *Label) GetNaturalWrapMode() NaturalWrapMode {

	cret := xLabelGetNaturalWrapMode(x.GoPointer())
	return cret
}

var xLabelGetSelectable func(uintptr) bool

// Returns whether the label is selectable.
func (x *Label) GetSelectable() bool {

	cret := xLabelGetSelectable(x.GoPointer())
	return cret
}

var xLabelGetSelectionBounds func(uintptr, *int, *int) bool

// Gets the selected range of characters in the label.
//
// The returned @start and @end positions are in characters.
func (x *Label) GetSelectionBounds(StartVar *int, EndVar *int) bool {

	cret := xLabelGetSelectionBounds(x.GoPointer(), StartVar, EndVar)
	return cret
}

var xLabelGetSingleLineMode func(uintptr) bool

// Returns whether the label is in single line mode.
func (x *Label) GetSingleLineMode() bool {

	cret := xLabelGetSingleLineMode(x.GoPointer())
	return cret
}

var xLabelGetTabs func(uintptr) *pango.TabArray

// Gets the tab stops for the label.
//
// The returned array will be `NULL` if “standard” (8-space) tabs are used.
func (x *Label) GetTabs() *pango.TabArray {

	cret := xLabelGetTabs(x.GoPointer())
	return cret
}

var xLabelGetText func(uintptr) string

// Gets the text of the label.
//
// The returned text is as it appears on screen. This does not include
// any embedded underlines indicating mnemonics or Pango markup. (See
// [method@Gtk.Label.get_label])
func (x *Label) GetText() string {

	cret := xLabelGetText(x.GoPointer())
	return cret
}

var xLabelGetUseMarkup func(uintptr) bool

// Returns whether the label’s text is interpreted as Pango markup.
//
// See [method@Gtk.Label.set_use_markup].
func (x *Label) GetUseMarkup() bool {

	cret := xLabelGetUseMarkup(x.GoPointer())
	return cret
}

var xLabelGetUseUnderline func(uintptr) bool

// Returns whether underlines in the label indicate mnemonics.
//
// See [method@Gtk.Label.set_use_underline].
func (x *Label) GetUseUnderline() bool {

	cret := xLabelGetUseUnderline(x.GoPointer())
	return cret
}

var xLabelGetWidthChars func(uintptr) int

// Retrieves the desired width of the label in characters.
//
// See [method@Gtk.Label.set_width_chars].
func (x *Label) GetWidthChars() int {

	cret := xLabelGetWidthChars(x.GoPointer())
	return cret
}

var xLabelGetWrap func(uintptr) bool

// Returns whether lines in the label are automatically wrapped.
//
// See [method@Gtk.Label.set_wrap].
func (x *Label) GetWrap() bool {

	cret := xLabelGetWrap(x.GoPointer())
	return cret
}

var xLabelGetWrapMode func(uintptr) pango.WrapMode

// Returns line wrap mode used by the label.
//
// See [method@Gtk.Label.set_wrap_mode].
func (x *Label) GetWrapMode() pango.WrapMode {

	cret := xLabelGetWrapMode(x.GoPointer())
	return cret
}

var xLabelGetXalign func(uintptr) float32

// Gets the `xalign` of the label.
//
// See the [property@Gtk.Label:xalign] property.
func (x *Label) GetXalign() float32 {

	cret := xLabelGetXalign(x.GoPointer())
	return cret
}

var xLabelGetYalign func(uintptr) float32

// Gets the `yalign` of the label.
//
// See the [property@Gtk.Label:yalign] property.
func (x *Label) GetYalign() float32 {

	cret := xLabelGetYalign(x.GoPointer())
	return cret
}

var xLabelSelectRegion func(uintptr, int, int)

// Selects a range of characters in the label, if the label is selectable.
//
// See [method@Gtk.Label.set_selectable]. If the label is not selectable,
// this function has no effect. If @start_offset or
// @end_offset are -1, then the end of the label will be substituted.
func (x *Label) SelectRegion(StartOffsetVar int, EndOffsetVar int) {

	xLabelSelectRegion(x.GoPointer(), StartOffsetVar, EndOffsetVar)

}

var xLabelSetAttributes func(uintptr, *pango.AttrList)

// Apply attributes to the label text.
//
// The attributes set with this function will be applied and merged with
// any other attributes previously effected by way of the
// [property@Gtk.Label:use-underline] or [property@Gtk.Label:use-markup]
// properties
//
// While it is not recommended to mix markup strings with manually set
// attributes, if you must; know that the attributes will be applied
// to the label after the markup string is parsed.
func (x *Label) SetAttributes(AttrsVar *pango.AttrList) {

	xLabelSetAttributes(x.GoPointer(), AttrsVar)

}

var xLabelSetEllipsize func(uintptr, pango.EllipsizeMode)

// Sets the mode used to ellipsize the text.
//
// The text will be ellipsized if there is not
// enough space to render the entire string.
func (x *Label) SetEllipsize(ModeVar pango.EllipsizeMode) {

	xLabelSetEllipsize(x.GoPointer(), ModeVar)

}

var xLabelSetExtraMenu func(uintptr, uintptr)

// Sets a menu model to add to the context menu of the label.
func (x *Label) SetExtraMenu(ModelVar *gio.MenuModel) {

	xLabelSetExtraMenu(x.GoPointer(), ModelVar.GoPointer())

}

var xLabelSetJustify func(uintptr, Justification)

// Sets the alignment of lines in the label relative to each other.
//
// This function has no effect on labels containing only a single line.
//
// [enum@Gtk.Justification.left] is the default value when the widget
// is first created with [ctor@Gtk.Label.new].
//
// If you instead want to set the alignment of the label as a whole,
// use [method@Gtk.Widget.set_halign] instead.
func (x *Label) SetJustify(JtypeVar Justification) {

	xLabelSetJustify(x.GoPointer(), JtypeVar)

}

var xLabelSetLabel func(uintptr, string)

// Sets the text of the label.
//
// The label is interpreted as including embedded underlines and/or Pango
// markup depending on the values of the [property@Gtk.Label:use-underline]
// and [property@Gtk.Label:use-markup] properties.
func (x *Label) SetLabel(StrVar string) {

	xLabelSetLabel(x.GoPointer(), StrVar)

}

var xLabelSetLines func(uintptr, int)

// Sets the number of lines to which an ellipsized, wrapping label
// should be limited.
//
// This has no effect if the label is not wrapping or ellipsized.
// Set this to -1 if you don’t want to limit the number of lines.
func (x *Label) SetLines(LinesVar int) {

	xLabelSetLines(x.GoPointer(), LinesVar)

}

var xLabelSetMarkup func(uintptr, string)

// Sets the labels text and attributes from markup.
//
// The string must be marked up with Pango markup
// (see [func@Pango.parse_markup]).
//
// If @str is external data, you may need to escape it
// with [func@GLib.markup_escape_text] or [func@GLib.markup_printf_escaped]:
//
// ```c
// GtkWidget *self = gtk_label_new (NULL);
// const char *str = "...";
// const char *format = "&lt;span style=\"italic\"&gt;\%s&lt;/span&gt;";
// char *markup;
//
// markup = g_markup_printf_escaped (format, str);
// gtk_label_set_markup (GTK_LABEL (self), markup);
// g_free (markup);
// ```
//
// This function sets the [property@Gtk.Label:use-markup] property
// to true.
//
// Also see [method@Gtk.Label.set_text].
func (x *Label) SetMarkup(StrVar string) {

	xLabelSetMarkup(x.GoPointer(), StrVar)

}

var xLabelSetMarkupWithMnemonic func(uintptr, string)

// Sets the labels text, attributes and mnemonic from markup.
//
// Parses @str which is marked up with Pango markup (see [func@Pango.parse_markup]),
// setting the label’s text and attribute list based on the parse results.
// If characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using [method@Gtk.Label.set_mnemonic_widget].
func (x *Label) SetMarkupWithMnemonic(StrVar string) {

	xLabelSetMarkupWithMnemonic(x.GoPointer(), StrVar)

}

var xLabelSetMaxWidthChars func(uintptr, int)

// Sets the maximum width of the label in characters.
func (x *Label) SetMaxWidthChars(NCharsVar int) {

	xLabelSetMaxWidthChars(x.GoPointer(), NCharsVar)

}

var xLabelSetMnemonicWidget func(uintptr, uintptr)

// Associate the label with its mnemonic target.
//
// If the label has been set so that it has a mnemonic key (using
// i.e. [method@Gtk.Label.set_markup_with_mnemonic],
// [method@Gtk.Label.set_text_with_mnemonic],
// [ctor@Gtk.Label.new_with_mnemonic]
// or the [property@Gtk.Label:use_underline] property) the label can
// be associated with a widget that is the target of the mnemonic.
// When the label is inside a widget (like a [class@Gtk.Button] or a
// [class@Gtk.Notebook] tab) it is automatically associated with the
// correct widget, but sometimes (i.e. when the target is a [class@Gtk.Entry]
// next to the label) you need to set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// [signal@Gtk.Widget::mnemonic-activate] signal on it. The default handler
// for this signal will activate the widget if there are no mnemonic
// collisions and toggle focus between the colliding widgets otherwise.
func (x *Label) SetMnemonicWidget(WidgetVar *Widget) {

	xLabelSetMnemonicWidget(x.GoPointer(), WidgetVar.GoPointer())

}

var xLabelSetNaturalWrapMode func(uintptr, NaturalWrapMode)

// Selects the line wrapping for the natural size request.
//
// This only affects the natural size requested, for the actual wrapping used,
// see the [property@Gtk.Label:wrap-mode] property.
func (x *Label) SetNaturalWrapMode(WrapModeVar NaturalWrapMode) {

	xLabelSetNaturalWrapMode(x.GoPointer(), WrapModeVar)

}

var xLabelSetSelectable func(uintptr, bool)

// Makes text in the label selectable.
//
// Selectable labels allow the user to select text from the label,
// for copy-and-paste.
func (x *Label) SetSelectable(SettingVar bool) {

	xLabelSetSelectable(x.GoPointer(), SettingVar)

}

var xLabelSetSingleLineMode func(uintptr, bool)

// Sets whether the label is in single line mode.
func (x *Label) SetSingleLineMode(SingleLineModeVar bool) {

	xLabelSetSingleLineMode(x.GoPointer(), SingleLineModeVar)

}

var xLabelSetTabs func(uintptr, *pango.TabArray)

// Sets tab stops for the label.
func (x *Label) SetTabs(TabsVar *pango.TabArray) {

	xLabelSetTabs(x.GoPointer(), TabsVar)

}

var xLabelSetText func(uintptr, string)

// Sets the text for the label.
//
// It overwrites any text that was there before and clears any
// previously set mnemonic accelerators, and sets the
// [property@Gtk.Label:use-underline] and
// [property@Gtk.Label:use-markup] properties to false.
//
// Also see [method@Gtk.Label.set_markup].
func (x *Label) SetText(StrVar string) {

	xLabelSetText(x.GoPointer(), StrVar)

}

var xLabelSetTextWithMnemonic func(uintptr, string)

// Sets the text for the label, with mnemonics.
//
// If characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using [method@Gtk.Label.set_mnemonic_widget].
func (x *Label) SetTextWithMnemonic(StrVar string) {

	xLabelSetTextWithMnemonic(x.GoPointer(), StrVar)

}

var xLabelSetUseMarkup func(uintptr, bool)

// Sets whether the text of the label contains markup.
//
// See [method@Gtk.Label.set_markup].
func (x *Label) SetUseMarkup(SettingVar bool) {

	xLabelSetUseMarkup(x.GoPointer(), SettingVar)

}

var xLabelSetUseUnderline func(uintptr, bool)

// Sets whether underlines in the text indicate mnemonics.
func (x *Label) SetUseUnderline(SettingVar bool) {

	xLabelSetUseUnderline(x.GoPointer(), SettingVar)

}

var xLabelSetWidthChars func(uintptr, int)

// Sets the desired width in characters of the label.
func (x *Label) SetWidthChars(NCharsVar int) {

	xLabelSetWidthChars(x.GoPointer(), NCharsVar)

}

var xLabelSetWrap func(uintptr, bool)

// Toggles line wrapping within the label.
//
// True makes it break lines if text exceeds the widget’s size.
// false lets the text get cut off by the edge of the widget if
// it exceeds the widget size.
//
// Note that setting line wrapping to true does not make the label
// wrap at its parent widget’s width, because GTK widgets conceptually
// can’t make their requisition depend on the parent  widget’s size.
// For a label that wraps at a specific position, set the label’s width
// using [method@Gtk.Widget.set_size_request].
func (x *Label) SetWrap(WrapVar bool) {

	xLabelSetWrap(x.GoPointer(), WrapVar)

}

var xLabelSetWrapMode func(uintptr, pango.WrapMode)

// Controls how line wrapping is done.
//
// This only affects the label if line wrapping is on. (See
// [method@Gtk.Label.set_wrap])
//
// The default is [enum@Pango.WrapMode.word], which means
// wrap on word boundaries.
//
// For sizing behavior, also consider the
// [property@Gtk.Label:natural-wrap-mode] property.
func (x *Label) SetWrapMode(WrapModeVar pango.WrapMode) {

	xLabelSetWrapMode(x.GoPointer(), WrapModeVar)

}

var xLabelSetXalign func(uintptr, float32)

// Sets the `xalign` of the label.
//
// See the [property@Gtk.Label:xalign] property.
func (x *Label) SetXalign(XalignVar float32) {

	xLabelSetXalign(x.GoPointer(), XalignVar)

}

var xLabelSetYalign func(uintptr, float32)

// Sets the `yalign` of the label.
//
// See the [property@Gtk.Label:yalign] property.
func (x *Label) SetYalign(YalignVar float32) {

	xLabelSetYalign(x.GoPointer(), YalignVar)

}

func (c *Label) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Label) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAttributes sets the "attributes" property.
// A list of style attributes to apply to the text of the label.
func (x *Label) SetPropertyAttributes(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("attributes", &v)
}

// GetPropertyAttributes gets the "attributes" property.
// A list of style attributes to apply to the text of the label.
func (x *Label) GetPropertyAttributes() uintptr {
	var v gobject.Value
	x.GetProperty("attributes", &v)
	return v.GetPointer()
}

// SetPropertyLabel sets the "label" property.
// The contents of the label.
//
// If the string contains Pango markup (see [func@Pango.parse_markup]),
// you will have to set the [property@Gtk.Label:use-markup] property to
// true in order for the label to display the markup attributes. See also
// [method@Gtk.Label.set_markup] for a convenience function that sets both
// this property and the [property@Gtk.Label:use-markup] property at the
// same time.
//
// If the string contains underlines acting as mnemonics, you will have to
// set the [property@Gtk.Label:use-underline] property to true in order
// for the label to display them.
func (x *Label) SetPropertyLabel(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("label", &v)
}

// GetPropertyLabel gets the "label" property.
// The contents of the label.
//
// If the string contains Pango markup (see [func@Pango.parse_markup]),
// you will have to set the [property@Gtk.Label:use-markup] property to
// true in order for the label to display the markup attributes. See also
// [method@Gtk.Label.set_markup] for a convenience function that sets both
// this property and the [property@Gtk.Label:use-markup] property at the
// same time.
//
// If the string contains underlines acting as mnemonics, you will have to
// set the [property@Gtk.Label:use-underline] property to true in order
// for the label to display them.
func (x *Label) GetPropertyLabel() string {
	var v gobject.Value
	x.GetProperty("label", &v)
	return v.GetString()
}

// SetPropertyLines sets the "lines" property.
// The number of lines to which an ellipsized, wrapping label
// should display before it gets ellipsized. This both prevents the label
// from ellipsizing before this many lines are displayed, and limits the
// height request of the label to this many lines.
//
// ::: warning
//
//	Setting this property has unintuitive and unfortunate consequences
//	for the minimum _width_ of the label. Specifically, if the height
//	of the label is such that it fits a smaller number of lines than
//	the value of this property, the label can not be ellipsized at all,
//	which means it must be wide enough to fit all the text fully.
//
// This property has no effect if the label is not wrapping or ellipsized.
//
// Set this property to -1 if you don't want to limit the number of lines.
func (x *Label) SetPropertyLines(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("lines", &v)
}

// GetPropertyLines gets the "lines" property.
// The number of lines to which an ellipsized, wrapping label
// should display before it gets ellipsized. This both prevents the label
// from ellipsizing before this many lines are displayed, and limits the
// height request of the label to this many lines.
//
// ::: warning
//
//	Setting this property has unintuitive and unfortunate consequences
//	for the minimum _width_ of the label. Specifically, if the height
//	of the label is such that it fits a smaller number of lines than
//	the value of this property, the label can not be ellipsized at all,
//	which means it must be wide enough to fit all the text fully.
//
// This property has no effect if the label is not wrapping or ellipsized.
//
// Set this property to -1 if you don't want to limit the number of lines.
func (x *Label) GetPropertyLines() int {
	var v gobject.Value
	x.GetProperty("lines", &v)
	return v.GetInt()
}

// SetPropertyMaxWidthChars sets the "max-width-chars" property.
// The desired maximum width of the label, in characters.
//
// If this property is set to -1, the width will be calculated automatically.
//
// See the section on [text layout](class.Label.html#text-layout) for details
// of how [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
// determine the width of ellipsized and wrapped labels.
func (x *Label) SetPropertyMaxWidthChars(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("max-width-chars", &v)
}

// GetPropertyMaxWidthChars gets the "max-width-chars" property.
// The desired maximum width of the label, in characters.
//
// If this property is set to -1, the width will be calculated automatically.
//
// See the section on [text layout](class.Label.html#text-layout) for details
// of how [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
// determine the width of ellipsized and wrapped labels.
func (x *Label) GetPropertyMaxWidthChars() int {
	var v gobject.Value
	x.GetProperty("max-width-chars", &v)
	return v.GetInt()
}

// GetPropertyMnemonicKeyval gets the "mnemonic-keyval" property.
// The mnemonic accelerator key for the label.
func (x *Label) GetPropertyMnemonicKeyval() uint {
	var v gobject.Value
	x.GetProperty("mnemonic-keyval", &v)
	return v.GetUint()
}

// SetPropertySelectable sets the "selectable" property.
// Whether the label text can be selected with the mouse.
func (x *Label) SetPropertySelectable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("selectable", &v)
}

// GetPropertySelectable gets the "selectable" property.
// Whether the label text can be selected with the mouse.
func (x *Label) GetPropertySelectable() bool {
	var v gobject.Value
	x.GetProperty("selectable", &v)
	return v.GetBoolean()
}

// SetPropertySingleLineMode sets the "single-line-mode" property.
// Whether the label is in single line mode.
//
// In single line mode, the height of the label does not depend on the
// actual text, it is always set to ascent + descent of the font. This
// can be an advantage in situations where resizing the label because
// of text changes would be distracting, e.g. in a statusbar.
func (x *Label) SetPropertySingleLineMode(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("single-line-mode", &v)
}

// GetPropertySingleLineMode gets the "single-line-mode" property.
// Whether the label is in single line mode.
//
// In single line mode, the height of the label does not depend on the
// actual text, it is always set to ascent + descent of the font. This
// can be an advantage in situations where resizing the label because
// of text changes would be distracting, e.g. in a statusbar.
func (x *Label) GetPropertySingleLineMode() bool {
	var v gobject.Value
	x.GetProperty("single-line-mode", &v)
	return v.GetBoolean()
}

// SetPropertyTabs sets the "tabs" property.
// Custom tabs for this label.
func (x *Label) SetPropertyTabs(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("tabs", &v)
}

// GetPropertyTabs gets the "tabs" property.
// Custom tabs for this label.
func (x *Label) GetPropertyTabs() uintptr {
	var v gobject.Value
	x.GetProperty("tabs", &v)
	return v.GetPointer()
}

// SetPropertyUseMarkup sets the "use-markup" property.
// True if the text of the label includes Pango markup.
//
// See [func@Pango.parse_markup].
func (x *Label) SetPropertyUseMarkup(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("use-markup", &v)
}

// GetPropertyUseMarkup gets the "use-markup" property.
// True if the text of the label includes Pango markup.
//
// See [func@Pango.parse_markup].
func (x *Label) GetPropertyUseMarkup() bool {
	var v gobject.Value
	x.GetProperty("use-markup", &v)
	return v.GetBoolean()
}

// SetPropertyUseUnderline sets the "use-underline" property.
// True if the text of the label indicates a mnemonic with an `_`
// before the mnemonic character.
func (x *Label) SetPropertyUseUnderline(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("use-underline", &v)
}

// GetPropertyUseUnderline gets the "use-underline" property.
// True if the text of the label indicates a mnemonic with an `_`
// before the mnemonic character.
func (x *Label) GetPropertyUseUnderline() bool {
	var v gobject.Value
	x.GetProperty("use-underline", &v)
	return v.GetBoolean()
}

// SetPropertyWidthChars sets the "width-chars" property.
// The desired width of the label, in characters.
//
// If this property is set to -1, the width will be calculated automatically.
//
// See the section on [text layout](class.Label.html#text-layout) for details
// of how [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
// determine the width of ellipsized and wrapped labels.
func (x *Label) SetPropertyWidthChars(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("width-chars", &v)
}

// GetPropertyWidthChars gets the "width-chars" property.
// The desired width of the label, in characters.
//
// If this property is set to -1, the width will be calculated automatically.
//
// See the section on [text layout](class.Label.html#text-layout) for details
// of how [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
// determine the width of ellipsized and wrapped labels.
func (x *Label) GetPropertyWidthChars() int {
	var v gobject.Value
	x.GetProperty("width-chars", &v)
	return v.GetInt()
}

// SetPropertyWrap sets the "wrap" property.
// True if the label text will wrap if it gets too wide.
func (x *Label) SetPropertyWrap(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("wrap", &v)
}

// GetPropertyWrap gets the "wrap" property.
// True if the label text will wrap if it gets too wide.
func (x *Label) GetPropertyWrap() bool {
	var v gobject.Value
	x.GetProperty("wrap", &v)
	return v.GetBoolean()
}

// SetPropertyXalign sets the "xalign" property.
// The horizontal alignment of the label text inside its size allocation.
//
// Compare this to [property@Gtk.Widget:halign], which determines how the
// labels size allocation is positioned in the space available for the label.
func (x *Label) SetPropertyXalign(value float32) {
	var v gobject.Value
	v.Init(gobject.TypeFloatVal)
	v.SetFloat(value)
	x.SetProperty("xalign", &v)
}

// GetPropertyXalign gets the "xalign" property.
// The horizontal alignment of the label text inside its size allocation.
//
// Compare this to [property@Gtk.Widget:halign], which determines how the
// labels size allocation is positioned in the space available for the label.
func (x *Label) GetPropertyXalign() float32 {
	var v gobject.Value
	x.GetProperty("xalign", &v)
	return v.GetFloat()
}

// SetPropertyYalign sets the "yalign" property.
// The vertical alignment of the label text inside its size allocation.
//
// Compare this to [property@Gtk.Widget:valign], which determines how the
// labels size allocation is positioned in the space available for the label.
func (x *Label) SetPropertyYalign(value float32) {
	var v gobject.Value
	v.Init(gobject.TypeFloatVal)
	v.SetFloat(value)
	x.SetProperty("yalign", &v)
}

// GetPropertyYalign gets the "yalign" property.
// The vertical alignment of the label text inside its size allocation.
//
// Compare this to [property@Gtk.Widget:valign], which determines how the
// labels size allocation is positioned in the space available for the label.
func (x *Label) GetPropertyYalign() float32 {
	var v gobject.Value
	x.GetProperty("yalign", &v)
	return v.GetFloat()
}

// Gets emitted when the user activates a link in the label.
//
// The `::activate-current-link` is a [keybinding signal](class.SignalAction.html).
//
// Applications may also emit the signal with g_signal_emit_by_name()
// if they need to control activation of URIs programmatically.
//
// The default bindings for this signal are all forms of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
func (x *Label) ConnectActivateCurrentLink(cb *func(Label)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate-current-link", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Label{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate-current-link", cbRefPtr)
}

// Gets emitted to activate a URI.
//
// Applications may connect to it to override the default behaviour,
// which is to call [method@Gtk.FileLauncher.launch].
func (x *Label) ConnectActivateLink(cb *func(Label, string) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate-link", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, UriVarp string) bool {
		fa := Label{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, UriVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate-link", cbRefPtr)
}

// Gets emitted to copy the selection to the clipboard.
//
// The `::copy-clipboard` signal is a [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;c&lt;/kbd&gt;.
func (x *Label) ConnectCopyClipboard(cb *func(Label)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "copy-clipboard", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Label{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "copy-clipboard", cbRefPtr)
}

// Gets emitted when the user initiates a cursor movement.
//
// The `::move-cursor` signal is a [keybinding signal](class.SignalAction.html).
// If the cursor is not visible in @entry, this signal causes the viewport to
// be moved instead.
//
// Applications should not connect to it, but may emit it with
// [func@GObject.signal_emit_by_name] if they need to control
// the cursor programmatically.
//
// The default bindings for this signal come in two variants, the
// variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the selection,
// the variant without the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier does not.
// There are too many key combinations to list them all here.
//
//   - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
//     move by individual characters/lines
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;←&lt;/kbd&gt;, etc. move by words/paragraphs
//   - &lt;kbd&gt;Home&lt;/kbd&gt; and &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
func (x *Label) ConnectMoveCursor(cb *func(Label, MovementStep, int, bool)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StepVarp MovementStep, CountVarp int, ExtendSelectionVarp bool) {
		fa := Label{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StepVarp, CountVarp, ExtendSelectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *Label) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *Label) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *Label) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *Label) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *Label) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *Label) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *Label) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *Label) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *Label) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *Label) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *Label) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *Label) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *Label) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *Label) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Label) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Label) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Label) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Label) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Label) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Label) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Updates the position of the caret.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time the caret has moved, in order to notify assistive
// technologies.
func (x *Label) UpdateCaretPosition() {

	XGtkAccessibleTextUpdateCaretPosition(x.GoPointer())

}

// Notifies assistive technologies of a change in contents.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time their contents change as the result of an operation,
// like an insertion or a removal.
//
// Note: If the change is a deletion, this function must be called *before*
// removing the contents, if it is an insertion, it must be called *after*
// inserting the new contents.
func (x *Label) UpdateContents(ChangeVar AccessibleTextContentChange, StartVar uint, EndVar uint) {

	XGtkAccessibleTextUpdateContents(x.GoPointer(), ChangeVar, StartVar, EndVar)

}

// Updates the boundary of the selection.
//
// Implementations of the `GtkAccessibleText` interface should call this
// function every time the selection has moved, in order to notify assistive
// technologies.
func (x *Label) UpdateSelectionBound() {

	XGtkAccessibleTextUpdateSelectionBound(x.GoPointer())

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *Label) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xLabelGLibType, libs, "gtk_label_get_type")

	core.PuregoSafeRegister(&xNewLabel, libs, "gtk_label_new")
	core.PuregoSafeRegister(&xNewLabelWithMnemonic, libs, "gtk_label_new_with_mnemonic")

	core.PuregoSafeRegister(&xLabelGetAttributes, libs, "gtk_label_get_attributes")
	core.PuregoSafeRegister(&xLabelGetCurrentUri, libs, "gtk_label_get_current_uri")
	core.PuregoSafeRegister(&xLabelGetEllipsize, libs, "gtk_label_get_ellipsize")
	core.PuregoSafeRegister(&xLabelGetExtraMenu, libs, "gtk_label_get_extra_menu")
	core.PuregoSafeRegister(&xLabelGetJustify, libs, "gtk_label_get_justify")
	core.PuregoSafeRegister(&xLabelGetLabel, libs, "gtk_label_get_label")
	core.PuregoSafeRegister(&xLabelGetLayout, libs, "gtk_label_get_layout")
	core.PuregoSafeRegister(&xLabelGetLayoutOffsets, libs, "gtk_label_get_layout_offsets")
	core.PuregoSafeRegister(&xLabelGetLines, libs, "gtk_label_get_lines")
	core.PuregoSafeRegister(&xLabelGetMaxWidthChars, libs, "gtk_label_get_max_width_chars")
	core.PuregoSafeRegister(&xLabelGetMnemonicKeyval, libs, "gtk_label_get_mnemonic_keyval")
	core.PuregoSafeRegister(&xLabelGetMnemonicWidget, libs, "gtk_label_get_mnemonic_widget")
	core.PuregoSafeRegister(&xLabelGetNaturalWrapMode, libs, "gtk_label_get_natural_wrap_mode")
	core.PuregoSafeRegister(&xLabelGetSelectable, libs, "gtk_label_get_selectable")
	core.PuregoSafeRegister(&xLabelGetSelectionBounds, libs, "gtk_label_get_selection_bounds")
	core.PuregoSafeRegister(&xLabelGetSingleLineMode, libs, "gtk_label_get_single_line_mode")
	core.PuregoSafeRegister(&xLabelGetTabs, libs, "gtk_label_get_tabs")
	core.PuregoSafeRegister(&xLabelGetText, libs, "gtk_label_get_text")
	core.PuregoSafeRegister(&xLabelGetUseMarkup, libs, "gtk_label_get_use_markup")
	core.PuregoSafeRegister(&xLabelGetUseUnderline, libs, "gtk_label_get_use_underline")
	core.PuregoSafeRegister(&xLabelGetWidthChars, libs, "gtk_label_get_width_chars")
	core.PuregoSafeRegister(&xLabelGetWrap, libs, "gtk_label_get_wrap")
	core.PuregoSafeRegister(&xLabelGetWrapMode, libs, "gtk_label_get_wrap_mode")
	core.PuregoSafeRegister(&xLabelGetXalign, libs, "gtk_label_get_xalign")
	core.PuregoSafeRegister(&xLabelGetYalign, libs, "gtk_label_get_yalign")
	core.PuregoSafeRegister(&xLabelSelectRegion, libs, "gtk_label_select_region")
	core.PuregoSafeRegister(&xLabelSetAttributes, libs, "gtk_label_set_attributes")
	core.PuregoSafeRegister(&xLabelSetEllipsize, libs, "gtk_label_set_ellipsize")
	core.PuregoSafeRegister(&xLabelSetExtraMenu, libs, "gtk_label_set_extra_menu")
	core.PuregoSafeRegister(&xLabelSetJustify, libs, "gtk_label_set_justify")
	core.PuregoSafeRegister(&xLabelSetLabel, libs, "gtk_label_set_label")
	core.PuregoSafeRegister(&xLabelSetLines, libs, "gtk_label_set_lines")
	core.PuregoSafeRegister(&xLabelSetMarkup, libs, "gtk_label_set_markup")
	core.PuregoSafeRegister(&xLabelSetMarkupWithMnemonic, libs, "gtk_label_set_markup_with_mnemonic")
	core.PuregoSafeRegister(&xLabelSetMaxWidthChars, libs, "gtk_label_set_max_width_chars")
	core.PuregoSafeRegister(&xLabelSetMnemonicWidget, libs, "gtk_label_set_mnemonic_widget")
	core.PuregoSafeRegister(&xLabelSetNaturalWrapMode, libs, "gtk_label_set_natural_wrap_mode")
	core.PuregoSafeRegister(&xLabelSetSelectable, libs, "gtk_label_set_selectable")
	core.PuregoSafeRegister(&xLabelSetSingleLineMode, libs, "gtk_label_set_single_line_mode")
	core.PuregoSafeRegister(&xLabelSetTabs, libs, "gtk_label_set_tabs")
	core.PuregoSafeRegister(&xLabelSetText, libs, "gtk_label_set_text")
	core.PuregoSafeRegister(&xLabelSetTextWithMnemonic, libs, "gtk_label_set_text_with_mnemonic")
	core.PuregoSafeRegister(&xLabelSetUseMarkup, libs, "gtk_label_set_use_markup")
	core.PuregoSafeRegister(&xLabelSetUseUnderline, libs, "gtk_label_set_use_underline")
	core.PuregoSafeRegister(&xLabelSetWidthChars, libs, "gtk_label_set_width_chars")
	core.PuregoSafeRegister(&xLabelSetWrap, libs, "gtk_label_set_wrap")
	core.PuregoSafeRegister(&xLabelSetWrapMode, libs, "gtk_label_set_wrap_mode")
	core.PuregoSafeRegister(&xLabelSetXalign, libs, "gtk_label_set_xalign")
	core.PuregoSafeRegister(&xLabelSetYalign, libs, "gtk_label_set_yalign")

}
