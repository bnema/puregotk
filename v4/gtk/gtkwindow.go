// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gsk"
)

type WindowClass struct {
	_ structs.HostLayout

	ParentClass WidgetClass

	xActivateFocus uintptr

	xActivateDefault uintptr

	xKeysChanged uintptr

	xEnableDebugging uintptr

	xCloseRequest uintptr

	Padding [8]uintptr
}

func (x *WindowClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideActivateFocus sets the "activate_focus" callback function.
// Activates the current focused widget within the window.
func (x *WindowClass) OverrideActivateFocus(cb func(*Window)) {
	if cb == nil {
		x.xActivateFocus = 0
	} else {
		x.xActivateFocus = purego.NewCallback(func(WindowVarp uintptr) {
			cb(WindowNewFromInternalPtr(WindowVarp))
		})
	}
}

// GetActivateFocus gets the "activate_focus" callback function.
// Activates the current focused widget within the window.
func (x *WindowClass) GetActivateFocus() func(*Window) {
	if x.xActivateFocus == 0 {
		return nil
	}
	var rawCallback func(WindowVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xActivateFocus)
	return func(WindowVar *Window) {
		rawCallback(WindowVar.GoPointer())
	}
}

// OverrideActivateDefault sets the "activate_default" callback function.
// Activates the default widget for the window.
func (x *WindowClass) OverrideActivateDefault(cb func(*Window)) {
	if cb == nil {
		x.xActivateDefault = 0
	} else {
		x.xActivateDefault = purego.NewCallback(func(WindowVarp uintptr) {
			cb(WindowNewFromInternalPtr(WindowVarp))
		})
	}
}

// GetActivateDefault gets the "activate_default" callback function.
// Activates the default widget for the window.
func (x *WindowClass) GetActivateDefault() func(*Window) {
	if x.xActivateDefault == 0 {
		return nil
	}
	var rawCallback func(WindowVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xActivateDefault)
	return func(WindowVar *Window) {
		rawCallback(WindowVar.GoPointer())
	}
}

// OverrideKeysChanged sets the "keys_changed" callback function.
// Signal gets emitted when the set of accelerators or
//
//	mnemonics that are associated with window changes.
func (x *WindowClass) OverrideKeysChanged(cb func(*Window)) {
	if cb == nil {
		x.xKeysChanged = 0
	} else {
		x.xKeysChanged = purego.NewCallback(func(WindowVarp uintptr) {
			cb(WindowNewFromInternalPtr(WindowVarp))
		})
	}
}

// GetKeysChanged gets the "keys_changed" callback function.
// Signal gets emitted when the set of accelerators or
//
//	mnemonics that are associated with window changes.
func (x *WindowClass) GetKeysChanged() func(*Window) {
	if x.xKeysChanged == 0 {
		return nil
	}
	var rawCallback func(WindowVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xKeysChanged)
	return func(WindowVar *Window) {
		rawCallback(WindowVar.GoPointer())
	}
}

// OverrideEnableDebugging sets the "enable_debugging" callback function.
// Class handler for the `GtkWindow::enable-debugging`
//
//	keybinding signal.
func (x *WindowClass) OverrideEnableDebugging(cb func(*Window, bool) bool) {
	if cb == nil {
		x.xEnableDebugging = 0
	} else {
		x.xEnableDebugging = purego.NewCallback(func(WindowVarp uintptr, ToggleVarp bool) bool {
			return cb(WindowNewFromInternalPtr(WindowVarp), ToggleVarp)
		})
	}
}

// GetEnableDebugging gets the "enable_debugging" callback function.
// Class handler for the `GtkWindow::enable-debugging`
//
//	keybinding signal.
func (x *WindowClass) GetEnableDebugging() func(*Window, bool) bool {
	if x.xEnableDebugging == 0 {
		return nil
	}
	var rawCallback func(WindowVarp uintptr, ToggleVarp bool) bool
	purego.RegisterFunc(&rawCallback, x.xEnableDebugging)
	return func(WindowVar *Window, ToggleVar bool) bool {
		return rawCallback(WindowVar.GoPointer(), ToggleVar)
	}
}

// OverrideCloseRequest sets the "close_request" callback function.
func (x *WindowClass) OverrideCloseRequest(cb func(*Window) bool) {
	if cb == nil {
		x.xCloseRequest = 0
	} else {
		x.xCloseRequest = purego.NewCallback(func(WindowVarp uintptr) bool {
			return cb(WindowNewFromInternalPtr(WindowVarp))
		})
	}
}

// GetCloseRequest gets the "close_request" callback function.
func (x *WindowClass) GetCloseRequest() func(*Window) bool {
	if x.xCloseRequest == 0 {
		return nil
	}
	var rawCallback func(WindowVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCloseRequest)
	return func(WindowVar *Window) bool {
		return rawCallback(WindowVar.GoPointer())
	}
}

type WindowGroupPrivate struct {
	_ structs.HostLayout
}

func (x *WindowGroupPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Determines which point or edge of a window is meant to remain fixed
// when a window changes size.
type WindowGravity int

var xWindowGravityGLibType func() types.GType

func WindowGravityGLibType() types.GType {
	return xWindowGravityGLibType()
}

const (

	// The top left corner
	WindowGravityTopLeftValue WindowGravity = 0
	// The top edge
	WindowGravityTopValue WindowGravity = 1
	// The top right corner
	WindowGravityTopRightValue WindowGravity = 2
	// The left edge
	WindowGravityLeftValue WindowGravity = 3
	// The center pointer
	WindowGravityCenterValue WindowGravity = 4
	// The right edge
	WindowGravityRightValue WindowGravity = 5
	// The bottom left corner
	WindowGravityBottomLeftValue WindowGravity = 6
	// the bottom edge
	WindowGravityBottomValue WindowGravity = 7
	// The bottom right corner
	WindowGravityBottomRightValue WindowGravity = 8
	// The top left or top right corner,
	//   depending on the text direction
	WindowGravityTopStartValue WindowGravity = 9
	// The top right or top left corner,
	//   depending on the text direction
	WindowGravityTopEndValue WindowGravity = 10
	// The left or right edge,
	//   depending on the text direction
	WindowGravityStartValue WindowGravity = 11
	// The right or left edge,
	//   depending on the text direction
	WindowGravityEndValue WindowGravity = 12
	// The bottom left or top right corner,
	//   depending on the text direction
	WindowGravityBottomStartValue WindowGravity = 13
	// The bottom right or top left corner,
	//   depending on the text direction
	WindowGravityBottomEndValue WindowGravity = 14
)

// A toplevel window which can contain other widgets.
//
// &lt;picture&gt;
//
//	&lt;source srcset="window-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkWindow" src="window.png"&gt;
//
// &lt;/picture&gt;
//
// Windows normally have decorations that are under the control
// of the windowing system and allow the user to manipulate the window
// (resize it, move it, close it,...).
//
// # GtkWindow as GtkBuildable
//
// The `GtkWindow` implementation of the [iface@Gtk.Buildable] interface supports
// setting a child as the titlebar by specifying “titlebar” as the “type”
// attribute of a `&lt;child&gt;` element.
//
// # Shortcuts and Gestures
//
// `GtkWindow` supports the following keyboard shortcuts:
//
// - &lt;kbd&gt;F10&lt;/kbd&gt; activates the menubar, if present.
// - &lt;kbd&gt;Alt&lt;/kbd&gt; makes the mnemonics visible while pressed.
//
// The following signals have default keybindings:
//
// - [signal@Gtk.Window::activate-default]
// - [signal@Gtk.Window::activate-focus]
// - [signal@Gtk.Window::enable-debugging]
//
// # Actions
//
// `GtkWindow` defines a set of built-in actions:
//
// - `default.activate` activates the default widget.
// - `window.minimize` minimizes the window.
// - `window.toggle-maximized` maximizes or restores the window.
// - `window.close` closes the window.
//
// # CSS nodes
//
// ```
// window.background [.csd / .solid-csd / .ssd] [.maximized / .fullscreen / .tiled]
// ├── &lt;child&gt;
// ╰── &lt;titlebar child&gt;.titlebar [.default-decoration]
// ```
//
// `GtkWindow` has a main CSS node with name window and style class .background.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .maximized, .fullscreen, .tiled (when supported,
// also .tiled-top, .tiled-left, .tiled-right, .tiled-bottom).
//
// `GtkWindow` subclasses often add their own discriminating style classes,
// such as .dialog, .popup or .tooltip.
//
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the
// main window node), the CSS border of the toplevel window is used for
// resize drags. In the .csd case, the shadow area outside of the window
// can be used to resize it.
//
// `GtkWindow` adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
//
// # Accessibility
//
// `GtkWindow` uses the [enum@Gtk.AccessibleRole.window] role.
//
// From GTK 4.12 to 4.18, it used the [enum@Gtk.AccessibleRole.application] role.
type Window struct {
	Widget
}

var xWindowGLibType func() types.GType

func WindowGLibType() types.GType {
	return xWindowGLibType()
}

func WindowNewFromInternalPtr(ptr uintptr) *Window {
	cls := &Window{}
	cls.Ptr = ptr
	return cls
}

var xNewWindow func() uintptr

// Creates a new `GtkWindow`.
//
// To get an undecorated window (without window borders),
// use [method@Gtk.Window.set_decorated].
//
// All top-level windows created by this function are stored
// in an internal top-level window list. This list can be obtained
// from [func@Gtk.Window.list_toplevels]. Due to GTK keeping a
// reference to the window internally, this function does not
// return a reference to the caller.
//
// To delete a `GtkWindow`, call [method@Gtk.Window.destroy].
func NewWindow() *Window {
	var cls *Window

	cret := xNewWindow()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Window{}
	cls.Ptr = cret
	return cls
}

var xWindowClose func(uintptr)

// Requests that the window is closed.
//
// This is similar to what happens when a window manager
// close button is clicked.
//
// This function can be used with close buttons in custom
// titlebars.
func (x *Window) Close() {

	xWindowClose(x.GoPointer())

}

var xWindowDestroy func(uintptr)

// Drops the internal reference GTK holds on toplevel windows.
func (x *Window) Destroy() {

	xWindowDestroy(x.GoPointer())

}

var xWindowFullscreen func(uintptr)

// Asks to place the window in the fullscreen state.
//
// Note that you shouldn’t assume the window is definitely fullscreen
// afterward, because other entities (e.g. the user or window manager)
// unfullscreen it again, and not all window managers honor requests
// to fullscreen windows.
//
// If a window is not explicitly fullscreened or unfullscreened before
// it is shown, the initial state is at the window managers discretion.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications of the [property@Gtk.Window:fullscreened] property.
func (x *Window) Fullscreen() {

	xWindowFullscreen(x.GoPointer())

}

var xWindowFullscreenOnMonitor func(uintptr, uintptr)

// Asks to place the window in the fullscreen state on the given monitor.
//
// Note that you shouldn't assume the window is definitely fullscreen
// afterward, or that the windowing system allows fullscreen windows on
// any given monitor.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications of the [property@Gtk.Window:fullscreened] property.
func (x *Window) FullscreenOnMonitor(MonitorVar *gdk.Monitor) {

	xWindowFullscreenOnMonitor(x.GoPointer(), MonitorVar.GoPointer())

}

var xWindowGetApplication func(uintptr) uintptr

// Gets the application object associated with the window.
func (x *Window) GetApplication() *Application {
	var cls *Application

	cret := xWindowGetApplication(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Application{}
	cls.Ptr = cret
	return cls
}

var xWindowGetChild func(uintptr) uintptr

// Gets the child widget of the window.
func (x *Window) GetChild() *Widget {
	var cls *Widget

	cret := xWindowGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWindowGetDecorated func(uintptr) bool

// Returns whether the window has been set to have decorations.
func (x *Window) GetDecorated() bool {

	cret := xWindowGetDecorated(x.GoPointer())

	return cret
}

var xWindowGetDefaultSize func(uintptr, *int, *int)

// Gets the default size of the window.
//
// A value of 0 for the width or height indicates that a default
// size has not been explicitly set for that dimension, so the
// “natural” size of the window will be used.
//
// This function is the recommended way for [saving window state
// across restarts of applications](https://developer.gnome.org/documentation/tutorials/save-state.html).
func (x *Window) GetDefaultSize(WidthVar *int, HeightVar *int) {

	xWindowGetDefaultSize(x.GoPointer(), WidthVar, HeightVar)

}

var xWindowGetDefaultWidget func(uintptr) uintptr

// Returns the default widget for @window.
func (x *Window) GetDefaultWidget() *Widget {
	var cls *Widget

	cret := xWindowGetDefaultWidget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWindowGetDeletable func(uintptr) bool

// Returns whether the window has been set to have a close button.
func (x *Window) GetDeletable() bool {

	cret := xWindowGetDeletable(x.GoPointer())

	return cret
}

var xWindowGetDestroyWithParent func(uintptr) bool

// Returns whether the window will be destroyed with its transient parent.
func (x *Window) GetDestroyWithParent() bool {

	cret := xWindowGetDestroyWithParent(x.GoPointer())

	return cret
}

var xWindowGetFocus func(uintptr) uintptr

// Retrieves the current focused widget within the window.
//
// Note that this is the widget that would have the focus
// if the toplevel window focused; if the toplevel window
// is not focused then `gtk_widget_has_focus (widget)` will
// not be false for the widget.
func (x *Window) GetFocus() *Widget {
	var cls *Widget

	cret := xWindowGetFocus(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWindowGetFocusVisible func(uintptr) bool

// Gets whether “focus rectangles” are supposed to be visible.
func (x *Window) GetFocusVisible() bool {

	cret := xWindowGetFocusVisible(x.GoPointer())

	return cret
}

var xWindowGetGravity func(uintptr) WindowGravity

// Returns the gravity that is used when changing the window size programmatically.
func (x *Window) GetGravity() WindowGravity {

	cret := xWindowGetGravity(x.GoPointer())

	return cret
}

var xWindowGetGroup func(uintptr) uintptr

// Returns the group for the window.
//
// If the window has no group, then the default group is returned.
func (x *Window) GetGroup() *WindowGroup {
	var cls *WindowGroup

	cret := xWindowGetGroup(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WindowGroup{}
	cls.Ptr = cret
	return cls
}

var xWindowGetHandleMenubarAccel func(uintptr) bool

// Returns whether this window reacts to &lt;kbd&gt;F10&lt;/kbd&gt;
// presses by activating a menubar it contains.
func (x *Window) GetHandleMenubarAccel() bool {

	cret := xWindowGetHandleMenubarAccel(x.GoPointer())

	return cret
}

var xWindowGetHideOnClose func(uintptr) bool

// Returns whether the window will be hidden instead of destroyed when the close
// button is clicked.
func (x *Window) GetHideOnClose() bool {

	cret := xWindowGetHideOnClose(x.GoPointer())

	return cret
}

var xWindowGetIconName func(uintptr) string

// Returns the name of the themed icon for the window.
func (x *Window) GetIconName() string {

	cret := xWindowGetIconName(x.GoPointer())

	return cret
}

var xWindowGetMnemonicsVisible func(uintptr) bool

// Gets whether mnemonics are supposed to be visible.
func (x *Window) GetMnemonicsVisible() bool {

	cret := xWindowGetMnemonicsVisible(x.GoPointer())

	return cret
}

var xWindowGetModal func(uintptr) bool

// Returns whether the window is modal.
func (x *Window) GetModal() bool {

	cret := xWindowGetModal(x.GoPointer())

	return cret
}

var xWindowGetResizable func(uintptr) bool

// Gets whether the user can resize the window.
func (x *Window) GetResizable() bool {

	cret := xWindowGetResizable(x.GoPointer())

	return cret
}

var xWindowGetTitle func(uintptr) string

// Retrieves the title of the window.
func (x *Window) GetTitle() string {

	cret := xWindowGetTitle(x.GoPointer())

	return cret
}

var xWindowGetTitlebar func(uintptr) uintptr

// Returns the titlebar that has been set with
// [method@Gtk.Window.set_titlebar].
func (x *Window) GetTitlebar() *Widget {
	var cls *Widget

	cret := xWindowGetTitlebar(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWindowGetTransientFor func(uintptr) uintptr

// Fetches the transient parent for this window.
func (x *Window) GetTransientFor() *Window {
	var cls *Window

	cret := xWindowGetTransientFor(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Window{}
	cls.Ptr = cret
	return cls
}

var xWindowHasGroup func(uintptr) bool

// Returns whether the window has an explicit window group.
func (x *Window) HasGroup() bool {

	cret := xWindowHasGroup(x.GoPointer())

	return cret
}

var xWindowIsActive func(uintptr) bool

// Returns whether the window is part of the current active toplevel.
//
// The active toplevel is the window receiving keystrokes.
//
// The return value is %TRUE if the window is active toplevel itself.
// You might use this function if you wanted to draw a widget
// differently in an active window from a widget in an inactive window.
func (x *Window) IsActive() bool {

	cret := xWindowIsActive(x.GoPointer())

	return cret
}

var xWindowIsFullscreen func(uintptr) bool

// Retrieves the current fullscreen state of the window.
//
// Note that since fullscreening is ultimately handled by the window
// manager and happens asynchronously to an application request, you
// shouldn’t assume the return value of this function changing
// immediately (or at all), as an effect of calling
// [method@Gtk.Window.fullscreen] or [method@Gtk.Window.unfullscreen].
//
// If the window isn't yet mapped, the value returned will whether the
// initial requested state is fullscreen.
func (x *Window) IsFullscreen() bool {

	cret := xWindowIsFullscreen(x.GoPointer())

	return cret
}

var xWindowIsMaximized func(uintptr) bool

// Retrieves the current maximized state of the window.
//
// Note that since maximization is ultimately handled by the window
// manager and happens asynchronously to an application request, you
// shouldn’t assume the return value of this function changing
// immediately (or at all), as an effect of calling
// [method@Gtk.Window.maximize] or [method@Gtk.Window.unmaximize].
//
// If the window isn't yet mapped, the value returned will whether the
// initial requested state is maximized.
func (x *Window) IsMaximized() bool {

	cret := xWindowIsMaximized(x.GoPointer())

	return cret
}

var xWindowIsSuspended func(uintptr) bool

// Retrieves the current suspended state of the window.
//
// A window being suspended means it's currently not visible
// to the user, for example by being on a inactive workspace,
// minimized, obstructed.
func (x *Window) IsSuspended() bool {

	cret := xWindowIsSuspended(x.GoPointer())

	return cret
}

var xWindowMaximize func(uintptr)

// Asks to maximize the window, so that it fills the screen.
//
// Note that you shouldn’t assume the window is definitely maximized
// afterward, because other entities (e.g. the user or window manager)
// could unmaximize it again, and not all window managers support
// maximization.
//
// It’s permitted to call this function before showing a window,
// in which case the window will be maximized when it appears onscreen
// initially.
//
// If a window is not explicitly maximized or unmaximized before it is
// shown, the initial state is at the window managers discretion. For
// example, it might decide to maximize a window that almost fills the
// screen.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications on the [property@Gtk.Window:maximized]
// property.
func (x *Window) Maximize() {

	xWindowMaximize(x.GoPointer())

}

var xWindowMinimize func(uintptr)

// Asks to minimize the window.
//
// Note that you shouldn’t assume the window is definitely minimized
// afterward, because the windowing system might not support this
// functionality; other entities (e.g. the user or the window manager)
// could unminimize it again, or there may not be a window manager in
// which case minimization isn’t possible, etc.
//
// It’s permitted to call this function before showing a window,
// in which case the window will be minimized before it ever appears
// onscreen.
//
// You can track result of this operation via the
// [property@Gdk.Toplevel:state] property.
func (x *Window) Minimize() {

	xWindowMinimize(x.GoPointer())

}

var xWindowPresent func(uintptr)

// Presents a window to the user.
//
// This may mean raising the window in the stacking order,
// unminimizing it, moving it to the current desktop and/or
// giving it the keyboard focus (possibly dependent on the user’s
// platform, window manager and preferences).
//
// If @window is hidden, this function also makes it visible.
func (x *Window) Present() {

	xWindowPresent(x.GoPointer())

}

var xWindowPresentWithTime func(uintptr, uint32)

// Presents a window to the user in response to an user interaction.
//
// See [method@Gtk.Window.present] for more details.
//
// The timestamp should be gathered when the window was requested
// to be shown (when clicking a link for example), rather than once
// the window is ready to be shown.
func (x *Window) PresentWithTime(TimestampVar uint32) {

	xWindowPresentWithTime(x.GoPointer(), TimestampVar)

}

var xWindowSetApplication func(uintptr, uintptr)

// Sets or unsets the application object associated with the window.
//
// The application will be kept alive for at least as long as it has
// any windows associated with it (see [method@Gio.Application.hold]
// for a way to keep it alive without windows).
//
// Normally, the connection between the application and the window will
// remain until the window is destroyed, but you can explicitly remove
// it by setting the @application to %NULL.
//
// This is equivalent to calling [method@Gtk.Application.remove_window]
// and/or [method@Gtk.Application.add_window] on the old/new applications
// as relevant.
func (x *Window) SetApplication(ApplicationVar *Application) {

	xWindowSetApplication(x.GoPointer(), ApplicationVar.GoPointer())

}

var xWindowSetChild func(uintptr, uintptr)

// Sets the child widget of the window.
func (x *Window) SetChild(ChildVar *Widget) {

	xWindowSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xWindowSetDecorated func(uintptr, bool)

// Sets whether the window should be decorated.
//
// By default, windows are decorated with a title bar, resize
// controls, etc. Some window managers allow GTK to disable these
// decorations, creating a borderless window. If you set the decorated
// property to false using this function, GTK will do its best to
// convince the window manager not to decorate the window. Depending on
// the system, this function may not have any effect when called on a
// window that is already visible, so you should call it before calling
// [method@Gtk.Widget.show].
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (x *Window) SetDecorated(SettingVar bool) {

	xWindowSetDecorated(x.GoPointer(), SettingVar)

}

var xWindowSetDefaultSize func(uintptr, int, int)

// Sets the default size of a window.
//
// The default size of a window is the size that will be used
// if no other constraints apply.
//
// The default size will be updated whenever the window is resized
// to reflect the new size, unless the window is forced to a size,
// like when it is maximized or fullscreened.
//
// If the window’s minimum size request is larger than
// the default, the default will be ignored.
//
// Setting the default size to a value &lt;= 0 will cause it to be
// ignored and the natural size request will be used instead. It
// is possible to do this while the window is showing to "reset"
// it to its initial size.
//
// Unlike [method@Gtk.Widget.set_size_request], which sets a size
// request for a widget and thus would keep users from shrinking
// the window, this function only sets the initial size, just as
// if the user had resized the window themselves. Users can still
// shrink the window again as they normally would. Setting a default
// size of -1 means to use the “natural” default size (the size request
// of the window).
//
// If you use this function to reestablish a previously saved window size,
// note that the appropriate size to save is the one returned by
// [method@Gtk.Window.get_default_size]. Using the window allocation
// directly will not work in all circumstances and can lead to growing
// or shrinking windows.
func (x *Window) SetDefaultSize(WidthVar int, HeightVar int) {

	xWindowSetDefaultSize(x.GoPointer(), WidthVar, HeightVar)

}

var xWindowSetDefaultWidget func(uintptr, uintptr)

// Sets the default widget.
//
// The default widget is the widget that is activated
// when the user presses &lt;kbd&gt;Enter&lt;/kbd&gt; in a dialog
// (for example).
func (x *Window) SetDefaultWidget(DefaultWidgetVar *Widget) {

	xWindowSetDefaultWidget(x.GoPointer(), DefaultWidgetVar.GoPointer())

}

var xWindowSetDeletable func(uintptr, bool)

// Sets whether the window should be deletable.
//
// By default, windows have a close button in the window frame.
// Some  window managers allow GTK to disable this button. If you
// set the deletable property to false using this function, GTK
// will do its best to convince the window manager not to show a
// close button. Depending on the system, this function may not
// have any effect when called on a window that is already visible,
// so you should call it before calling [method@Gtk.Widget.show].
//
// On Windows, this function always works, since there’s no window
// manager policy involved.
func (x *Window) SetDeletable(SettingVar bool) {

	xWindowSetDeletable(x.GoPointer(), SettingVar)

}

var xWindowSetDestroyWithParent func(uintptr, bool)

// Sets whether to destroy the window when the transient parent is destroyed.
//
// This is useful for dialogs that shouldn’t persist beyond the lifetime
// of the main window they are associated with, for example.
func (x *Window) SetDestroyWithParent(SettingVar bool) {

	xWindowSetDestroyWithParent(x.GoPointer(), SettingVar)

}

var xWindowSetDisplay func(uintptr, uintptr)

// Sets the display where the window is displayed.
//
// If the window is already mapped, it will be unmapped,
// and then remapped on the new display.
func (x *Window) SetDisplay(DisplayVar *gdk.Display) {

	xWindowSetDisplay(x.GoPointer(), DisplayVar.GoPointer())

}

var xWindowSetFocus func(uintptr, uintptr)

// Sets the focus widget.
//
// If @focus is not the current focus widget, and is focusable,
// sets it as the focus widget for the window. If @focus is %NULL,
// unsets the focus widget for this window. To set the focus to a
// particular widget in the toplevel, it is usually more convenient
// to use [method@Gtk.Widget.grab_focus] instead of this function.
func (x *Window) SetFocus(FocusVar *Widget) {

	xWindowSetFocus(x.GoPointer(), FocusVar.GoPointer())

}

var xWindowSetFocusVisible func(uintptr, bool)

// Sets whether “focus rectangles” are supposed to be visible.
//
// This property is maintained by GTK based on user input,
// and should not be set by applications.
func (x *Window) SetFocusVisible(SettingVar bool) {

	xWindowSetFocusVisible(x.GoPointer(), SettingVar)

}

var xWindowSetGravity func(uintptr, WindowGravity)

// Sets the gravity that is used when changing the window size programmatically.
func (x *Window) SetGravity(GravityVar WindowGravity) {

	xWindowSetGravity(x.GoPointer(), GravityVar)

}

var xWindowSetHandleMenubarAccel func(uintptr, bool)

// Sets whether this window should react to &lt;kbd&gt;F10&lt;/kbd&gt;
// presses by activating a menubar it contains.
func (x *Window) SetHandleMenubarAccel(HandleMenubarAccelVar bool) {

	xWindowSetHandleMenubarAccel(x.GoPointer(), HandleMenubarAccelVar)

}

var xWindowSetHideOnClose func(uintptr, bool)

// Sets whether clicking the close button will hide the window instead
// of destroying it.
func (x *Window) SetHideOnClose(SettingVar bool) {

	xWindowSetHideOnClose(x.GoPointer(), SettingVar)

}

var xWindowSetIconName func(uintptr, uintptr)

// Sets the icon for the window from a named themed icon.
//
// See the docs for [class@Gtk.IconTheme] for more details.
// On some platforms, the window icon is not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME
// property which is mentioned in the ICCCM.
func (x *Window) SetIconName(NameVar *string) {

	NameVarPtr, NameVarBytes := core.NullableStringToPtr(NameVar)

	xWindowSetIconName(x.GoPointer(), NameVarPtr)

	runtime.KeepAlive(NameVarBytes)

}

var xWindowSetMnemonicsVisible func(uintptr, bool)

// Sets whether mnemonics are supposed to be visible.
//
// This property is maintained by GTK based on user input,
// and should not be set by applications.
func (x *Window) SetMnemonicsVisible(SettingVar bool) {

	xWindowSetMnemonicsVisible(x.GoPointer(), SettingVar)

}

var xWindowSetModal func(uintptr, bool)

// Sets a window modal or non-modal.
//
// Modal windows prevent interaction with other windows in the same
// application. To keep modal dialogs on top of main application windows,
// use [method@Gtk.Window.set_transient_for] to make the dialog transient
// for the parent; most window managers will then disallow lowering the
// dialog below the parent.
func (x *Window) SetModal(ModalVar bool) {

	xWindowSetModal(x.GoPointer(), ModalVar)

}

var xWindowSetResizable func(uintptr, bool)

// Sets whether the user can resize a window.
//
// Windows are user resizable by default.
func (x *Window) SetResizable(ResizableVar bool) {

	xWindowSetResizable(x.GoPointer(), ResizableVar)

}

var xWindowSetStartupId func(uintptr, string)

// Sets the startup notification ID.
//
// Startup notification identifiers are used by desktop environment
// to track application startup, to provide user feedback and other
// features. This function changes the corresponding property on the
// underlying `GdkSurface`.
//
// Normally, startup identifier is managed automatically and you should
// only use this function in special cases like transferring focus from
// other processes. You should use this function before calling
// [method@Gtk.Window.present] or any equivalent function generating
// a window map event.
//
// This function is only useful on Wayland or X11, not with other GDK
// backends.
func (x *Window) SetStartupId(StartupIdVar string) {

	xWindowSetStartupId(x.GoPointer(), StartupIdVar)

}

var xWindowSetTitle func(uintptr, uintptr)

// Sets the title of the window.
//
// The title of a window will be displayed in its title bar; on the
// X Window System, the title bar is rendered by the window manager
// so exactly how the title appears to users may vary according to a
// user’s exact configuration. The title should help a user distinguish
// this window from other windows they may have open. A good title might
// include the application name and current document filename, for example.
//
// Passing `NULL` does the same as setting the title to an empty string.
func (x *Window) SetTitle(TitleVar *string) {

	TitleVarPtr, TitleVarBytes := core.NullableStringToPtr(TitleVar)

	xWindowSetTitle(x.GoPointer(), TitleVarPtr)

	runtime.KeepAlive(TitleVarBytes)

}

var xWindowSetTitlebar func(uintptr, uintptr)

// Sets a custom titlebar for the window.
//
// A typical widget used here is [class@Gtk.HeaderBar], as it
// provides various features expected of a titlebar while allowing
// the addition of child widgets to it.
//
// If you set a custom titlebar, GTK will do its best to convince
// the window manager not to put its own titlebar on the window.
// Depending on the system, this function may not work for a window
// that is already visible, so you set the titlebar before calling
// [method@Gtk.Widget.show].
func (x *Window) SetTitlebar(TitlebarVar *Widget) {

	xWindowSetTitlebar(x.GoPointer(), TitlebarVar.GoPointer())

}

var xWindowSetTransientFor func(uintptr, uintptr)

// Sets a transient parent for the window.
//
// Dialog windows should be set transient for the main application
// window they were spawned from. This allows window managers to e.g.
// keep the dialog on top of the main window, or center the dialog
// over the main window. [ctor@Gtk.Dialog.new_with_buttons] and other
// convenience functions in GTK will sometimes call this function on
// your behalf.
//
// Passing `NULL` for @parent unsets the current transient window.
//
// On Windows, this function puts the child window on top of the parent,
// much as the window manager would have done on X.
func (x *Window) SetTransientFor(ParentVar *Window) {

	xWindowSetTransientFor(x.GoPointer(), ParentVar.GoPointer())

}

var xWindowUnfullscreen func(uintptr)

// Asks to remove the fullscreen state for the window, and return to
// its previous state.
//
// Note that you shouldn’t assume the window is definitely not
// fullscreen afterward, because other entities (e.g. the user or
// window manager) could fullscreen it again, and not all window
// managers honor requests to unfullscreen windows; normally the
// window will end up restored to its normal state. Just don’t
// write code that crashes if not.
//
// If a window is not explicitly fullscreened or unfullscreened before
// it is shown, the initial state is at the window managers discretion.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications of the [property@Gtk.Window:fullscreened] property.
func (x *Window) Unfullscreen() {

	xWindowUnfullscreen(x.GoPointer())

}

var xWindowUnmaximize func(uintptr)

// Asks to unmaximize the window.
//
// Note that you shouldn’t assume the window is definitely unmaximized
// afterward, because other entities (e.g. the user or window manager)
// maximize it again, and not all window managers honor requests to
// unmaximize.
//
// If a window is not explicitly maximized or unmaximized before it is
// shown, the initial state is at the window managers discretion. For
// example, it might decide to maximize a window that almost fills the
// screen.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications on the [property@Gtk.Window:maximized] property.
func (x *Window) Unmaximize() {

	xWindowUnmaximize(x.GoPointer())

}

var xWindowUnminimize func(uintptr)

// Asks to unminimize the window.
//
// Note that you shouldn’t assume the window is definitely unminimized
// afterward, because the windowing system might not support this
// functionality; other entities (e.g. the user or the window manager)
// could minimize it again, or there may not be a window manager in
// which case minimization isn’t possible, etc.
//
// You can track result of this operation via the
// [property@Gdk.Toplevel:state] property.
func (x *Window) Unminimize() {

	xWindowUnminimize(x.GoPointer())

}

func (c *Window) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Window) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyDecorated sets the "decorated" property.
// Whether the window should have a frame (also known as *decorations*).
func (x *Window) SetPropertyDecorated(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("decorated", &v)
}

// GetPropertyDecorated gets the "decorated" property.
// Whether the window should have a frame (also known as *decorations*).
func (x *Window) GetPropertyDecorated() bool {
	var v gobject.Value
	x.GetProperty("decorated", &v)
	return v.GetBoolean()
}

// SetPropertyDefaultHeight sets the "default-height" property.
// The default height of the window.
func (x *Window) SetPropertyDefaultHeight(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("default-height", &v)
}

// GetPropertyDefaultHeight gets the "default-height" property.
// The default height of the window.
func (x *Window) GetPropertyDefaultHeight() int {
	var v gobject.Value
	x.GetProperty("default-height", &v)
	return v.GetInt()
}

// SetPropertyDefaultWidth sets the "default-width" property.
// The default width of the window.
func (x *Window) SetPropertyDefaultWidth(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("default-width", &v)
}

// GetPropertyDefaultWidth gets the "default-width" property.
// The default width of the window.
func (x *Window) GetPropertyDefaultWidth() int {
	var v gobject.Value
	x.GetProperty("default-width", &v)
	return v.GetInt()
}

// SetPropertyDeletable sets the "deletable" property.
// Whether the window frame should have a close button.
func (x *Window) SetPropertyDeletable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("deletable", &v)
}

// GetPropertyDeletable gets the "deletable" property.
// Whether the window frame should have a close button.
func (x *Window) GetPropertyDeletable() bool {
	var v gobject.Value
	x.GetProperty("deletable", &v)
	return v.GetBoolean()
}

// SetPropertyDestroyWithParent sets the "destroy-with-parent" property.
// If this window should be destroyed when the parent is destroyed.
func (x *Window) SetPropertyDestroyWithParent(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("destroy-with-parent", &v)
}

// GetPropertyDestroyWithParent gets the "destroy-with-parent" property.
// If this window should be destroyed when the parent is destroyed.
func (x *Window) GetPropertyDestroyWithParent() bool {
	var v gobject.Value
	x.GetProperty("destroy-with-parent", &v)
	return v.GetBoolean()
}

// SetPropertyFocusVisible sets the "focus-visible" property.
// Whether 'focus rectangles' are currently visible in this window.
//
// This property is maintained by GTK based on user input
// and should not be set by applications.
func (x *Window) SetPropertyFocusVisible(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("focus-visible", &v)
}

// GetPropertyFocusVisible gets the "focus-visible" property.
// Whether 'focus rectangles' are currently visible in this window.
//
// This property is maintained by GTK based on user input
// and should not be set by applications.
func (x *Window) GetPropertyFocusVisible() bool {
	var v gobject.Value
	x.GetProperty("focus-visible", &v)
	return v.GetBoolean()
}

// SetPropertyFullscreened sets the "fullscreened" property.
// Whether the window is fullscreen.
//
// Setting this property is the equivalent of calling
// [method@Gtk.Window.fullscreen] or [method@Gtk.Window.unfullscreen];
// either operation is asynchronous, which means you will need to
// connect to the ::notify signal in order to know whether the
// operation was successful.
func (x *Window) SetPropertyFullscreened(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("fullscreened", &v)
}

// GetPropertyFullscreened gets the "fullscreened" property.
// Whether the window is fullscreen.
//
// Setting this property is the equivalent of calling
// [method@Gtk.Window.fullscreen] or [method@Gtk.Window.unfullscreen];
// either operation is asynchronous, which means you will need to
// connect to the ::notify signal in order to know whether the
// operation was successful.
func (x *Window) GetPropertyFullscreened() bool {
	var v gobject.Value
	x.GetProperty("fullscreened", &v)
	return v.GetBoolean()
}

// SetPropertyHandleMenubarAccel sets the "handle-menubar-accel" property.
// Whether the window frame should handle &lt;kbd&gt;F10&lt;/kbd&gt; for activating
// menubars.
func (x *Window) SetPropertyHandleMenubarAccel(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("handle-menubar-accel", &v)
}

// GetPropertyHandleMenubarAccel gets the "handle-menubar-accel" property.
// Whether the window frame should handle &lt;kbd&gt;F10&lt;/kbd&gt; for activating
// menubars.
func (x *Window) GetPropertyHandleMenubarAccel() bool {
	var v gobject.Value
	x.GetProperty("handle-menubar-accel", &v)
	return v.GetBoolean()
}

// SetPropertyHideOnClose sets the "hide-on-close" property.
// If this window should be hidden instead of destroyed when the user clicks
// the close button.
func (x *Window) SetPropertyHideOnClose(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("hide-on-close", &v)
}

// GetPropertyHideOnClose gets the "hide-on-close" property.
// If this window should be hidden instead of destroyed when the user clicks
// the close button.
func (x *Window) GetPropertyHideOnClose() bool {
	var v gobject.Value
	x.GetProperty("hide-on-close", &v)
	return v.GetBoolean()
}

// SetPropertyIconName sets the "icon-name" property.
// Specifies the name of the themed icon to use as the window icon.
//
// See [class@Gtk.IconTheme] for more details.
func (x *Window) SetPropertyIconName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("icon-name", &v)
}

// GetPropertyIconName gets the "icon-name" property.
// Specifies the name of the themed icon to use as the window icon.
//
// See [class@Gtk.IconTheme] for more details.
func (x *Window) GetPropertyIconName() string {
	var v gobject.Value
	x.GetProperty("icon-name", &v)
	return v.GetString()
}

// GetPropertyIsActive gets the "is-active" property.
// Whether the toplevel is the currently active window.
func (x *Window) GetPropertyIsActive() bool {
	var v gobject.Value
	x.GetProperty("is-active", &v)
	return v.GetBoolean()
}

// SetPropertyMaximized sets the "maximized" property.
// Whether the window is maximized.
//
// Setting this property is the equivalent of calling
// [method@Gtk.Window.maximize] or [method@Gtk.Window.unmaximize];
// either operation is asynchronous, which means you will need to
// connect to the ::notify signal in order to know whether the
// operation was successful.
func (x *Window) SetPropertyMaximized(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("maximized", &v)
}

// GetPropertyMaximized gets the "maximized" property.
// Whether the window is maximized.
//
// Setting this property is the equivalent of calling
// [method@Gtk.Window.maximize] or [method@Gtk.Window.unmaximize];
// either operation is asynchronous, which means you will need to
// connect to the ::notify signal in order to know whether the
// operation was successful.
func (x *Window) GetPropertyMaximized() bool {
	var v gobject.Value
	x.GetProperty("maximized", &v)
	return v.GetBoolean()
}

// SetPropertyMnemonicsVisible sets the "mnemonics-visible" property.
// Whether mnemonics are currently visible in this window.
//
// This property is maintained by GTK based on user input,
// and should not be set by applications.
func (x *Window) SetPropertyMnemonicsVisible(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("mnemonics-visible", &v)
}

// GetPropertyMnemonicsVisible gets the "mnemonics-visible" property.
// Whether mnemonics are currently visible in this window.
//
// This property is maintained by GTK based on user input,
// and should not be set by applications.
func (x *Window) GetPropertyMnemonicsVisible() bool {
	var v gobject.Value
	x.GetProperty("mnemonics-visible", &v)
	return v.GetBoolean()
}

// SetPropertyModal sets the "modal" property.
// If true, the window is modal.
func (x *Window) SetPropertyModal(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("modal", &v)
}

// GetPropertyModal gets the "modal" property.
// If true, the window is modal.
func (x *Window) GetPropertyModal() bool {
	var v gobject.Value
	x.GetProperty("modal", &v)
	return v.GetBoolean()
}

// SetPropertyResizable sets the "resizable" property.
// If true, users can resize the window.
func (x *Window) SetPropertyResizable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("resizable", &v)
}

// GetPropertyResizable gets the "resizable" property.
// If true, users can resize the window.
func (x *Window) GetPropertyResizable() bool {
	var v gobject.Value
	x.GetProperty("resizable", &v)
	return v.GetBoolean()
}

// SetPropertyStartupId sets the "startup-id" property.
// A write-only property for setting window's startup notification identifier.
func (x *Window) SetPropertyStartupId(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("startup-id", &v)
}

// GetPropertySuspended gets the "suspended" property.
// Whether the window is suspended.
//
// See [method@Gtk.Window.is_suspended] for details about what suspended means.
func (x *Window) GetPropertySuspended() bool {
	var v gobject.Value
	x.GetProperty("suspended", &v)
	return v.GetBoolean()
}

// SetPropertyTitle sets the "title" property.
// The title of the window.
func (x *Window) SetPropertyTitle(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("title", &v)
}

// GetPropertyTitle gets the "title" property.
// The title of the window.
func (x *Window) GetPropertyTitle() string {
	var v gobject.Value
	x.GetProperty("title", &v)
	return v.GetString()
}

// Emitted when the user activates the default widget.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The keybindings for this signal are all forms of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
func (x *Window) ConnectActivateDefault(cb *func(Window)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate-default", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate-default", cbRefPtr)
}

// Emitted when the user activates the currently focused
// widget of @window.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is &lt;kbd&gt;␣&lt;/kbd&gt;.
func (x *Window) ConnectActivateFocus(cb *func(Window)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate-focus", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate-focus", cbRefPtr)
}

// Emitted when the user clicks on the close button of the window.
func (x *Window) ConnectCloseRequest(cb *func(Window) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "close-request", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "close-request", cbRefPtr)
}

// Emitted when the user enables or disables interactive debugging.
//
// When @toggle is true, interactive debugging is toggled on or off,
// when it is false, the debugger will be pointed at the widget
// under the pointer.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;I&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;D&lt;/kbd&gt;.
func (x *Window) ConnectEnableDebugging(cb *func(Window, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "enable-debugging", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ToggleVarp bool) bool {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ToggleVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "enable-debugging", cbRefPtr)
}

// Emitted when the set of accelerators or mnemonics that
// are associated with the window changes.
func (x *Window) ConnectKeysChanged(cb *func(Window)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "keys-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "keys-changed", cbRefPtr)
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *Window) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *Window) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *Window) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())

	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *Window) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *Window) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)

	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *Window) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *Window) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *Window) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)

	return cret
}

// Resets the accessible property to its default value.
func (x *Window) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *Window) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *Window) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *Window) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *Window) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *Window) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Window) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Window) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Window) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Window) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Window) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Window) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *Window) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())

	return cret
}

// Returns the renderer that is used for this `GtkNative`.
func (x *Window) GetRenderer() *gsk.Renderer {
	var cls *gsk.Renderer

	cret := XGtkNativeGetRenderer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gsk.Renderer{}
	cls.Ptr = cret
	return cls
}

// Returns the surface of this `GtkNative`.
func (x *Window) GetSurface() *gdk.Surface {
	var cls *gdk.Surface

	cret := XGtkNativeGetSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Surface{}
	cls.Ptr = cret
	return cls
}

// Retrieves the surface transform of @self.
//
// This is the translation from @self's surface coordinates into
// @self's widget coordinates.
func (x *Window) GetSurfaceTransform(XVar *float64, YVar *float64) {

	XGtkNativeGetSurfaceTransform(x.GoPointer(), XVar, YVar)

}

// Realizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *Window) Realize() {

	XGtkNativeRealize(x.GoPointer())

}

// Unrealizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *Window) Unrealize() {

	XGtkNativeUnrealize(x.GoPointer())

}

// Returns the display that this `GtkRoot` is on.
func (x *Window) GetDisplay() *gdk.Display {
	var cls *gdk.Display

	cret := XGtkRootGetDisplay(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Display{}
	cls.Ptr = cret
	return cls
}

var xWindowGetDefaultIconName func() string

// Returns the fallback icon name for windows.
//
// The returned string is owned by GTK and should not
// be modified. It is only valid until the next call to
// [func@Gtk.Window.set_default_icon_name].
func WindowGetDefaultIconName() string {

	cret := xWindowGetDefaultIconName()

	return cret
}

var xWindowGetToplevels func() uintptr

// Returns the list of all existing toplevel windows.
//
// If you want to iterate through the list and perform actions involving
// callbacks that might destroy the widgets or add new ones, be aware that
// the list of toplevels will change and emit the "items-changed" signal.
func WindowGetToplevels() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xWindowGetToplevels()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xWindowListToplevels func() *glib.List

// Returns the list of all existing toplevel windows.
//
// The widgets in the list are not individually referenced.
// If you want to iterate through the list and perform actions
// involving callbacks that might destroy the widgets, you must
// call `g_list_foreach (result, (GFunc)g_object_ref, NULL)` first,
// and then unref all the widgets afterwards.
func WindowListToplevels() *glib.List {

	cret := xWindowListToplevels()

	return cret
}

var xWindowSetAutoStartupNotification func(bool)

// Sets whether the window should request startup notification.
//
// By default, after showing the first window, GTK calls
// [method@Gdk.Toplevel.set_startup_id]. Call this function
// to disable the automatic startup notification. You might do this
// if your first window is a splash screen, and you want to delay
// notification until after your real main window has been shown,
// for example.
//
// In that example, you would disable startup notification
// temporarily, show your splash screen, then re-enable it so that
// showing the main window would automatically result in notification.
func WindowSetAutoStartupNotification(SettingVar bool) {

	xWindowSetAutoStartupNotification(SettingVar)

}

var xWindowSetDefaultIconName func(string)

// Sets an icon to be used as fallback.
//
// The fallback icon is used for windows that
// haven't had [method@Gtk.Window.set_icon_name]
// called on them.
func WindowSetDefaultIconName(NameVar string) {

	xWindowSetDefaultIconName(NameVar)

}

var xWindowSetInteractiveDebugging func(bool)

// Opens or closes the [interactive debugger](running.html#interactive-debugging).
//
// The debugger offers access to the widget hierarchy of the application
// and to useful debugging tools.
//
// This function allows applications that already use
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;I&lt;/kbd&gt;
// (or &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;D&lt;/kbd&gt;)
// for their own key shortcuts to add a different shortcut to open the Inspector.
//
// If you are not overriding the default key shortcuts for the Inspector,
// you should not use this function.
func WindowSetInteractiveDebugging(EnableVar bool) {

	xWindowSetInteractiveDebugging(EnableVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWindowGravityGLibType, libs, "gtk_window_gravity_get_type")

	core.PuregoSafeRegister(&xWindowGLibType, libs, "gtk_window_get_type")

	core.PuregoSafeRegister(&xNewWindow, libs, "gtk_window_new")

	core.PuregoSafeRegister(&xWindowClose, libs, "gtk_window_close")
	core.PuregoSafeRegister(&xWindowDestroy, libs, "gtk_window_destroy")
	core.PuregoSafeRegister(&xWindowFullscreen, libs, "gtk_window_fullscreen")
	core.PuregoSafeRegister(&xWindowFullscreenOnMonitor, libs, "gtk_window_fullscreen_on_monitor")
	core.PuregoSafeRegister(&xWindowGetApplication, libs, "gtk_window_get_application")
	core.PuregoSafeRegister(&xWindowGetChild, libs, "gtk_window_get_child")
	core.PuregoSafeRegister(&xWindowGetDecorated, libs, "gtk_window_get_decorated")
	core.PuregoSafeRegister(&xWindowGetDefaultSize, libs, "gtk_window_get_default_size")
	core.PuregoSafeRegister(&xWindowGetDefaultWidget, libs, "gtk_window_get_default_widget")
	core.PuregoSafeRegister(&xWindowGetDeletable, libs, "gtk_window_get_deletable")
	core.PuregoSafeRegister(&xWindowGetDestroyWithParent, libs, "gtk_window_get_destroy_with_parent")
	core.PuregoSafeRegister(&xWindowGetFocus, libs, "gtk_window_get_focus")
	core.PuregoSafeRegister(&xWindowGetFocusVisible, libs, "gtk_window_get_focus_visible")
	core.PuregoSafeRegister(&xWindowGetGravity, libs, "gtk_window_get_gravity")
	core.PuregoSafeRegister(&xWindowGetGroup, libs, "gtk_window_get_group")
	core.PuregoSafeRegister(&xWindowGetHandleMenubarAccel, libs, "gtk_window_get_handle_menubar_accel")
	core.PuregoSafeRegister(&xWindowGetHideOnClose, libs, "gtk_window_get_hide_on_close")
	core.PuregoSafeRegister(&xWindowGetIconName, libs, "gtk_window_get_icon_name")
	core.PuregoSafeRegister(&xWindowGetMnemonicsVisible, libs, "gtk_window_get_mnemonics_visible")
	core.PuregoSafeRegister(&xWindowGetModal, libs, "gtk_window_get_modal")
	core.PuregoSafeRegister(&xWindowGetResizable, libs, "gtk_window_get_resizable")
	core.PuregoSafeRegister(&xWindowGetTitle, libs, "gtk_window_get_title")
	core.PuregoSafeRegister(&xWindowGetTitlebar, libs, "gtk_window_get_titlebar")
	core.PuregoSafeRegister(&xWindowGetTransientFor, libs, "gtk_window_get_transient_for")
	core.PuregoSafeRegister(&xWindowHasGroup, libs, "gtk_window_has_group")
	core.PuregoSafeRegister(&xWindowIsActive, libs, "gtk_window_is_active")
	core.PuregoSafeRegister(&xWindowIsFullscreen, libs, "gtk_window_is_fullscreen")
	core.PuregoSafeRegister(&xWindowIsMaximized, libs, "gtk_window_is_maximized")
	core.PuregoSafeRegister(&xWindowIsSuspended, libs, "gtk_window_is_suspended")
	core.PuregoSafeRegister(&xWindowMaximize, libs, "gtk_window_maximize")
	core.PuregoSafeRegister(&xWindowMinimize, libs, "gtk_window_minimize")
	core.PuregoSafeRegister(&xWindowPresent, libs, "gtk_window_present")
	core.PuregoSafeRegister(&xWindowPresentWithTime, libs, "gtk_window_present_with_time")
	core.PuregoSafeRegister(&xWindowSetApplication, libs, "gtk_window_set_application")
	core.PuregoSafeRegister(&xWindowSetChild, libs, "gtk_window_set_child")
	core.PuregoSafeRegister(&xWindowSetDecorated, libs, "gtk_window_set_decorated")
	core.PuregoSafeRegister(&xWindowSetDefaultSize, libs, "gtk_window_set_default_size")
	core.PuregoSafeRegister(&xWindowSetDefaultWidget, libs, "gtk_window_set_default_widget")
	core.PuregoSafeRegister(&xWindowSetDeletable, libs, "gtk_window_set_deletable")
	core.PuregoSafeRegister(&xWindowSetDestroyWithParent, libs, "gtk_window_set_destroy_with_parent")
	core.PuregoSafeRegister(&xWindowSetDisplay, libs, "gtk_window_set_display")
	core.PuregoSafeRegister(&xWindowSetFocus, libs, "gtk_window_set_focus")
	core.PuregoSafeRegister(&xWindowSetFocusVisible, libs, "gtk_window_set_focus_visible")
	core.PuregoSafeRegister(&xWindowSetGravity, libs, "gtk_window_set_gravity")
	core.PuregoSafeRegister(&xWindowSetHandleMenubarAccel, libs, "gtk_window_set_handle_menubar_accel")
	core.PuregoSafeRegister(&xWindowSetHideOnClose, libs, "gtk_window_set_hide_on_close")
	core.PuregoSafeRegister(&xWindowSetIconName, libs, "gtk_window_set_icon_name")
	core.PuregoSafeRegister(&xWindowSetMnemonicsVisible, libs, "gtk_window_set_mnemonics_visible")
	core.PuregoSafeRegister(&xWindowSetModal, libs, "gtk_window_set_modal")
	core.PuregoSafeRegister(&xWindowSetResizable, libs, "gtk_window_set_resizable")
	core.PuregoSafeRegister(&xWindowSetStartupId, libs, "gtk_window_set_startup_id")
	core.PuregoSafeRegister(&xWindowSetTitle, libs, "gtk_window_set_title")
	core.PuregoSafeRegister(&xWindowSetTitlebar, libs, "gtk_window_set_titlebar")
	core.PuregoSafeRegister(&xWindowSetTransientFor, libs, "gtk_window_set_transient_for")
	core.PuregoSafeRegister(&xWindowUnfullscreen, libs, "gtk_window_unfullscreen")
	core.PuregoSafeRegister(&xWindowUnmaximize, libs, "gtk_window_unmaximize")
	core.PuregoSafeRegister(&xWindowUnminimize, libs, "gtk_window_unminimize")

	core.PuregoSafeRegister(&xWindowGetDefaultIconName, libs, "gtk_window_get_default_icon_name")
	core.PuregoSafeRegister(&xWindowGetToplevels, libs, "gtk_window_get_toplevels")
	core.PuregoSafeRegister(&xWindowListToplevels, libs, "gtk_window_list_toplevels")
	core.PuregoSafeRegister(&xWindowSetAutoStartupNotification, libs, "gtk_window_set_auto_startup_notification")
	core.PuregoSafeRegister(&xWindowSetDefaultIconName, libs, "gtk_window_set_default_icon_name")
	core.PuregoSafeRegister(&xWindowSetInteractiveDebugging, libs, "gtk_window_set_interactive_debugging")

}
