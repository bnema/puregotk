// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/cairo"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/graphene"
	"github.com/jwijenbergh/puregotk/v4/gsk"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// Callback type for adding a function to update animations.
//
// See [method@Gtk.Widget.add_tick_callback].
type TickCallback func(uintptr, uintptr, uintptr) bool

// The type of the callback functions used for activating
// actions installed with [method@Gtk.WidgetClass.install_action].
//
// The @parameter must match the @parameter_type of the action.
type WidgetActionActivateFunc func(uintptr, string, *glib.Variant)

// Represents the desired size of a widget.
//
// See [GtkWidget’s geometry management section](class.Widget.html#height-for-width-geometry-management)
// for more information.
type Requisition struct {
	_ structs.HostLayout

	Width int

	Height int
}

var xRequisitionGLibType func() types.GType

func RequisitionGLibType() types.GType {
	return xRequisitionGLibType()
}

func (x *Requisition) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewRequisition func() *Requisition

// Allocates a new `GtkRequisition`.
//
// The struct is initialized to zero.
func NewRequisition() *Requisition {

	cret := xNewRequisition()
	return cret
}

var xRequisitionCopy func(uintptr) *Requisition

// Copies a `GtkRequisition`.
func (x *Requisition) Copy() *Requisition {

	cret := xRequisitionCopy(x.GoPointer())
	return cret
}

var xRequisitionFree func(uintptr)

// Frees a `GtkRequisition`.
func (x *Requisition) Free() {

	xRequisitionFree(x.GoPointer())

}

type WidgetClass struct {
	_ structs.HostLayout

	ParentClass gobject.InitiallyUnownedClass

	xShow uintptr

	xHide uintptr

	xMap uintptr

	xUnmap uintptr

	xRealize uintptr

	xUnrealize uintptr

	xRoot uintptr

	xUnroot uintptr

	xSizeAllocate uintptr

	xStateFlagsChanged uintptr

	xDirectionChanged uintptr

	xGetRequestMode uintptr

	xMeasure uintptr

	xMnemonicActivate uintptr

	xGrabFocus uintptr

	xFocus uintptr

	xSetFocusChild uintptr

	xMoveFocus uintptr

	xKeynavFailed uintptr

	xQueryTooltip uintptr

	xComputeExpand uintptr

	xCssChanged uintptr

	xSystemSettingChanged uintptr

	xSnapshot uintptr

	xContains uintptr

	Priv *WidgetClassPrivate

	Padding [8]uintptr
}

func (x *WidgetClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xWidgetClassAddBinding func(uintptr, uint, gdk.ModifierType, uintptr, uintptr, ...interface{})

// Creates a new shortcut for @widget_class that calls the given @callback
// with arguments according to @format_string.
//
// The arguments and format string must be provided in the same way as
// with [ctor@GLib.Variant.new].
//
// This function is a convenience wrapper around
// [method@Gtk.WidgetClass.add_shortcut] and must be called during class
// initialization. It does not provide for user data, if you need that,
// you will have to use [method@Gtk.WidgetClass.add_shortcut] with a custom
// shortcut.
func (x *WidgetClass) AddBinding(KeyvalVar uint, ModsVar gdk.ModifierType, CallbackVar *ShortcutFunc, FormatStringVar *string, varArgs ...interface{}) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 *glib.Variant, arg2 uintptr) bool {
				cbFn := *CallbackVar
				return cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	FormatStringVarPtr := core.GStrdupNullable(FormatStringVar)
	defer core.GFreeNullable(FormatStringVarPtr)

	xWidgetClassAddBinding(x.GoPointer(), KeyvalVar, ModsVar, CallbackVarRef, FormatStringVarPtr, varArgs...)

}

var xWidgetClassAddBindingAction func(uintptr, uint, gdk.ModifierType, string, uintptr, ...interface{})

// Creates a new shortcut for @widget_class that activates the given
// @action_name with arguments read according to @format_string.
//
// The arguments and format string must be provided in the same way as
// with [ctor@GLib.Variant.new].
//
// This function is a convenience wrapper around
// [method@Gtk.WidgetClass.add_shortcut] and must be called during class
// initialization.
func (x *WidgetClass) AddBindingAction(KeyvalVar uint, ModsVar gdk.ModifierType, ActionNameVar string, FormatStringVar *string, varArgs ...interface{}) {

	FormatStringVarPtr := core.GStrdupNullable(FormatStringVar)
	defer core.GFreeNullable(FormatStringVarPtr)

	xWidgetClassAddBindingAction(x.GoPointer(), KeyvalVar, ModsVar, ActionNameVar, FormatStringVarPtr, varArgs...)

}

var xWidgetClassAddBindingSignal func(uintptr, uint, gdk.ModifierType, string, uintptr, ...interface{})

// Creates a new shortcut for @widget_class that emits the given action
// @signal with arguments read according to @format_string.
//
// The arguments and format string must be provided in the same way as
// with [ctor@GLib.Variant.new].
//
// This function is a convenience wrapper around
// [method@Gtk.WidgetClass.add_shortcut] and must be called during class
// initialization.
func (x *WidgetClass) AddBindingSignal(KeyvalVar uint, ModsVar gdk.ModifierType, SignalVar string, FormatStringVar *string, varArgs ...interface{}) {

	FormatStringVarPtr := core.GStrdupNullable(FormatStringVar)
	defer core.GFreeNullable(FormatStringVarPtr)

	xWidgetClassAddBindingSignal(x.GoPointer(), KeyvalVar, ModsVar, SignalVar, FormatStringVarPtr, varArgs...)

}

var xWidgetClassAddShortcut func(uintptr, uintptr)

// Installs a shortcut in @widget_class.
//
// Every instance created for @widget_class or its subclasses will
// inherit this shortcut and trigger it.
//
// Shortcuts added this way will be triggered in the [enum@Gtk.PropagationPhase.bubble]
// phase, which means they may also trigger if child widgets have focus.
//
// This function must only be used in class initialization functions
// otherwise it is not guaranteed that the shortcut will be installed.
func (x *WidgetClass) AddShortcut(ShortcutVar *Shortcut) {

	xWidgetClassAddShortcut(x.GoPointer(), ShortcutVar.GoPointer())

}

var xWidgetClassBindTemplateCallbackFull func(uintptr, string, uintptr)

// Associates a name to be used in GtkBuilder XML with a symbol.
//
// This function is not supported after [method@Gtk.WidgetClass.set_template_scope]
// has been used on @widget_class.
//
// See [method@Gtk.BuilderCScope.add_callback_symbol].
//
// Note that this must be called from a composite widget classes
// class initializer after calling [method@Gtk.WidgetClass.set_template].
func (x *WidgetClass) BindTemplateCallbackFull(CallbackNameVar string, CallbackSymbolVar *gobject.Callback) {

	var CallbackSymbolVarRef uintptr
	if CallbackSymbolVar != nil {
		CallbackSymbolVarPtr := uintptr(unsafe.Pointer(CallbackSymbolVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackSymbolVarPtr); ok {
			CallbackSymbolVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackSymbolVar
				cbFn()
			}
			CallbackSymbolVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackSymbolVarPtr, CallbackSymbolVarRef, CallbackSymbolVar)
		}
	}

	xWidgetClassBindTemplateCallbackFull(x.GoPointer(), CallbackNameVar, CallbackSymbolVarRef)

}

var xWidgetClassBindTemplateChildFull func(uintptr, string, bool, int)

// Assigns an object declared in the class template XML to be set to
// a location on a freshly built instance’s private data, or
// alternatively accessible via [method@Gtk.Widget.get_template_child].
//
// The struct can point either into the public instance, then you should
// use `G_STRUCT_OFFSET(WidgetType, member)` for @struct_offset, or in the
// private struct, then you should use `G_PRIVATE_OFFSET(WidgetType, member)`.
//
// An explicit strong reference will be held automatically for the duration
// of your instance’s life cycle, it will be released automatically when
// `GObjectClass.dispose()` runs on your instance and if a nonzero @struct_offset
// is specified, then the automatic location in your instance public or private
// data will be set to `NULL`. You can however access an automated child pointer
// the first time your classes `GObjectClass.dispose()` runs, or alternatively
// in [signal@Gtk.Widget::destroy].
//
// If @internal_child is specified, [vfunc@Gtk.Buildable.get_internal_child]
// will be automatically implemented by the widget class so there is no
// need to implement it manually.
//
// The wrapper macros [func@Gtk.widget_class_bind_template_child],
// [func@Gtk.widget_class_bind_template_child_internal],
// [func@Gtk.widget_class_bind_template_child_private] and
// [func@Gtk.widget_class_bind_template_child_internal_private]
// might be more convenient to use.
//
// Note that this must be called from a composite widget classes class
// initializer after calling [method@Gtk.WidgetClass.set_template].
func (x *WidgetClass) BindTemplateChildFull(NameVar string, InternalChildVar bool, StructOffsetVar int) {

	xWidgetClassBindTemplateChildFull(x.GoPointer(), NameVar, InternalChildVar, StructOffsetVar)

}

var xWidgetClassGetAccessibleRole func(uintptr) AccessibleRole

// Retrieves the accessible role used by the given widget class.
//
// Different accessible roles have different states, and are rendered
// differently by assistive technologies.
//
// See also: [method@Gtk.Accessible.get_accessible_role].
func (x *WidgetClass) GetAccessibleRole() AccessibleRole {

	cret := xWidgetClassGetAccessibleRole(x.GoPointer())
	return cret
}

var xWidgetClassGetActivateSignal func(uintptr) uint

// Retrieves the signal id for the activation signal.
//
// The activation signal is set using
// [method@Gtk.WidgetClass.set_activate_signal].
func (x *WidgetClass) GetActivateSignal() uint {

	cret := xWidgetClassGetActivateSignal(x.GoPointer())
	return cret
}

var xWidgetClassGetCssName func(uintptr) string

// Gets the name used by this class for matching in CSS code.
//
// See [method@Gtk.WidgetClass.set_css_name] for details.
func (x *WidgetClass) GetCssName() string {

	cret := xWidgetClassGetCssName(x.GoPointer())
	return cret
}

var xWidgetClassGetLayoutManagerType func(uintptr) types.GType

// Retrieves the type of the [class@Gtk.LayoutManager]
// used by widgets of class @widget_class.
//
// See also: [method@Gtk.WidgetClass.set_layout_manager_type].
func (x *WidgetClass) GetLayoutManagerType() types.GType {

	cret := xWidgetClassGetLayoutManagerType(x.GoPointer())
	return cret
}

var xWidgetClassInstallAction func(uintptr, string, uintptr, uintptr)

// Adds an action for all instances of a widget class.
//
// This function should be called at class initialization time.
//
// Actions installed by this function are stateless. The only state
// they have is whether they are enabled or not (which can be changed
// with [method@Gtk.Widget.action_set_enabled]).
func (x *WidgetClass) InstallAction(ActionNameVar string, ParameterTypeVar *string, ActivateVar *WidgetActionActivateFunc) {

	var ActivateVarRef uintptr
	if ActivateVar != nil {
		ActivateVarPtr := uintptr(unsafe.Pointer(ActivateVar))
		if cbRefPtr, ok := glib.GetCallback(ActivateVarPtr); ok {
			ActivateVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 string, arg2 *glib.Variant) {
				cbFn := *ActivateVar
				cbFn(arg0, arg1, arg2)
			}
			ActivateVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(ActivateVarPtr, ActivateVarRef, ActivateVar)
		}
	}

	ParameterTypeVarPtr := core.GStrdupNullable(ParameterTypeVar)
	defer core.GFreeNullable(ParameterTypeVarPtr)

	xWidgetClassInstallAction(x.GoPointer(), ActionNameVar, ParameterTypeVarPtr, ActivateVarRef)

}

var xWidgetClassInstallPropertyAction func(uintptr, string, string)

// Installs an action called @action_name on @widget_class and
// binds its state to the value of the @property_name property.
//
// This function will perform a few sanity checks on the property selected
// via @property_name. Namely, the property must exist, must be readable,
// writable and must not be construct-only. There are also restrictions
// on the type of the given property, it must be boolean, int, unsigned int,
// double or string. If any of these conditions are not met, a critical
// warning will be printed and no action will be added.
//
// The state type of the action matches the property type.
//
// If the property is boolean, the action will have no parameter and
// toggle the property value. Otherwise, the action will have a parameter
// of the same type as the property.
func (x *WidgetClass) InstallPropertyAction(ActionNameVar string, PropertyNameVar string) {

	xWidgetClassInstallPropertyAction(x.GoPointer(), ActionNameVar, PropertyNameVar)

}

var xWidgetClassQueryAction func(uintptr, uint, *types.GType, *string, **glib.VariantType, *string) bool

// Returns details about an action that has been
// installed for @widget_class.
//
// See [method@Gtk.WidgetClass.install_action] for details on
// how to install actions.
//
// Note that this function will also return actions defined
// by parent classes. You can identify those by looking
// at @owner.
func (x *WidgetClass) QueryAction(IndexVar uint, OwnerVar *types.GType, ActionNameVar *string, ParameterTypeVar **glib.VariantType, PropertyNameVar *string) bool {

	cret := xWidgetClassQueryAction(x.GoPointer(), IndexVar, OwnerVar, ActionNameVar, ParameterTypeVar, PropertyNameVar)
	return cret
}

var xWidgetClassSetAccessibleRole func(uintptr, AccessibleRole)

// Sets the accessible role used by the given widget class.
//
// Different accessible roles have different states, and are
// rendered differently by assistive technologies.
func (x *WidgetClass) SetAccessibleRole(AccessibleRoleVar AccessibleRole) {

	xWidgetClassSetAccessibleRole(x.GoPointer(), AccessibleRoleVar)

}

var xWidgetClassSetActivateSignal func(uintptr, uint)

// Sets the activation signal for a widget class.
//
// The signal will be emitted when calling [method@Gtk.Widget.activate].
//
// The @signal_id must have been registered with [function.GObject.signal_new]
// or [func@GObject.signal_newv] before calling this function.
func (x *WidgetClass) SetActivateSignal(SignalIdVar uint) {

	xWidgetClassSetActivateSignal(x.GoPointer(), SignalIdVar)

}

var xWidgetClassSetActivateSignalFromName func(uintptr, string)

// Sets the activation signal for a widget class.
//
// The signal id will by looked up by @signal_name.
//
// The signal will be emitted when calling [method@Gtk.Widget.activate].
//
// The @signal_name must have been registered with [function.GObject.signal_new]
// or [func@GObject.signal_newv] before calling this function.
func (x *WidgetClass) SetActivateSignalFromName(SignalNameVar string) {

	xWidgetClassSetActivateSignalFromName(x.GoPointer(), SignalNameVar)

}

var xWidgetClassSetCssName func(uintptr, string)

// Sets the name to be used for CSS matching of widgets.
//
// If this function is not called for a given class, the name
// set on the parent class is used. By default, `GtkWidget`
// uses the name "widget".
func (x *WidgetClass) SetCssName(NameVar string) {

	xWidgetClassSetCssName(x.GoPointer(), NameVar)

}

var xWidgetClassSetLayoutManagerType func(uintptr, types.GType)

// Sets the type to be used for creating layout managers for
// widgets of @widget_class.
//
// The given @type must be a subtype of [class@Gtk.LayoutManager].
//
// This function should only be called from class init functions
// of widgets.
func (x *WidgetClass) SetLayoutManagerType(TypeVar types.GType) {

	xWidgetClassSetLayoutManagerType(x.GoPointer(), TypeVar)

}

var xWidgetClassSetTemplate func(uintptr, *glib.Bytes)

// This should be called at class initialization time to specify
// the `GtkBuilder` XML to be used to extend a widget.
//
// For convenience, [method@Gtk.WidgetClass.set_template_from_resource]
// is also provided.
//
// Note that any class that installs templates must call
// [method@Gtk.Widget.init_template] in the widget’s instance initializer.
func (x *WidgetClass) SetTemplate(TemplateBytesVar *glib.Bytes) {

	xWidgetClassSetTemplate(x.GoPointer(), TemplateBytesVar)

}

var xWidgetClassSetTemplateFromResource func(uintptr, string)

// A convenience function that calls [method@Gtk.WidgetClass.set_template]
// with the contents of a resource.
//
// Note that any class that installs templates must call
// [method@Gtk.Widget.init_template] in the widget’s instance
// initializer.
func (x *WidgetClass) SetTemplateFromResource(ResourceNameVar string) {

	xWidgetClassSetTemplateFromResource(x.GoPointer(), ResourceNameVar)

}

var xWidgetClassSetTemplateScope func(uintptr, uintptr)

// Overrides the default scope to be used when parsing the class template.
//
// This function is intended for language bindings.
//
// Note that this must be called from a composite widget classes class
// initializer after calling [method@Gtk.WidgetClass.set_template].
func (x *WidgetClass) SetTemplateScope(ScopeVar BuilderScope) {

	xWidgetClassSetTemplateScope(x.GoPointer(), ScopeVar.GoPointer())

}

// OverrideShow sets the "show" callback function.
// Signal emitted when widget is shown
func (x *WidgetClass) OverrideShow(cb func(*Widget)) {
	if cb == nil {
		x.xShow = 0
	} else {
		x.xShow = purego.NewCallback(func(WidgetVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetShow gets the "show" callback function.
// Signal emitted when widget is shown
func (x *WidgetClass) GetShow() func(*Widget) {
	if x.xShow == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xShow)
	return func(WidgetVar *Widget) {
		rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideHide sets the "hide" callback function.
// Signal emitted when widget is hidden.
func (x *WidgetClass) OverrideHide(cb func(*Widget)) {
	if cb == nil {
		x.xHide = 0
	} else {
		x.xHide = purego.NewCallback(func(WidgetVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetHide gets the "hide" callback function.
// Signal emitted when widget is hidden.
func (x *WidgetClass) GetHide() func(*Widget) {
	if x.xHide == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xHide)
	return func(WidgetVar *Widget) {
		rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideMap sets the "map" callback function.
// Signal emitted when widget is going to be mapped, that is
//
//	when the widget is visible (which is controlled with
//	gtk_widget_set_visible()) and all its parents up to the toplevel
//	widget are also visible.
func (x *WidgetClass) OverrideMap(cb func(*Widget)) {
	if cb == nil {
		x.xMap = 0
	} else {
		x.xMap = purego.NewCallback(func(WidgetVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetMap gets the "map" callback function.
// Signal emitted when widget is going to be mapped, that is
//
//	when the widget is visible (which is controlled with
//	gtk_widget_set_visible()) and all its parents up to the toplevel
//	widget are also visible.
func (x *WidgetClass) GetMap() func(*Widget) {
	if x.xMap == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMap)
	return func(WidgetVar *Widget) {
		rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideUnmap sets the "unmap" callback function.
// Signal emitted when widget is going to be unmapped, which
//
//	means that either it or any of its parents up to the toplevel
//	widget have been set as hidden.
func (x *WidgetClass) OverrideUnmap(cb func(*Widget)) {
	if cb == nil {
		x.xUnmap = 0
	} else {
		x.xUnmap = purego.NewCallback(func(WidgetVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetUnmap gets the "unmap" callback function.
// Signal emitted when widget is going to be unmapped, which
//
//	means that either it or any of its parents up to the toplevel
//	widget have been set as hidden.
func (x *WidgetClass) GetUnmap() func(*Widget) {
	if x.xUnmap == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnmap)
	return func(WidgetVar *Widget) {
		rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideRealize sets the "realize" callback function.
// Signal emitted when widget is associated with a
//
//	`GdkSurface`, which means that gtk_widget_realize() has been called or
//	the widget has been mapped (that is, it is going to be drawn).
func (x *WidgetClass) OverrideRealize(cb func(*Widget)) {
	if cb == nil {
		x.xRealize = 0
	} else {
		x.xRealize = purego.NewCallback(func(WidgetVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetRealize gets the "realize" callback function.
// Signal emitted when widget is associated with a
//
//	`GdkSurface`, which means that gtk_widget_realize() has been called or
//	the widget has been mapped (that is, it is going to be drawn).
func (x *WidgetClass) GetRealize() func(*Widget) {
	if x.xRealize == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRealize)
	return func(WidgetVar *Widget) {
		rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideUnrealize sets the "unrealize" callback function.
// Signal emitted when the GdkSurface associated with
//
//	widget is destroyed, which means that gtk_widget_unrealize() has
//	been called or the widget has been unmapped (that is, it is going
//	to be hidden).
func (x *WidgetClass) OverrideUnrealize(cb func(*Widget)) {
	if cb == nil {
		x.xUnrealize = 0
	} else {
		x.xUnrealize = purego.NewCallback(func(WidgetVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetUnrealize gets the "unrealize" callback function.
// Signal emitted when the GdkSurface associated with
//
//	widget is destroyed, which means that gtk_widget_unrealize() has
//	been called or the widget has been unmapped (that is, it is going
//	to be hidden).
func (x *WidgetClass) GetUnrealize() func(*Widget) {
	if x.xUnrealize == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnrealize)
	return func(WidgetVar *Widget) {
		rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideRoot sets the "root" callback function.
// Called when the widget gets added to a `GtkRoot` widget. Must
//
//	chain up
func (x *WidgetClass) OverrideRoot(cb func(*Widget)) {
	if cb == nil {
		x.xRoot = 0
	} else {
		x.xRoot = purego.NewCallback(func(WidgetVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetRoot gets the "root" callback function.
// Called when the widget gets added to a `GtkRoot` widget. Must
//
//	chain up
func (x *WidgetClass) GetRoot() func(*Widget) {
	if x.xRoot == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRoot)
	return func(WidgetVar *Widget) {
		rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideUnroot sets the "unroot" callback function.
// Called when the widget is about to be removed from its
//
//	`GtkRoot` widget. Must chain up
func (x *WidgetClass) OverrideUnroot(cb func(*Widget)) {
	if cb == nil {
		x.xUnroot = 0
	} else {
		x.xUnroot = purego.NewCallback(func(WidgetVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetUnroot gets the "unroot" callback function.
// Called when the widget is about to be removed from its
//
//	`GtkRoot` widget. Must chain up
func (x *WidgetClass) GetUnroot() func(*Widget) {
	if x.xUnroot == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnroot)
	return func(WidgetVar *Widget) {
		rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideSizeAllocate sets the "size_allocate" callback function.
// Called to set the allocation, if the widget does
//
//	not have a layout manager.
func (x *WidgetClass) OverrideSizeAllocate(cb func(*Widget, int, int, int)) {
	if cb == nil {
		x.xSizeAllocate = 0
	} else {
		x.xSizeAllocate = purego.NewCallback(func(WidgetVarp uintptr, WidthVarp int, HeightVarp int, BaselineVarp int) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), WidthVarp, HeightVarp, BaselineVarp)
		})
	}
}

// GetSizeAllocate gets the "size_allocate" callback function.
// Called to set the allocation, if the widget does
//
//	not have a layout manager.
func (x *WidgetClass) GetSizeAllocate() func(*Widget, int, int, int) {
	if x.xSizeAllocate == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, WidthVarp int, HeightVarp int, BaselineVarp int)
	purego.RegisterFunc(&rawCallback, x.xSizeAllocate)
	return func(WidgetVar *Widget, WidthVar int, HeightVar int, BaselineVar int) {
		rawCallback(WidgetVar.GoPointer(), WidthVar, HeightVar, BaselineVar)
	}
}

// OverrideStateFlagsChanged sets the "state_flags_changed" callback function.
// Signal emitted when the widget state changes,
//
//	see gtk_widget_get_state_flags().
func (x *WidgetClass) OverrideStateFlagsChanged(cb func(*Widget, StateFlags)) {
	if cb == nil {
		x.xStateFlagsChanged = 0
	} else {
		x.xStateFlagsChanged = purego.NewCallback(func(WidgetVarp uintptr, PreviousStateFlagsVarp StateFlags) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), PreviousStateFlagsVarp)
		})
	}
}

// GetStateFlagsChanged gets the "state_flags_changed" callback function.
// Signal emitted when the widget state changes,
//
//	see gtk_widget_get_state_flags().
func (x *WidgetClass) GetStateFlagsChanged() func(*Widget, StateFlags) {
	if x.xStateFlagsChanged == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, PreviousStateFlagsVarp StateFlags)
	purego.RegisterFunc(&rawCallback, x.xStateFlagsChanged)
	return func(WidgetVar *Widget, PreviousStateFlagsVar StateFlags) {
		rawCallback(WidgetVar.GoPointer(), PreviousStateFlagsVar)
	}
}

// OverrideDirectionChanged sets the "direction_changed" callback function.
// Signal emitted when the text direction of a
//
//	widget changes.
func (x *WidgetClass) OverrideDirectionChanged(cb func(*Widget, TextDirection)) {
	if cb == nil {
		x.xDirectionChanged = 0
	} else {
		x.xDirectionChanged = purego.NewCallback(func(WidgetVarp uintptr, PreviousDirectionVarp TextDirection) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), PreviousDirectionVarp)
		})
	}
}

// GetDirectionChanged gets the "direction_changed" callback function.
// Signal emitted when the text direction of a
//
//	widget changes.
func (x *WidgetClass) GetDirectionChanged() func(*Widget, TextDirection) {
	if x.xDirectionChanged == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, PreviousDirectionVarp TextDirection)
	purego.RegisterFunc(&rawCallback, x.xDirectionChanged)
	return func(WidgetVar *Widget, PreviousDirectionVar TextDirection) {
		rawCallback(WidgetVar.GoPointer(), PreviousDirectionVar)
	}
}

// OverrideGetRequestMode sets the "get_request_mode" callback function.
// Called to get the request mode, if the widget
//
//	does not have a layout manager.
//	This allows a widget to tell its parent container whether
//	it prefers to be allocated in %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH or
//	%GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT mode.
//	%GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH means the widget prefers to have
//	`GtkWidgetClass.measure()` called first to get the default width (passing
//	a for_size of -1), then again to get the height for said default width.
//	%GTK_SIZE_REQUEST_CONSTANT_SIZE disables any height-for-width or
//	width-for-height geometry management for said widget and is the
//	default return.
//	It’s important to note that any widget
//	which trades height-for-width or width-for-height must respond properly
//	to a for_size value &gt;= -1 passed to `GtkWidgetClass.measure`, for both
//	possible orientations.
func (x *WidgetClass) OverrideGetRequestMode(cb func(*Widget) SizeRequestMode) {
	if cb == nil {
		x.xGetRequestMode = 0
	} else {
		x.xGetRequestMode = purego.NewCallback(func(WidgetVarp uintptr) SizeRequestMode {
			return cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetGetRequestMode gets the "get_request_mode" callback function.
// Called to get the request mode, if the widget
//
//	does not have a layout manager.
//	This allows a widget to tell its parent container whether
//	it prefers to be allocated in %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH or
//	%GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT mode.
//	%GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH means the widget prefers to have
//	`GtkWidgetClass.measure()` called first to get the default width (passing
//	a for_size of -1), then again to get the height for said default width.
//	%GTK_SIZE_REQUEST_CONSTANT_SIZE disables any height-for-width or
//	width-for-height geometry management for said widget and is the
//	default return.
//	It’s important to note that any widget
//	which trades height-for-width or width-for-height must respond properly
//	to a for_size value &gt;= -1 passed to `GtkWidgetClass.measure`, for both
//	possible orientations.
func (x *WidgetClass) GetGetRequestMode() func(*Widget) SizeRequestMode {
	if x.xGetRequestMode == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr) SizeRequestMode
	purego.RegisterFunc(&rawCallback, x.xGetRequestMode)
	return func(WidgetVar *Widget) SizeRequestMode {
		return rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideMeasure sets the "measure" callback function.
// Called to obtain the minimum and natural size of the widget,
//
//	if the widget does not have a layout manager.
//	Depending on the orientation parameter, the passed for_size can be
//	interpreted as width or height. A widget will never be allocated less
//	than its minimum size.
func (x *WidgetClass) OverrideMeasure(cb func(*Widget, Orientation, int, *int, *int, *int, *int)) {
	if cb == nil {
		x.xMeasure = 0
	} else {
		x.xMeasure = purego.NewCallback(func(WidgetVarp uintptr, OrientationVarp Orientation, ForSizeVarp int, MinimumVarp *int, NaturalVarp *int, MinimumBaselineVarp *int, NaturalBaselineVarp *int) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), OrientationVarp, ForSizeVarp, MinimumVarp, NaturalVarp, MinimumBaselineVarp, NaturalBaselineVarp)
		})
	}
}

// GetMeasure gets the "measure" callback function.
// Called to obtain the minimum and natural size of the widget,
//
//	if the widget does not have a layout manager.
//	Depending on the orientation parameter, the passed for_size can be
//	interpreted as width or height. A widget will never be allocated less
//	than its minimum size.
func (x *WidgetClass) GetMeasure() func(*Widget, Orientation, int, *int, *int, *int, *int) {
	if x.xMeasure == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, OrientationVarp Orientation, ForSizeVarp int, MinimumVarp *int, NaturalVarp *int, MinimumBaselineVarp *int, NaturalBaselineVarp *int)
	purego.RegisterFunc(&rawCallback, x.xMeasure)
	return func(WidgetVar *Widget, OrientationVar Orientation, ForSizeVar int, MinimumVar *int, NaturalVar *int, MinimumBaselineVar *int, NaturalBaselineVar *int) {
		rawCallback(WidgetVar.GoPointer(), OrientationVar, ForSizeVar, MinimumVar, NaturalVar, MinimumBaselineVar, NaturalBaselineVar)
	}
}

// OverrideMnemonicActivate sets the "mnemonic_activate" callback function.
// Activates the @widget if @group_cycling is
//
//	%FALSE, and just grabs the focus if @group_cycling is %TRUE.
func (x *WidgetClass) OverrideMnemonicActivate(cb func(*Widget, bool) bool) {
	if cb == nil {
		x.xMnemonicActivate = 0
	} else {
		x.xMnemonicActivate = purego.NewCallback(func(WidgetVarp uintptr, GroupCyclingVarp bool) bool {
			return cb(WidgetNewFromInternalPtr(WidgetVarp), GroupCyclingVarp)
		})
	}
}

// GetMnemonicActivate gets the "mnemonic_activate" callback function.
// Activates the @widget if @group_cycling is
//
//	%FALSE, and just grabs the focus if @group_cycling is %TRUE.
func (x *WidgetClass) GetMnemonicActivate() func(*Widget, bool) bool {
	if x.xMnemonicActivate == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, GroupCyclingVarp bool) bool
	purego.RegisterFunc(&rawCallback, x.xMnemonicActivate)
	return func(WidgetVar *Widget, GroupCyclingVar bool) bool {
		return rawCallback(WidgetVar.GoPointer(), GroupCyclingVar)
	}
}

// OverrideGrabFocus sets the "grab_focus" callback function.
// Causes @widget to have the keyboard focus for the
//
//	`GtkWindow` it’s inside.
func (x *WidgetClass) OverrideGrabFocus(cb func(*Widget) bool) {
	if cb == nil {
		x.xGrabFocus = 0
	} else {
		x.xGrabFocus = purego.NewCallback(func(WidgetVarp uintptr) bool {
			return cb(WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetGrabFocus gets the "grab_focus" callback function.
// Causes @widget to have the keyboard focus for the
//
//	`GtkWindow` it’s inside.
func (x *WidgetClass) GetGrabFocus() func(*Widget) bool {
	if x.xGrabFocus == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xGrabFocus)
	return func(WidgetVar *Widget) bool {
		return rawCallback(WidgetVar.GoPointer())
	}
}

// OverrideFocus sets the "focus" callback function.
// Vfunc for gtk_widget_child_focus()
func (x *WidgetClass) OverrideFocus(cb func(*Widget, DirectionType) bool) {
	if cb == nil {
		x.xFocus = 0
	} else {
		x.xFocus = purego.NewCallback(func(WidgetVarp uintptr, DirectionVarp DirectionType) bool {
			return cb(WidgetNewFromInternalPtr(WidgetVarp), DirectionVarp)
		})
	}
}

// GetFocus gets the "focus" callback function.
// Vfunc for gtk_widget_child_focus()
func (x *WidgetClass) GetFocus() func(*Widget, DirectionType) bool {
	if x.xFocus == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, DirectionVarp DirectionType) bool
	purego.RegisterFunc(&rawCallback, x.xFocus)
	return func(WidgetVar *Widget, DirectionVar DirectionType) bool {
		return rawCallback(WidgetVar.GoPointer(), DirectionVar)
	}
}

// OverrideSetFocusChild sets the "set_focus_child" callback function.
// Sets the focused child of a widget. Must chain up
func (x *WidgetClass) OverrideSetFocusChild(cb func(*Widget, *Widget)) {
	if cb == nil {
		x.xSetFocusChild = 0
	} else {
		x.xSetFocusChild = purego.NewCallback(func(WidgetVarp uintptr, ChildVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), WidgetNewFromInternalPtr(ChildVarp))
		})
	}
}

// GetSetFocusChild gets the "set_focus_child" callback function.
// Sets the focused child of a widget. Must chain up
func (x *WidgetClass) GetSetFocusChild() func(*Widget, *Widget) {
	if x.xSetFocusChild == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, ChildVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSetFocusChild)
	return func(WidgetVar *Widget, ChildVar *Widget) {
		rawCallback(WidgetVar.GoPointer(), ChildVar.GoPointer())
	}
}

// OverrideMoveFocus sets the "move_focus" callback function.
// Signal emitted when a change of focus is requested
func (x *WidgetClass) OverrideMoveFocus(cb func(*Widget, DirectionType)) {
	if cb == nil {
		x.xMoveFocus = 0
	} else {
		x.xMoveFocus = purego.NewCallback(func(WidgetVarp uintptr, DirectionVarp DirectionType) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), DirectionVarp)
		})
	}
}

// GetMoveFocus gets the "move_focus" callback function.
// Signal emitted when a change of focus is requested
func (x *WidgetClass) GetMoveFocus() func(*Widget, DirectionType) {
	if x.xMoveFocus == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, DirectionVarp DirectionType)
	purego.RegisterFunc(&rawCallback, x.xMoveFocus)
	return func(WidgetVar *Widget, DirectionVar DirectionType) {
		rawCallback(WidgetVar.GoPointer(), DirectionVar)
	}
}

// OverrideKeynavFailed sets the "keynav_failed" callback function.
// Signal emitted if keyboard navigation fails.
func (x *WidgetClass) OverrideKeynavFailed(cb func(*Widget, DirectionType) bool) {
	if cb == nil {
		x.xKeynavFailed = 0
	} else {
		x.xKeynavFailed = purego.NewCallback(func(WidgetVarp uintptr, DirectionVarp DirectionType) bool {
			return cb(WidgetNewFromInternalPtr(WidgetVarp), DirectionVarp)
		})
	}
}

// GetKeynavFailed gets the "keynav_failed" callback function.
// Signal emitted if keyboard navigation fails.
func (x *WidgetClass) GetKeynavFailed() func(*Widget, DirectionType) bool {
	if x.xKeynavFailed == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, DirectionVarp DirectionType) bool
	purego.RegisterFunc(&rawCallback, x.xKeynavFailed)
	return func(WidgetVar *Widget, DirectionVar DirectionType) bool {
		return rawCallback(WidgetVar.GoPointer(), DirectionVar)
	}
}

// OverrideQueryTooltip sets the "query_tooltip" callback function.
// Signal emitted when “has-tooltip” is %TRUE and the
//
//	hover timeout has expired with the cursor hovering “above”
//	widget; or emitted when widget got focus in keyboard mode.
func (x *WidgetClass) OverrideQueryTooltip(cb func(*Widget, int, int, bool, *Tooltip) bool) {
	if cb == nil {
		x.xQueryTooltip = 0
	} else {
		x.xQueryTooltip = purego.NewCallback(func(WidgetVarp uintptr, XVarp int, YVarp int, KeyboardTooltipVarp bool, TooltipVarp uintptr) bool {
			return cb(WidgetNewFromInternalPtr(WidgetVarp), XVarp, YVarp, KeyboardTooltipVarp, TooltipNewFromInternalPtr(TooltipVarp))
		})
	}
}

// GetQueryTooltip gets the "query_tooltip" callback function.
// Signal emitted when “has-tooltip” is %TRUE and the
//
//	hover timeout has expired with the cursor hovering “above”
//	widget; or emitted when widget got focus in keyboard mode.
func (x *WidgetClass) GetQueryTooltip() func(*Widget, int, int, bool, *Tooltip) bool {
	if x.xQueryTooltip == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, XVarp int, YVarp int, KeyboardTooltipVarp bool, TooltipVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xQueryTooltip)
	return func(WidgetVar *Widget, XVar int, YVar int, KeyboardTooltipVar bool, TooltipVar *Tooltip) bool {
		return rawCallback(WidgetVar.GoPointer(), XVar, YVar, KeyboardTooltipVar, TooltipVar.GoPointer())
	}
}

// OverrideComputeExpand sets the "compute_expand" callback function.
// Computes whether a container should give this
//
//	widget extra space when possible.
func (x *WidgetClass) OverrideComputeExpand(cb func(*Widget, bool, bool)) {
	if cb == nil {
		x.xComputeExpand = 0
	} else {
		x.xComputeExpand = purego.NewCallback(func(WidgetVarp uintptr, HexpandPVarp bool, VexpandPVarp bool) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), HexpandPVarp, VexpandPVarp)
		})
	}
}

// GetComputeExpand gets the "compute_expand" callback function.
// Computes whether a container should give this
//
//	widget extra space when possible.
func (x *WidgetClass) GetComputeExpand() func(*Widget, bool, bool) {
	if x.xComputeExpand == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, HexpandPVarp bool, VexpandPVarp bool)
	purego.RegisterFunc(&rawCallback, x.xComputeExpand)
	return func(WidgetVar *Widget, HexpandPVar bool, VexpandPVar bool) {
		rawCallback(WidgetVar.GoPointer(), HexpandPVar, VexpandPVar)
	}
}

// OverrideCssChanged sets the "css_changed" callback function.
// Vfunc called when the CSS used by widget was changed. Widgets
//
//	should then discard their caches that depend on CSS and queue resizes or
//	redraws accordingly. The default implementation will take care of this for
//	all the default CSS properties, so implementations must chain up.
func (x *WidgetClass) OverrideCssChanged(cb func(*Widget, *CssStyleChange)) {
	if cb == nil {
		x.xCssChanged = 0
	} else {
		x.xCssChanged = purego.NewCallback(func(WidgetVarp uintptr, ChangeVarp *CssStyleChange) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), ChangeVarp)
		})
	}
}

// GetCssChanged gets the "css_changed" callback function.
// Vfunc called when the CSS used by widget was changed. Widgets
//
//	should then discard their caches that depend on CSS and queue resizes or
//	redraws accordingly. The default implementation will take care of this for
//	all the default CSS properties, so implementations must chain up.
func (x *WidgetClass) GetCssChanged() func(*Widget, *CssStyleChange) {
	if x.xCssChanged == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, ChangeVarp *CssStyleChange)
	purego.RegisterFunc(&rawCallback, x.xCssChanged)
	return func(WidgetVar *Widget, ChangeVar *CssStyleChange) {
		rawCallback(WidgetVar.GoPointer(), ChangeVar)
	}
}

// OverrideSystemSettingChanged sets the "system_setting_changed" callback function.
// Emitted when a system setting was changed. Must chain up.
func (x *WidgetClass) OverrideSystemSettingChanged(cb func(*Widget, SystemSetting)) {
	if cb == nil {
		x.xSystemSettingChanged = 0
	} else {
		x.xSystemSettingChanged = purego.NewCallback(func(WidgetVarp uintptr, SettingsVarp SystemSetting) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), SettingsVarp)
		})
	}
}

// GetSystemSettingChanged gets the "system_setting_changed" callback function.
// Emitted when a system setting was changed. Must chain up.
func (x *WidgetClass) GetSystemSettingChanged() func(*Widget, SystemSetting) {
	if x.xSystemSettingChanged == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, SettingsVarp SystemSetting)
	purego.RegisterFunc(&rawCallback, x.xSystemSettingChanged)
	return func(WidgetVar *Widget, SettingsVar SystemSetting) {
		rawCallback(WidgetVar.GoPointer(), SettingsVar)
	}
}

// OverrideSnapshot sets the "snapshot" callback function.
// Vfunc called when a new snapshot of the widget has to be taken.
func (x *WidgetClass) OverrideSnapshot(cb func(*Widget, *Snapshot)) {
	if cb == nil {
		x.xSnapshot = 0
	} else {
		x.xSnapshot = purego.NewCallback(func(WidgetVarp uintptr, SnapshotVarp uintptr) {
			cb(WidgetNewFromInternalPtr(WidgetVarp), SnapshotNewFromInternalPtr(SnapshotVarp))
		})
	}
}

// GetSnapshot gets the "snapshot" callback function.
// Vfunc called when a new snapshot of the widget has to be taken.
func (x *WidgetClass) GetSnapshot() func(*Widget, *Snapshot) {
	if x.xSnapshot == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, SnapshotVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSnapshot)
	return func(WidgetVar *Widget, SnapshotVar *Snapshot) {
		rawCallback(WidgetVar.GoPointer(), SnapshotVar.GoPointer())
	}
}

// OverrideContains sets the "contains" callback function.
// Vfunc for gtk_widget_contains().
func (x *WidgetClass) OverrideContains(cb func(*Widget, float64, float64) bool) {
	if cb == nil {
		x.xContains = 0
	} else {
		x.xContains = purego.NewCallback(func(WidgetVarp uintptr, XVarp float64, YVarp float64) bool {
			return cb(WidgetNewFromInternalPtr(WidgetVarp), XVarp, YVarp)
		})
	}
}

// GetContains gets the "contains" callback function.
// Vfunc for gtk_widget_contains().
func (x *WidgetClass) GetContains() func(*Widget, float64, float64) bool {
	if x.xContains == 0 {
		return nil
	}
	var rawCallback func(WidgetVarp uintptr, XVarp float64, YVarp float64) bool
	purego.RegisterFunc(&rawCallback, x.xContains)
	return func(WidgetVar *Widget, XVar float64, YVar float64) bool {
		return rawCallback(WidgetVar.GoPointer(), XVar, YVar)
	}
}

type WidgetClassPrivate struct {
	_ structs.HostLayout
}

func (x *WidgetClassPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type WidgetPrivate struct {
	_ structs.HostLayout
}

func (x *WidgetPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The rectangle representing the area allocated for a widget by its parent.
type Allocation = uintptr

// The base class for all widgets.
//
// It manages the widget lifecycle, layout, states and style.
//
// ### Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much
// vertical space it needs, depending on the amount of horizontal space
// that it is given (and similar for width-for-height). The most common
// example is a label that reflows to fill up the available width, wraps
// to fewer lines, and therefore needs less height.
//
// Height-for-width geometry management is implemented in GTK by way
// of two virtual methods:
//
// - [vfunc@Gtk.Widget.get_request_mode]
// - [vfunc@Gtk.Widget.measure]
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct `GtkWidget` subclass that supports
// height-for-width or width-for-height geometry management for itself
// or its child widgets, the [vfunc@Gtk.Widget.get_request_mode] virtual
// function must be implemented as well and return the widget's preferred
// request mode. The default implementation of this virtual function
// returns %GTK_SIZE_REQUEST_CONSTANT_SIZE, which means that the widget will
// only ever get -1 passed as the for_size value to its
// [vfunc@Gtk.Widget.measure] implementation.
//
// The geometry management system will query a widget hierarchy in
// only one orientation at a time. When widgets are initially queried
// for their minimum sizes it is generally done in two initial passes
// in the [enum@Gtk.SizeRequestMode] chosen by the toplevel.
//
// For example, when queried in the normal %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH mode:
//
// First, the default minimum and natural width for each widget
// in the interface will be computed using [method@Gtk.Widget.measure] with an
// orientation of %GTK_ORIENTATION_HORIZONTAL and a for_size of -1.
// Because the preferred widths for each widget depend on the preferred
// widths of their children, this information propagates up the hierarchy,
// and finally a minimum and natural width is determined for the entire
// toplevel. Next, the toplevel will use the minimum width to query for the
// minimum height contextual to that width using [method@Gtk.Widget.measure] with an
// orientation of %GTK_ORIENTATION_VERTICAL and a for_size of the just computed
// width. This will also be a highly recursive operation. The minimum height
// for the minimum width is normally used to set the minimum size constraint
// on the toplevel.
//
// After the toplevel window has initially requested its size in both
// dimensions it can go on to allocate itself a reasonable size (or a size
// previously specified with [method@Gtk.Window.set_default_size]). During the
// recursive allocation process it’s important to note that request cycles
// will be recursively executed while widgets allocate their children.
// Each widget, once allocated a size, will go on to first share the
// space in one orientation among its children and then request each child's
// height for its target allocated width or its width for allocated height,
// depending. In this way a widget will typically be requested its size
// a number of times before actually being allocated a size. The size a
// widget is finally allocated can of course differ from the size it has
// requested. For this reason, `GtkWidget` caches a  small number of results
// to avoid re-querying for the same sizes in one allocation cycle.
//
// If a widget does move content around to intelligently use up the
// allocated size then it must support the request in both
// `GtkSizeRequestMode`s even if the widget in question only
// trades sizes in a single orientation.
//
// For instance, a [class@Gtk.Label] that does height-for-width word wrapping
// will not expect to have [vfunc@Gtk.Widget.measure] with an orientation of
// %GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will
// always be allocated at least enough space to fit its own content.
//
// Here are some examples of how a %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
// ```c
// static void
// foo_widget_measure (GtkWidget      *widget,
//
//	GtkOrientation  orientation,
//	int             for_size,
//	int            *minimum_size,
//	int            *natural_size,
//	int            *minimum_baseline,
//	int            *natural_baseline)
//
//	{
//	  if (orientation == GTK_ORIENTATION_HORIZONTAL)
//	    {
//	      // Calculate minimum and natural width
//	    }
//	  else // VERTICAL
//	    {
//	      if (i_am_in_height_for_width_mode)
//	        {
//	          int min_width, dummy;
//
//	          // First, get the minimum width of our widget
//	          GTK_WIDGET_GET_CLASS (widget)-&gt;measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//	                                                  &amp;min_width, &amp;dummy, &amp;dummy, &amp;dummy);
//
//	          // Now use the minimum width to retrieve the minimum and natural height to display
//	          // that width.
//	          GTK_WIDGET_GET_CLASS (widget)-&gt;measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//	                                                  minimum_size, natural_size, &amp;dummy, &amp;dummy);
//	        }
//	      else
//	        {
//	          // ... some widgets do both.
//	        }
//	    }
//	}
//
// ```
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also
// compute width. Or when deciding how to use an allocation, the widget
// may need to know its natural size. In these cases, the widget should
// be careful to call its virtual methods directly, like in the code
// example above.
//
// It will not work to use the wrapper function [method@Gtk.Widget.measure]
// inside your own [vfunc@Gtk.Widget.size_allocate] implementation.
// These return a request adjusted by [class@Gtk.SizeGroup], the widget's
// align and expand flags, as well as its CSS style.
//
// If a widget used the wrappers inside its virtual method implementations,
// then the adjustments (such as widget margins) would be applied
// twice. GTK therefore does not allow this and will warn if you try
// to do it.
//
// Of course if you are getting the size request for another widget, such
// as a child widget, you must use [method@Gtk.Widget.measure]; otherwise, you
// would not properly consider widget margins, [class@Gtk.SizeGroup], and
// so forth.
//
// GTK also supports baseline vertical alignment of widgets. This
// means that widgets are positioned such that the typographical baseline of
// widgets in the same row are aligned. This happens if a widget supports
// baselines, has a vertical alignment using baselines, and is inside
// a widget that supports baselines and has a natural “row” that it aligns to
// the baseline, or a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is also done by the
// [vfunc@Gtk.Widget.measure] virtual function. It allows you to report
// both a minimum and natural size.
//
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was %GTK_ALIGN_FILL, but the selected baseline can be
// found via [method@Gtk.Widget.get_baseline]. If the baseline has a
// value other than -1 you need to align the widget such that the baseline
// appears at the position.
//
// ### GtkWidget as GtkBuildable
//
// The `GtkWidget` implementation of the `GtkBuildable` interface
// supports various custom elements to specify additional aspects of widgets
// that are not directly expressed as properties.
//
// If the widget uses a [class@Gtk.LayoutManager], `GtkWidget` supports
// a custom `&lt;layout&gt;` element, used to define layout properties:
//
// ```xml
// &lt;object class="GtkGrid" id="my_grid"&gt;
//
//	&lt;child&gt;
//	  &lt;object class="GtkLabel" id="label1"&gt;
//	    &lt;property name="label"&gt;Description&lt;/property&gt;
//	    &lt;layout&gt;
//	      &lt;property name="column"&gt;0&lt;/property&gt;
//	      &lt;property name="row"&gt;0&lt;/property&gt;
//	      &lt;property name="row-span"&gt;1&lt;/property&gt;
//	      &lt;property name="column-span"&gt;1&lt;/property&gt;
//	    &lt;/layout&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//	&lt;child&gt;
//	  &lt;object class="GtkEntry" id="description_entry"&gt;
//	    &lt;layout&gt;
//	      &lt;property name="column"&gt;1&lt;/property&gt;
//	      &lt;property name="row"&gt;0&lt;/property&gt;
//	      &lt;property name="row-span"&gt;1&lt;/property&gt;
//	      &lt;property name="column-span"&gt;1&lt;/property&gt;
//	    &lt;/layout&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//
// &lt;/object&gt;
// ```
//
// `GtkWidget` allows style information such as style classes to
// be associated with widgets, using the custom `&lt;style&gt;` element:
//
// ```xml
// &lt;object class="GtkButton" id="button1"&gt;
//
//	&lt;style&gt;
//	  &lt;class name="my-special-button-class"/&gt;
//	  &lt;class name="dark-button"/&gt;
//	&lt;/style&gt;
//
// &lt;/object&gt;
// ```
//
// `GtkWidget` allows defining accessibility information, such as properties,
// relations, and states, using the custom `&lt;accessibility&gt;` element:
//
// ```xml
// &lt;object class="GtkButton" id="button1"&gt;
//
//	&lt;accessibility&gt;
//	  &lt;property name="label"&gt;Download&lt;/property&gt;
//	  &lt;relation name="labelled-by"&gt;label1&lt;/relation&gt;
//	&lt;/accessibility&gt;
//
// &lt;/object&gt;
// ```
//
// ### Building composite widgets from template XML
//
// `GtkWidget `exposes some facilities to automate the procedure
// of creating composite widgets using "templates".
//
// To create composite widgets with `GtkBuilder` XML, one must associate
// the interface description with the widget class at class initialization
// time using [method@Gtk.WidgetClass.set_template].
//
// The interface description semantics expected in composite template descriptions
// is slightly different from regular [class@Gtk.Builder] XML.
//
// Unlike regular interface descriptions, [method@Gtk.WidgetClass.set_template]
// will expect a `&lt;template&gt;` tag as a direct child of the toplevel
// `&lt;interface&gt;` tag. The `&lt;template&gt;` tag must specify the “class” attribute
// which must be the type name of the widget. Optionally, the “parent”
// attribute may be specified to specify the direct parent type of the widget
// type; this is ignored by `GtkBuilder` but can be used by UI design tools to
// introspect what kind of properties and internal children exist for a given
// type when the actual type does not exist.
//
// The XML which is contained inside the `&lt;template&gt;` tag behaves as if it were
// added to the `&lt;object&gt;` tag defining the widget itself. You may set properties
// on a widget by inserting `&lt;property&gt;` tags into the `&lt;template&gt;` tag, and also
// add `&lt;child&gt;` tags to add children and extend a widget in the normal way you
// would with `&lt;object&gt;` tags.
//
// Additionally, `&lt;object&gt;` tags can also be added before and after the initial
// `&lt;template&gt;` tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// `&lt;template&gt;` tag.
//
// Since, unlike the `&lt;object&gt;` tag, the `&lt;template&gt;` tag does not contain an
// “id” attribute, if you need to refer to the instance of the object itself that
// the template will create, simply refer to the template class name in an
// applicable element content.
//
// Here is an example of a template definition, which includes an example of
// this in the `&lt;signal&gt;` tag:
//
// ```xml
// &lt;interface&gt;
//
//	&lt;template class="FooWidget" parent="GtkBox"&gt;
//	  &lt;property name="orientation"&gt;horizontal&lt;/property&gt;
//	  &lt;property name="spacing"&gt;4&lt;/property&gt;
//	  &lt;child&gt;
//	    &lt;object class="GtkButton" id="hello_button"&gt;
//	      &lt;property name="label"&gt;Hello World&lt;/property&gt;
//	      &lt;signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/&gt;
//	    &lt;/object&gt;
//	  &lt;/child&gt;
//	  &lt;child&gt;
//	    &lt;object class="GtkButton" id="goodbye_button"&gt;
//	      &lt;property name="label"&gt;Goodbye World&lt;/property&gt;
//	    &lt;/object&gt;
//	  &lt;/child&gt;
//	&lt;/template&gt;
//
// &lt;/interface&gt;
// ```
//
// Typically, you'll place the template fragment into a file that is
// bundled with your project, using `GResource`. In order to load the
// template, you need to call [method@Gtk.WidgetClass.set_template_from_resource]
// from the class initialization of your `GtkWidget` type:
//
// ```c
// static void
// foo_widget_class_init (FooWidgetClass *klass)
//
//	{
//	  // ...
//
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	}
//
// ```
//
// You will also need to call [method@Gtk.Widget.init_template] from the
// instance initialization function:
//
// ```c
// static void
// foo_widget_init (FooWidget *self)
//
//	{
//	  gtk_widget_init_template (GTK_WIDGET (self));
//
//	  // Initialize the rest of the widget...
//	}
//
// ```
//
// as well as calling [method@Gtk.Widget.dispose_template] from the dispose
// function:
//
// ```c
// static void
// foo_widget_dispose (GObject *gobject)
//
//	{
//	  FooWidget *self = FOO_WIDGET (gobject);
//
//	  // Dispose objects for which you have a reference...
//
//	  // Clear the template children for this widget type
//	  gtk_widget_dispose_template (GTK_WIDGET (self), FOO_TYPE_WIDGET);
//
//	  G_OBJECT_CLASS (foo_widget_parent_class)-&gt;dispose (gobject);
//	}
//
// ```
//
// You can access widgets defined in the template using the
// [method@Gtk.Widget.get_template_child] function, but you will typically declare
// a pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// [method@Gtk.WidgetClass.bind_template_child_full] (or one of its wrapper macros
// [func@Gtk.widget_class_bind_template_child] and [func@Gtk.widget_class_bind_template_child_private])
// with that name, e.g.
//
// ```c
//
//	typedef struct {
//	  GtkWidget *hello_button;
//	  GtkWidget *goodbye_button;
//	} FooWidgetPrivate;
//
// G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
// static void
// foo_widget_dispose (GObject *gobject)
//
//	{
//	  gtk_widget_dispose_template (GTK_WIDGET (gobject), FOO_TYPE_WIDGET);
//
//	  G_OBJECT_CLASS (foo_widget_parent_class)-&gt;dispose (gobject);
//	}
//
// static void
// foo_widget_class_init (FooWidgetClass *klass)
//
//	{
//	  // ...
//	  G_OBJECT_CLASS (klass)-&gt;dispose = foo_widget_dispose;
//
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	  gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//	                                                FooWidget, hello_button);
//	  gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//	                                                FooWidget, goodbye_button);
//	}
//
// static void
// foo_widget_init (FooWidget *widget)
//
//	{
//	  gtk_widget_init_template (GTK_WIDGET (widget));
//	}
//
// ```
//
// You can also use [method@Gtk.WidgetClass.bind_template_callback_full] (or
// is wrapper macro [func@Gtk.widget_class_bind_template_callback]) to connect
// a signal callback defined in the template with a function visible in the
// scope of the class, e.g.
//
// ```c
// // the signal handler has the instance and user data swapped
// // because of the swapped="yes" attribute in the template XML
// static void
// hello_button_clicked (FooWidget *self,
//
//	GtkButton *button)
//
//	{
//	  g_print ("Hello, world!\n");
//	}
//
// static void
// foo_widget_class_init (FooWidgetClass *klass)
//
//	{
//	  // ...
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	  gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//	}
//
// ```
type Widget struct {
	gobject.InitiallyUnowned
}

var xWidgetGLibType func() types.GType

func WidgetGLibType() types.GType {
	return xWidgetGLibType()
}

func WidgetNewFromInternalPtr(ptr uintptr) *Widget {
	cls := &Widget{}
	cls.Ptr = ptr
	return cls
}

var xWidgetActionSetEnabled func(uintptr, string, bool)

// Enables or disables an action installed with
// [method@Gtk.WidgetClass.install_action].
func (x *Widget) ActionSetEnabled(ActionNameVar string, EnabledVar bool) {

	xWidgetActionSetEnabled(x.GoPointer(), ActionNameVar, EnabledVar)

}

var xWidgetActivate func(uintptr) bool

// Activates the widget.
//
// The activation will emit the signal set using
// [method@Gtk.WidgetClass.set_activate_signal]
// during class initialization.
//
// Activation is what happens when you press &lt;kbd&gt;Enter&lt;/kbd&gt;
// on a widget.
//
// If you wish to handle the activation keybinding yourself,
// it is recommended to use [method@Gtk.WidgetClass.add_shortcut]
// with an action created with [ctor@Gtk.SignalAction.new].
//
// If @widget is not activatable, the function returns false.
func (x *Widget) Activate() bool {

	cret := xWidgetActivate(x.GoPointer())
	return cret
}

var xWidgetActivateAction func(uintptr, string, uintptr, ...interface{}) bool

// Activates an action for the widget.
//
// The action is looked up in the action groups associated with
// @widget and its ancestors.
//
// This is a wrapper around [method@Gtk.Widget.activate_action_variant]
// that constructs the @args variant according to @format_string.
func (x *Widget) ActivateAction(NameVar string, FormatStringVar *string, varArgs ...interface{}) bool {

	FormatStringVarPtr := core.GStrdupNullable(FormatStringVar)
	defer core.GFreeNullable(FormatStringVarPtr)

	cret := xWidgetActivateAction(x.GoPointer(), NameVar, FormatStringVarPtr, varArgs...)
	return cret
}

var xWidgetActivateActionVariant func(uintptr, string, *glib.Variant) bool

// Activates an action for the widget.
//
// The action is looked up in the action groups associated with
// @widget and its ancestors.
//
// If the action is in an action group added with
// [method@Gtk.Widget.insert_action_group], the @name is expected
// to be prefixed with the prefix that was used when the group was
// inserted.
//
// The arguments must match the actions expected parameter type,
// as returned by [method@Gio.Action.get_parameter_type].
func (x *Widget) ActivateActionVariant(NameVar string, ArgsVar *glib.Variant) bool {

	cret := xWidgetActivateActionVariant(x.GoPointer(), NameVar, ArgsVar)
	return cret
}

var xWidgetActivateDefault func(uintptr)

// Activates the `default.activate` action for the widget.
//
// The action is looked up in the same was as for
// [method@Gtk.Widget.activate_action].
func (x *Widget) ActivateDefault() {

	xWidgetActivateDefault(x.GoPointer())

}

var xWidgetAddController func(uintptr, uintptr)

// Adds an event controller to the widget.
//
// The event controllers of a widget handle the events that are
// propagated to the widget.
//
// You will usually want to call this function right after
// creating any kind of [class@Gtk.EventController].
func (x *Widget) AddController(ControllerVar *EventController) {

	xWidgetAddController(x.GoPointer(), ControllerVar.GoPointer())

}

var xWidgetAddCssClass func(uintptr, string)

// Adds a style class to the widget.
//
// After calling this function, the widget’s style will match
// for @css_class, according to CSS matching rules.
//
// Use [method@Gtk.Widget.remove_css_class] to remove the
// style again.
func (x *Widget) AddCssClass(CssClassVar string) {

	xWidgetAddCssClass(x.GoPointer(), CssClassVar)

}

var xWidgetAddMnemonicLabel func(uintptr, uintptr)

// Adds a widget to the list of mnemonic labels for this widget.
//
// See [method@Gtk.Widget.list_mnemonic_labels].
//
// Note that the list of mnemonic labels for the widget is cleared
// when the widget is destroyed, so the caller must make sure
// to update its internal state at this point as well.
func (x *Widget) AddMnemonicLabel(LabelVar *Widget) {

	xWidgetAddMnemonicLabel(x.GoPointer(), LabelVar.GoPointer())

}

var xWidgetAddTickCallback func(uintptr, uintptr, uintptr, uintptr) uint

// Queues an animation frame update and adds a callback to be called
// before each frame.
//
// Until the tick callback is removed, it will be called frequently
// (usually at the frame rate of the output device or as quickly as
// the application can be repainted, whichever is slower). For this
// reason, is most suitable for handling graphics that change every
// frame or every few frames.
//
// The tick callback does not automatically imply a relayout or repaint.
// If you want a repaint or relayout, and aren’t changing widget properties
// that would trigger that (for example, changing the text of a label),
// then you will have to call [method@Gtk.Widget.queue_resize] or
// [method@Gtk.Widget.queue_draw] yourself.
//
// [method@Gdk.FrameClock.get_frame_time] should generally be used
// for timing continuous animations and
// [method@Gdk.FrameTimings.get_predicted_presentation_time] should be
// used if you are trying to display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// [signal@Gdk.FrameClock::update] signal of the frame clock, since you
// don't have to worry about when a frame clock is assigned to a widget.
//
// To remove a tick callback, pass the ID that is returned by this function
// to [method@Gtk.Widget.remove_tick_callback].
func (x *Widget) AddTickCallback(CallbackVar *TickCallback, UserDataVar uintptr, NotifyVar *glib.DestroyNotify) uint {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) bool {
				cbFn := *CallbackVar
				return cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	var NotifyVarRef uintptr
	if NotifyVar != nil {
		NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
		if cbRefPtr, ok := glib.GetCallback(NotifyVarPtr); ok {
			NotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *NotifyVar
				cbFn(arg0)
			}
			NotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(NotifyVarPtr, NotifyVarRef, NotifyVar)
		}
	}

	cret := xWidgetAddTickCallback(x.GoPointer(), CallbackVarRef, UserDataVar, NotifyVarRef)
	return cret
}

var xWidgetAllocate func(uintptr, int, int, int, *gsk.Transform)

// Assigns size, position, (optionally) a baseline and transform
// to a child widget.
//
// In this function, the allocation and baseline may be adjusted.
// The given allocation will be forced to be bigger than the
// widget's minimum size, as well as at least 0×0 in size.
//
// This function is only used by widget implementations.
//
// For a version that does not take a transform, see
// [method@Gtk.Widget.size_allocate].
func (x *Widget) Allocate(WidthVar int, HeightVar int, BaselineVar int, TransformVar *gsk.Transform) {

	xWidgetAllocate(x.GoPointer(), WidthVar, HeightVar, BaselineVar, TransformVar)

}

var xWidgetChildFocus func(uintptr, DirectionType) bool

// Called by widgets as the user moves around the window using
// keyboard shortcuts.
//
// The @direction argument indicates what kind of motion is taking
// place (up, down, left, right, tab forward, tab backward).
//
// This function calls the [vfunc@Gtk.Widget.focus] virtual function;
// widgets can override the virtual function in order to implement
// appropriate focus behavior.
//
// The default `focus()` virtual function for a widget should return
// true if moving in @direction left the focus on a focusable location
// inside that widget, and false if moving in @direction moved the focus
// outside the widget. When returning true, widgets normally call
// [method@Gtk.Widget.grab_focus] to place the focus accordingly;
// when returning false, they don’t modify the current focus location.
//
// This function is used by custom widget implementations; if you're
// writing an app, you’d use [method@Gtk.Widget.grab_focus] to move
// the focus to a particular widget.
func (x *Widget) ChildFocus(DirectionVar DirectionType) bool {

	cret := xWidgetChildFocus(x.GoPointer(), DirectionVar)
	return cret
}

var xWidgetComputeBounds func(uintptr, uintptr, *graphene.Rect) bool

// Computes the bounds for @widget in the coordinate space of @target.
//
// The bounds of widget are (the bounding box of) the region that it is
// expected to draw in. See the [coordinate system](coordinates.html)
// overview to learn more.
//
// If the operation is successful, true is returned. If @widget has no
// bounds or the bounds cannot be expressed in @target's coordinate space
// (for example if both widgets are in different windows), false is
// returned and @bounds is set to the zero rectangle.
//
// It is valid for @widget and @target to be the same widget.
func (x *Widget) ComputeBounds(TargetVar *Widget, OutBoundsVar *graphene.Rect) bool {

	cret := xWidgetComputeBounds(x.GoPointer(), TargetVar.GoPointer(), OutBoundsVar)
	return cret
}

var xWidgetComputeExpand func(uintptr, Orientation) bool

// Computes whether a parent widget should give this widget
// extra space when possible.
//
// Widgets with children should check this, rather than looking at
// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
//
// This function already checks whether the widget is visible, so
// visibility does not need to be checked separately. Non-visible
// widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly
// set on the widget itself, or, if none has been explicitly set,
// the widget may expand if some of its children do.
func (x *Widget) ComputeExpand(OrientationVar Orientation) bool {

	cret := xWidgetComputeExpand(x.GoPointer(), OrientationVar)
	return cret
}

var xWidgetComputePoint func(uintptr, uintptr, *graphene.Point, *graphene.Point) bool

// Translates the given @point in @widget's coordinates to coordinates
// in @target’s coordinate system.
//
// In order to perform this operation, both widgets must share a
// a common ancestor. If that is not the case, @out_point is set
// to (0, 0) and false is returned.
func (x *Widget) ComputePoint(TargetVar *Widget, PointVar *graphene.Point, OutPointVar *graphene.Point) bool {

	cret := xWidgetComputePoint(x.GoPointer(), TargetVar.GoPointer(), PointVar, OutPointVar)
	return cret
}

var xWidgetComputeTransform func(uintptr, uintptr, *graphene.Matrix) bool

// Computes a matrix suitable to describe a transformation from
// @widget's coordinate system into @target's coordinate system.
//
// The transform can not be computed in certain cases, for example
// when @widget and @target do not share a common ancestor. In that
// case @out_transform gets set to the identity matrix.
//
// To learn more about widget coordinate systems, see the coordinate
// system [overview](coordinates.html).
func (x *Widget) ComputeTransform(TargetVar *Widget, OutTransformVar *graphene.Matrix) bool {

	cret := xWidgetComputeTransform(x.GoPointer(), TargetVar.GoPointer(), OutTransformVar)
	return cret
}

var xWidgetContains func(uintptr, float64, float64) bool

// Tests if a given point is contained in the widget.
//
// The coordinates for (x, y) must be in widget coordinates, so
// (0, 0) is assumed to be the top left of @widget's content area.
func (x *Widget) Contains(XVar float64, YVar float64) bool {

	cret := xWidgetContains(x.GoPointer(), XVar, YVar)
	return cret
}

var xWidgetCreatePangoContext func(uintptr) uintptr

// Creates a new `PangoContext` that is configured for the widget.
//
// The `PangoContext` will have the appropriate font map,
// font options, font description, and base direction set.
//
// See also [method@Gtk.Widget.get_pango_context].
func (x *Widget) CreatePangoContext() *pango.Context {
	var cls *pango.Context

	cret := xWidgetCreatePangoContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &pango.Context{}
	cls.Ptr = cret
	return cls
}

var xWidgetCreatePangoLayout func(uintptr, uintptr) uintptr

// Creates a new `PangoLayout` that is configured for the widget.
//
// The `PangoLayout` will have the appropriate font map,
// font description, and base direction set.
//
// If you keep a `PangoLayout` created in this way around,
// you need to re-create it when the widgets `PangoContext`
// is replaced. This can be tracked by listening to changes
// of the [property@Gtk.Widget:root] property on the widget.
func (x *Widget) CreatePangoLayout(TextVar *string) *pango.Layout {
	var cls *pango.Layout

	TextVarPtr := core.GStrdupNullable(TextVar)
	defer core.GFreeNullable(TextVarPtr)

	cret := xWidgetCreatePangoLayout(x.GoPointer(), TextVarPtr)

	if cret == 0 {
		return nil
	}
	cls = &pango.Layout{}
	cls.Ptr = cret
	return cls
}

var xWidgetDisposeTemplate func(uintptr, types.GType)

// Clears the template children for the widget.
//
// This function is the opposite of [method@Gtk.Widget.init_template],
// and it is used to clear all the template children from a widget
// instance. If you bound a template child to a field in the instance
// structure, or in the instance private data structure, the field will
// be set to `NULL` after this function returns.
//
// You should call this function inside the `GObjectClass.dispose()`
// implementation of any widget that called [method@Gtk.Widget.init_template].
// Typically, you will want to call this function last, right before
// chaining up to the parent type's dispose implementation, e.g.
//
// ```c
// static void
// some_widget_dispose (GObject *gobject)
//
//	{
//	  SomeWidget *self = SOME_WIDGET (gobject);
//
//	  // Clear the template data for SomeWidget
//	  gtk_widget_dispose_template (GTK_WIDGET (self), SOME_TYPE_WIDGET);
//
//	  G_OBJECT_CLASS (some_widget_parent_class)-&gt;dispose (gobject);
//	}
//
// ```
func (x *Widget) DisposeTemplate(WidgetTypeVar types.GType) {

	xWidgetDisposeTemplate(x.GoPointer(), WidgetTypeVar)

}

var xWidgetDragCheckThreshold func(uintptr, int, int, int, int) bool

// Checks to see if a drag movement has passed the GTK drag threshold.
func (x *Widget) DragCheckThreshold(StartXVar int, StartYVar int, CurrentXVar int, CurrentYVar int) bool {

	cret := xWidgetDragCheckThreshold(x.GoPointer(), StartXVar, StartYVar, CurrentXVar, CurrentYVar)
	return cret
}

var xWidgetErrorBell func(uintptr)

// Notifies the user about an input-related error on the widget.
//
// If the [property@Gtk.Settings:gtk-error-bell] setting is true,
// it calls [method@Gdk.Surface.beep], otherwise it does nothing.
//
// Note that the effect of [method@Gdk.Surface.beep] can be configured
// in many ways, depending on the windowing backend and the desktop
// environment or window manager that is used.
func (x *Widget) ErrorBell() {

	xWidgetErrorBell(x.GoPointer())

}

var xWidgetGetAllocatedBaseline func(uintptr) int

// Returns the baseline that has currently been allocated to the widget.
//
// This function is intended to be used when implementing handlers
// for the `GtkWidget`Class.snapshot() function, and when allocating
// child widgets in `GtkWidget`Class.size_allocate().
func (x *Widget) GetAllocatedBaseline() int {

	cret := xWidgetGetAllocatedBaseline(x.GoPointer())
	return cret
}

var xWidgetGetAllocatedHeight func(uintptr) int

// Returns the height that has currently been allocated to the widget.
//
// To learn more about widget sizes, see the coordinate
// system [overview](coordinates.html).
func (x *Widget) GetAllocatedHeight() int {

	cret := xWidgetGetAllocatedHeight(x.GoPointer())
	return cret
}

var xWidgetGetAllocatedWidth func(uintptr) int

// Returns the width that has currently been allocated to the widget.
//
// To learn more about widget sizes, see the coordinate
// system [overview](coordinates.html).
func (x *Widget) GetAllocatedWidth() int {

	cret := xWidgetGetAllocatedWidth(x.GoPointer())
	return cret
}

var xWidgetGetAllocation func(uintptr, *Allocation)

// Retrieves the widget’s allocation.
//
// Note, when implementing a layout widget: a widget’s allocation
// will be its “adjusted” allocation, that is, the widget’s parent
// typically calls [method@Gtk.Widget.size_allocate] with an allocation,
// and that allocation is then adjusted (to handle margin
// and alignment for example) before assignment to the widget.
// [method@Gtk.Widget.get_allocation] returns the adjusted allocation that
// was actually assigned to the widget. The adjusted allocation is
// guaranteed to be completely contained within the
// [method@Gtk.Widget.size_allocate] allocation, however.
//
// So a layout widget is guaranteed that its children stay inside
// the assigned bounds, but not that they have exactly the bounds the
// widget assigned.
func (x *Widget) GetAllocation(AllocationVar *Allocation) {

	xWidgetGetAllocation(x.GoPointer(), AllocationVar)

}

var xWidgetGetAncestor func(uintptr, types.GType) uintptr

// Gets the first ancestor of the widget with type @widget_type.
//
// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)`
// gets the first `GtkBox` that’s an ancestor of @widget. No
// reference will be added to the returned widget; it should
// not be unreferenced.
//
// Note that unlike [method@Gtk.Widget.is_ancestor], this function
// considers @widget to be an ancestor of itself.
func (x *Widget) GetAncestor(WidgetTypeVar types.GType) *Widget {
	var cls *Widget

	cret := xWidgetGetAncestor(x.GoPointer(), WidgetTypeVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetBaseline func(uintptr) int

// Returns the baseline that has currently been allocated to the widget.
//
// This function is intended to be used when implementing handlers
// for the `GtkWidgetClass.snapshot()` function, and when allocating
// child widgets in `GtkWidgetClass.size_allocate()`.
func (x *Widget) GetBaseline() int {

	cret := xWidgetGetBaseline(x.GoPointer())
	return cret
}

var xWidgetGetCanFocus func(uintptr) bool

// Determines whether the input focus can enter the widget or any
// of its children.
//
// See [method@Gtk.Widget.set_can_focus].
func (x *Widget) GetCanFocus() bool {

	cret := xWidgetGetCanFocus(x.GoPointer())
	return cret
}

var xWidgetGetCanTarget func(uintptr) bool

// Queries whether the widget can be the target of pointer events.
func (x *Widget) GetCanTarget() bool {

	cret := xWidgetGetCanTarget(x.GoPointer())
	return cret
}

var xWidgetGetChildVisible func(uintptr) bool

// Gets the value set with [method@Gtk.Widget.set_child_visible].
//
// If you feel a need to use this function, your code probably
// needs reorganization.
//
// This function is only useful for widget implementations
// and should never be called by an application.
func (x *Widget) GetChildVisible() bool {

	cret := xWidgetGetChildVisible(x.GoPointer())
	return cret
}

var xWidgetGetClipboard func(uintptr) uintptr

// Gets the clipboard object for the widget.
//
// This is a utility function to get the clipboard object for the
// display that @widget is using.
//
// Note that this function always works, even when @widget is not
// realized yet.
func (x *Widget) GetClipboard() *gdk.Clipboard {
	var cls *gdk.Clipboard

	cret := xWidgetGetClipboard(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Clipboard{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetColor func(uintptr, *gdk.RGBA)

// Gets the current foreground color for the widget’s style.
//
// This function should only be used in snapshot
// implementations that need to do custom drawing
// with the foreground color.
func (x *Widget) GetColor(ColorVar *gdk.RGBA) {

	xWidgetGetColor(x.GoPointer(), ColorVar)

}

var xWidgetGetCssClasses func(uintptr) []string

// Returns the list of style classes applied to the widget.
func (x *Widget) GetCssClasses() []string {

	cret := xWidgetGetCssClasses(x.GoPointer())
	return cret
}

var xWidgetGetCssName func(uintptr) string

// Returns the CSS name of the widget.
func (x *Widget) GetCssName() string {

	cret := xWidgetGetCssName(x.GoPointer())
	return cret
}

var xWidgetGetCursor func(uintptr) uintptr

// Gets the cursor set on the widget.
//
// See [method@Gtk.Widget.set_cursor] for details.
func (x *Widget) GetCursor() *gdk.Cursor {
	var cls *gdk.Cursor

	cret := xWidgetGetCursor(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Cursor{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetDirection func(uintptr) TextDirection

// Gets the reading direction for the widget.
//
// See [method@Gtk.Widget.set_direction].
func (x *Widget) GetDirection() TextDirection {

	cret := xWidgetGetDirection(x.GoPointer())
	return cret
}

var xWidgetGetDisplay func(uintptr) uintptr

// Get the display for the window that the widget belongs to.
//
// This function can only be called after the widget has been
// added to a widget hierarchy with a `GtkRoot` at the top.
//
// In general, you should only create display-specific
// resources when a widget has been realized, and you should
// free those resources when the widget is unrealized.
func (x *Widget) GetDisplay() *gdk.Display {
	var cls *gdk.Display

	cret := xWidgetGetDisplay(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Display{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetFirstChild func(uintptr) uintptr

// Returns the widget’s first child.
//
// This function is primarily meant for widget implementations.
func (x *Widget) GetFirstChild() *Widget {
	var cls *Widget

	cret := xWidgetGetFirstChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetFocusChild func(uintptr) uintptr

// Returns the focus child of the widget.
func (x *Widget) GetFocusChild() *Widget {
	var cls *Widget

	cret := xWidgetGetFocusChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetFocusOnClick func(uintptr) bool

// Returns whether the widget should grab focus when it is clicked
// with the mouse.
//
// See [method@Gtk.Widget.set_focus_on_click].
func (x *Widget) GetFocusOnClick() bool {

	cret := xWidgetGetFocusOnClick(x.GoPointer())
	return cret
}

var xWidgetGetFocusable func(uintptr) bool

// Determines whether the widget can own the input focus.
//
// See [method@Gtk.Widget.set_focusable].
func (x *Widget) GetFocusable() bool {

	cret := xWidgetGetFocusable(x.GoPointer())
	return cret
}

var xWidgetGetFontMap func(uintptr) uintptr

// Gets the font map of the widget.
//
// See [method@Gtk.Widget.set_font_map].
func (x *Widget) GetFontMap() *pango.FontMap {
	var cls *pango.FontMap

	cret := xWidgetGetFontMap(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &pango.FontMap{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetFontOptions func(uintptr) *cairo.FontOptions

// Returns the `cairo_font_options_t` of the widget.
//
// Seee [method@Gtk.Widget.set_font_options].
func (x *Widget) GetFontOptions() *cairo.FontOptions {

	cret := xWidgetGetFontOptions(x.GoPointer())
	return cret
}

var xWidgetGetFrameClock func(uintptr) uintptr

// Obtains the frame clock for a widget.
//
// The frame clock is a global “ticker” that can be used to drive
// animations and repaints. The most common reason to get the frame
// clock is to call [method@Gdk.FrameClock.get_frame_time], in order
// to get a time to use for animating. For example you might record
// the start of the animation with an initial value from
// [method@Gdk.FrameClock.get_frame_time], and then update the animation
// by calling [method@Gdk.FrameClock.get_frame_time] again during each repaint.
//
// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
// clock, but won’t necessarily repaint any widgets. To repaint a widget,
// you have to use [method@Gtk.Widget.queue_draw] which invalidates the
// widget (thus scheduling it to receive a draw on the next frame).
// [method@Gtk.Widget.queue_draw] will also end up requesting a frame
// on the appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change
// the widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
func (x *Widget) GetFrameClock() *gdk.FrameClock {
	var cls *gdk.FrameClock

	cret := xWidgetGetFrameClock(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.FrameClock{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetHalign func(uintptr) Align

// Gets the horizontal alignment of the widget.
//
// For backwards compatibility reasons this method will never return
// one of the baseline alignments, but instead it will convert it to
// [enum@Gtk.Align.fill] or [enum@Gtk.Align.center].
//
// Baselines are not supported for horizontal alignment.
func (x *Widget) GetHalign() Align {

	cret := xWidgetGetHalign(x.GoPointer())
	return cret
}

var xWidgetGetHasTooltip func(uintptr) bool

// Returns the current value of the `has-tooltip` property.
func (x *Widget) GetHasTooltip() bool {

	cret := xWidgetGetHasTooltip(x.GoPointer())
	return cret
}

var xWidgetGetHeight func(uintptr) int

// Returns the content height of the widget.
//
// This function returns the height passed to its
// size-allocate implementation, which is the height you
// should be using in [vfunc@Gtk.Widget.snapshot].
//
// For pointer events, see [method@Gtk.Widget.contains].
//
// To learn more about widget sizes, see the coordinate
// system [overview](coordinates.html).
func (x *Widget) GetHeight() int {

	cret := xWidgetGetHeight(x.GoPointer())
	return cret
}

var xWidgetGetHexpand func(uintptr) bool

// Gets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a window, widgets with expand set to true generally
// receive the extra space. For example, a list or scrollable area
// or document in your window would often be set to expand.
//
// Widgets with children should use [method@Gtk.Widget.compute_expand]
// rather than this function, to see whether any of its children,
// has the expand flag set. If any child of a widget wants to
// expand, the parent may ask to expand also.
//
// This function only looks at the widget’s own hexpand flag, rather
// than computing whether the entire widget tree rooted at this widget
// wants to expand.
func (x *Widget) GetHexpand() bool {

	cret := xWidgetGetHexpand(x.GoPointer())
	return cret
}

var xWidgetGetHexpandSet func(uintptr) bool

// Gets whether the `hexpand` flag has been explicitly set.
//
// If [property@Gtk.Widget:hexpand] property is set, then it
// overrides any computed expand value based on child widgets.
// If `hexpand` is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here
// for completeness and consistency.
func (x *Widget) GetHexpandSet() bool {

	cret := xWidgetGetHexpandSet(x.GoPointer())
	return cret
}

var xWidgetGetLastChild func(uintptr) uintptr

// Returns the widget’s last child.
//
// This function is primarily meant for widget implementations.
func (x *Widget) GetLastChild() *Widget {
	var cls *Widget

	cret := xWidgetGetLastChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetLayoutManager func(uintptr) uintptr

// Retrieves the layout manager of the widget.
//
// See [method@Gtk.Widget.set_layout_manager].
func (x *Widget) GetLayoutManager() *LayoutManager {
	var cls *LayoutManager

	cret := xWidgetGetLayoutManager(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &LayoutManager{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetLimitEvents func(uintptr) bool

// Gets the value of the [property@Gtk.Widget:limit-events] property.
func (x *Widget) GetLimitEvents() bool {

	cret := xWidgetGetLimitEvents(x.GoPointer())
	return cret
}

var xWidgetGetMapped func(uintptr) bool

// Returns whether the widget is mapped.
func (x *Widget) GetMapped() bool {

	cret := xWidgetGetMapped(x.GoPointer())
	return cret
}

var xWidgetGetMarginBottom func(uintptr) int

// Gets the bottom margin of the widget.
func (x *Widget) GetMarginBottom() int {

	cret := xWidgetGetMarginBottom(x.GoPointer())
	return cret
}

var xWidgetGetMarginEnd func(uintptr) int

// Gets the end margin of the widget.
func (x *Widget) GetMarginEnd() int {

	cret := xWidgetGetMarginEnd(x.GoPointer())
	return cret
}

var xWidgetGetMarginStart func(uintptr) int

// Gets the start margin of the widget.
func (x *Widget) GetMarginStart() int {

	cret := xWidgetGetMarginStart(x.GoPointer())
	return cret
}

var xWidgetGetMarginTop func(uintptr) int

// Gets the top margin of the widget.
func (x *Widget) GetMarginTop() int {

	cret := xWidgetGetMarginTop(x.GoPointer())
	return cret
}

var xWidgetGetName func(uintptr) string

// Retrieves the name of a widget.
//
// See [method@Gtk.Widget.set_name] for the significance of widget names.
func (x *Widget) GetName() string {

	cret := xWidgetGetName(x.GoPointer())
	return cret
}

var xWidgetGetNative func(uintptr) uintptr

// Returns the nearest `GtkNative` ancestor of the widget.
//
// This function will return `NULL` if the widget is not
// contained inside a widget tree with a native ancestor.
//
// `GtkNative` widgets will return themselves here.
func (x *Widget) GetNative() *NativeBase {
	var cls *NativeBase

	cret := xWidgetGetNative(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NativeBase{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetNextSibling func(uintptr) uintptr

// Returns the widget’s next sibling.
//
// This function is primarily meant for widget implementations.
func (x *Widget) GetNextSibling() *Widget {
	var cls *Widget

	cret := xWidgetGetNextSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetOpacity func(uintptr) float64

// Fetches the requested opacity for the widget.
//
// See [method@Gtk.Widget.set_opacity].
func (x *Widget) GetOpacity() float64 {

	cret := xWidgetGetOpacity(x.GoPointer())
	return cret
}

var xWidgetGetOverflow func(uintptr) Overflow

// Returns the widget’s overflow value.
func (x *Widget) GetOverflow() Overflow {

	cret := xWidgetGetOverflow(x.GoPointer())
	return cret
}

var xWidgetGetPangoContext func(uintptr) uintptr

// Gets a `PangoContext` that is configured for the widget.
//
// The `PangoContext` will have the appropriate font map, font description,
// and base direction set.
//
// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
// this context is owned by the widget (it can be used until the screen
// for the widget changes or the widget is removed from its toplevel),
// and will be updated to match any changes to the widget’s attributes.
// This can be tracked by listening to changes of the
// [property@Gtk.Widget:root] property on the widget.
func (x *Widget) GetPangoContext() *pango.Context {
	var cls *pango.Context

	cret := xWidgetGetPangoContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &pango.Context{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetParent func(uintptr) uintptr

// Returns the parent widget of the widget.
func (x *Widget) GetParent() *Widget {
	var cls *Widget

	cret := xWidgetGetParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetPreferredSize func(uintptr, *Requisition, *Requisition)

// Retrieves the minimum and natural size of a widget, taking
// into account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do
// not impose any restrictions on the child placement. It can be used
// to deduce toplevel window and menu sizes as well as child widgets in
// free-form containers such as `GtkFixed`.
//
// Handle with care. Note that the natural height of a height-for-width
// widget will generally be a smaller size than the minimum height, since
// the required height for the natural width is generally smaller than the
// required height for the minimum width.
//
// Use [method@Gtk.Widget.measure] if you want to support baseline alignment.
func (x *Widget) GetPreferredSize(MinimumSizeVar *Requisition, NaturalSizeVar *Requisition) {

	xWidgetGetPreferredSize(x.GoPointer(), MinimumSizeVar, NaturalSizeVar)

}

var xWidgetGetPrevSibling func(uintptr) uintptr

// Returns the widget’s previous sibling.
//
// This function is primarily meant for widget implementations.
func (x *Widget) GetPrevSibling() *Widget {
	var cls *Widget

	cret := xWidgetGetPrevSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetPrimaryClipboard func(uintptr) uintptr

// Gets the primary clipboard of the widget.
//
// This is a utility function to get the primary clipboard object
// for the display that @widget is using.
//
// Note that this function always works, even when @widget is not
// realized yet.
func (x *Widget) GetPrimaryClipboard() *gdk.Clipboard {
	var cls *gdk.Clipboard

	cret := xWidgetGetPrimaryClipboard(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Clipboard{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetRealized func(uintptr) bool

// Determines whether the widget is realized.
func (x *Widget) GetRealized() bool {

	cret := xWidgetGetRealized(x.GoPointer())
	return cret
}

var xWidgetGetReceivesDefault func(uintptr) bool

// Determines whether the widget is always treated as the default widget
// within its toplevel when it has the focus, even if another widget
// is the default.
//
// See [method@Gtk.Widget.set_receives_default].
func (x *Widget) GetReceivesDefault() bool {

	cret := xWidgetGetReceivesDefault(x.GoPointer())
	return cret
}

var xWidgetGetRequestMode func(uintptr) SizeRequestMode

// Gets whether the widget prefers a height-for-width layout
// or a width-for-height layout.
//
// Single-child widgets generally propagate the preference of
// their child, more complex widgets need to request something
// either in context of their children or in context of their
// allocation capabilities.
func (x *Widget) GetRequestMode() SizeRequestMode {

	cret := xWidgetGetRequestMode(x.GoPointer())
	return cret
}

var xWidgetGetRoot func(uintptr) uintptr

// Returns the `GtkRoot` widget of the widget.
//
// This function will return `NULL` if the widget is not contained
// inside a widget tree with a root widget.
//
// `GtkRoot` widgets will return themselves here.
func (x *Widget) GetRoot() *RootBase {
	var cls *RootBase

	cret := xWidgetGetRoot(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RootBase{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetScaleFactor func(uintptr) int

// Retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels.
//
// On traditional systems this is 1, on high density outputs,
// it can be a higher value (typically 2).
//
// See [method@Gdk.Surface.get_scale_factor].
//
// Note that modern systems may support *fractional* scaling,
// where the scale factor is not an integer. On such systems,
// this function will return the next higher integer value,
// but you probably want to use [method@Gdk.Surface.get_scale]
// to get the fractional scale value.
func (x *Widget) GetScaleFactor() int {

	cret := xWidgetGetScaleFactor(x.GoPointer())
	return cret
}

var xWidgetGetSensitive func(uintptr) bool

// Returns the widget’s sensitivity.
//
// This function returns the value that has been set using
// [method@Gtk.Widget.set_sensitive]).
//
// The effective sensitivity of a widget is however determined
// by both its own and its parent widget’s sensitivity.
// See [method@Gtk.Widget.is_sensitive].
func (x *Widget) GetSensitive() bool {

	cret := xWidgetGetSensitive(x.GoPointer())
	return cret
}

var xWidgetGetSettings func(uintptr) uintptr

// Gets the settings object holding the settings used for the widget.
//
// Note that this function can only be called when the `GtkWidget`
// is attached to a toplevel, since the settings object is specific
// to a particular display. If you want to monitor the widget for
// changes in its settings, connect to the `notify::display` signal.
func (x *Widget) GetSettings() *Settings {
	var cls *Settings

	cret := xWidgetGetSettings(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetSize func(uintptr, Orientation) int

// Returns the content width or height of the widget.
//
// Which dimension is returned depends on @orientation.
//
// This is equivalent to calling [method@Gtk.Widget.get_width]
// for [enum@Gtk.Orientation.horizontal] or [method@Gtk.Widget.get_height]
// for [enum@Gtk.Orientation.vertical], but can be used when
// writing orientation-independent code, such as when
// implementing [iface@Gtk.Orientable] widgets.
//
// To learn more about widget sizes, see the coordinate
// system [overview](coordinates.html).
func (x *Widget) GetSize(OrientationVar Orientation) int {

	cret := xWidgetGetSize(x.GoPointer(), OrientationVar)
	return cret
}

var xWidgetGetSizeRequest func(uintptr, *int, *int)

// Gets the size request that was explicitly set for the widget.
//
// A value of -1 stored in @width or @height indicates that that
// dimension has not been set explicitly and the natural requisition
// of the widget will be used instead.
//
// See [method@Gtk.Widget.set_size_request].
//
// To get the size a widget will actually request, call
// [method@Gtk.Widget.measure] instead of this function.
func (x *Widget) GetSizeRequest(WidthVar *int, HeightVar *int) {

	xWidgetGetSizeRequest(x.GoPointer(), WidthVar, HeightVar)

}

var xWidgetGetStateFlags func(uintptr) StateFlags

// Returns the widget state as a flag set.
//
// It is worth mentioning that the effective [flags@Gtk.StateFlags.insensitive]
// state will be returned, that is, also based on parent insensitivity,
// even if @widget itself is sensitive.
//
// Also note that if you are looking for a way to obtain the
// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext]
// method, you should look at [method@Gtk.StyleContext.get_state].
func (x *Widget) GetStateFlags() StateFlags {

	cret := xWidgetGetStateFlags(x.GoPointer())
	return cret
}

var xWidgetGetStyleContext func(uintptr) uintptr

// Returns the style context associated to the widget.
//
// The returned object is guaranteed to be the same
// for the lifetime of @widget.
func (x *Widget) GetStyleContext() *StyleContext {
	var cls *StyleContext

	cret := xWidgetGetStyleContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &StyleContext{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetTemplateChild func(uintptr, types.GType, string) uintptr

// Fetches an object build from the template XML for @widget_type in
// the widget.
//
// This will only report children which were previously declared
// with [method@Gtk.WidgetClass.bind_template_child_full] or one of its
// variants.
//
// This function is only meant to be called for code which is private
// to the @widget_type which declared the child and is meant for language
// bindings which cannot easily make use of the GObject structure offsets.
func (x *Widget) GetTemplateChild(WidgetTypeVar types.GType, NameVar string) *gobject.Object {
	var cls *gobject.Object

	cret := xWidgetGetTemplateChild(x.GoPointer(), WidgetTypeVar, NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetTooltipMarkup func(uintptr) string

// Gets the contents of the tooltip for the widget.
//
// If the tooltip has not been set using
// [method@Gtk.Widget.set_tooltip_markup], this
// function returns `NULL`.
func (x *Widget) GetTooltipMarkup() string {

	cret := xWidgetGetTooltipMarkup(x.GoPointer())
	return cret
}

var xWidgetGetTooltipText func(uintptr) string

// Gets the contents of the tooltip for the widget.
//
// If the @widget's tooltip was set using
// [method@Gtk.Widget.set_tooltip_markup],
// this function will return the escaped text.
func (x *Widget) GetTooltipText() string {

	cret := xWidgetGetTooltipText(x.GoPointer())
	return cret
}

var xWidgetGetValign func(uintptr) Align

// Gets the vertical alignment of the widget.
func (x *Widget) GetValign() Align {

	cret := xWidgetGetValign(x.GoPointer())
	return cret
}

var xWidgetGetVexpand func(uintptr) bool

// Gets whether the widget would like any available extra vertical
// space.
//
// See [method@Gtk.Widget.get_hexpand] for more detail.
func (x *Widget) GetVexpand() bool {

	cret := xWidgetGetVexpand(x.GoPointer())
	return cret
}

var xWidgetGetVexpandSet func(uintptr) bool

// Gets whether the `vexpand` flag has been explicitly set.
//
// See [method@Gtk.Widget.get_hexpand_set] for more detail.
func (x *Widget) GetVexpandSet() bool {

	cret := xWidgetGetVexpandSet(x.GoPointer())
	return cret
}

var xWidgetGetVisible func(uintptr) bool

// Determines whether the widget is visible.
//
// If you want to take into account whether the widget’s
// parent is also marked as visible, use
// [method@Gtk.Widget.is_visible] instead.
//
// This function does not check if the widget is
// obscured in any way.
//
// See [method@Gtk.Widget.set_visible].
func (x *Widget) GetVisible() bool {

	cret := xWidgetGetVisible(x.GoPointer())
	return cret
}

var xWidgetGetWidth func(uintptr) int

// Returns the content width of the widget.
//
// This function returns the width passed to its
// size-allocate implementation, which is the width you
// should be using in [vfunc@Gtk.Widget.snapshot].
//
// For pointer events, see [method@Gtk.Widget.contains].
//
// To learn more about widget sizes, see the coordinate
// system [overview](coordinates.html).
func (x *Widget) GetWidth() int {

	cret := xWidgetGetWidth(x.GoPointer())
	return cret
}

var xWidgetGrabFocus func(uintptr) bool

// Causes @widget to have the keyboard focus for the window
// that it belongs to.
//
// If @widget is not focusable, or its [vfunc@Gtk.Widget.grab_focus]
// implementation cannot transfer the focus to a descendant of @widget
// that is focusable, it will not take focus and false will be returned.
//
// Calling [method@Gtk.Widget.grab_focus] on an already focused widget
// is allowed, should not have an effect, and return true.
func (x *Widget) GrabFocus() bool {

	cret := xWidgetGrabFocus(x.GoPointer())
	return cret
}

var xWidgetHasCssClass func(uintptr, string) bool

// Returns whether a style class is currently applied to the widget.
func (x *Widget) HasCssClass(CssClassVar string) bool {

	cret := xWidgetHasCssClass(x.GoPointer(), CssClassVar)
	return cret
}

var xWidgetHasDefault func(uintptr) bool

// Determines whether the widget is the current default widget
// within its toplevel.
func (x *Widget) HasDefault() bool {

	cret := xWidgetHasDefault(x.GoPointer())
	return cret
}

var xWidgetHasFocus func(uintptr) bool

// Determines if the widget has the global input focus.
//
// See [method@Gtk.Widget.is_focus] for the difference between
// having the global input focus, and only having the focus
// within a toplevel.
func (x *Widget) HasFocus() bool {

	cret := xWidgetHasFocus(x.GoPointer())
	return cret
}

var xWidgetHasVisibleFocus func(uintptr) bool

// Determines if the widget should show a visible indication that
// it has the global input focus.
//
// This is a convenience function that takes into account whether
// focus indication should currently be shown in the toplevel window
// of @widget. See [method@Gtk.Window.get_focus_visible] for more
// information about focus indication.
//
// To find out if the widget has the global input focus, use
// [method@Gtk.Widget.has_focus].
func (x *Widget) HasVisibleFocus() bool {

	cret := xWidgetHasVisibleFocus(x.GoPointer())
	return cret
}

var xWidgetHide func(uintptr)

// Reverses the effects of [method.Gtk.Widget.show].
//
// This is causing the widget to be hidden (invisible to the user).
func (x *Widget) Hide() {

	xWidgetHide(x.GoPointer())

}

var xWidgetInDestruction func(uintptr) bool

// Returns whether the widget is currently being destroyed.
//
// This information can sometimes be used to avoid doing
// unnecessary work.
func (x *Widget) InDestruction() bool {

	cret := xWidgetInDestruction(x.GoPointer())
	return cret
}

var xWidgetInitTemplate func(uintptr)

// Creates and initializes child widgets defined in templates.
//
// This function must be called in the instance initializer
// for any class which assigned itself a template using
// [method@Gtk.WidgetClass.set_template].
//
// It is important to call this function in the instance initializer
// of a widget subclass and not in `GObject.constructed()` or
// `GObject.constructor()` for two reasons:
//
//   - derived widgets will assume that the composite widgets
//     defined by its parent classes have been created in their
//     relative instance initializers
//   - when calling `g_object_new()` on a widget with composite templates,
//     it’s important to build the composite widgets before the construct
//     properties are set. Properties passed to `g_object_new()` should
//     take precedence over properties set in the private template XML
//
// A good rule of thumb is to call this function as the first thing in
// an instance initialization function.
func (x *Widget) InitTemplate() {

	xWidgetInitTemplate(x.GoPointer())

}

var xWidgetInsertActionGroup func(uintptr, string, uintptr)

// Inserts an action group into the widget's actions.
//
// Children of @widget that implement [iface@Gtk.Actionable] can
// then be associated with actions in @group by setting their
// “action-name” to @prefix.`action-name`.
//
// Note that inheritance is defined for individual actions. I.e.
// even if you insert a group with prefix @prefix, actions with
// the same prefix will still be inherited from the parent, unless
// the group contains an action with the same name.
//
// If @group is `NULL`, a previously inserted group for @name is
// removed from @widget.
func (x *Widget) InsertActionGroup(NameVar string, GroupVar gio.ActionGroup) {

	xWidgetInsertActionGroup(x.GoPointer(), NameVar, GroupVar.GoPointer())

}

var xWidgetInsertAfter func(uintptr, uintptr, uintptr)

// Sets the parent widget of the widget.
//
// In contrast to [method@Gtk.Widget.set_parent], this function
// inserts @widget at a specific position into the list of children
// of the @parent widget.
//
// It will be placed after @previous_sibling, or at the beginning if
// @previous_sibling is `NULL`.
//
// After calling this function, `gtk_widget_get_prev_sibling (widget)`
// will return @previous_sibling.
//
// If @parent is already set as the parent widget of @widget, this
// function can also be used to reorder @widget in the child widget
// list of @parent.
//
// This function is primarily meant for widget implementations; if you are
// just using a widget, you *must* use its own API for adding children.
func (x *Widget) InsertAfter(ParentVar *Widget, PreviousSiblingVar *Widget) {

	xWidgetInsertAfter(x.GoPointer(), ParentVar.GoPointer(), PreviousSiblingVar.GoPointer())

}

var xWidgetInsertBefore func(uintptr, uintptr, uintptr)

// Sets the parent widget of the widget.
//
// In contrast to [method@Gtk.Widget.set_parent], this function
// inserts @widget at a specific position into the list of children
// of the @parent widget.
//
// It will be placed before @next_sibling, or at the end if
// @next_sibling is `NULL`.
//
// After calling this function, `gtk_widget_get_next_sibling (widget)`
// will return @next_sibling.
//
// If @parent is already set as the parent widget of @widget, this function
// can also be used to reorder @widget in the child widget list of @parent.
//
// This function is primarily meant for widget implementations; if you are
// just using a widget, you *must* use its own API for adding children.
func (x *Widget) InsertBefore(ParentVar *Widget, NextSiblingVar *Widget) {

	xWidgetInsertBefore(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

var xWidgetIsAncestor func(uintptr, uintptr) bool

// Determines whether the widget is a descendent of @ancestor.
func (x *Widget) IsAncestor(AncestorVar *Widget) bool {

	cret := xWidgetIsAncestor(x.GoPointer(), AncestorVar.GoPointer())
	return cret
}

var xWidgetIsDrawable func(uintptr) bool

// Determines whether the widget can be drawn to.
//
// A widget can be drawn if it is mapped and visible.
func (x *Widget) IsDrawable() bool {

	cret := xWidgetIsDrawable(x.GoPointer())
	return cret
}

var xWidgetIsFocus func(uintptr) bool

// Determines if the widget is the focus widget within its
// toplevel.
//
// This does not mean that the [property@Gtk.Widget:has-focus]
// property is necessarily set; [property@Gtk.Widget:has-focus]
// will only be set if the toplevel widget additionally has the
// global input focus.
func (x *Widget) IsFocus() bool {

	cret := xWidgetIsFocus(x.GoPointer())
	return cret
}

var xWidgetIsSensitive func(uintptr) bool

// Returns the widget’s effective sensitivity.
//
// This means it is sensitive itself and also its
// parent widget is sensitive.
func (x *Widget) IsSensitive() bool {

	cret := xWidgetIsSensitive(x.GoPointer())
	return cret
}

var xWidgetIsVisible func(uintptr) bool

// Determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also [method@Gtk.Widget.get_visible] and
// [method@Gtk.Widget.set_visible].
func (x *Widget) IsVisible() bool {

	cret := xWidgetIsVisible(x.GoPointer())
	return cret
}

var xWidgetKeynavFailed func(uintptr, DirectionType) bool

// Emits the [signal@Gtk.Widget::keynav-failed] signal on the widget.
//
// This function should be called whenever keyboard navigation
// within a single widget hits a boundary.
//
// The return value of this function should be interpreted
// in a way similar to the return value of
// [method@Gtk.Widget.child_focus]. When true is returned,
// stay in the widget, the failed keyboard navigation is ok
// and/or there is nowhere we can/should move the focus to.
// When false is returned, the caller should continue with
// keyboard navigation outside the widget, e.g. by calling
// [method@Gtk.Widget.child_focus] on the widget’s toplevel.
//
// The default [signal@Gtk.Widget::keynav-failed] handler returns
// false for [enum@Gtk.DirectionType.tab-forward] and
// [enum@Gtk.DirectionType.tab-backward]. For the other values
// of [enum@Gtk.DirectionType] it returns true.
//
// Whenever the default handler returns true, it also calls
// [method@Gtk.Widget.error_bell] to notify the user of the
// failed keyboard navigation.
//
// A use case for providing an own implementation of `::keynav-failed`
// (either by connecting to it or by overriding it) would be a row of
// [class@Gtk.Entry] widgets where the user should be able to navigate
// the entire row with the cursor keys, as e.g. known from user
// interfaces that require entering license keys.
func (x *Widget) KeynavFailed(DirectionVar DirectionType) bool {

	cret := xWidgetKeynavFailed(x.GoPointer(), DirectionVar)
	return cret
}

var xWidgetListMnemonicLabels func(uintptr) *glib.List

// Returns the widgets for which this widget is the target of a
// mnemonic.
//
// Typically, these widgets will be labels. See, for example,
// [method@Gtk.Label.set_mnemonic_widget].
//
// The widgets in the list are not individually referenced.
// If you want to iterate through the list and perform actions
// involving callbacks that might destroy the widgets, you
// must call `g_list_foreach (result, (GFunc)g_object_ref, NULL)`
// first, and then unref all the widgets afterwards.
func (x *Widget) ListMnemonicLabels() *glib.List {

	cret := xWidgetListMnemonicLabels(x.GoPointer())
	return cret
}

var xWidgetMap func(uintptr)

// Causes a widget to be mapped if it isn’t already.
//
// This function is only for use in widget implementations.
func (x *Widget) Map() {

	xWidgetMap(x.GoPointer())

}

var xWidgetMeasure func(uintptr, Orientation, int, *int, *int, *int, *int)

// Measures @widget in the orientation @orientation and for the given @for_size.
//
// As an example, if @orientation is %GTK_ORIENTATION_HORIZONTAL and @for_size
// is 300, this functions will compute the minimum and natural width of @widget
// if it is allocated at a height of 300 pixels.
//
// See [GtkWidget’s geometry management section](class.Widget.html#height-for-width-geometry-management) for
// a more details on implementing `GtkWidgetClass.measure()`.
func (x *Widget) Measure(OrientationVar Orientation, ForSizeVar int, MinimumVar *int, NaturalVar *int, MinimumBaselineVar *int, NaturalBaselineVar *int) {

	xWidgetMeasure(x.GoPointer(), OrientationVar, ForSizeVar, MinimumVar, NaturalVar, MinimumBaselineVar, NaturalBaselineVar)

}

var xWidgetMnemonicActivate func(uintptr, bool) bool

// Emits the [signal@Gtk.Widget::mnemonic-activate] signal.
func (x *Widget) MnemonicActivate(GroupCyclingVar bool) bool {

	cret := xWidgetMnemonicActivate(x.GoPointer(), GroupCyclingVar)
	return cret
}

var xWidgetObserveChildren func(uintptr) uintptr

// Returns a list model to track the children of the widget.
//
// Calling this function will enable extra internal bookkeeping
// to track children and emit signals on the returned listmodel.
// It may slow down operations a lot.
//
// Applications should try hard to avoid calling this function
// because of the slowdowns.
func (x *Widget) ObserveChildren() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xWidgetObserveChildren(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xWidgetObserveControllers func(uintptr) uintptr

// Returns a list model to track the event controllers of the widget.
//
// Calling this function will enable extra internal bookkeeping
// to track controllers and emit signals on the returned listmodel.
// It may slow down operations a lot.
//
// Applications should try hard to avoid calling this function
// because of the slowdowns.
func (x *Widget) ObserveControllers() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xWidgetObserveControllers(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xWidgetPick func(uintptr, float64, float64, PickFlags) uintptr

// Finds the descendant of the widget closest to a point.
//
// The point (x, y) must be given in widget coordinates, so (0, 0)
// is assumed to be the top left of @widget's content area.
//
// Usually widgets will return `NULL` if the given coordinate is not
// contained in @widget checked via [method@Gtk.Widget.contains].
// Otherwise they will recursively try to find a child that does
// not return `NULL`. Widgets are however free to customize their
// picking algorithm.
//
// This function is used on the toplevel to determine the widget
// below the mouse cursor for purposes of hover highlighting and
// delivering events.
func (x *Widget) Pick(XVar float64, YVar float64, FlagsVar PickFlags) *Widget {
	var cls *Widget

	cret := xWidgetPick(x.GoPointer(), XVar, YVar, FlagsVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetQueueAllocate func(uintptr)

// Flags the widget for a rerun of the [vfunc@Gtk.Widget.size_allocate]
// function.
//
// Use this function instead of [method@Gtk.Widget.queue_resize]
// when the @widget's size request didn't change but it wants to
// reposition its contents.
//
// An example user of this function is [method@Gtk.Widget.set_halign].
//
// This function is only for use in widget implementations.
func (x *Widget) QueueAllocate() {

	xWidgetQueueAllocate(x.GoPointer())

}

var xWidgetQueueDraw func(uintptr)

// Schedules this widget to be redrawn.
//
// The redraw will happen in the paint phase
// of the current or the next frame.
//
// This means @widget's [vfunc@Gtk.Widget.snapshot]
// implementation will be called.
func (x *Widget) QueueDraw() {

	xWidgetQueueDraw(x.GoPointer())

}

var xWidgetQueueResize func(uintptr)

// Flags a widget to have its size renegotiated.
//
// This should be called when a widget for some reason has a new
// size request. For example, when you change the text in a
// [class@Gtk.Label], the label queues a resize to ensure there’s
// enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget
// from inside its implementation of the [vfunc@Gtk.Widget.size_allocate]
// virtual method. Calls to gtk_widget_queue_resize() from inside
// [vfunc@Gtk.Widget.size_allocate] will be silently ignored.
//
// This function is only for use in widget implementations.
func (x *Widget) QueueResize() {

	xWidgetQueueResize(x.GoPointer())

}

var xWidgetRealize func(uintptr)

// Creates the GDK resources associated with a widget.
//
// Normally realization happens implicitly; if you show a widget
// and all its parent containers, then the widget will be realized
// and mapped automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be
// realized; calling this function realizes the widget’s parents
// in addition to @widget itself. If a widget is not yet inside a
// toplevel window when you realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and
// isn’t very useful otherwise. Many times when you think you might
// need it, a better approach is to connect to a signal that will be
// called after the widget is realized automatically, such as
// [signal@Gtk.Widget::realize].
func (x *Widget) Realize() {

	xWidgetRealize(x.GoPointer())

}

var xWidgetRemoveController func(uintptr, uintptr)

// Removes an event controller from the widget.
//
// The removed event controller will not receive any more events,
// and should not be used again.
//
// Widgets will remove all event controllers automatically when they
// are destroyed, there is normally no need to call this function.
func (x *Widget) RemoveController(ControllerVar *EventController) {

	xWidgetRemoveController(x.GoPointer(), ControllerVar.GoPointer())

}

var xWidgetRemoveCssClass func(uintptr, string)

// Removes a style from the widget.
//
// After this, the style of @widget will stop matching for @css_class.
func (x *Widget) RemoveCssClass(CssClassVar string) {

	xWidgetRemoveCssClass(x.GoPointer(), CssClassVar)

}

var xWidgetRemoveMnemonicLabel func(uintptr, uintptr)

// Removes a widget from the list of mnemonic labels for this widget.
//
// See [method@Gtk.Widget.list_mnemonic_labels].
//
// The widget must have previously been added to the list with
// [method@Gtk.Widget.add_mnemonic_label].
func (x *Widget) RemoveMnemonicLabel(LabelVar *Widget) {

	xWidgetRemoveMnemonicLabel(x.GoPointer(), LabelVar.GoPointer())

}

var xWidgetRemoveTickCallback func(uintptr, uint)

// Removes a tick callback previously registered with
// [method@Gtk.Widget.add_tick_callback].
func (x *Widget) RemoveTickCallback(IdVar uint) {

	xWidgetRemoveTickCallback(x.GoPointer(), IdVar)

}

var xWidgetSetCanFocus func(uintptr, bool)

// Sets whether the input focus can enter the widget or
// any of its children.
//
// Applications should set @can_focus to false to mark a
// widget as for pointer/touch use only.
//
// Note that having @can_focus be true is only one of the
// necessary conditions for being focusable. A widget must
// also be sensitive and focusable and not have an ancestor
// that is marked as not can-focus in order to receive input
// focus.
//
// See [method@Gtk.Widget.grab_focus] for actually setting
// the input focus on a widget.
func (x *Widget) SetCanFocus(CanFocusVar bool) {

	xWidgetSetCanFocus(x.GoPointer(), CanFocusVar)

}

var xWidgetSetCanTarget func(uintptr, bool)

// Sets whether the widget can be the target of pointer events.
func (x *Widget) SetCanTarget(CanTargetVar bool) {

	xWidgetSetCanTarget(x.GoPointer(), CanTargetVar)

}

var xWidgetSetChildVisible func(uintptr, bool)

// Sets whether the widget should be mapped along with its parent.
//
// The child visibility can be set for widget before it is added
// to a container with [method@Gtk.Widget.set_parent], to avoid
// mapping children unnecessary before immediately unmapping them.
// However it will be reset to its default state of true when the
// widget is removed from a container.
//
// Note that changing the child visibility of a widget does not
// queue a resize on the widget. Most of the time, the size of
// a widget is computed from all visible children, whether or
// not they are mapped. If this is not the case, the container
// can queue a resize itself.
//
// This function is only useful for widget implementations
// and should never be called by an application.
func (x *Widget) SetChildVisible(ChildVisibleVar bool) {

	xWidgetSetChildVisible(x.GoPointer(), ChildVisibleVar)

}

var xWidgetSetCssClasses func(uintptr, []string)

// Replaces the current style classes of the widget with @classes.
func (x *Widget) SetCssClasses(ClassesVar []string) {

	xWidgetSetCssClasses(x.GoPointer(), ClassesVar)

}

var xWidgetSetCursor func(uintptr, uintptr)

// Sets the cursor to be shown when the pointer hovers over
// the widget.
//
// If the @cursor is `NULL`, @widget will use the cursor
// inherited from its parent.
func (x *Widget) SetCursor(CursorVar *gdk.Cursor) {

	xWidgetSetCursor(x.GoPointer(), CursorVar.GoPointer())

}

var xWidgetSetCursorFromName func(uintptr, uintptr)

// Sets the cursor to be shown when the pointer hovers over
// the widget.
//
// This is a utility function that creates a cursor via
// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget
// with [method@Gtk.Widget.set_cursor]. See those functions for
// details.
//
// On top of that, this function allows @name to be `NULL`, which
// will do the same as calling [method@Gtk.Widget.set_cursor]
// with a `NULL` cursor.
func (x *Widget) SetCursorFromName(NameVar *string) {

	NameVarPtr := core.GStrdupNullable(NameVar)
	defer core.GFreeNullable(NameVarPtr)

	xWidgetSetCursorFromName(x.GoPointer(), NameVarPtr)

}

var xWidgetSetDirection func(uintptr, TextDirection)

// Sets the reading direction on the widget.
//
// This direction controls the primary direction for widgets
// containing text, and also the direction in which the children
// of a container are packed. The ability to set the direction is
// present in order so that correct localization into languages with
// right-to-left reading directions can be done.
//
// Generally, applications will let the default reading direction
// prevail, except for widgets where the children are arranged in
// an order that is explicitly visual rather than logical (such as
// buttons for text justification).
//
// If the direction is set to [enum@Gtk.TextDirection.none], then
// the value set by [func@Gtk.Widget.set_default_direction] will be used.
func (x *Widget) SetDirection(DirVar TextDirection) {

	xWidgetSetDirection(x.GoPointer(), DirVar)

}

var xWidgetSetFocusChild func(uintptr, uintptr)

// Set the focus child of the widget.
//
// This function is only suitable for widget implementations.
// If you want a certain widget to get the input focus, call
// [method@Gtk.Widget.grab_focus] on it.
func (x *Widget) SetFocusChild(ChildVar *Widget) {

	xWidgetSetFocusChild(x.GoPointer(), ChildVar.GoPointer())

}

var xWidgetSetFocusOnClick func(uintptr, bool)

// Sets whether the widget should grab focus when it is clicked
// with the mouse.
//
// Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from
// the main area of the application.
func (x *Widget) SetFocusOnClick(FocusOnClickVar bool) {

	xWidgetSetFocusOnClick(x.GoPointer(), FocusOnClickVar)

}

var xWidgetSetFocusable func(uintptr, bool)

// Sets whether the widget can own the input focus.
//
// Widget implementations should set @focusable to true in
// their init() function if they want to receive keyboard input.
//
// Note that having @focusable be true is only one of the
// necessary conditions for being focusable. A widget must
// also be sensitive and can-focus and not have an ancestor
// that is marked as not can-focus in order to receive input
// focus.
//
// See [method@Gtk.Widget.grab_focus] for actually setting
// the input focus on a widget.
func (x *Widget) SetFocusable(FocusableVar bool) {

	xWidgetSetFocusable(x.GoPointer(), FocusableVar)

}

var xWidgetSetFontMap func(uintptr, uintptr)

// Sets the font map to use for text rendering in the widget.
//
// The font map is the object that is used to look up fonts.
// Setting a custom font map can be useful in special situations,
// e.g. when you need to add application-specific fonts to the set
// of available fonts.
//
// When not set, the widget will inherit the font map from its parent.
func (x *Widget) SetFontMap(FontMapVar *pango.FontMap) {

	xWidgetSetFontMap(x.GoPointer(), FontMapVar.GoPointer())

}

var xWidgetSetFontOptions func(uintptr, *cairo.FontOptions)

// Sets the `cairo_font_options_t` used for text rendering
// in the widget.
//
// When not set, the default font options for the `GdkDisplay`
// will be used.
func (x *Widget) SetFontOptions(OptionsVar *cairo.FontOptions) {

	xWidgetSetFontOptions(x.GoPointer(), OptionsVar)

}

var xWidgetSetHalign func(uintptr, Align)

// Sets the horizontal alignment of the widget.
func (x *Widget) SetHalign(AlignVar Align) {

	xWidgetSetHalign(x.GoPointer(), AlignVar)

}

var xWidgetSetHasTooltip func(uintptr, bool)

// Sets the `has-tooltip` property on the widget.
func (x *Widget) SetHasTooltip(HasTooltipVar bool) {

	xWidgetSetHasTooltip(x.GoPointer(), HasTooltipVar)

}

var xWidgetSetHexpand func(uintptr, bool)

// Sets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a window, widgets with expand set to true generally
// receive the extra space. For example, a list or scrollable area
// or document in your window would often be set to expand.
//
// Call this function to set the expand flag if you would like your
// widget to become larger horizontally when the window has extra
// room.
//
// By default, widgets automatically expand if any of their children
// want to expand. (To see if a widget will automatically expand given
// its current children and state, call [method@Gtk.Widget.compute_expand].
// A widget can decide how the expandability of children affects its
// own expansion by overriding the `compute_expand` virtual method on
// `GtkWidget`.).
//
// Setting hexpand explicitly with this function will override the
// automatic expand behavior.
//
// This function forces the widget to expand or not to expand,
// regardless of children. The override occurs because
// [method@Gtk.Widget.set_hexpand] sets the hexpand-set property (see
// [method@Gtk.Widget.set_hexpand_set]) which causes the widget’s hexpand
// value to be used, rather than looking at children and widget state.
func (x *Widget) SetHexpand(ExpandVar bool) {

	xWidgetSetHexpand(x.GoPointer(), ExpandVar)

}

var xWidgetSetHexpandSet func(uintptr, bool)

// Sets whether the hexpand flag will be used.
//
// The [property@Gtk.Widget:hexpand-set] property will be set
// automatically when you call [method@Gtk.Widget.set_hexpand]
// to set hexpand, so the most likely reason to use this function
// would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed
// expand value based on child widgets. If hexpand is not
// set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here
// for completeness and consistency.
func (x *Widget) SetHexpandSet(SetVar bool) {

	xWidgetSetHexpandSet(x.GoPointer(), SetVar)

}

var xWidgetSetLayoutManager func(uintptr, uintptr)

// Sets the layout manager to use for measuring and allocating children
// of the widget.
func (x *Widget) SetLayoutManager(LayoutManagerVar *LayoutManager) {

	xWidgetSetLayoutManager(x.GoPointer(), LayoutManagerVar.GoPointer())

}

var xWidgetSetLimitEvents func(uintptr, bool)

// Sets whether the widget acts like a modal dialog,
// with respect to event delivery.
func (x *Widget) SetLimitEvents(LimitEventsVar bool) {

	xWidgetSetLimitEvents(x.GoPointer(), LimitEventsVar)

}

var xWidgetSetMarginBottom func(uintptr, int)

// Sets the bottom margin of the widget.
func (x *Widget) SetMarginBottom(MarginVar int) {

	xWidgetSetMarginBottom(x.GoPointer(), MarginVar)

}

var xWidgetSetMarginEnd func(uintptr, int)

// Sets the end margin of the widget.
func (x *Widget) SetMarginEnd(MarginVar int) {

	xWidgetSetMarginEnd(x.GoPointer(), MarginVar)

}

var xWidgetSetMarginStart func(uintptr, int)

// Sets the start margin of the widget.
func (x *Widget) SetMarginStart(MarginVar int) {

	xWidgetSetMarginStart(x.GoPointer(), MarginVar)

}

var xWidgetSetMarginTop func(uintptr, int)

// Sets the top margin of the widget.
func (x *Widget) SetMarginTop(MarginVar int) {

	xWidgetSetMarginTop(x.GoPointer(), MarginVar)

}

var xWidgetSetName func(uintptr, string)

// Sets a widgets name.
//
// Setting a name allows you to refer to the widget from a
// CSS file. You can apply a style to widgets with a particular name
// in the CSS file. See the documentation for the CSS syntax (on the
// same page as the docs for [class@Gtk.StyleContext].
//
// Note that the CSS syntax has certain special characters to delimit
// and represent elements in a selector (period, #, &gt;, *...), so using
// these will make your widget impossible to match by name. Any combination
// of alphanumeric symbols, dashes and underscores will suffice.
func (x *Widget) SetName(NameVar string) {

	xWidgetSetName(x.GoPointer(), NameVar)

}

var xWidgetSetOpacity func(uintptr, float64)

// Requests the widget to be rendered partially transparent.
//
// An opacity of 0 is fully transparent and an opacity of 1
// is fully opaque.
//
// Opacity works on both toplevel widgets and child widgets, although
// there are some limitations: For toplevel widgets, applying opacity
// depends on the capabilities of the windowing system. On X11, this
// has any effect only on X displays with a compositing manager, see
// [method@Gdk.Display.is_composited]. On Windows and Wayland it will
// always work, although setting a window’s opacity after the window
// has been shown may cause some flicker.
//
// Note that the opacity is inherited through inclusion — if you set
// a toplevel to be partially translucent, all of its content will
// appear translucent, since it is ultimatively rendered on that
// toplevel. The opacity value itself is not inherited by child
// widgets (since that would make widgets deeper in the hierarchy
// progressively more translucent). As a consequence, [class@Gtk.Popover]
// instances and other [iface@Gtk.Native] widgets with their own surface
// will use their own opacity value, and thus by default appear
// non-translucent, even if they are attached to a toplevel that
// is translucent.
func (x *Widget) SetOpacity(OpacityVar float64) {

	xWidgetSetOpacity(x.GoPointer(), OpacityVar)

}

var xWidgetSetOverflow func(uintptr, Overflow)

// Sets how the widget treats content that is drawn outside the
// it's content area.
//
// See the definition of [enum@Gtk.Overflow] for details.
//
// This setting is provided for widget implementations and
// should not be used by application code.
//
// The default value is [enum@Gtk.Overflow.visible].
func (x *Widget) SetOverflow(OverflowVar Overflow) {

	xWidgetSetOverflow(x.GoPointer(), OverflowVar)

}

var xWidgetSetParent func(uintptr, uintptr)

// Sets the parent widget of the widget.
//
// This takes care of details such as updating the state and style
// of the child to reflect its new location and resizing the parent.
// The opposite function is [method@Gtk.Widget.unparent].
//
// This function is useful only when implementing subclasses of
// `GtkWidget`.
func (x *Widget) SetParent(ParentVar *Widget) {

	xWidgetSetParent(x.GoPointer(), ParentVar.GoPointer())

}

var xWidgetSetReceivesDefault func(uintptr, bool)

// Sets whether the widget will be treated as the default
// widget within its toplevel when it has the focus, even if
// another widget is the default.
func (x *Widget) SetReceivesDefault(ReceivesDefaultVar bool) {

	xWidgetSetReceivesDefault(x.GoPointer(), ReceivesDefaultVar)

}

var xWidgetSetSensitive func(uintptr, bool)

// Sets the sensitivity of the widget.
//
// A widget is sensitive if the user can interact with it.
// Insensitive widgets are “grayed out” and the user can’t
// interact with them. Insensitive widgets are known as
// “inactive”, “disabled”, or “ghosted” in some other toolkits.
func (x *Widget) SetSensitive(SensitiveVar bool) {

	xWidgetSetSensitive(x.GoPointer(), SensitiveVar)

}

var xWidgetSetSizeRequest func(uintptr, int, int)

// Sets the minimum size of the widget.
//
// That is, the widget’s size request will be at least @width
// by @height. You can use this function to force a widget to
// be larger than it normally would be.
//
// In most cases, [method@Gtk.Window.set_default_size] is a better
// choice for toplevel windows than this function; setting the default
// size will still allow users to shrink the window. Setting the size
// request will force them to leave the window at least as large as
// the size request.
//
// Note the inherent danger of setting any fixed size - themes,
// translations into other languages, different fonts, and user action
// can all change the appropriate size for a given widget. So, it is
// basically impossible to hardcode a size that will always work.
//
// The size request of a widget is the smallest size a widget can
// accept while still functioning well and drawing itself correctly.
// However in some strange cases a widget may be allocated less than
// its requested size, and in many cases a widget may be allocated more
// space than it requested.
//
// If the size request in a given direction is -1 (unset), then
// the “natural” size request of the widget will be used instead.
//
// The size request set here does not include any margin from the
// properties
// [property@Gtk.Widget:margin-start],
// [property@Gtk.Widget:margin-end],
// [property@Gtk.Widget:margin-top], and
// [property@Gtk.Widget:margin-bottom], but it does include pretty
// much all other padding or border properties set by any subclass
// of `GtkWidget`.
func (x *Widget) SetSizeRequest(WidthVar int, HeightVar int) {

	xWidgetSetSizeRequest(x.GoPointer(), WidthVar, HeightVar)

}

var xWidgetSetStateFlags func(uintptr, StateFlags, bool)

// Turns on flag values in the current widget state.
//
// Typical widget states are insensitive, prelighted, etc.
//
// This function accepts the values [flags@Gtk.StateFlags.dir-ltr] and
// [flags@Gtk.StateFlags.dir-rtl] but ignores them. If you want to set
// the widget's direction, use [method@Gtk.Widget.set_direction].
//
// This function is for use in widget implementations.
func (x *Widget) SetStateFlags(FlagsVar StateFlags, ClearVar bool) {

	xWidgetSetStateFlags(x.GoPointer(), FlagsVar, ClearVar)

}

var xWidgetSetTooltipMarkup func(uintptr, uintptr)

// Sets the contents of the tooltip for widget.
//
// @markup must contain Pango markup.
//
// This function will take care of setting the
// [property@Gtk.Widget:has-tooltip] as a side effect, and of the
// default handler for the [signal@Gtk.Widget::query-tooltip] signal.
//
// See also [method@Gtk.Tooltip.set_markup].
func (x *Widget) SetTooltipMarkup(MarkupVar *string) {

	MarkupVarPtr := core.GStrdupNullable(MarkupVar)
	defer core.GFreeNullable(MarkupVarPtr)

	xWidgetSetTooltipMarkup(x.GoPointer(), MarkupVarPtr)

}

var xWidgetSetTooltipText func(uintptr, uintptr)

// Sets the contents of the tooltip for the widget.
//
// If @text contains any markup, it will be escaped.
//
// This function will take care of setting
// [property@Gtk.Widget:has-tooltip] as a side effect,
// and of the default handler for the
// [signal@Gtk.Widget::query-tooltip] signal.
//
// See also [method@Gtk.Tooltip.set_text].
func (x *Widget) SetTooltipText(TextVar *string) {

	TextVarPtr := core.GStrdupNullable(TextVar)
	defer core.GFreeNullable(TextVarPtr)

	xWidgetSetTooltipText(x.GoPointer(), TextVarPtr)

}

var xWidgetSetValign func(uintptr, Align)

// Sets the vertical alignment of the widget.
func (x *Widget) SetValign(AlignVar Align) {

	xWidgetSetValign(x.GoPointer(), AlignVar)

}

var xWidgetSetVexpand func(uintptr, bool)

// Sets whether the widget would like any available extra vertical
// space.
//
// See [method@Gtk.Widget.set_hexpand] for more detail.
func (x *Widget) SetVexpand(ExpandVar bool) {

	xWidgetSetVexpand(x.GoPointer(), ExpandVar)

}

var xWidgetSetVexpandSet func(uintptr, bool)

// Sets whether the vexpand flag will be used.
//
// See [method@Gtk.Widget.set_hexpand_set] for more detail.
func (x *Widget) SetVexpandSet(SetVar bool) {

	xWidgetSetVexpandSet(x.GoPointer(), SetVar)

}

var xWidgetSetVisible func(uintptr, bool)

// Sets the visibility state of @widget.
//
// Note that setting this to true doesn’t mean the widget is
// actually viewable, see [method@Gtk.Widget.get_visible].
func (x *Widget) SetVisible(VisibleVar bool) {

	xWidgetSetVisible(x.GoPointer(), VisibleVar)

}

var xWidgetShouldLayout func(uintptr) bool

// Returns whether the widget should contribute to
// the measuring and allocation of its parent.
//
// This is false for invisible children, but also
// for children that have their own surface, such
// as [class@Gtk.Popover] instances.
func (x *Widget) ShouldLayout() bool {

	cret := xWidgetShouldLayout(x.GoPointer())
	return cret
}

var xWidgetShow func(uintptr)

// Flags a widget to be displayed.
//
// Any widget that isn’t shown will not appear on the screen.
//
// Remember that you have to show the containers containing a widget,
// in addition to the widget itself, before it will appear onscreen.
//
// When a toplevel widget is shown, it is immediately realized and
// mapped; other shown widgets are realized and mapped when their
// toplevel widget is realized and mapped.
func (x *Widget) Show() {

	xWidgetShow(x.GoPointer())

}

var xWidgetSizeAllocate func(uintptr, *Allocation, int)

// Allocates widget with a transformation that translates
// the origin to the position in @allocation.
//
// This is a simple form of [method@Gtk.Widget.allocate].
func (x *Widget) SizeAllocate(AllocationVar *Allocation, BaselineVar int) {

	xWidgetSizeAllocate(x.GoPointer(), AllocationVar, BaselineVar)

}

var xWidgetSnapshotChild func(uintptr, uintptr, uintptr)

// Snapshots a child of the widget.
//
// When a widget receives a call to the snapshot function,
// it must send synthetic [vfunc@Gtk.Widget.snapshot] calls
// to all children. This function provides a convenient way
// of doing this. A widget, when it receives a call to its
// [vfunc@Gtk.Widget.snapshot] function, calls
// gtk_widget_snapshot_child() once for each child, passing in
// the @snapshot the widget received.
//
// This function takes care of translating the origin of @snapshot,
// and deciding whether the child needs to be snapshot.
//
// It does nothing for children that implement `GtkNative`.
func (x *Widget) SnapshotChild(ChildVar *Widget, SnapshotVar *Snapshot) {

	xWidgetSnapshotChild(x.GoPointer(), ChildVar.GoPointer(), SnapshotVar.GoPointer())

}

var xWidgetTranslateCoordinates func(uintptr, uintptr, float64, float64, *float64, *float64) bool

// Translates coordinates relative to @src_widget’s allocation
// to coordinates relative to @dest_widget’s allocations.
//
// In order to perform this operation, both widget must share
// a common ancestor. If that is not the case, @dest_x and @dest_y
// are set to 0 and false is returned.
func (x *Widget) TranslateCoordinates(DestWidgetVar *Widget, SrcXVar float64, SrcYVar float64, DestXVar *float64, DestYVar *float64) bool {

	cret := xWidgetTranslateCoordinates(x.GoPointer(), DestWidgetVar.GoPointer(), SrcXVar, SrcYVar, DestXVar, DestYVar)
	return cret
}

var xWidgetTriggerTooltipQuery func(uintptr)

// Triggers a tooltip query on the display of the widget.
func (x *Widget) TriggerTooltipQuery() {

	xWidgetTriggerTooltipQuery(x.GoPointer())

}

var xWidgetUnmap func(uintptr)

// Causes a widget to be unmapped if it’s currently mapped.
//
// This function is only for use in widget implementations.
func (x *Widget) Unmap() {

	xWidgetUnmap(x.GoPointer())

}

var xWidgetUnparent func(uintptr)

// Removes @widget from its parent.
//
// This function is only for use in widget implementations,
// typically in dispose.
func (x *Widget) Unparent() {

	xWidgetUnparent(x.GoPointer())

}

var xWidgetUnrealize func(uintptr)

// Causes a widget to be unrealized.
//
// This frees all GDK resources associated with the widget.
//
// This function is only useful in widget implementations.
func (x *Widget) Unrealize() {

	xWidgetUnrealize(x.GoPointer())

}

var xWidgetUnsetStateFlags func(uintptr, StateFlags)

// Turns off flag values for the current widget state.
//
// See [method@Gtk.Widget.set_state_flags].
//
// This function is for use in widget implementations.
func (x *Widget) UnsetStateFlags(FlagsVar StateFlags) {

	xWidgetUnsetStateFlags(x.GoPointer(), FlagsVar)

}

func (c *Widget) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Widget) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyCanFocus sets the "can-focus" property.
// Whether the widget or any of its descendents can accept
// the input focus.
//
// This property is meant to be set by widget implementations,
// typically in their instance init function.
func (x *Widget) SetPropertyCanFocus(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("can-focus", &v)
}

// GetPropertyCanFocus gets the "can-focus" property.
// Whether the widget or any of its descendents can accept
// the input focus.
//
// This property is meant to be set by widget implementations,
// typically in their instance init function.
func (x *Widget) GetPropertyCanFocus() bool {
	var v gobject.Value
	x.GetProperty("can-focus", &v)
	return v.GetBoolean()
}

// SetPropertyCanTarget sets the "can-target" property.
// Whether the widget can receive pointer events.
func (x *Widget) SetPropertyCanTarget(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("can-target", &v)
}

// GetPropertyCanTarget gets the "can-target" property.
// Whether the widget can receive pointer events.
func (x *Widget) GetPropertyCanTarget() bool {
	var v gobject.Value
	x.GetProperty("can-target", &v)
	return v.GetBoolean()
}

// SetPropertyCssClasses sets the "css-classes" property.
// A list of css classes applied to this widget.
func (x *Widget) SetPropertyCssClasses(value []string) {
	var v gobject.Value
	v.Init(glib.StrvGetType())
	v.SetBoxed(uintptr(unsafe.Pointer(core.ByteSlice(value))))
	x.SetProperty("css-classes", &v)
}

// GetPropertyCssClasses gets the "css-classes" property.
// A list of css classes applied to this widget.
func (x *Widget) GetPropertyCssClasses() []string {
	var v gobject.Value
	x.GetProperty("css-classes", &v)
	return core.GoStringSlice(v.GetBoxed())
}

// SetPropertyCssName sets the "css-name" property.
// The name of this widget in the CSS tree.
//
// This property is meant to be set by widget implementations,
// typically in their instance init function.
func (x *Widget) SetPropertyCssName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("css-name", &v)
}

// GetPropertyCssName gets the "css-name" property.
// The name of this widget in the CSS tree.
//
// This property is meant to be set by widget implementations,
// typically in their instance init function.
func (x *Widget) GetPropertyCssName() string {
	var v gobject.Value
	x.GetProperty("css-name", &v)
	return v.GetString()
}

// SetPropertyFocusOnClick sets the "focus-on-click" property.
// Whether the widget should grab focus when it is clicked with the mouse.
//
// This property is only relevant for widgets that can take focus.
func (x *Widget) SetPropertyFocusOnClick(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("focus-on-click", &v)
}

// GetPropertyFocusOnClick gets the "focus-on-click" property.
// Whether the widget should grab focus when it is clicked with the mouse.
//
// This property is only relevant for widgets that can take focus.
func (x *Widget) GetPropertyFocusOnClick() bool {
	var v gobject.Value
	x.GetProperty("focus-on-click", &v)
	return v.GetBoolean()
}

// SetPropertyFocusable sets the "focusable" property.
// Whether this widget itself will accept the input focus.
func (x *Widget) SetPropertyFocusable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("focusable", &v)
}

// GetPropertyFocusable gets the "focusable" property.
// Whether this widget itself will accept the input focus.
func (x *Widget) GetPropertyFocusable() bool {
	var v gobject.Value
	x.GetProperty("focusable", &v)
	return v.GetBoolean()
}

// GetPropertyHasDefault gets the "has-default" property.
// Whether the widget is the default widget.
func (x *Widget) GetPropertyHasDefault() bool {
	var v gobject.Value
	x.GetProperty("has-default", &v)
	return v.GetBoolean()
}

// GetPropertyHasFocus gets the "has-focus" property.
// Whether the widget has the input focus.
func (x *Widget) GetPropertyHasFocus() bool {
	var v gobject.Value
	x.GetProperty("has-focus", &v)
	return v.GetBoolean()
}

// SetPropertyHasTooltip sets the "has-tooltip" property.
// Enables or disables the emission of the [signal@Gtk.Widget::query-tooltip]
// signal on @widget.
//
// A true value indicates that @widget can have a tooltip, in this case
// the widget will be queried using [signal@Gtk.Widget::query-tooltip] to
// determine whether it will provide a tooltip or not.
func (x *Widget) SetPropertyHasTooltip(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("has-tooltip", &v)
}

// GetPropertyHasTooltip gets the "has-tooltip" property.
// Enables or disables the emission of the [signal@Gtk.Widget::query-tooltip]
// signal on @widget.
//
// A true value indicates that @widget can have a tooltip, in this case
// the widget will be queried using [signal@Gtk.Widget::query-tooltip] to
// determine whether it will provide a tooltip or not.
func (x *Widget) GetPropertyHasTooltip() bool {
	var v gobject.Value
	x.GetProperty("has-tooltip", &v)
	return v.GetBoolean()
}

// SetPropertyHeightRequest sets the "height-request" property.
// Overrides for height request of the widget.
//
// If this is -1, the natural request will be used.
func (x *Widget) SetPropertyHeightRequest(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("height-request", &v)
}

// GetPropertyHeightRequest gets the "height-request" property.
// Overrides for height request of the widget.
//
// If this is -1, the natural request will be used.
func (x *Widget) GetPropertyHeightRequest() int {
	var v gobject.Value
	x.GetProperty("height-request", &v)
	return v.GetInt()
}

// SetPropertyHexpand sets the "hexpand" property.
// Whether to expand horizontally.
func (x *Widget) SetPropertyHexpand(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("hexpand", &v)
}

// GetPropertyHexpand gets the "hexpand" property.
// Whether to expand horizontally.
func (x *Widget) GetPropertyHexpand() bool {
	var v gobject.Value
	x.GetProperty("hexpand", &v)
	return v.GetBoolean()
}

// SetPropertyHexpandSet sets the "hexpand-set" property.
// Whether to use the `hexpand` property.
func (x *Widget) SetPropertyHexpandSet(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("hexpand-set", &v)
}

// GetPropertyHexpandSet gets the "hexpand-set" property.
// Whether to use the `hexpand` property.
func (x *Widget) GetPropertyHexpandSet() bool {
	var v gobject.Value
	x.GetProperty("hexpand-set", &v)
	return v.GetBoolean()
}

// SetPropertyLimitEvents sets the "limit-events" property.
// Makes this widget act like a modal dialog, with respect to
// event delivery.
//
// Global event controllers will not handle events with targets
// inside the widget, unless they are set up to ignore propagation
// limits. See [method@Gtk.EventController.set_propagation_limit].
func (x *Widget) SetPropertyLimitEvents(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("limit-events", &v)
}

// GetPropertyLimitEvents gets the "limit-events" property.
// Makes this widget act like a modal dialog, with respect to
// event delivery.
//
// Global event controllers will not handle events with targets
// inside the widget, unless they are set up to ignore propagation
// limits. See [method@Gtk.EventController.set_propagation_limit].
func (x *Widget) GetPropertyLimitEvents() bool {
	var v gobject.Value
	x.GetProperty("limit-events", &v)
	return v.GetBoolean()
}

// SetPropertyMarginBottom sets the "margin-bottom" property.
// Margin on bottom side of widget.
//
// This property adds margin outside of the widget's normal size
// request, the margin will be added in addition to the size from
// [method@Gtk.Widget.set_size_request] for example.
func (x *Widget) SetPropertyMarginBottom(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("margin-bottom", &v)
}

// GetPropertyMarginBottom gets the "margin-bottom" property.
// Margin on bottom side of widget.
//
// This property adds margin outside of the widget's normal size
// request, the margin will be added in addition to the size from
// [method@Gtk.Widget.set_size_request] for example.
func (x *Widget) GetPropertyMarginBottom() int {
	var v gobject.Value
	x.GetProperty("margin-bottom", &v)
	return v.GetInt()
}

// SetPropertyMarginEnd sets the "margin-end" property.
// Margin on end of widget, horizontally.
//
// This property supports left-to-right and right-to-left text
// directions.
//
// This property adds margin outside of the widget's normal size
// request, the margin will be added in addition to the size from
// [method@Gtk.Widget.set_size_request] for example.
func (x *Widget) SetPropertyMarginEnd(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("margin-end", &v)
}

// GetPropertyMarginEnd gets the "margin-end" property.
// Margin on end of widget, horizontally.
//
// This property supports left-to-right and right-to-left text
// directions.
//
// This property adds margin outside of the widget's normal size
// request, the margin will be added in addition to the size from
// [method@Gtk.Widget.set_size_request] for example.
func (x *Widget) GetPropertyMarginEnd() int {
	var v gobject.Value
	x.GetProperty("margin-end", &v)
	return v.GetInt()
}

// SetPropertyMarginStart sets the "margin-start" property.
// Margin on start of widget, horizontally.
//
// This property supports left-to-right and right-to-left text
// directions.
//
// This property adds margin outside of the widget's normal size
// request, the margin will be added in addition to the size from
// [method@Gtk.Widget.set_size_request] for example.
func (x *Widget) SetPropertyMarginStart(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("margin-start", &v)
}

// GetPropertyMarginStart gets the "margin-start" property.
// Margin on start of widget, horizontally.
//
// This property supports left-to-right and right-to-left text
// directions.
//
// This property adds margin outside of the widget's normal size
// request, the margin will be added in addition to the size from
// [method@Gtk.Widget.set_size_request] for example.
func (x *Widget) GetPropertyMarginStart() int {
	var v gobject.Value
	x.GetProperty("margin-start", &v)
	return v.GetInt()
}

// SetPropertyMarginTop sets the "margin-top" property.
// Margin on top side of widget.
//
// This property adds margin outside of the widget's normal size
// request, the margin will be added in addition to the size from
// [method@Gtk.Widget.set_size_request] for example.
func (x *Widget) SetPropertyMarginTop(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("margin-top", &v)
}

// GetPropertyMarginTop gets the "margin-top" property.
// Margin on top side of widget.
//
// This property adds margin outside of the widget's normal size
// request, the margin will be added in addition to the size from
// [method@Gtk.Widget.set_size_request] for example.
func (x *Widget) GetPropertyMarginTop() int {
	var v gobject.Value
	x.GetProperty("margin-top", &v)
	return v.GetInt()
}

// SetPropertyName sets the "name" property.
// The name of the widget.
func (x *Widget) SetPropertyName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("name", &v)
}

// GetPropertyName gets the "name" property.
// The name of the widget.
func (x *Widget) GetPropertyName() string {
	var v gobject.Value
	x.GetProperty("name", &v)
	return v.GetString()
}

// SetPropertyOpacity sets the "opacity" property.
// The requested opacity of the widget.
func (x *Widget) SetPropertyOpacity(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("opacity", &v)
}

// GetPropertyOpacity gets the "opacity" property.
// The requested opacity of the widget.
func (x *Widget) GetPropertyOpacity() float64 {
	var v gobject.Value
	x.GetProperty("opacity", &v)
	return v.GetDouble()
}

// SetPropertyReceivesDefault sets the "receives-default" property.
// Whether the widget will receive the default action when it is focused.
func (x *Widget) SetPropertyReceivesDefault(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("receives-default", &v)
}

// GetPropertyReceivesDefault gets the "receives-default" property.
// Whether the widget will receive the default action when it is focused.
func (x *Widget) GetPropertyReceivesDefault() bool {
	var v gobject.Value
	x.GetProperty("receives-default", &v)
	return v.GetBoolean()
}

// GetPropertyScaleFactor gets the "scale-factor" property.
// The scale factor of the widget.
func (x *Widget) GetPropertyScaleFactor() int {
	var v gobject.Value
	x.GetProperty("scale-factor", &v)
	return v.GetInt()
}

// SetPropertySensitive sets the "sensitive" property.
// Whether the widget responds to input.
func (x *Widget) SetPropertySensitive(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("sensitive", &v)
}

// GetPropertySensitive gets the "sensitive" property.
// Whether the widget responds to input.
func (x *Widget) GetPropertySensitive() bool {
	var v gobject.Value
	x.GetProperty("sensitive", &v)
	return v.GetBoolean()
}

// SetPropertyTooltipMarkup sets the "tooltip-markup" property.
// Sets the text of tooltip to be the given string, which is marked up
// with Pango markup.
//
// Also see [method@Gtk.Tooltip.set_markup].
//
// This is a convenience property which will take care of getting the
// tooltip shown if the given string is not `NULL`:
// [property@Gtk.Widget:has-tooltip] will automatically be set to true
// and there will be taken care of [signal@Gtk.Widget::query-tooltip] in
// the default signal handler.
//
// Note that if both [property@Gtk.Widget:tooltip-text] and
// [property@Gtk.Widget:tooltip-markup] are set, the last one wins.
func (x *Widget) SetPropertyTooltipMarkup(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("tooltip-markup", &v)
}

// GetPropertyTooltipMarkup gets the "tooltip-markup" property.
// Sets the text of tooltip to be the given string, which is marked up
// with Pango markup.
//
// Also see [method@Gtk.Tooltip.set_markup].
//
// This is a convenience property which will take care of getting the
// tooltip shown if the given string is not `NULL`:
// [property@Gtk.Widget:has-tooltip] will automatically be set to true
// and there will be taken care of [signal@Gtk.Widget::query-tooltip] in
// the default signal handler.
//
// Note that if both [property@Gtk.Widget:tooltip-text] and
// [property@Gtk.Widget:tooltip-markup] are set, the last one wins.
func (x *Widget) GetPropertyTooltipMarkup() string {
	var v gobject.Value
	x.GetProperty("tooltip-markup", &v)
	return v.GetString()
}

// SetPropertyTooltipText sets the "tooltip-text" property.
// Sets the text of tooltip to be the given string.
//
// Also see [method@Gtk.Tooltip.set_text].
//
// This is a convenience property which will take care of getting the
// tooltip shown if the given string is not `NULL`:
// [property@Gtk.Widget:has-tooltip] will automatically be set to true
// and there will be taken care of [signal@Gtk.Widget::query-tooltip] in
// the default signal handler.
//
// Note that if both [property@Gtk.Widget:tooltip-text] and
// [property@Gtk.Widget:tooltip-markup] are set, the last one wins.
func (x *Widget) SetPropertyTooltipText(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("tooltip-text", &v)
}

// GetPropertyTooltipText gets the "tooltip-text" property.
// Sets the text of tooltip to be the given string.
//
// Also see [method@Gtk.Tooltip.set_text].
//
// This is a convenience property which will take care of getting the
// tooltip shown if the given string is not `NULL`:
// [property@Gtk.Widget:has-tooltip] will automatically be set to true
// and there will be taken care of [signal@Gtk.Widget::query-tooltip] in
// the default signal handler.
//
// Note that if both [property@Gtk.Widget:tooltip-text] and
// [property@Gtk.Widget:tooltip-markup] are set, the last one wins.
func (x *Widget) GetPropertyTooltipText() string {
	var v gobject.Value
	x.GetProperty("tooltip-text", &v)
	return v.GetString()
}

// SetPropertyVexpand sets the "vexpand" property.
// Whether to expand vertically.
func (x *Widget) SetPropertyVexpand(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("vexpand", &v)
}

// GetPropertyVexpand gets the "vexpand" property.
// Whether to expand vertically.
func (x *Widget) GetPropertyVexpand() bool {
	var v gobject.Value
	x.GetProperty("vexpand", &v)
	return v.GetBoolean()
}

// SetPropertyVexpandSet sets the "vexpand-set" property.
// Whether to use the `vexpand` property.
func (x *Widget) SetPropertyVexpandSet(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("vexpand-set", &v)
}

// GetPropertyVexpandSet gets the "vexpand-set" property.
// Whether to use the `vexpand` property.
func (x *Widget) GetPropertyVexpandSet() bool {
	var v gobject.Value
	x.GetProperty("vexpand-set", &v)
	return v.GetBoolean()
}

// SetPropertyVisible sets the "visible" property.
// Whether the widget is visible.
func (x *Widget) SetPropertyVisible(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("visible", &v)
}

// GetPropertyVisible gets the "visible" property.
// Whether the widget is visible.
func (x *Widget) GetPropertyVisible() bool {
	var v gobject.Value
	x.GetProperty("visible", &v)
	return v.GetBoolean()
}

// SetPropertyWidthRequest sets the "width-request" property.
// Overrides for width request of the widget.
//
// If this is -1, the natural request will be used.
func (x *Widget) SetPropertyWidthRequest(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("width-request", &v)
}

// GetPropertyWidthRequest gets the "width-request" property.
// Overrides for width request of the widget.
//
// If this is -1, the natural request will be used.
func (x *Widget) GetPropertyWidthRequest() int {
	var v gobject.Value
	x.GetProperty("width-request", &v)
	return v.GetInt()
}

// Signals that all holders of a reference to the widget should release
// the reference that they hold.
//
// May result in finalization of the widget if all references are released.
//
// This signal is not suitable for saving widget state.
func (x *Widget) ConnectDestroy(cb *func(Widget)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "destroy", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "destroy", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the text direction of a widget changes.
func (x *Widget) ConnectDirectionChanged(cb *func(Widget, TextDirection)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "direction-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, PreviousDirectionVarp TextDirection) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PreviousDirectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "direction-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when @widget is hidden.
func (x *Widget) ConnectHide(cb *func(Widget)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "hide", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "hide", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted if keyboard navigation fails.
//
// See [method@Gtk.Widget.keynav_failed] for details.
func (x *Widget) ConnectKeynavFailed(cb *func(Widget, DirectionType) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "keynav-failed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, DirectionVarp DirectionType) bool {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, DirectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "keynav-failed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when @widget is going to be mapped.
//
// A widget is mapped when the widget is visible (which is controlled with
// [property@Gtk.Widget:visible]) and all its parents up to the toplevel widget
// are also visible.
//
// The `::map` signal can be used to determine whether a widget will be drawn,
// for instance it can resume an animation that was stopped during the
// emission of [signal@Gtk.Widget::unmap].
func (x *Widget) ConnectMap(cb *func(Widget)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "map", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "map", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when a widget is activated via a mnemonic.
//
// The default handler for this signal activates @widget if @group_cycling
// is false, or just makes @widget grab focus if @group_cycling is true.
func (x *Widget) ConnectMnemonicActivate(cb *func(Widget, bool) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "mnemonic-activate", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, GroupCyclingVarp bool) bool {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, GroupCyclingVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "mnemonic-activate", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the focus is moved.
//
// The `::move-focus` signal is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are &lt;kbd&gt;Tab&lt;/kbd&gt; to move forward,
// and &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Tab&lt;/kbd&gt; to move backward.
func (x *Widget) ConnectMoveFocus(cb *func(Widget, DirectionType)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "move-focus", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, DirectionVarp DirectionType) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DirectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "move-focus", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the widget’s tooltip is about to be shown.
//
// This happens when the [property@Gtk.Widget:has-tooltip] property
// is true and the hover timeout has expired with the cursor hovering
// above @widget; or emitted when @widget got focus in keyboard mode.
//
// Using the given coordinates, the signal handler should determine
// whether a tooltip should be shown for @widget. If this is the case
// true should be returned, false otherwise. Note that if @keyboard_mode
// is true, the values of @x and @y are undefined and should not be used.
//
// The signal handler is free to manipulate @tooltip with the therefore
// destined function calls.
func (x *Widget) ConnectQueryTooltip(cb *func(Widget, int, int, bool, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "query-tooltip", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, XVarp int, YVarp int, KeyboardModeVarp bool, TooltipVarp uintptr) bool {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, XVarp, YVarp, KeyboardModeVarp, TooltipVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "query-tooltip", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when @widget is associated with a `GdkSurface`.
//
// This means that [method@Gtk.Widget.realize] has been called
// or the widget has been mapped (that is, it is going to be drawn).
func (x *Widget) ConnectRealize(cb *func(Widget)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "realize", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "realize", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when @widget is shown.
func (x *Widget) ConnectShow(cb *func(Widget)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "show", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "show", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the widget state changes.
//
// See [method@Gtk.Widget.get_state_flags].
func (x *Widget) ConnectStateFlagsChanged(cb *func(Widget, StateFlags)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "state-flags-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, FlagsVarp StateFlags) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, FlagsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "state-flags-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when @widget is going to be unmapped.
//
// A widget is unmapped when either it or any of its parents up to the
// toplevel widget have been set as hidden.
//
// As `::unmap` indicates that a widget will not be shown any longer,
// it can be used to, for example, stop an animation on the widget.
func (x *Widget) ConnectUnmap(cb *func(Widget)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "unmap", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "unmap", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the `GdkSurface` associated with @widget is destroyed.
//
// This means that [method@Gtk.Widget.unrealize] has been called
// or the widget has been unmapped (that is, it is going to be hidden).
func (x *Widget) ConnectUnrealize(cb *func(Widget)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "unrealize", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "unrealize", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *Widget) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *Widget) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *Widget) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *Widget) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *Widget) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *Widget) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *Widget) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *Widget) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *Widget) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *Widget) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *Widget) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *Widget) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *Widget) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *Widget) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Widget) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Widget) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Widget) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Widget) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Widget) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Widget) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *Widget) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

var xWidgetGetDefaultDirection func() TextDirection

// Obtains the default reading direction.
//
// See [func@Gtk.Widget.set_default_direction].
func WidgetGetDefaultDirection() TextDirection {

	cret := xWidgetGetDefaultDirection()
	return cret
}

var xWidgetSetDefaultDirection func(TextDirection)

// Sets the default reading direction for widgets.
//
// See [method@Gtk.Widget.set_direction].
func WidgetSetDefaultDirection(DirVar TextDirection) {

	xWidgetSetDefaultDirection(DirVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xRequisitionGLibType, libs, "gtk_requisition_get_type")

	core.PuregoSafeRegister(&xNewRequisition, libs, "gtk_requisition_new")

	core.PuregoSafeRegister(&xRequisitionCopy, libs, "gtk_requisition_copy")
	core.PuregoSafeRegister(&xRequisitionFree, libs, "gtk_requisition_free")

	core.PuregoSafeRegister(&xWidgetClassAddBinding, libs, "gtk_widget_class_add_binding")
	core.PuregoSafeRegister(&xWidgetClassAddBindingAction, libs, "gtk_widget_class_add_binding_action")
	core.PuregoSafeRegister(&xWidgetClassAddBindingSignal, libs, "gtk_widget_class_add_binding_signal")
	core.PuregoSafeRegister(&xWidgetClassAddShortcut, libs, "gtk_widget_class_add_shortcut")
	core.PuregoSafeRegister(&xWidgetClassBindTemplateCallbackFull, libs, "gtk_widget_class_bind_template_callback_full")
	core.PuregoSafeRegister(&xWidgetClassBindTemplateChildFull, libs, "gtk_widget_class_bind_template_child_full")
	core.PuregoSafeRegister(&xWidgetClassGetAccessibleRole, libs, "gtk_widget_class_get_accessible_role")
	core.PuregoSafeRegister(&xWidgetClassGetActivateSignal, libs, "gtk_widget_class_get_activate_signal")
	core.PuregoSafeRegister(&xWidgetClassGetCssName, libs, "gtk_widget_class_get_css_name")
	core.PuregoSafeRegister(&xWidgetClassGetLayoutManagerType, libs, "gtk_widget_class_get_layout_manager_type")
	core.PuregoSafeRegister(&xWidgetClassInstallAction, libs, "gtk_widget_class_install_action")
	core.PuregoSafeRegister(&xWidgetClassInstallPropertyAction, libs, "gtk_widget_class_install_property_action")
	core.PuregoSafeRegister(&xWidgetClassQueryAction, libs, "gtk_widget_class_query_action")
	core.PuregoSafeRegister(&xWidgetClassSetAccessibleRole, libs, "gtk_widget_class_set_accessible_role")
	core.PuregoSafeRegister(&xWidgetClassSetActivateSignal, libs, "gtk_widget_class_set_activate_signal")
	core.PuregoSafeRegister(&xWidgetClassSetActivateSignalFromName, libs, "gtk_widget_class_set_activate_signal_from_name")
	core.PuregoSafeRegister(&xWidgetClassSetCssName, libs, "gtk_widget_class_set_css_name")
	core.PuregoSafeRegister(&xWidgetClassSetLayoutManagerType, libs, "gtk_widget_class_set_layout_manager_type")
	core.PuregoSafeRegister(&xWidgetClassSetTemplate, libs, "gtk_widget_class_set_template")
	core.PuregoSafeRegister(&xWidgetClassSetTemplateFromResource, libs, "gtk_widget_class_set_template_from_resource")
	core.PuregoSafeRegister(&xWidgetClassSetTemplateScope, libs, "gtk_widget_class_set_template_scope")

	core.PuregoSafeRegister(&xWidgetGLibType, libs, "gtk_widget_get_type")

	core.PuregoSafeRegister(&xWidgetActionSetEnabled, libs, "gtk_widget_action_set_enabled")
	core.PuregoSafeRegister(&xWidgetActivate, libs, "gtk_widget_activate")
	core.PuregoSafeRegister(&xWidgetActivateAction, libs, "gtk_widget_activate_action")
	core.PuregoSafeRegister(&xWidgetActivateActionVariant, libs, "gtk_widget_activate_action_variant")
	core.PuregoSafeRegister(&xWidgetActivateDefault, libs, "gtk_widget_activate_default")
	core.PuregoSafeRegister(&xWidgetAddController, libs, "gtk_widget_add_controller")
	core.PuregoSafeRegister(&xWidgetAddCssClass, libs, "gtk_widget_add_css_class")
	core.PuregoSafeRegister(&xWidgetAddMnemonicLabel, libs, "gtk_widget_add_mnemonic_label")
	core.PuregoSafeRegister(&xWidgetAddTickCallback, libs, "gtk_widget_add_tick_callback")
	core.PuregoSafeRegister(&xWidgetAllocate, libs, "gtk_widget_allocate")
	core.PuregoSafeRegister(&xWidgetChildFocus, libs, "gtk_widget_child_focus")
	core.PuregoSafeRegister(&xWidgetComputeBounds, libs, "gtk_widget_compute_bounds")
	core.PuregoSafeRegister(&xWidgetComputeExpand, libs, "gtk_widget_compute_expand")
	core.PuregoSafeRegister(&xWidgetComputePoint, libs, "gtk_widget_compute_point")
	core.PuregoSafeRegister(&xWidgetComputeTransform, libs, "gtk_widget_compute_transform")
	core.PuregoSafeRegister(&xWidgetContains, libs, "gtk_widget_contains")
	core.PuregoSafeRegister(&xWidgetCreatePangoContext, libs, "gtk_widget_create_pango_context")
	core.PuregoSafeRegister(&xWidgetCreatePangoLayout, libs, "gtk_widget_create_pango_layout")
	core.PuregoSafeRegister(&xWidgetDisposeTemplate, libs, "gtk_widget_dispose_template")
	core.PuregoSafeRegister(&xWidgetDragCheckThreshold, libs, "gtk_drag_check_threshold")
	core.PuregoSafeRegister(&xWidgetErrorBell, libs, "gtk_widget_error_bell")
	core.PuregoSafeRegister(&xWidgetGetAllocatedBaseline, libs, "gtk_widget_get_allocated_baseline")
	core.PuregoSafeRegister(&xWidgetGetAllocatedHeight, libs, "gtk_widget_get_allocated_height")
	core.PuregoSafeRegister(&xWidgetGetAllocatedWidth, libs, "gtk_widget_get_allocated_width")
	core.PuregoSafeRegister(&xWidgetGetAllocation, libs, "gtk_widget_get_allocation")
	core.PuregoSafeRegister(&xWidgetGetAncestor, libs, "gtk_widget_get_ancestor")
	core.PuregoSafeRegister(&xWidgetGetBaseline, libs, "gtk_widget_get_baseline")
	core.PuregoSafeRegister(&xWidgetGetCanFocus, libs, "gtk_widget_get_can_focus")
	core.PuregoSafeRegister(&xWidgetGetCanTarget, libs, "gtk_widget_get_can_target")
	core.PuregoSafeRegister(&xWidgetGetChildVisible, libs, "gtk_widget_get_child_visible")
	core.PuregoSafeRegister(&xWidgetGetClipboard, libs, "gtk_widget_get_clipboard")
	core.PuregoSafeRegister(&xWidgetGetColor, libs, "gtk_widget_get_color")
	core.PuregoSafeRegister(&xWidgetGetCssClasses, libs, "gtk_widget_get_css_classes")
	core.PuregoSafeRegister(&xWidgetGetCssName, libs, "gtk_widget_get_css_name")
	core.PuregoSafeRegister(&xWidgetGetCursor, libs, "gtk_widget_get_cursor")
	core.PuregoSafeRegister(&xWidgetGetDirection, libs, "gtk_widget_get_direction")
	core.PuregoSafeRegister(&xWidgetGetDisplay, libs, "gtk_widget_get_display")
	core.PuregoSafeRegister(&xWidgetGetFirstChild, libs, "gtk_widget_get_first_child")
	core.PuregoSafeRegister(&xWidgetGetFocusChild, libs, "gtk_widget_get_focus_child")
	core.PuregoSafeRegister(&xWidgetGetFocusOnClick, libs, "gtk_widget_get_focus_on_click")
	core.PuregoSafeRegister(&xWidgetGetFocusable, libs, "gtk_widget_get_focusable")
	core.PuregoSafeRegister(&xWidgetGetFontMap, libs, "gtk_widget_get_font_map")
	core.PuregoSafeRegister(&xWidgetGetFontOptions, libs, "gtk_widget_get_font_options")
	core.PuregoSafeRegister(&xWidgetGetFrameClock, libs, "gtk_widget_get_frame_clock")
	core.PuregoSafeRegister(&xWidgetGetHalign, libs, "gtk_widget_get_halign")
	core.PuregoSafeRegister(&xWidgetGetHasTooltip, libs, "gtk_widget_get_has_tooltip")
	core.PuregoSafeRegister(&xWidgetGetHeight, libs, "gtk_widget_get_height")
	core.PuregoSafeRegister(&xWidgetGetHexpand, libs, "gtk_widget_get_hexpand")
	core.PuregoSafeRegister(&xWidgetGetHexpandSet, libs, "gtk_widget_get_hexpand_set")
	core.PuregoSafeRegister(&xWidgetGetLastChild, libs, "gtk_widget_get_last_child")
	core.PuregoSafeRegister(&xWidgetGetLayoutManager, libs, "gtk_widget_get_layout_manager")
	core.PuregoSafeRegister(&xWidgetGetLimitEvents, libs, "gtk_widget_get_limit_events")
	core.PuregoSafeRegister(&xWidgetGetMapped, libs, "gtk_widget_get_mapped")
	core.PuregoSafeRegister(&xWidgetGetMarginBottom, libs, "gtk_widget_get_margin_bottom")
	core.PuregoSafeRegister(&xWidgetGetMarginEnd, libs, "gtk_widget_get_margin_end")
	core.PuregoSafeRegister(&xWidgetGetMarginStart, libs, "gtk_widget_get_margin_start")
	core.PuregoSafeRegister(&xWidgetGetMarginTop, libs, "gtk_widget_get_margin_top")
	core.PuregoSafeRegister(&xWidgetGetName, libs, "gtk_widget_get_name")
	core.PuregoSafeRegister(&xWidgetGetNative, libs, "gtk_widget_get_native")
	core.PuregoSafeRegister(&xWidgetGetNextSibling, libs, "gtk_widget_get_next_sibling")
	core.PuregoSafeRegister(&xWidgetGetOpacity, libs, "gtk_widget_get_opacity")
	core.PuregoSafeRegister(&xWidgetGetOverflow, libs, "gtk_widget_get_overflow")
	core.PuregoSafeRegister(&xWidgetGetPangoContext, libs, "gtk_widget_get_pango_context")
	core.PuregoSafeRegister(&xWidgetGetParent, libs, "gtk_widget_get_parent")
	core.PuregoSafeRegister(&xWidgetGetPreferredSize, libs, "gtk_widget_get_preferred_size")
	core.PuregoSafeRegister(&xWidgetGetPrevSibling, libs, "gtk_widget_get_prev_sibling")
	core.PuregoSafeRegister(&xWidgetGetPrimaryClipboard, libs, "gtk_widget_get_primary_clipboard")
	core.PuregoSafeRegister(&xWidgetGetRealized, libs, "gtk_widget_get_realized")
	core.PuregoSafeRegister(&xWidgetGetReceivesDefault, libs, "gtk_widget_get_receives_default")
	core.PuregoSafeRegister(&xWidgetGetRequestMode, libs, "gtk_widget_get_request_mode")
	core.PuregoSafeRegister(&xWidgetGetRoot, libs, "gtk_widget_get_root")
	core.PuregoSafeRegister(&xWidgetGetScaleFactor, libs, "gtk_widget_get_scale_factor")
	core.PuregoSafeRegister(&xWidgetGetSensitive, libs, "gtk_widget_get_sensitive")
	core.PuregoSafeRegister(&xWidgetGetSettings, libs, "gtk_widget_get_settings")
	core.PuregoSafeRegister(&xWidgetGetSize, libs, "gtk_widget_get_size")
	core.PuregoSafeRegister(&xWidgetGetSizeRequest, libs, "gtk_widget_get_size_request")
	core.PuregoSafeRegister(&xWidgetGetStateFlags, libs, "gtk_widget_get_state_flags")
	core.PuregoSafeRegister(&xWidgetGetStyleContext, libs, "gtk_widget_get_style_context")
	core.PuregoSafeRegister(&xWidgetGetTemplateChild, libs, "gtk_widget_get_template_child")
	core.PuregoSafeRegister(&xWidgetGetTooltipMarkup, libs, "gtk_widget_get_tooltip_markup")
	core.PuregoSafeRegister(&xWidgetGetTooltipText, libs, "gtk_widget_get_tooltip_text")
	core.PuregoSafeRegister(&xWidgetGetValign, libs, "gtk_widget_get_valign")
	core.PuregoSafeRegister(&xWidgetGetVexpand, libs, "gtk_widget_get_vexpand")
	core.PuregoSafeRegister(&xWidgetGetVexpandSet, libs, "gtk_widget_get_vexpand_set")
	core.PuregoSafeRegister(&xWidgetGetVisible, libs, "gtk_widget_get_visible")
	core.PuregoSafeRegister(&xWidgetGetWidth, libs, "gtk_widget_get_width")
	core.PuregoSafeRegister(&xWidgetGrabFocus, libs, "gtk_widget_grab_focus")
	core.PuregoSafeRegister(&xWidgetHasCssClass, libs, "gtk_widget_has_css_class")
	core.PuregoSafeRegister(&xWidgetHasDefault, libs, "gtk_widget_has_default")
	core.PuregoSafeRegister(&xWidgetHasFocus, libs, "gtk_widget_has_focus")
	core.PuregoSafeRegister(&xWidgetHasVisibleFocus, libs, "gtk_widget_has_visible_focus")
	core.PuregoSafeRegister(&xWidgetHide, libs, "gtk_widget_hide")
	core.PuregoSafeRegister(&xWidgetInDestruction, libs, "gtk_widget_in_destruction")
	core.PuregoSafeRegister(&xWidgetInitTemplate, libs, "gtk_widget_init_template")
	core.PuregoSafeRegister(&xWidgetInsertActionGroup, libs, "gtk_widget_insert_action_group")
	core.PuregoSafeRegister(&xWidgetInsertAfter, libs, "gtk_widget_insert_after")
	core.PuregoSafeRegister(&xWidgetInsertBefore, libs, "gtk_widget_insert_before")
	core.PuregoSafeRegister(&xWidgetIsAncestor, libs, "gtk_widget_is_ancestor")
	core.PuregoSafeRegister(&xWidgetIsDrawable, libs, "gtk_widget_is_drawable")
	core.PuregoSafeRegister(&xWidgetIsFocus, libs, "gtk_widget_is_focus")
	core.PuregoSafeRegister(&xWidgetIsSensitive, libs, "gtk_widget_is_sensitive")
	core.PuregoSafeRegister(&xWidgetIsVisible, libs, "gtk_widget_is_visible")
	core.PuregoSafeRegister(&xWidgetKeynavFailed, libs, "gtk_widget_keynav_failed")
	core.PuregoSafeRegister(&xWidgetListMnemonicLabels, libs, "gtk_widget_list_mnemonic_labels")
	core.PuregoSafeRegister(&xWidgetMap, libs, "gtk_widget_map")
	core.PuregoSafeRegister(&xWidgetMeasure, libs, "gtk_widget_measure")
	core.PuregoSafeRegister(&xWidgetMnemonicActivate, libs, "gtk_widget_mnemonic_activate")
	core.PuregoSafeRegister(&xWidgetObserveChildren, libs, "gtk_widget_observe_children")
	core.PuregoSafeRegister(&xWidgetObserveControllers, libs, "gtk_widget_observe_controllers")
	core.PuregoSafeRegister(&xWidgetPick, libs, "gtk_widget_pick")
	core.PuregoSafeRegister(&xWidgetQueueAllocate, libs, "gtk_widget_queue_allocate")
	core.PuregoSafeRegister(&xWidgetQueueDraw, libs, "gtk_widget_queue_draw")
	core.PuregoSafeRegister(&xWidgetQueueResize, libs, "gtk_widget_queue_resize")
	core.PuregoSafeRegister(&xWidgetRealize, libs, "gtk_widget_realize")
	core.PuregoSafeRegister(&xWidgetRemoveController, libs, "gtk_widget_remove_controller")
	core.PuregoSafeRegister(&xWidgetRemoveCssClass, libs, "gtk_widget_remove_css_class")
	core.PuregoSafeRegister(&xWidgetRemoveMnemonicLabel, libs, "gtk_widget_remove_mnemonic_label")
	core.PuregoSafeRegister(&xWidgetRemoveTickCallback, libs, "gtk_widget_remove_tick_callback")
	core.PuregoSafeRegister(&xWidgetSetCanFocus, libs, "gtk_widget_set_can_focus")
	core.PuregoSafeRegister(&xWidgetSetCanTarget, libs, "gtk_widget_set_can_target")
	core.PuregoSafeRegister(&xWidgetSetChildVisible, libs, "gtk_widget_set_child_visible")
	core.PuregoSafeRegister(&xWidgetSetCssClasses, libs, "gtk_widget_set_css_classes")
	core.PuregoSafeRegister(&xWidgetSetCursor, libs, "gtk_widget_set_cursor")
	core.PuregoSafeRegister(&xWidgetSetCursorFromName, libs, "gtk_widget_set_cursor_from_name")
	core.PuregoSafeRegister(&xWidgetSetDirection, libs, "gtk_widget_set_direction")
	core.PuregoSafeRegister(&xWidgetSetFocusChild, libs, "gtk_widget_set_focus_child")
	core.PuregoSafeRegister(&xWidgetSetFocusOnClick, libs, "gtk_widget_set_focus_on_click")
	core.PuregoSafeRegister(&xWidgetSetFocusable, libs, "gtk_widget_set_focusable")
	core.PuregoSafeRegister(&xWidgetSetFontMap, libs, "gtk_widget_set_font_map")
	core.PuregoSafeRegister(&xWidgetSetFontOptions, libs, "gtk_widget_set_font_options")
	core.PuregoSafeRegister(&xWidgetSetHalign, libs, "gtk_widget_set_halign")
	core.PuregoSafeRegister(&xWidgetSetHasTooltip, libs, "gtk_widget_set_has_tooltip")
	core.PuregoSafeRegister(&xWidgetSetHexpand, libs, "gtk_widget_set_hexpand")
	core.PuregoSafeRegister(&xWidgetSetHexpandSet, libs, "gtk_widget_set_hexpand_set")
	core.PuregoSafeRegister(&xWidgetSetLayoutManager, libs, "gtk_widget_set_layout_manager")
	core.PuregoSafeRegister(&xWidgetSetLimitEvents, libs, "gtk_widget_set_limit_events")
	core.PuregoSafeRegister(&xWidgetSetMarginBottom, libs, "gtk_widget_set_margin_bottom")
	core.PuregoSafeRegister(&xWidgetSetMarginEnd, libs, "gtk_widget_set_margin_end")
	core.PuregoSafeRegister(&xWidgetSetMarginStart, libs, "gtk_widget_set_margin_start")
	core.PuregoSafeRegister(&xWidgetSetMarginTop, libs, "gtk_widget_set_margin_top")
	core.PuregoSafeRegister(&xWidgetSetName, libs, "gtk_widget_set_name")
	core.PuregoSafeRegister(&xWidgetSetOpacity, libs, "gtk_widget_set_opacity")
	core.PuregoSafeRegister(&xWidgetSetOverflow, libs, "gtk_widget_set_overflow")
	core.PuregoSafeRegister(&xWidgetSetParent, libs, "gtk_widget_set_parent")
	core.PuregoSafeRegister(&xWidgetSetReceivesDefault, libs, "gtk_widget_set_receives_default")
	core.PuregoSafeRegister(&xWidgetSetSensitive, libs, "gtk_widget_set_sensitive")
	core.PuregoSafeRegister(&xWidgetSetSizeRequest, libs, "gtk_widget_set_size_request")
	core.PuregoSafeRegister(&xWidgetSetStateFlags, libs, "gtk_widget_set_state_flags")
	core.PuregoSafeRegister(&xWidgetSetTooltipMarkup, libs, "gtk_widget_set_tooltip_markup")
	core.PuregoSafeRegister(&xWidgetSetTooltipText, libs, "gtk_widget_set_tooltip_text")
	core.PuregoSafeRegister(&xWidgetSetValign, libs, "gtk_widget_set_valign")
	core.PuregoSafeRegister(&xWidgetSetVexpand, libs, "gtk_widget_set_vexpand")
	core.PuregoSafeRegister(&xWidgetSetVexpandSet, libs, "gtk_widget_set_vexpand_set")
	core.PuregoSafeRegister(&xWidgetSetVisible, libs, "gtk_widget_set_visible")
	core.PuregoSafeRegister(&xWidgetShouldLayout, libs, "gtk_widget_should_layout")
	core.PuregoSafeRegister(&xWidgetShow, libs, "gtk_widget_show")
	core.PuregoSafeRegister(&xWidgetSizeAllocate, libs, "gtk_widget_size_allocate")
	core.PuregoSafeRegister(&xWidgetSnapshotChild, libs, "gtk_widget_snapshot_child")
	core.PuregoSafeRegister(&xWidgetTranslateCoordinates, libs, "gtk_widget_translate_coordinates")
	core.PuregoSafeRegister(&xWidgetTriggerTooltipQuery, libs, "gtk_widget_trigger_tooltip_query")
	core.PuregoSafeRegister(&xWidgetUnmap, libs, "gtk_widget_unmap")
	core.PuregoSafeRegister(&xWidgetUnparent, libs, "gtk_widget_unparent")
	core.PuregoSafeRegister(&xWidgetUnrealize, libs, "gtk_widget_unrealize")
	core.PuregoSafeRegister(&xWidgetUnsetStateFlags, libs, "gtk_widget_unset_state_flags")

	core.PuregoSafeRegister(&xWidgetGetDefaultDirection, libs, "gtk_widget_get_default_direction")
	core.PuregoSafeRegister(&xWidgetSetDefaultDirection, libs, "gtk_widget_set_default_direction")

}
