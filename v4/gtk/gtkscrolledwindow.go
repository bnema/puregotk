// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Specifies which corner a child widget should be placed in when packed into
// a `GtkScrolledWindow.`
//
// This is effectively the opposite of where the scroll bars are placed.
type CornerType int

var xCornerTypeGLibType func() types.GType

func CornerTypeGLibType() types.GType {
	return xCornerTypeGLibType()
}

const (

	// Place the scrollbars on the right and bottom of the
	//   widget (default behaviour).
	CornerTopLeftValue CornerType = 0
	// Place the scrollbars on the top and right of the
	//   widget.
	CornerBottomLeftValue CornerType = 1
	// Place the scrollbars on the left and bottom of the
	//   widget.
	CornerTopRightValue CornerType = 2
	// Place the scrollbars on the top and left of the
	//   widget.
	CornerBottomRightValue CornerType = 3
)

// Determines how the size should be computed to achieve the one of the
// visibility mode for the scrollbars.
type PolicyType int

var xPolicyTypeGLibType func() types.GType

func PolicyTypeGLibType() types.GType {
	return xPolicyTypeGLibType()
}

const (

	// The scrollbar is always visible. The view size is
	//   independent of the content.
	PolicyAlwaysValue PolicyType = 0
	// The scrollbar will appear and disappear as necessary.
	//   For example, when all of a `GtkTreeView` can not be seen.
	PolicyAutomaticValue PolicyType = 1
	// The scrollbar should never appear. In this mode the
	//   content determines the size.
	PolicyNeverValue PolicyType = 2
	// Don't show a scrollbar, but don't force the
	//   size to follow the content. This can be used e.g. to make multiple
	//   scrolled windows share a scrollbar.
	PolicyExternalValue PolicyType = 3
)

// Makes its child scrollable.
//
// &lt;picture&gt;
//
//	&lt;source srcset="scrolledwindow-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkScrolledWindow" src="scrolledwindow.png"&gt;
//
// &lt;/picture&gt;
//
// It does so using either internally added scrollbars or externally
// associated adjustments, and optionally draws a frame around the child.
//
// Widgets with native scrolling support, i.e. those whose classes implement
// the [iface@Gtk.Scrollable] interface, are added directly. For other types
// of widget, the class [class@Gtk.Viewport] acts as an adaptor, giving
// scrollability to other widgets. [method@Gtk.ScrolledWindow.set_child]
// intelligently accounts for whether or not the added child is a `GtkScrollable`.
// If it isn’t, then it wraps the child in a `GtkViewport`. Therefore, you can
// just add any child widget and not worry about the details.
//
// If [method@Gtk.ScrolledWindow.set_child] has added a `GtkViewport` for you,
// it will be automatically removed when you unset the child.
// Unless [property@Gtk.ScrolledWindow:hscrollbar-policy] and
// [property@Gtk.ScrolledWindow:vscrollbar-policy] are %GTK_POLICY_NEVER or
// %GTK_POLICY_EXTERNAL, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
// around its child. The scroll position of the child, and if applicable the
// scrollbars, is controlled by the [property@Gtk.ScrolledWindow:hadjustment]
// and [property@Gtk.ScrolledWindow:vadjustment] that are associated with the
// `GtkScrolledWindow`. See the docs on [class@Gtk.Scrollbar] for the details,
// but note that the “step_increment” and “page_increment” fields are only
// effective if the policy causes scrollbars to be present.
//
// If a `GtkScrolledWindow` doesn’t behave quite as you would like, or
// doesn’t have exactly the right layout, it’s very possible to set up
// your own scrolling with `GtkScrollbar` and for example a `GtkGrid`.
//
// # Touch support
//
// `GtkScrolledWindow` has built-in support for touch devices. When a
// touchscreen is used, swiping will move the scrolled window, and will
// expose 'kinetic' behavior. This can be turned off with the
// [property@Gtk.ScrolledWindow:kinetic-scrolling] property if it is undesired.
//
// `GtkScrolledWindow` also displays visual 'overshoot' indication when
// the content is pulled beyond the end, and this situation can be
// captured with the [signal@Gtk.ScrolledWindow::edge-overshot] signal.
//
// If no mouse device is present, the scrollbars will overlaid as
// narrow, auto-hiding indicators over the content. If traditional
// scrollbars are desired although no mouse is present, this behaviour
// can be turned off with the [property@Gtk.ScrolledWindow:overlay-scrolling]
// property.
//
// # Shortcuts and Gestures
//
// The following signals have default keybindings:
//
// - [signal@Gtk.ScrolledWindow::scroll-child]
//
// # CSS nodes
//
// `GtkScrolledWindow` has a main CSS node with name scrolledwindow.
// It gets a .frame style class added when [property@Gtk.ScrolledWindow:has-frame]
// is %TRUE.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow
// and underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// `GtkScrolledWindow` also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn
// with a subnode named junction.
//
// # Accessibility
//
// Until GTK 4.10, `GtkScrolledWindow` used the [enum@Gtk.AccessibleRole.group] role.
//
// Starting from GTK 4.12, `GtkScrolledWindow` uses the [enum@Gtk.AccessibleRole.generic]
// role.
type ScrolledWindow struct {
	Widget
}

var xScrolledWindowGLibType func() types.GType

func ScrolledWindowGLibType() types.GType {
	return xScrolledWindowGLibType()
}

func ScrolledWindowNewFromInternalPtr(ptr uintptr) *ScrolledWindow {
	cls := &ScrolledWindow{}
	cls.Ptr = ptr
	return cls
}

var xNewScrolledWindow func() uintptr

// Creates a new scrolled window.
func NewScrolledWindow() *ScrolledWindow {
	var cls *ScrolledWindow

	cret := xNewScrolledWindow()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ScrolledWindow{}
	cls.Ptr = cret
	return cls
}

var xScrolledWindowGetChild func(uintptr) uintptr

// Gets the child widget of @scrolled_window.
//
// If the scrolled window automatically added a [class@Gtk.Viewport], this
// function will return the viewport widget, and you can retrieve its child
// using [method@Gtk.Viewport.get_child].
func (x *ScrolledWindow) GetChild() *Widget {
	var cls *Widget

	cret := xScrolledWindowGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xScrolledWindowGetHadjustment func(uintptr) uintptr

// Returns the horizontal scrollbar’s adjustment.
//
// This is the adjustment used to connect the horizontal scrollbar
// to the child widget’s horizontal scroll functionality.
func (x *ScrolledWindow) GetHadjustment() *Adjustment {
	var cls *Adjustment

	cret := xScrolledWindowGetHadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

var xScrolledWindowGetHasFrame func(uintptr) bool

// Gets whether the scrolled window draws a frame.
func (x *ScrolledWindow) GetHasFrame() bool {

	cret := xScrolledWindowGetHasFrame(x.GoPointer())
	return cret
}

var xScrolledWindowGetHscrollbar func(uintptr) uintptr

// Returns the horizontal scrollbar of @scrolled_window.
func (x *ScrolledWindow) GetHscrollbar() *Widget {
	var cls *Widget

	cret := xScrolledWindowGetHscrollbar(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xScrolledWindowGetKineticScrolling func(uintptr) bool

// Returns the specified kinetic scrolling behavior.
func (x *ScrolledWindow) GetKineticScrolling() bool {

	cret := xScrolledWindowGetKineticScrolling(x.GoPointer())
	return cret
}

var xScrolledWindowGetMaxContentHeight func(uintptr) int

// Returns the maximum content height set.
func (x *ScrolledWindow) GetMaxContentHeight() int {

	cret := xScrolledWindowGetMaxContentHeight(x.GoPointer())
	return cret
}

var xScrolledWindowGetMaxContentWidth func(uintptr) int

// Returns the maximum content width set.
func (x *ScrolledWindow) GetMaxContentWidth() int {

	cret := xScrolledWindowGetMaxContentWidth(x.GoPointer())
	return cret
}

var xScrolledWindowGetMinContentHeight func(uintptr) int

// Gets the minimal content height of @scrolled_window.
func (x *ScrolledWindow) GetMinContentHeight() int {

	cret := xScrolledWindowGetMinContentHeight(x.GoPointer())
	return cret
}

var xScrolledWindowGetMinContentWidth func(uintptr) int

// Gets the minimum content width of @scrolled_window.
func (x *ScrolledWindow) GetMinContentWidth() int {

	cret := xScrolledWindowGetMinContentWidth(x.GoPointer())
	return cret
}

var xScrolledWindowGetOverlayScrolling func(uintptr) bool

// Returns whether overlay scrolling is enabled for this scrolled window.
func (x *ScrolledWindow) GetOverlayScrolling() bool {

	cret := xScrolledWindowGetOverlayScrolling(x.GoPointer())
	return cret
}

var xScrolledWindowGetPlacement func(uintptr) CornerType

// Gets the placement of the contents with respect to the scrollbars.
func (x *ScrolledWindow) GetPlacement() CornerType {

	cret := xScrolledWindowGetPlacement(x.GoPointer())
	return cret
}

var xScrolledWindowGetPolicy func(uintptr, *PolicyType, *PolicyType)

// Retrieves the current policy values for the horizontal and vertical
// scrollbars.
//
// See [method@Gtk.ScrolledWindow.set_policy].
func (x *ScrolledWindow) GetPolicy(HscrollbarPolicyVar *PolicyType, VscrollbarPolicyVar *PolicyType) {

	xScrolledWindowGetPolicy(x.GoPointer(), HscrollbarPolicyVar, VscrollbarPolicyVar)

}

var xScrolledWindowGetPropagateNaturalHeight func(uintptr) bool

// Reports whether the natural height of the child will be calculated
// and propagated through the scrolled window’s requested natural height.
func (x *ScrolledWindow) GetPropagateNaturalHeight() bool {

	cret := xScrolledWindowGetPropagateNaturalHeight(x.GoPointer())
	return cret
}

var xScrolledWindowGetPropagateNaturalWidth func(uintptr) bool

// Reports whether the natural width of the child will be calculated
// and propagated through the scrolled window’s requested natural width.
func (x *ScrolledWindow) GetPropagateNaturalWidth() bool {

	cret := xScrolledWindowGetPropagateNaturalWidth(x.GoPointer())
	return cret
}

var xScrolledWindowGetVadjustment func(uintptr) uintptr

// Returns the vertical scrollbar’s adjustment.
//
// This is the adjustment used to connect the vertical
// scrollbar to the child widget’s vertical scroll functionality.
func (x *ScrolledWindow) GetVadjustment() *Adjustment {
	var cls *Adjustment

	cret := xScrolledWindowGetVadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

var xScrolledWindowGetVscrollbar func(uintptr) uintptr

// Returns the vertical scrollbar of @scrolled_window.
func (x *ScrolledWindow) GetVscrollbar() *Widget {
	var cls *Widget

	cret := xScrolledWindowGetVscrollbar(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xScrolledWindowSetChild func(uintptr, uintptr)

// Sets the child widget of @scrolled_window.
//
// If @child does not implement the [iface@Gtk.Scrollable] interface,
// the scrolled window will add @child to a [class@Gtk.Viewport] instance
// and then add the viewport as its child widget.
func (x *ScrolledWindow) SetChild(ChildVar *Widget) {

	xScrolledWindowSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xScrolledWindowSetHadjustment func(uintptr, uintptr)

// Sets the `GtkAdjustment` for the horizontal scrollbar.
func (x *ScrolledWindow) SetHadjustment(HadjustmentVar *Adjustment) {

	xScrolledWindowSetHadjustment(x.GoPointer(), HadjustmentVar.GoPointer())

}

var xScrolledWindowSetHasFrame func(uintptr, bool)

// Changes the frame drawn around the contents of @scrolled_window.
func (x *ScrolledWindow) SetHasFrame(HasFrameVar bool) {

	xScrolledWindowSetHasFrame(x.GoPointer(), HasFrameVar)

}

var xScrolledWindowSetKineticScrolling func(uintptr, bool)

// Turns kinetic scrolling on or off.
//
// Kinetic scrolling only applies to devices with source
// %GDK_SOURCE_TOUCHSCREEN.
func (x *ScrolledWindow) SetKineticScrolling(KineticScrollingVar bool) {

	xScrolledWindowSetKineticScrolling(x.GoPointer(), KineticScrollingVar)

}

var xScrolledWindowSetMaxContentHeight func(uintptr, int)

// Sets the maximum height that @scrolled_window should keep visible.
//
// The @scrolled_window will grow up to this height before it starts
// scrolling the content.
//
// It is a programming error to set the maximum content height to a value
// smaller than [property@Gtk.ScrolledWindow:min-content-height].
func (x *ScrolledWindow) SetMaxContentHeight(HeightVar int) {

	xScrolledWindowSetMaxContentHeight(x.GoPointer(), HeightVar)

}

var xScrolledWindowSetMaxContentWidth func(uintptr, int)

// Sets the maximum width that @scrolled_window should keep visible.
//
// The @scrolled_window will grow up to this width before it starts
// scrolling the content.
//
// It is a programming error to set the maximum content width to a
// value smaller than [property@Gtk.ScrolledWindow:min-content-width].
func (x *ScrolledWindow) SetMaxContentWidth(WidthVar int) {

	xScrolledWindowSetMaxContentWidth(x.GoPointer(), WidthVar)

}

var xScrolledWindowSetMinContentHeight func(uintptr, int)

// Sets the minimum height that @scrolled_window should keep visible.
//
// Note that this can and (usually will) be smaller than the minimum
// size of the content.
//
// It is a programming error to set the minimum content height to a
// value greater than [property@Gtk.ScrolledWindow:max-content-height].
func (x *ScrolledWindow) SetMinContentHeight(HeightVar int) {

	xScrolledWindowSetMinContentHeight(x.GoPointer(), HeightVar)

}

var xScrolledWindowSetMinContentWidth func(uintptr, int)

// Sets the minimum width that @scrolled_window should keep visible.
//
// Note that this can and (usually will) be smaller than the minimum
// size of the content.
//
// It is a programming error to set the minimum content width to a
// value greater than [property@Gtk.ScrolledWindow:max-content-width].
func (x *ScrolledWindow) SetMinContentWidth(WidthVar int) {

	xScrolledWindowSetMinContentWidth(x.GoPointer(), WidthVar)

}

var xScrolledWindowSetOverlayScrolling func(uintptr, bool)

// Enables or disables overlay scrolling for this scrolled window.
func (x *ScrolledWindow) SetOverlayScrolling(OverlayScrollingVar bool) {

	xScrolledWindowSetOverlayScrolling(x.GoPointer(), OverlayScrollingVar)

}

var xScrolledWindowSetPlacement func(uintptr, CornerType)

// Sets the placement of the contents with respect to the scrollbars
// for the scrolled window.
//
// The default is %GTK_CORNER_TOP_LEFT, meaning the child is
// in the top left, with the scrollbars underneath and to the right.
// Other values in [enum@Gtk.CornerType] are %GTK_CORNER_TOP_RIGHT,
// %GTK_CORNER_BOTTOM_LEFT, and %GTK_CORNER_BOTTOM_RIGHT.
//
// See also [method@Gtk.ScrolledWindow.get_placement] and
// [method@Gtk.ScrolledWindow.unset_placement].
func (x *ScrolledWindow) SetPlacement(WindowPlacementVar CornerType) {

	xScrolledWindowSetPlacement(x.GoPointer(), WindowPlacementVar)

}

var xScrolledWindowSetPolicy func(uintptr, PolicyType, PolicyType)

// Sets the scrollbar policy for the horizontal and vertical scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value
// from the [enum@Gtk.PolicyType] enumeration. If %GTK_POLICY_ALWAYS, the
// scrollbar is always present; if %GTK_POLICY_NEVER, the scrollbar is
// never present; if %GTK_POLICY_AUTOMATIC, the scrollbar is present only
// if needed (that is, if the slider part of the bar would be smaller
// than the trough — the display is larger than the page size).
func (x *ScrolledWindow) SetPolicy(HscrollbarPolicyVar PolicyType, VscrollbarPolicyVar PolicyType) {

	xScrolledWindowSetPolicy(x.GoPointer(), HscrollbarPolicyVar, VscrollbarPolicyVar)

}

var xScrolledWindowSetPropagateNaturalHeight func(uintptr, bool)

// Sets whether the natural height of the child should be calculated
// and propagated through the scrolled window’s requested natural height.
func (x *ScrolledWindow) SetPropagateNaturalHeight(PropagateVar bool) {

	xScrolledWindowSetPropagateNaturalHeight(x.GoPointer(), PropagateVar)

}

var xScrolledWindowSetPropagateNaturalWidth func(uintptr, bool)

// Sets whether the natural width of the child should be calculated
// and propagated through the scrolled window’s requested natural width.
func (x *ScrolledWindow) SetPropagateNaturalWidth(PropagateVar bool) {

	xScrolledWindowSetPropagateNaturalWidth(x.GoPointer(), PropagateVar)

}

var xScrolledWindowSetVadjustment func(uintptr, uintptr)

// Sets the `GtkAdjustment` for the vertical scrollbar.
func (x *ScrolledWindow) SetVadjustment(VadjustmentVar *Adjustment) {

	xScrolledWindowSetVadjustment(x.GoPointer(), VadjustmentVar.GoPointer())

}

var xScrolledWindowUnsetPlacement func(uintptr)

// Unsets the placement of the contents with respect to the scrollbars.
//
// If no window placement is set for a scrolled window,
// it defaults to %GTK_CORNER_TOP_LEFT.
func (x *ScrolledWindow) UnsetPlacement() {

	xScrolledWindowUnsetPlacement(x.GoPointer())

}

func (c *ScrolledWindow) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *ScrolledWindow) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyHasFrame sets the "has-frame" property.
// Whether to draw a frame around the contents.
func (x *ScrolledWindow) SetPropertyHasFrame(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("has-frame", &v)
}

// GetPropertyHasFrame gets the "has-frame" property.
// Whether to draw a frame around the contents.
func (x *ScrolledWindow) GetPropertyHasFrame() bool {
	var v gobject.Value
	x.GetProperty("has-frame", &v)
	return v.GetBoolean()
}

// SetPropertyKineticScrolling sets the "kinetic-scrolling" property.
// Whether kinetic scrolling is enabled or not.
//
// Kinetic scrolling only applies to devices with source %GDK_SOURCE_TOUCHSCREEN.
func (x *ScrolledWindow) SetPropertyKineticScrolling(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("kinetic-scrolling", &v)
}

// GetPropertyKineticScrolling gets the "kinetic-scrolling" property.
// Whether kinetic scrolling is enabled or not.
//
// Kinetic scrolling only applies to devices with source %GDK_SOURCE_TOUCHSCREEN.
func (x *ScrolledWindow) GetPropertyKineticScrolling() bool {
	var v gobject.Value
	x.GetProperty("kinetic-scrolling", &v)
	return v.GetBoolean()
}

// SetPropertyMaxContentHeight sets the "max-content-height" property.
// The maximum content height of @scrolled_window.
func (x *ScrolledWindow) SetPropertyMaxContentHeight(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("max-content-height", &v)
}

// GetPropertyMaxContentHeight gets the "max-content-height" property.
// The maximum content height of @scrolled_window.
func (x *ScrolledWindow) GetPropertyMaxContentHeight() int {
	var v gobject.Value
	x.GetProperty("max-content-height", &v)
	return v.GetInt()
}

// SetPropertyMaxContentWidth sets the "max-content-width" property.
// The maximum content width of @scrolled_window.
func (x *ScrolledWindow) SetPropertyMaxContentWidth(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("max-content-width", &v)
}

// GetPropertyMaxContentWidth gets the "max-content-width" property.
// The maximum content width of @scrolled_window.
func (x *ScrolledWindow) GetPropertyMaxContentWidth() int {
	var v gobject.Value
	x.GetProperty("max-content-width", &v)
	return v.GetInt()
}

// SetPropertyMinContentHeight sets the "min-content-height" property.
// The minimum content height of @scrolled_window.
func (x *ScrolledWindow) SetPropertyMinContentHeight(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("min-content-height", &v)
}

// GetPropertyMinContentHeight gets the "min-content-height" property.
// The minimum content height of @scrolled_window.
func (x *ScrolledWindow) GetPropertyMinContentHeight() int {
	var v gobject.Value
	x.GetProperty("min-content-height", &v)
	return v.GetInt()
}

// SetPropertyMinContentWidth sets the "min-content-width" property.
// The minimum content width of @scrolled_window.
func (x *ScrolledWindow) SetPropertyMinContentWidth(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("min-content-width", &v)
}

// GetPropertyMinContentWidth gets the "min-content-width" property.
// The minimum content width of @scrolled_window.
func (x *ScrolledWindow) GetPropertyMinContentWidth() int {
	var v gobject.Value
	x.GetProperty("min-content-width", &v)
	return v.GetInt()
}

// SetPropertyOverlayScrolling sets the "overlay-scrolling" property.
// Whether overlay scrolling is enabled or not.
//
// If it is, the scrollbars are only added as traditional widgets
// when a mouse is present. Otherwise, they are overlaid on top of
// the content, as narrow indicators.
//
// Note that overlay scrolling can also be globally disabled, with
// the [property@Gtk.Settings:gtk-overlay-scrolling] setting.
func (x *ScrolledWindow) SetPropertyOverlayScrolling(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("overlay-scrolling", &v)
}

// GetPropertyOverlayScrolling gets the "overlay-scrolling" property.
// Whether overlay scrolling is enabled or not.
//
// If it is, the scrollbars are only added as traditional widgets
// when a mouse is present. Otherwise, they are overlaid on top of
// the content, as narrow indicators.
//
// Note that overlay scrolling can also be globally disabled, with
// the [property@Gtk.Settings:gtk-overlay-scrolling] setting.
func (x *ScrolledWindow) GetPropertyOverlayScrolling() bool {
	var v gobject.Value
	x.GetProperty("overlay-scrolling", &v)
	return v.GetBoolean()
}

// SetPropertyPropagateNaturalHeight sets the "propagate-natural-height" property.
// Whether the natural height of the child should be calculated and propagated
// through the scrolled window’s requested natural height.
//
// This is useful in cases where an attempt should be made to allocate exactly
// enough space for the natural size of the child.
func (x *ScrolledWindow) SetPropertyPropagateNaturalHeight(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("propagate-natural-height", &v)
}

// GetPropertyPropagateNaturalHeight gets the "propagate-natural-height" property.
// Whether the natural height of the child should be calculated and propagated
// through the scrolled window’s requested natural height.
//
// This is useful in cases where an attempt should be made to allocate exactly
// enough space for the natural size of the child.
func (x *ScrolledWindow) GetPropertyPropagateNaturalHeight() bool {
	var v gobject.Value
	x.GetProperty("propagate-natural-height", &v)
	return v.GetBoolean()
}

// SetPropertyPropagateNaturalWidth sets the "propagate-natural-width" property.
// Whether the natural width of the child should be calculated and propagated
// through the scrolled window’s requested natural width.
//
// This is useful in cases where an attempt should be made to allocate exactly
// enough space for the natural size of the child.
func (x *ScrolledWindow) SetPropertyPropagateNaturalWidth(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("propagate-natural-width", &v)
}

// GetPropertyPropagateNaturalWidth gets the "propagate-natural-width" property.
// Whether the natural width of the child should be calculated and propagated
// through the scrolled window’s requested natural width.
//
// This is useful in cases where an attempt should be made to allocate exactly
// enough space for the natural size of the child.
func (x *ScrolledWindow) GetPropertyPropagateNaturalWidth() bool {
	var v gobject.Value
	x.GetProperty("propagate-natural-width", &v)
	return v.GetBoolean()
}

// Emitted whenever user initiated scrolling makes the scrolled
// window firmly surpass the limits defined by the adjustment
// in that orientation.
//
// A similar behavior without edge resistance is provided by the
// [signal@Gtk.ScrolledWindow::edge-reached] signal.
//
// Note: The @pos argument is LTR/RTL aware, so callers should be
// aware too if intending to provide behavior on horizontal edges.
func (x *ScrolledWindow) ConnectEdgeOvershot(cb *func(ScrolledWindow, PositionType)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "edge-overshot", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PosVarp PositionType) {
		fa := ScrolledWindow{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PosVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "edge-overshot", cbRefPtr)
}

// Emitted whenever user-initiated scrolling makes the scrolled
// window exactly reach the lower or upper limits defined by the
// adjustment in that orientation.
//
// A similar behavior with edge resistance is provided by the
// [signal@Gtk.ScrolledWindow::edge-overshot] signal.
//
// Note: The @pos argument is LTR/RTL aware, so callers should be
// aware too if intending to provide behavior on horizontal edges.
func (x *ScrolledWindow) ConnectEdgeReached(cb *func(ScrolledWindow, PositionType)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "edge-reached", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PosVarp PositionType) {
		fa := ScrolledWindow{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PosVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "edge-reached", cbRefPtr)
}

// Emitted when focus is moved away from the scrolled window by a
// keybinding.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Tab&lt;/kbd&gt; to move forward and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Tab&lt;/kbd&gt;` to move backward.
func (x *ScrolledWindow) ConnectMoveFocusOut(cb *func(ScrolledWindow, DirectionType)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-focus-out", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, DirectionTypeVarp DirectionType) {
		fa := ScrolledWindow{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DirectionTypeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "move-focus-out", cbRefPtr)
}

// Emitted when a keybinding that scrolls is pressed.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The horizontal or vertical adjustment is updated which triggers a
// signal that the scrolled window’s child may listen to and scroll itself.
func (x *ScrolledWindow) ConnectScrollChild(cb *func(ScrolledWindow, ScrollType, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "scroll-child", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ScrollVarp ScrollType, HorizontalVarp bool) bool {
		fa := ScrolledWindow{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ScrollVarp, HorizontalVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "scroll-child", cbRefPtr)
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *ScrolledWindow) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *ScrolledWindow) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *ScrolledWindow) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *ScrolledWindow) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *ScrolledWindow) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *ScrolledWindow) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *ScrolledWindow) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *ScrolledWindow) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *ScrolledWindow) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *ScrolledWindow) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *ScrolledWindow) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *ScrolledWindow) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *ScrolledWindow) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *ScrolledWindow) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *ScrolledWindow) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ScrolledWindow) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *ScrolledWindow) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ScrolledWindow) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *ScrolledWindow) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ScrolledWindow) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *ScrolledWindow) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCornerTypeGLibType, libs, "gtk_corner_type_get_type")

	core.PuregoSafeRegister(&xPolicyTypeGLibType, libs, "gtk_policy_type_get_type")

	core.PuregoSafeRegister(&xScrolledWindowGLibType, libs, "gtk_scrolled_window_get_type")

	core.PuregoSafeRegister(&xNewScrolledWindow, libs, "gtk_scrolled_window_new")

	core.PuregoSafeRegister(&xScrolledWindowGetChild, libs, "gtk_scrolled_window_get_child")
	core.PuregoSafeRegister(&xScrolledWindowGetHadjustment, libs, "gtk_scrolled_window_get_hadjustment")
	core.PuregoSafeRegister(&xScrolledWindowGetHasFrame, libs, "gtk_scrolled_window_get_has_frame")
	core.PuregoSafeRegister(&xScrolledWindowGetHscrollbar, libs, "gtk_scrolled_window_get_hscrollbar")
	core.PuregoSafeRegister(&xScrolledWindowGetKineticScrolling, libs, "gtk_scrolled_window_get_kinetic_scrolling")
	core.PuregoSafeRegister(&xScrolledWindowGetMaxContentHeight, libs, "gtk_scrolled_window_get_max_content_height")
	core.PuregoSafeRegister(&xScrolledWindowGetMaxContentWidth, libs, "gtk_scrolled_window_get_max_content_width")
	core.PuregoSafeRegister(&xScrolledWindowGetMinContentHeight, libs, "gtk_scrolled_window_get_min_content_height")
	core.PuregoSafeRegister(&xScrolledWindowGetMinContentWidth, libs, "gtk_scrolled_window_get_min_content_width")
	core.PuregoSafeRegister(&xScrolledWindowGetOverlayScrolling, libs, "gtk_scrolled_window_get_overlay_scrolling")
	core.PuregoSafeRegister(&xScrolledWindowGetPlacement, libs, "gtk_scrolled_window_get_placement")
	core.PuregoSafeRegister(&xScrolledWindowGetPolicy, libs, "gtk_scrolled_window_get_policy")
	core.PuregoSafeRegister(&xScrolledWindowGetPropagateNaturalHeight, libs, "gtk_scrolled_window_get_propagate_natural_height")
	core.PuregoSafeRegister(&xScrolledWindowGetPropagateNaturalWidth, libs, "gtk_scrolled_window_get_propagate_natural_width")
	core.PuregoSafeRegister(&xScrolledWindowGetVadjustment, libs, "gtk_scrolled_window_get_vadjustment")
	core.PuregoSafeRegister(&xScrolledWindowGetVscrollbar, libs, "gtk_scrolled_window_get_vscrollbar")
	core.PuregoSafeRegister(&xScrolledWindowSetChild, libs, "gtk_scrolled_window_set_child")
	core.PuregoSafeRegister(&xScrolledWindowSetHadjustment, libs, "gtk_scrolled_window_set_hadjustment")
	core.PuregoSafeRegister(&xScrolledWindowSetHasFrame, libs, "gtk_scrolled_window_set_has_frame")
	core.PuregoSafeRegister(&xScrolledWindowSetKineticScrolling, libs, "gtk_scrolled_window_set_kinetic_scrolling")
	core.PuregoSafeRegister(&xScrolledWindowSetMaxContentHeight, libs, "gtk_scrolled_window_set_max_content_height")
	core.PuregoSafeRegister(&xScrolledWindowSetMaxContentWidth, libs, "gtk_scrolled_window_set_max_content_width")
	core.PuregoSafeRegister(&xScrolledWindowSetMinContentHeight, libs, "gtk_scrolled_window_set_min_content_height")
	core.PuregoSafeRegister(&xScrolledWindowSetMinContentWidth, libs, "gtk_scrolled_window_set_min_content_width")
	core.PuregoSafeRegister(&xScrolledWindowSetOverlayScrolling, libs, "gtk_scrolled_window_set_overlay_scrolling")
	core.PuregoSafeRegister(&xScrolledWindowSetPlacement, libs, "gtk_scrolled_window_set_placement")
	core.PuregoSafeRegister(&xScrolledWindowSetPolicy, libs, "gtk_scrolled_window_set_policy")
	core.PuregoSafeRegister(&xScrolledWindowSetPropagateNaturalHeight, libs, "gtk_scrolled_window_set_propagate_natural_height")
	core.PuregoSafeRegister(&xScrolledWindowSetPropagateNaturalWidth, libs, "gtk_scrolled_window_set_propagate_natural_width")
	core.PuregoSafeRegister(&xScrolledWindowSetVadjustment, libs, "gtk_scrolled_window_set_vadjustment")
	core.PuregoSafeRegister(&xScrolledWindowUnsetPlacement, libs, "gtk_scrolled_window_unset_placement")

}
