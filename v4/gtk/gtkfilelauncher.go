// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type FileLauncherClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *FileLauncherClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Asynchronous API to open a file with an application.
//
// `GtkFileLauncher` collects the arguments that are needed to open the file.
//
// Depending on system configuration, user preferences and available APIs, this
// may or may not show an app chooser dialog or launch the default application
// right away.
//
// The operation is started with the [method@Gtk.FileLauncher.launch] function.
//
// To launch uris that don't represent files, use [class@Gtk.UriLauncher].
type FileLauncher struct {
	gobject.Object
}

var xFileLauncherGLibType func() types.GType

func FileLauncherGLibType() types.GType {
	return xFileLauncherGLibType()
}

func FileLauncherNewFromInternalPtr(ptr uintptr) *FileLauncher {
	cls := &FileLauncher{}
	cls.Ptr = ptr
	return cls
}

var xNewFileLauncher func(uintptr) uintptr

// Creates a new `GtkFileLauncher` object.
func NewFileLauncher(FileVar gio.File) *FileLauncher {
	var cls *FileLauncher

	cret := xNewFileLauncher(FileVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileLauncher{}
	cls.Ptr = cret
	return cls
}

var xFileLauncherGetAlwaysAsk func(uintptr) bool

// Returns whether to ask the user which app to use.
func (x *FileLauncher) GetAlwaysAsk() bool {

	cret := xFileLauncherGetAlwaysAsk(x.GoPointer())
	return cret
}

var xFileLauncherGetFile func(uintptr) uintptr

// Gets the file that will be opened.
func (x *FileLauncher) GetFile() *gio.FileBase {
	var cls *gio.FileBase

	cret := xFileLauncherGetFile(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileLauncherGetWritable func(uintptr) bool

// Returns whether to make the file writable for the handler.
func (x *FileLauncher) GetWritable() bool {

	cret := xFileLauncherGetWritable(x.GoPointer())
	return cret
}

var xFileLauncherLaunch func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Launches an application to open the file.
//
// This may present an app chooser dialog to the user.
func (x *FileLauncher) Launch(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileLauncherLaunch(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileLauncherLaunchFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes the [method@Gtk.FileLauncher.launch] call and
// returns the result.
func (x *FileLauncher) LaunchFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xFileLauncherLaunchFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileLauncherOpenContainingFolder func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Launches a file manager to show the file in its parent directory.
//
// This is only supported for native files. It will fail if @file
// is e.g. a http:// uri.
func (x *FileLauncher) OpenContainingFolder(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileLauncherOpenContainingFolder(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileLauncherOpenContainingFolderFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes the [method@Gtk.FileLauncher.open_containing_folder]
// call and returns the result.
func (x *FileLauncher) OpenContainingFolderFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xFileLauncherOpenContainingFolderFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileLauncherSetAlwaysAsk func(uintptr, bool)

// Sets whether to always ask the user which app to use.
//
// If false, the file might be opened with a default app
// or the previous choice.
func (x *FileLauncher) SetAlwaysAsk(AlwaysAskVar bool) {

	xFileLauncherSetAlwaysAsk(x.GoPointer(), AlwaysAskVar)

}

var xFileLauncherSetFile func(uintptr, uintptr)

// Sets the file that will be opened.
func (x *FileLauncher) SetFile(FileVar gio.File) {

	xFileLauncherSetFile(x.GoPointer(), FileVar.GoPointer())

}

var xFileLauncherSetWritable func(uintptr, bool)

// Sets whether to make the file writable for the handler.
func (x *FileLauncher) SetWritable(WritableVar bool) {

	xFileLauncherSetWritable(x.GoPointer(), WritableVar)

}

func (c *FileLauncher) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *FileLauncher) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAlwaysAsk sets the "always-ask" property.
// Whether to ask the user to choose an app for opening the file. If `FALSE`,
// the file might be opened with a default app or the previous choice.
func (x *FileLauncher) SetPropertyAlwaysAsk(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("always-ask", &v)
}

// GetPropertyAlwaysAsk gets the "always-ask" property.
// Whether to ask the user to choose an app for opening the file. If `FALSE`,
// the file might be opened with a default app or the previous choice.
func (x *FileLauncher) GetPropertyAlwaysAsk() bool {
	var v gobject.Value
	x.GetProperty("always-ask", &v)
	return v.GetBoolean()
}

// SetPropertyWritable sets the "writable" property.
// Whether to make the file writable for the handler.
func (x *FileLauncher) SetPropertyWritable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("writable", &v)
}

// GetPropertyWritable gets the "writable" property.
// Whether to make the file writable for the handler.
func (x *FileLauncher) GetPropertyWritable() bool {
	var v gobject.Value
	x.GetProperty("writable", &v)
	return v.GetBoolean()
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xFileLauncherGLibType, libs, "gtk_file_launcher_get_type")

	core.PuregoSafeRegister(&xNewFileLauncher, libs, "gtk_file_launcher_new")

	core.PuregoSafeRegister(&xFileLauncherGetAlwaysAsk, libs, "gtk_file_launcher_get_always_ask")
	core.PuregoSafeRegister(&xFileLauncherGetFile, libs, "gtk_file_launcher_get_file")
	core.PuregoSafeRegister(&xFileLauncherGetWritable, libs, "gtk_file_launcher_get_writable")
	core.PuregoSafeRegister(&xFileLauncherLaunch, libs, "gtk_file_launcher_launch")
	core.PuregoSafeRegister(&xFileLauncherLaunchFinish, libs, "gtk_file_launcher_launch_finish")
	core.PuregoSafeRegister(&xFileLauncherOpenContainingFolder, libs, "gtk_file_launcher_open_containing_folder")
	core.PuregoSafeRegister(&xFileLauncherOpenContainingFolderFinish, libs, "gtk_file_launcher_open_containing_folder_finish")
	core.PuregoSafeRegister(&xFileLauncherSetAlwaysAsk, libs, "gtk_file_launcher_set_always_ask")
	core.PuregoSafeRegister(&xFileLauncherSetFile, libs, "gtk_file_launcher_set_file")
	core.PuregoSafeRegister(&xFileLauncherSetWritable, libs, "gtk_file_launcher_set_writable")

}
