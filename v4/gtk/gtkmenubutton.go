// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// User-provided callback function to create a popup for a
// `GtkMenuButton` on demand.
//
// This function is called when the popup of @menu_button is shown,
// but none has been provided via [method@Gtk.MenuButton.set_popover]
// or [method@Gtk.MenuButton.set_menu_model].
type MenuButtonCreatePopupFunc func(uintptr, uintptr)

// Displays a popup when clicked.
//
// &lt;picture&gt;
//
//	&lt;source srcset="menu-button-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkMenuButton" src="menu-button.png"&gt;
//
// &lt;/picture&gt;
//
// This popup can be provided either as a `GtkPopover` or as an abstract
// `GMenuModel`.
//
// The `GtkMenuButton` widget can show either an icon (set with the
// [property@Gtk.MenuButton:icon-name] property) or a label (set with the
// [property@Gtk.MenuButton:label] property). If neither is explicitly set,
// a [class@Gtk.Image] is automatically created, using an arrow image oriented
// according to [property@Gtk.MenuButton:direction] or the generic
// “open-menu-symbolic” icon if the direction is not set.
//
// The positioning of the popup is determined by the
// [property@Gtk.MenuButton:direction] property of the menu button.
//
// For menus, the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties of the menu are also taken into account. For example, when the
// direction is %GTK_ARROW_DOWN and the horizontal alignment is %GTK_ALIGN_START,
// the menu will be positioned below the button, with the starting edge
// (depending on the text direction) of the menu aligned with the starting
// edge of the button. If there is not enough space below the button, the
// menu is popped up above the button instead. If the alignment would move
// part of the menu offscreen, it is “pushed in”.
//
// |           | start                | center                | end                |
// | -         | ---                  | ---                   | ---                |
// | **down**  | ![](down-start.png)  | ![](down-center.png)  | ![](down-end.png)  |
// | **up**    | ![](up-start.png)    | ![](up-center.png)    | ![](up-end.png)    |
// | **left**  | ![](left-start.png)  | ![](left-center.png)  | ![](left-end.png)  |
// | **right** | ![](right-start.png) | ![](right-center.png) | ![](right-end.png) |
//
// # CSS nodes
//
// ```
// menubutton
// ╰── button.toggle
//
//	╰── &lt;content&gt;
//	     ╰── [arrow]
//
// ```
//
// `GtkMenuButton` has a single CSS node with name `menubutton`
// which contains a `button` node with a `.toggle` style class.
//
// If the button contains an icon, it will have the `.image-button` style class,
// if it contains text, it will have `.text-button` style class. If an arrow is
// visible in addition to an icon, text or a custom child, it will also have
// `.arrow-button` style class.
//
// Inside the toggle button content, there is an `arrow` node for
// the indicator, which will carry one of the `.none`, `.up`, `.down`,
// `.left` or `.right` style classes to indicate the direction that
// the menu will appear in. The CSS is expected to provide a suitable
// image for each of these cases using the `-gtk-icon-source` property.
//
// Optionally, the `menubutton` node can carry the `.circular` style class
// to request a round appearance.
//
// # Accessibility
//
// `GtkMenuButton` uses the [enum@Gtk.AccessibleRole.button] role.
type MenuButton struct {
	Widget
}

var xMenuButtonGLibType func() types.GType

func MenuButtonGLibType() types.GType {
	return xMenuButtonGLibType()
}

func MenuButtonNewFromInternalPtr(ptr uintptr) *MenuButton {
	cls := &MenuButton{}
	cls.Ptr = ptr
	return cls
}

var xNewMenuButton func() uintptr

// Creates a new `GtkMenuButton` widget with downwards-pointing
// arrow as the only child.
//
// You can replace the child widget with another `GtkWidget`
// should you wish to.
func NewMenuButton() *MenuButton {
	var cls *MenuButton

	cret := xNewMenuButton()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &MenuButton{}
	cls.Ptr = cret
	return cls
}

var xMenuButtonGetActive func(uintptr) bool

// Returns whether the menu button is active.
func (x *MenuButton) GetActive() bool {

	cret := xMenuButtonGetActive(x.GoPointer())
	return cret
}

var xMenuButtonGetAlwaysShowArrow func(uintptr) bool

// Gets whether to show a dropdown arrow even when using an icon or a custom
// child.
func (x *MenuButton) GetAlwaysShowArrow() bool {

	cret := xMenuButtonGetAlwaysShowArrow(x.GoPointer())
	return cret
}

var xMenuButtonGetCanShrink func(uintptr) bool

// Retrieves whether the button can be smaller than the natural
// size of its contents.
func (x *MenuButton) GetCanShrink() bool {

	cret := xMenuButtonGetCanShrink(x.GoPointer())
	return cret
}

var xMenuButtonGetChild func(uintptr) uintptr

// Gets the child widget of @menu_button.
func (x *MenuButton) GetChild() *Widget {
	var cls *Widget

	cret := xMenuButtonGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xMenuButtonGetDirection func(uintptr) ArrowType

// Returns the direction the popup will be pointing at when popped up.
func (x *MenuButton) GetDirection() ArrowType {

	cret := xMenuButtonGetDirection(x.GoPointer())
	return cret
}

var xMenuButtonGetHasFrame func(uintptr) bool

// Returns whether the button has a frame.
func (x *MenuButton) GetHasFrame() bool {

	cret := xMenuButtonGetHasFrame(x.GoPointer())
	return cret
}

var xMenuButtonGetIconName func(uintptr) string

// Gets the name of the icon shown in the button.
func (x *MenuButton) GetIconName() string {

	cret := xMenuButtonGetIconName(x.GoPointer())
	return cret
}

var xMenuButtonGetLabel func(uintptr) string

// Gets the label shown in the button
func (x *MenuButton) GetLabel() string {

	cret := xMenuButtonGetLabel(x.GoPointer())
	return cret
}

var xMenuButtonGetMenuModel func(uintptr) uintptr

// Returns the `GMenuModel` used to generate the popup.
func (x *MenuButton) GetMenuModel() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xMenuButtonGetMenuModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xMenuButtonGetPopover func(uintptr) uintptr

// Returns the `GtkPopover` that pops out of the button.
//
// If the button is not using a `GtkPopover`, this function
// returns %NULL.
func (x *MenuButton) GetPopover() *Popover {
	var cls *Popover

	cret := xMenuButtonGetPopover(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Popover{}
	cls.Ptr = cret
	return cls
}

var xMenuButtonGetPrimary func(uintptr) bool

// Returns whether the menu button acts as a primary menu.
func (x *MenuButton) GetPrimary() bool {

	cret := xMenuButtonGetPrimary(x.GoPointer())
	return cret
}

var xMenuButtonGetUseUnderline func(uintptr) bool

// Returns whether an embedded underline in the text indicates a
// mnemonic.
func (x *MenuButton) GetUseUnderline() bool {

	cret := xMenuButtonGetUseUnderline(x.GoPointer())
	return cret
}

var xMenuButtonPopdown func(uintptr)

// Dismiss the menu.
func (x *MenuButton) Popdown() {

	xMenuButtonPopdown(x.GoPointer())

}

var xMenuButtonPopup func(uintptr)

// Pop up the menu.
func (x *MenuButton) Popup() {

	xMenuButtonPopup(x.GoPointer())

}

var xMenuButtonSetActive func(uintptr, bool)

// Sets whether the menu button is active.
func (x *MenuButton) SetActive(ActiveVar bool) {

	xMenuButtonSetActive(x.GoPointer(), ActiveVar)

}

var xMenuButtonSetAlwaysShowArrow func(uintptr, bool)

// Sets whether to show a dropdown arrow even when using an icon or a custom
// child.
func (x *MenuButton) SetAlwaysShowArrow(AlwaysShowArrowVar bool) {

	xMenuButtonSetAlwaysShowArrow(x.GoPointer(), AlwaysShowArrowVar)

}

var xMenuButtonSetCanShrink func(uintptr, bool)

// Sets whether the button size can be smaller than the natural size of
// its contents.
//
// For text buttons, setting @can_shrink to true will ellipsize the label.
//
// For icon buttons, this function has no effect.
func (x *MenuButton) SetCanShrink(CanShrinkVar bool) {

	xMenuButtonSetCanShrink(x.GoPointer(), CanShrinkVar)

}

var xMenuButtonSetChild func(uintptr, uintptr)

// Sets the child widget of @menu_button.
//
// Setting a child resets [property@Gtk.MenuButton:label] and
// [property@Gtk.MenuButton:icon-name].
//
// If [property@Gtk.MenuButton:always-show-arrow] is set to `TRUE` and
// [property@Gtk.MenuButton:direction] is not `GTK_ARROW_NONE`, a dropdown arrow
// will be shown next to the child.
func (x *MenuButton) SetChild(ChildVar *Widget) {

	xMenuButtonSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xMenuButtonSetCreatePopupFunc func(uintptr, uintptr, uintptr, uintptr)

// Sets @func to be called when a popup is about to be shown.
//
// @func should use one of
//
//   - [method@Gtk.MenuButton.set_popover]
//   - [method@Gtk.MenuButton.set_menu_model]
//
// to set a popup for @menu_button.
// If @func is non-%NULL, @menu_button will always be sensitive.
//
// Using this function will not reset the menu widget attached to
// @menu_button. Instead, this can be done manually in @func.
func (x *MenuButton) SetCreatePopupFunc(FuncVar *MenuButtonCreatePopupFunc, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := glib.GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) {
				cbFn := *FuncVar
				cbFn(arg0, arg1)
			}
			FuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(FuncVarPtr, FuncVarRef, FuncVar)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyNotifyVarPtr, DestroyNotifyVarRef, DestroyNotifyVar)
		}
	}

	xMenuButtonSetCreatePopupFunc(x.GoPointer(), FuncVarRef, UserDataVar, DestroyNotifyVarRef)

}

var xMenuButtonSetDirection func(uintptr, ArrowType)

// Sets the direction in which the popup will be popped up.
//
// If the button is automatically populated with an arrow icon,
// its direction will be changed to match.
//
// If the does not fit in the available space in the given direction,
// GTK will its best to keep it inside the screen and fully visible.
//
// If you pass %GTK_ARROW_NONE for a @direction, the popup will behave
// as if you passed %GTK_ARROW_DOWN (although you won’t see any arrows).
func (x *MenuButton) SetDirection(DirectionVar ArrowType) {

	xMenuButtonSetDirection(x.GoPointer(), DirectionVar)

}

var xMenuButtonSetHasFrame func(uintptr, bool)

// Sets the style of the button.
func (x *MenuButton) SetHasFrame(HasFrameVar bool) {

	xMenuButtonSetHasFrame(x.GoPointer(), HasFrameVar)

}

var xMenuButtonSetIconName func(uintptr, string)

// Sets the name of an icon to show inside the menu button.
//
// Setting icon name resets [property@Gtk.MenuButton:label] and
// [property@Gtk.MenuButton:child].
//
// If [property@Gtk.MenuButton:always-show-arrow] is set to `TRUE` and
// [property@Gtk.MenuButton:direction] is not `GTK_ARROW_NONE`, a dropdown arrow
// will be shown next to the icon.
func (x *MenuButton) SetIconName(IconNameVar string) {

	xMenuButtonSetIconName(x.GoPointer(), IconNameVar)

}

var xMenuButtonSetLabel func(uintptr, string)

// Sets the label to show inside the menu button.
//
// Setting a label resets [property@Gtk.MenuButton:icon-name] and
// [property@Gtk.MenuButton:child].
//
// If [property@Gtk.MenuButton:direction] is not `GTK_ARROW_NONE`, a dropdown
// arrow will be shown next to the label.
func (x *MenuButton) SetLabel(LabelVar string) {

	xMenuButtonSetLabel(x.GoPointer(), LabelVar)

}

var xMenuButtonSetMenuModel func(uintptr, uintptr)

// Sets the `GMenuModel` from which the popup will be constructed.
//
// If @menu_model is %NULL, the button is disabled.
//
// A [class@Gtk.Popover] will be created from the menu model with
// [ctor@Gtk.PopoverMenu.new_from_model]. Actions will be connected
// as documented for this function.
//
// If [property@Gtk.MenuButton:popover] is already set, it will be
// dissociated from the @menu_button, and the property is set to %NULL.
func (x *MenuButton) SetMenuModel(MenuModelVar *gio.MenuModel) {

	xMenuButtonSetMenuModel(x.GoPointer(), MenuModelVar.GoPointer())

}

var xMenuButtonSetPopover func(uintptr, uintptr)

// Sets the `GtkPopover` that will be popped up when the @menu_button is clicked.
//
// If @popover is %NULL, the button is disabled.
//
// If [property@Gtk.MenuButton:menu-model] is set, the menu model is dissociated
// from the @menu_button, and the property is set to %NULL.
func (x *MenuButton) SetPopover(PopoverVar *Popover) {

	xMenuButtonSetPopover(x.GoPointer(), PopoverVar.GoPointer())

}

var xMenuButtonSetPrimary func(uintptr, bool)

// Sets whether menu button acts as a primary menu.
//
// Primary menus can be opened with the &lt;kbd&gt;F10&lt;/kbd&gt; key.
func (x *MenuButton) SetPrimary(PrimaryVar bool) {

	xMenuButtonSetPrimary(x.GoPointer(), PrimaryVar)

}

var xMenuButtonSetUseUnderline func(uintptr, bool)

// If true, an underline in the text indicates a mnemonic.
func (x *MenuButton) SetUseUnderline(UseUnderlineVar bool) {

	xMenuButtonSetUseUnderline(x.GoPointer(), UseUnderlineVar)

}

func (c *MenuButton) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *MenuButton) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyActive sets the "active" property.
// Whether the menu button is active.
func (x *MenuButton) SetPropertyActive(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("active", &v)
}

// GetPropertyActive gets the "active" property.
// Whether the menu button is active.
func (x *MenuButton) GetPropertyActive() bool {
	var v gobject.Value
	x.GetProperty("active", &v)
	return v.GetBoolean()
}

// SetPropertyAlwaysShowArrow sets the "always-show-arrow" property.
// Whether to show a dropdown arrow even when using an icon or a custom child.
func (x *MenuButton) SetPropertyAlwaysShowArrow(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("always-show-arrow", &v)
}

// GetPropertyAlwaysShowArrow gets the "always-show-arrow" property.
// Whether to show a dropdown arrow even when using an icon or a custom child.
func (x *MenuButton) GetPropertyAlwaysShowArrow() bool {
	var v gobject.Value
	x.GetProperty("always-show-arrow", &v)
	return v.GetBoolean()
}

// SetPropertyCanShrink sets the "can-shrink" property.
// Whether the size of the button can be made smaller than the natural
// size of its contents.
func (x *MenuButton) SetPropertyCanShrink(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("can-shrink", &v)
}

// GetPropertyCanShrink gets the "can-shrink" property.
// Whether the size of the button can be made smaller than the natural
// size of its contents.
func (x *MenuButton) GetPropertyCanShrink() bool {
	var v gobject.Value
	x.GetProperty("can-shrink", &v)
	return v.GetBoolean()
}

// SetPropertyHasFrame sets the "has-frame" property.
// Whether the button has a frame.
func (x *MenuButton) SetPropertyHasFrame(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("has-frame", &v)
}

// GetPropertyHasFrame gets the "has-frame" property.
// Whether the button has a frame.
func (x *MenuButton) GetPropertyHasFrame() bool {
	var v gobject.Value
	x.GetProperty("has-frame", &v)
	return v.GetBoolean()
}

// SetPropertyIconName sets the "icon-name" property.
// The name of the icon used to automatically populate the button.
func (x *MenuButton) SetPropertyIconName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("icon-name", &v)
}

// GetPropertyIconName gets the "icon-name" property.
// The name of the icon used to automatically populate the button.
func (x *MenuButton) GetPropertyIconName() string {
	var v gobject.Value
	x.GetProperty("icon-name", &v)
	return v.GetString()
}

// SetPropertyLabel sets the "label" property.
// The label for the button.
func (x *MenuButton) SetPropertyLabel(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("label", &v)
}

// GetPropertyLabel gets the "label" property.
// The label for the button.
func (x *MenuButton) GetPropertyLabel() string {
	var v gobject.Value
	x.GetProperty("label", &v)
	return v.GetString()
}

// SetPropertyPrimary sets the "primary" property.
// Whether the menu button acts as a primary menu.
//
// Primary menus can be opened using the &lt;kbd&gt;F10&lt;/kbd&gt; key
func (x *MenuButton) SetPropertyPrimary(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("primary", &v)
}

// GetPropertyPrimary gets the "primary" property.
// Whether the menu button acts as a primary menu.
//
// Primary menus can be opened using the &lt;kbd&gt;F10&lt;/kbd&gt; key
func (x *MenuButton) GetPropertyPrimary() bool {
	var v gobject.Value
	x.GetProperty("primary", &v)
	return v.GetBoolean()
}

// SetPropertyUseUnderline sets the "use-underline" property.
// If set an underscore in the text indicates a mnemonic.
func (x *MenuButton) SetPropertyUseUnderline(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("use-underline", &v)
}

// GetPropertyUseUnderline gets the "use-underline" property.
// If set an underscore in the text indicates a mnemonic.
func (x *MenuButton) GetPropertyUseUnderline() bool {
	var v gobject.Value
	x.GetProperty("use-underline", &v)
	return v.GetBoolean()
}

// Emitted to when the menu button is activated.
//
// The `::activate` signal on `GtkMenuButton` is an action signal and
// emitting it causes the button to pop up its menu.
func (x *MenuButton) ConnectActivate(cb *func(MenuButton)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := MenuButton{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *MenuButton) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *MenuButton) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *MenuButton) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *MenuButton) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *MenuButton) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *MenuButton) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *MenuButton) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *MenuButton) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *MenuButton) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *MenuButton) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *MenuButton) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *MenuButton) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *MenuButton) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *MenuButton) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *MenuButton) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MenuButton) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *MenuButton) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MenuButton) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *MenuButton) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MenuButton) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *MenuButton) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMenuButtonGLibType, libs, "gtk_menu_button_get_type")

	core.PuregoSafeRegister(&xNewMenuButton, libs, "gtk_menu_button_new")

	core.PuregoSafeRegister(&xMenuButtonGetActive, libs, "gtk_menu_button_get_active")
	core.PuregoSafeRegister(&xMenuButtonGetAlwaysShowArrow, libs, "gtk_menu_button_get_always_show_arrow")
	core.PuregoSafeRegister(&xMenuButtonGetCanShrink, libs, "gtk_menu_button_get_can_shrink")
	core.PuregoSafeRegister(&xMenuButtonGetChild, libs, "gtk_menu_button_get_child")
	core.PuregoSafeRegister(&xMenuButtonGetDirection, libs, "gtk_menu_button_get_direction")
	core.PuregoSafeRegister(&xMenuButtonGetHasFrame, libs, "gtk_menu_button_get_has_frame")
	core.PuregoSafeRegister(&xMenuButtonGetIconName, libs, "gtk_menu_button_get_icon_name")
	core.PuregoSafeRegister(&xMenuButtonGetLabel, libs, "gtk_menu_button_get_label")
	core.PuregoSafeRegister(&xMenuButtonGetMenuModel, libs, "gtk_menu_button_get_menu_model")
	core.PuregoSafeRegister(&xMenuButtonGetPopover, libs, "gtk_menu_button_get_popover")
	core.PuregoSafeRegister(&xMenuButtonGetPrimary, libs, "gtk_menu_button_get_primary")
	core.PuregoSafeRegister(&xMenuButtonGetUseUnderline, libs, "gtk_menu_button_get_use_underline")
	core.PuregoSafeRegister(&xMenuButtonPopdown, libs, "gtk_menu_button_popdown")
	core.PuregoSafeRegister(&xMenuButtonPopup, libs, "gtk_menu_button_popup")
	core.PuregoSafeRegister(&xMenuButtonSetActive, libs, "gtk_menu_button_set_active")
	core.PuregoSafeRegister(&xMenuButtonSetAlwaysShowArrow, libs, "gtk_menu_button_set_always_show_arrow")
	core.PuregoSafeRegister(&xMenuButtonSetCanShrink, libs, "gtk_menu_button_set_can_shrink")
	core.PuregoSafeRegister(&xMenuButtonSetChild, libs, "gtk_menu_button_set_child")
	core.PuregoSafeRegister(&xMenuButtonSetCreatePopupFunc, libs, "gtk_menu_button_set_create_popup_func")
	core.PuregoSafeRegister(&xMenuButtonSetDirection, libs, "gtk_menu_button_set_direction")
	core.PuregoSafeRegister(&xMenuButtonSetHasFrame, libs, "gtk_menu_button_set_has_frame")
	core.PuregoSafeRegister(&xMenuButtonSetIconName, libs, "gtk_menu_button_set_icon_name")
	core.PuregoSafeRegister(&xMenuButtonSetLabel, libs, "gtk_menu_button_set_label")
	core.PuregoSafeRegister(&xMenuButtonSetMenuModel, libs, "gtk_menu_button_set_menu_model")
	core.PuregoSafeRegister(&xMenuButtonSetPopover, libs, "gtk_menu_button_set_popover")
	core.PuregoSafeRegister(&xMenuButtonSetPrimary, libs, "gtk_menu_button_set_primary")
	core.PuregoSafeRegister(&xMenuButtonSetUseUnderline, libs, "gtk_menu_button_set_use_underline")

}
