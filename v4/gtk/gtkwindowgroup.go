// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type WindowGroupClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xGtkReserved1 uintptr

	xGtkReserved2 uintptr

	xGtkReserved3 uintptr

	xGtkReserved4 uintptr
}

func (x *WindowGroupClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGtkReserved1 sets the "_gtk_reserved1" callback function.
func (x *WindowGroupClass) OverrideGtkReserved1(cb func()) {
	if cb == nil {
		x.xGtkReserved1 = 0
	} else {
		x.xGtkReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved1 gets the "_gtk_reserved1" callback function.
func (x *WindowGroupClass) GetGtkReserved1() func() {
	if x.xGtkReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved2 sets the "_gtk_reserved2" callback function.
func (x *WindowGroupClass) OverrideGtkReserved2(cb func()) {
	if cb == nil {
		x.xGtkReserved2 = 0
	} else {
		x.xGtkReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved2 gets the "_gtk_reserved2" callback function.
func (x *WindowGroupClass) GetGtkReserved2() func() {
	if x.xGtkReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved3 sets the "_gtk_reserved3" callback function.
func (x *WindowGroupClass) OverrideGtkReserved3(cb func()) {
	if cb == nil {
		x.xGtkReserved3 = 0
	} else {
		x.xGtkReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved3 gets the "_gtk_reserved3" callback function.
func (x *WindowGroupClass) GetGtkReserved3() func() {
	if x.xGtkReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved4 sets the "_gtk_reserved4" callback function.
func (x *WindowGroupClass) OverrideGtkReserved4(cb func()) {
	if cb == nil {
		x.xGtkReserved4 = 0
	} else {
		x.xGtkReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved4 gets the "_gtk_reserved4" callback function.
func (x *WindowGroupClass) GetGtkReserved4() func() {
	if x.xGtkReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved4)
	return func() {
		rawCallback()
	}
}

// Creates groups of windows that behave like separate applications.
//
// It achieves this by limiting the effect of GTK grabs and modality
// to windows in the same group.
//
// A window can be a member in at most one window group at a time.
// Windows that have not been explicitly assigned to a group are
// implicitly treated like windows of the default window group.
//
// `GtkWindowGroup` objects are referenced by each window in the group,
// so once you have added all windows to a `GtkWindowGroup`, you can drop
// the initial reference to the window group with g_object_unref(). If the
// windows in the window group are subsequently destroyed, then they will
// be removed from the window group and drop their references on the window
// group; when all window have been removed, the window group will be
// freed.
type WindowGroup struct {
	gobject.Object
}

var xWindowGroupGLibType func() types.GType

func WindowGroupGLibType() types.GType {
	return xWindowGroupGLibType()
}

func WindowGroupNewFromInternalPtr(ptr uintptr) *WindowGroup {
	cls := &WindowGroup{}
	cls.Ptr = ptr
	return cls
}

var xNewWindowGroup func() uintptr

// Creates a new `GtkWindowGroup` object.
//
// Modality of windows only affects windows
// within the same `GtkWindowGroup`.
func NewWindowGroup() *WindowGroup {
	var cls *WindowGroup

	cret := xNewWindowGroup()

	if cret == 0 {
		return nil
	}
	cls = &WindowGroup{}
	cls.Ptr = cret
	return cls
}

var xWindowGroupAddWindow func(uintptr, uintptr)

// Adds a window to a `GtkWindowGroup`.
func (x *WindowGroup) AddWindow(WindowVar *Window) {

	xWindowGroupAddWindow(x.GoPointer(), WindowVar.GoPointer())

}

var xWindowGroupListWindows func(uintptr) *glib.List

// Returns a list of the `GtkWindows` that belong to @window_group.
func (x *WindowGroup) ListWindows() *glib.List {

	cret := xWindowGroupListWindows(x.GoPointer())
	return cret
}

var xWindowGroupRemoveWindow func(uintptr, uintptr)

// Removes a window from a `GtkWindowGroup`.
func (x *WindowGroup) RemoveWindow(WindowVar *Window) {

	xWindowGroupRemoveWindow(x.GoPointer(), WindowVar.GoPointer())

}

func (c *WindowGroup) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WindowGroup) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWindowGroupGLibType, libs, "gtk_window_group_get_type")

	core.PuregoSafeRegister(&xNewWindowGroup, libs, "gtk_window_group_new")

	core.PuregoSafeRegister(&xWindowGroupAddWindow, libs, "gtk_window_group_add_window")
	core.PuregoSafeRegister(&xWindowGroupListWindows, libs, "gtk_window_group_list_windows")
	core.PuregoSafeRegister(&xWindowGroupRemoveWindow, libs, "gtk_window_group_remove_window")

}
