// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type FileDialogClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *FileDialogClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Asynchronous API to present a file chooser dialog.
//
// `GtkFileDialog` collects the arguments that are needed to present
// the dialog to the user, such as a title for the dialog and whether
// it should be modal.
//
// The dialog is shown with [method@Gtk.FileDialog.open],
// [method@Gtk.FileDialog.save], etc.
type FileDialog struct {
	gobject.Object
}

var xFileDialogGLibType func() types.GType

func FileDialogGLibType() types.GType {
	return xFileDialogGLibType()
}

func FileDialogNewFromInternalPtr(ptr uintptr) *FileDialog {
	cls := &FileDialog{}
	cls.Ptr = ptr
	return cls
}

var xNewFileDialog func() uintptr

// Creates a new `GtkFileDialog` object.
func NewFileDialog() *FileDialog {
	var cls *FileDialog

	cret := xNewFileDialog()

	if cret == 0 {
		return nil
	}
	cls = &FileDialog{}
	cls.Ptr = cret
	return cls
}

var xFileDialogGetAcceptLabel func(uintptr) string

// Retrieves the text used by the dialog on its accept button.
func (x *FileDialog) GetAcceptLabel() string {

	cret := xFileDialogGetAcceptLabel(x.GoPointer())

	return cret
}

var xFileDialogGetDefaultFilter func(uintptr) uintptr

// Gets the filter that will be selected by default
// in the file chooser dialog.
func (x *FileDialog) GetDefaultFilter() *FileFilter {
	var cls *FileFilter

	cret := xFileDialogGetDefaultFilter(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileFilter{}
	cls.Ptr = cret
	return cls
}

var xFileDialogGetFilters func(uintptr) uintptr

// Gets the filters that will be offered to the user
// in the file chooser dialog.
func (x *FileDialog) GetFilters() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xFileDialogGetFilters(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xFileDialogGetInitialFile func(uintptr) uintptr

// Gets the file that will be initially selected in
// the file chooser dialog.
func (x *FileDialog) GetInitialFile() *gio.FileBase {
	var cls *gio.FileBase

	cret := xFileDialogGetInitialFile(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileDialogGetInitialFolder func(uintptr) uintptr

// Gets the folder that will be set as the
// initial folder in the file chooser dialog.
func (x *FileDialog) GetInitialFolder() *gio.FileBase {
	var cls *gio.FileBase

	cret := xFileDialogGetInitialFolder(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileDialogGetInitialName func(uintptr) string

// Gets the filename that will be initially selected.
func (x *FileDialog) GetInitialName() string {

	cret := xFileDialogGetInitialName(x.GoPointer())

	return cret
}

var xFileDialogGetModal func(uintptr) bool

// Returns whether the file chooser dialog blocks interaction
// with the parent window while it is presented.
func (x *FileDialog) GetModal() bool {

	cret := xFileDialogGetModal(x.GoPointer())

	return cret
}

var xFileDialogGetTitle func(uintptr) string

// Returns the title that will be shown on the file chooser dialog.
func (x *FileDialog) GetTitle() string {

	cret := xFileDialogGetTitle(x.GoPointer())

	return cret
}

var xFileDialogOpen func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Presents a file chooser dialog to the user.
//
// The file chooser dialog will be set up to select a single file.
//
// The @callback will be called when the dialog is closed.
func (x *FileDialog) Open(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileDialogOpen(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileDialogOpenFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes the [method@Gtk.FileDialog.open] call.
//
// Note that this function returns a [error@Gtk.DialogError.DISMISSED]
// error if the user cancels the dialog.
func (x *FileDialog) OpenFinish(ResultVar gio.AsyncResult) (*gio.FileBase, error) {
	var cls *gio.FileBase
	var cerr *glib.Error

	cret := xFileDialogOpenFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileDialogOpenMultiple func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Presents a file chooser dialog to the user.
//
// The file chooser dialog will be set up to select multiple files.
//
// The file chooser dialog will initially be opened in the directory
// [property@Gtk.FileDialog:initial-folder].
//
// The @callback will be called when the dialog is closed.
func (x *FileDialog) OpenMultiple(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileDialogOpenMultiple(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileDialogOpenMultipleFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes the [method@Gtk.FileDialog.open] call.
//
// Note that this function returns a [error@Gtk.DialogError.DISMISSED]
// error if the user cancels the dialog.
func (x *FileDialog) OpenMultipleFinish(ResultVar gio.AsyncResult) (*gio.ListModelBase, error) {
	var cls *gio.ListModelBase
	var cerr *glib.Error

	cret := xFileDialogOpenMultipleFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileDialogOpenMultipleTextFiles func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Presents a file chooser dialog to the user.
//
// The file chooser dialog will be set up to select multiple files.
//
// The file chooser dialog will initially be opened in the directory
// [property@Gtk.FileDialog:initial-folder].
//
// In contrast to [method@Gtk.FileDialog.open], this function
// lets the user select the text encoding for the files, if possible.
//
// The @callback will be called when the dialog is closed.
func (x *FileDialog) OpenMultipleTextFiles(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileDialogOpenMultipleTextFiles(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileDialogOpenMultipleTextFilesFinish func(uintptr, uintptr, *string, **glib.Error) uintptr

// Finishes the [method@Gtk.FileDialog.open] call.
//
// Note that this function returns a [error@Gtk.DialogError.DISMISSED]
// error if the user cancels the dialog.
func (x *FileDialog) OpenMultipleTextFilesFinish(ResultVar gio.AsyncResult, EncodingVar *string) (*gio.ListModelBase, error) {
	var cls *gio.ListModelBase
	var cerr *glib.Error

	cret := xFileDialogOpenMultipleTextFilesFinish(x.GoPointer(), ResultVar.GoPointer(), EncodingVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileDialogOpenTextFile func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Initiates a file selection operation by presenting a file chooser
// dialog to the user.
//
// In contrast to [method@Gtk.FileDialog.open], this function
// lets the user select the text encoding for the file, if possible.
//
// The @callback will be called when the dialog is closed.
func (x *FileDialog) OpenTextFile(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileDialogOpenTextFile(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileDialogOpenTextFileFinish func(uintptr, uintptr, *string, **glib.Error) uintptr

// Finishes the [method@Gtk.FileDialog.open_text_file] call
// and returns the resulting file and text encoding.
//
// If the user has explicitly selected a text encoding to use
// for the file, then @encoding will be set to a codeset name that
// is suitable for passing to iconv_open(). Otherwise, it will
// be `NULL`.
//
// Note that this function returns a [error@Gtk.DialogError.DISMISSED]
// error if the user cancels the dialog.
func (x *FileDialog) OpenTextFileFinish(ResultVar gio.AsyncResult, EncodingVar *string) (*gio.FileBase, error) {
	var cls *gio.FileBase
	var cerr *glib.Error

	cret := xFileDialogOpenTextFileFinish(x.GoPointer(), ResultVar.GoPointer(), EncodingVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileDialogSave func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Presents a file chooser dialog to the user.
//
// The file chooser dialog will be save mode.
//
// The @callback will be called when the dialog is closed.
func (x *FileDialog) Save(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileDialogSave(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileDialogSaveFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes the [method@Gtk.FileDialog.save] call.
//
// Note that this function returns a [error@Gtk.DialogError.DISMISSED]
// error if the user cancels the dialog.
func (x *FileDialog) SaveFinish(ResultVar gio.AsyncResult) (*gio.FileBase, error) {
	var cls *gio.FileBase
	var cerr *glib.Error

	cret := xFileDialogSaveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileDialogSaveTextFile func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Initiates a file save operation by presenting a file chooser
// dialog to the user.
//
// In contrast to [method@Gtk.FileDialog.save], this function
// lets the user select the text encoding and line endings for
// the text file, if possible.
//
// The @callback will be called when the dialog is closed.
func (x *FileDialog) SaveTextFile(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileDialogSaveTextFile(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileDialogSaveTextFileFinish func(uintptr, uintptr, *string, *string, **glib.Error) uintptr

// Finishes the [method@Gtk.FileDialog.save_text_file] call
// and returns the resulting file, text encoding and line endings.
//
// If the user has explicitly selected a text encoding to use
// for the file, then @encoding will be set to a codeset name that
// is suitable for passing to iconv_open(). Otherwise, it will
// be `NULL`.
//
// The @line_ending will be set to one of "\n", "\r\n", "\r" or "",
// where the latter means to preserve existing line endings.
//
// Note that this function returns a [error@Gtk.DialogError.DISMISSED]
// error if the user cancels the dialog.
func (x *FileDialog) SaveTextFileFinish(ResultVar gio.AsyncResult, EncodingVar *string, LineEndingVar *string) (*gio.FileBase, error) {
	var cls *gio.FileBase
	var cerr *glib.Error

	cret := xFileDialogSaveTextFileFinish(x.GoPointer(), ResultVar.GoPointer(), EncodingVar, LineEndingVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileDialogSelectFolder func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Presents a file chooser dialog to the user.
//
// The file chooser dialog will be set up to select a single folder.
//
// If you pass @initial_folder, the file chooser dialog will initially
// be opened in the parent directory of that folder, otherwise, it
// will be in the directory [property@Gtk.FileDialog:initial-folder].
//
// The @callback will be called when the dialog is closed.
func (x *FileDialog) SelectFolder(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileDialogSelectFolder(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileDialogSelectFolderFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes the [method@Gtk.FileDialog.select_folder] call.
//
// Note that this function returns a [error@Gtk.DialogError.DISMISSED]
// error if the user cancels the dialog.
func (x *FileDialog) SelectFolderFinish(ResultVar gio.AsyncResult) (*gio.FileBase, error) {
	var cls *gio.FileBase
	var cerr *glib.Error

	cret := xFileDialogSelectFolderFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileDialogSelectMultipleFolders func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Presents a file chooser dialog to the user.
//
// The file chooser dialog will be set up to allow selecting
// multiple folders.
//
// The file chooser dialog will initially be opened in the
// directory [property@Gtk.FileDialog:initial-folder].
//
// The @callback will be called when the dialog is closed.
func (x *FileDialog) SelectMultipleFolders(ParentVar *Window, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileDialogSelectMultipleFolders(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileDialogSelectMultipleFoldersFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes the [method@Gtk.FileDialog.select_multiple_folders] call.
//
// Note that this function returns a [error@Gtk.DialogError.DISMISSED]
// error if the user cancels the dialog.
func (x *FileDialog) SelectMultipleFoldersFinish(ResultVar gio.AsyncResult) (*gio.ListModelBase, error) {
	var cls *gio.ListModelBase
	var cerr *glib.Error

	cret := xFileDialogSelectMultipleFoldersFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileDialogSetAcceptLabel func(uintptr, uintptr)

// Sets the label shown on the file chooser's accept button.
//
// Leaving the accept label unset or setting it as `NULL` will
// fall back to a default label, depending on what API is used
// to launch the file dialog.
func (x *FileDialog) SetAcceptLabel(AcceptLabelVar *string) {

	AcceptLabelVarPtr, AcceptLabelVarBytes := core.NullableStringToPtr(AcceptLabelVar)

	xFileDialogSetAcceptLabel(x.GoPointer(), AcceptLabelVarPtr)

	runtime.KeepAlive(AcceptLabelVarBytes)

}

var xFileDialogSetDefaultFilter func(uintptr, uintptr)

// Sets the filter that will be selected by default
// in the file chooser dialog.
//
// If set to `NULL`, the first item in [property@Gtk.FileDialog:filters]
// will be used as the default filter. If that list is empty, the dialog
// will be unfiltered.
func (x *FileDialog) SetDefaultFilter(FilterVar *FileFilter) {

	xFileDialogSetDefaultFilter(x.GoPointer(), FilterVar.GoPointer())

}

var xFileDialogSetFilters func(uintptr, uintptr)

// Sets the filters that will be offered to the user
// in the file chooser dialog.
func (x *FileDialog) SetFilters(FiltersVar gio.ListModel) {

	xFileDialogSetFilters(x.GoPointer(), FiltersVar.GoPointer())

}

var xFileDialogSetInitialFile func(uintptr, uintptr)

// Sets the file that will be initially selected in
// the file chooser dialog.
//
// This function is a shortcut for calling both
// [method@Gtk.FileDialog.set_initial_folder] and
// [method@Gtk.FileDialog.set_initial_name] with the
// directory and name of @file, respectively.
func (x *FileDialog) SetInitialFile(FileVar gio.File) {

	xFileDialogSetInitialFile(x.GoPointer(), FileVar.GoPointer())

}

var xFileDialogSetInitialFolder func(uintptr, uintptr)

// Sets the folder that will be set as the
// initial folder in the file chooser dialog.
func (x *FileDialog) SetInitialFolder(FolderVar gio.File) {

	xFileDialogSetInitialFolder(x.GoPointer(), FolderVar.GoPointer())

}

var xFileDialogSetInitialName func(uintptr, uintptr)

// Sets the filename that will be initially selected.
//
// For save dialogs, @name will usually be pre-entered into the
// name field.
//
// If a file with this name already exists in the directory set
// via [property@Gtk.FileDialog:initial-folder], the dialog will
// preselect it.
func (x *FileDialog) SetInitialName(NameVar *string) {

	NameVarPtr, NameVarBytes := core.NullableStringToPtr(NameVar)

	xFileDialogSetInitialName(x.GoPointer(), NameVarPtr)

	runtime.KeepAlive(NameVarBytes)

}

var xFileDialogSetModal func(uintptr, bool)

// Sets whether the file chooser dialog blocks interaction
// with the parent window while it is presented.
func (x *FileDialog) SetModal(ModalVar bool) {

	xFileDialogSetModal(x.GoPointer(), ModalVar)

}

var xFileDialogSetTitle func(uintptr, string)

// Sets the title that will be shown on the file chooser dialog.
func (x *FileDialog) SetTitle(TitleVar string) {

	xFileDialogSetTitle(x.GoPointer(), TitleVar)

}

func (c *FileDialog) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *FileDialog) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAcceptLabel sets the "accept-label" property.
// Label for the file chooser's accept button.
func (x *FileDialog) SetPropertyAcceptLabel(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("accept-label", &v)
}

// GetPropertyAcceptLabel gets the "accept-label" property.
// Label for the file chooser's accept button.
func (x *FileDialog) GetPropertyAcceptLabel() string {
	var v gobject.Value
	x.GetProperty("accept-label", &v)
	return v.GetString()
}

// SetPropertyInitialName sets the "initial-name" property.
// The initial name.
//
// This is the name of the file that is initially selected in the file chooser dialog.
func (x *FileDialog) SetPropertyInitialName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("initial-name", &v)
}

// GetPropertyInitialName gets the "initial-name" property.
// The initial name.
//
// This is the name of the file that is initially selected in the file chooser dialog.
func (x *FileDialog) GetPropertyInitialName() string {
	var v gobject.Value
	x.GetProperty("initial-name", &v)
	return v.GetString()
}

// SetPropertyModal sets the "modal" property.
// Whether the file chooser dialog is modal.
func (x *FileDialog) SetPropertyModal(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("modal", &v)
}

// GetPropertyModal gets the "modal" property.
// Whether the file chooser dialog is modal.
func (x *FileDialog) GetPropertyModal() bool {
	var v gobject.Value
	x.GetProperty("modal", &v)
	return v.GetBoolean()
}

// SetPropertyTitle sets the "title" property.
// A title that may be shown on the file chooser dialog.
func (x *FileDialog) SetPropertyTitle(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("title", &v)
}

// GetPropertyTitle gets the "title" property.
// A title that may be shown on the file chooser dialog.
func (x *FileDialog) GetPropertyTitle() string {
	var v gobject.Value
	x.GetProperty("title", &v)
	return v.GetString()
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xFileDialogGLibType, libs, "gtk_file_dialog_get_type")

	core.PuregoSafeRegister(&xNewFileDialog, libs, "gtk_file_dialog_new")

	core.PuregoSafeRegister(&xFileDialogGetAcceptLabel, libs, "gtk_file_dialog_get_accept_label")
	core.PuregoSafeRegister(&xFileDialogGetDefaultFilter, libs, "gtk_file_dialog_get_default_filter")
	core.PuregoSafeRegister(&xFileDialogGetFilters, libs, "gtk_file_dialog_get_filters")
	core.PuregoSafeRegister(&xFileDialogGetInitialFile, libs, "gtk_file_dialog_get_initial_file")
	core.PuregoSafeRegister(&xFileDialogGetInitialFolder, libs, "gtk_file_dialog_get_initial_folder")
	core.PuregoSafeRegister(&xFileDialogGetInitialName, libs, "gtk_file_dialog_get_initial_name")
	core.PuregoSafeRegister(&xFileDialogGetModal, libs, "gtk_file_dialog_get_modal")
	core.PuregoSafeRegister(&xFileDialogGetTitle, libs, "gtk_file_dialog_get_title")
	core.PuregoSafeRegister(&xFileDialogOpen, libs, "gtk_file_dialog_open")
	core.PuregoSafeRegister(&xFileDialogOpenFinish, libs, "gtk_file_dialog_open_finish")
	core.PuregoSafeRegister(&xFileDialogOpenMultiple, libs, "gtk_file_dialog_open_multiple")
	core.PuregoSafeRegister(&xFileDialogOpenMultipleFinish, libs, "gtk_file_dialog_open_multiple_finish")
	core.PuregoSafeRegister(&xFileDialogOpenMultipleTextFiles, libs, "gtk_file_dialog_open_multiple_text_files")
	core.PuregoSafeRegister(&xFileDialogOpenMultipleTextFilesFinish, libs, "gtk_file_dialog_open_multiple_text_files_finish")
	core.PuregoSafeRegister(&xFileDialogOpenTextFile, libs, "gtk_file_dialog_open_text_file")
	core.PuregoSafeRegister(&xFileDialogOpenTextFileFinish, libs, "gtk_file_dialog_open_text_file_finish")
	core.PuregoSafeRegister(&xFileDialogSave, libs, "gtk_file_dialog_save")
	core.PuregoSafeRegister(&xFileDialogSaveFinish, libs, "gtk_file_dialog_save_finish")
	core.PuregoSafeRegister(&xFileDialogSaveTextFile, libs, "gtk_file_dialog_save_text_file")
	core.PuregoSafeRegister(&xFileDialogSaveTextFileFinish, libs, "gtk_file_dialog_save_text_file_finish")
	core.PuregoSafeRegister(&xFileDialogSelectFolder, libs, "gtk_file_dialog_select_folder")
	core.PuregoSafeRegister(&xFileDialogSelectFolderFinish, libs, "gtk_file_dialog_select_folder_finish")
	core.PuregoSafeRegister(&xFileDialogSelectMultipleFolders, libs, "gtk_file_dialog_select_multiple_folders")
	core.PuregoSafeRegister(&xFileDialogSelectMultipleFoldersFinish, libs, "gtk_file_dialog_select_multiple_folders_finish")
	core.PuregoSafeRegister(&xFileDialogSetAcceptLabel, libs, "gtk_file_dialog_set_accept_label")
	core.PuregoSafeRegister(&xFileDialogSetDefaultFilter, libs, "gtk_file_dialog_set_default_filter")
	core.PuregoSafeRegister(&xFileDialogSetFilters, libs, "gtk_file_dialog_set_filters")
	core.PuregoSafeRegister(&xFileDialogSetInitialFile, libs, "gtk_file_dialog_set_initial_file")
	core.PuregoSafeRegister(&xFileDialogSetInitialFolder, libs, "gtk_file_dialog_set_initial_folder")
	core.PuregoSafeRegister(&xFileDialogSetInitialName, libs, "gtk_file_dialog_set_initial_name")
	core.PuregoSafeRegister(&xFileDialogSetModal, libs, "gtk_file_dialog_set_modal")
	core.PuregoSafeRegister(&xFileDialogSetTitle, libs, "gtk_file_dialog_set_title")

}
