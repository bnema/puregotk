// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type MediaFileClass struct {
	_ structs.HostLayout

	ParentClass MediaStreamClass

	xOpen uintptr

	xClose uintptr

	xGtkReserved1 uintptr

	xGtkReserved2 uintptr

	xGtkReserved3 uintptr

	xGtkReserved4 uintptr
}

func (x *MediaFileClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideOpen sets the "open" callback function.
func (x *MediaFileClass) OverrideOpen(cb func(*MediaFile)) {
	if cb == nil {
		x.xOpen = 0
	} else {
		x.xOpen = purego.NewCallback(func(SelfVarp uintptr) {
			cb(MediaFileNewFromInternalPtr(SelfVarp))
		})
	}
}

// GetOpen gets the "open" callback function.
func (x *MediaFileClass) GetOpen() func(*MediaFile) {
	if x.xOpen == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xOpen)
	return func(SelfVar *MediaFile) {
		rawCallback(SelfVar.GoPointer())
	}
}

// OverrideClose sets the "close" callback function.
func (x *MediaFileClass) OverrideClose(cb func(*MediaFile)) {
	if cb == nil {
		x.xClose = 0
	} else {
		x.xClose = purego.NewCallback(func(SelfVarp uintptr) {
			cb(MediaFileNewFromInternalPtr(SelfVarp))
		})
	}
}

// GetClose gets the "close" callback function.
func (x *MediaFileClass) GetClose() func(*MediaFile) {
	if x.xClose == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xClose)
	return func(SelfVar *MediaFile) {
		rawCallback(SelfVar.GoPointer())
	}
}

// OverrideGtkReserved1 sets the "_gtk_reserved1" callback function.
func (x *MediaFileClass) OverrideGtkReserved1(cb func()) {
	if cb == nil {
		x.xGtkReserved1 = 0
	} else {
		x.xGtkReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved1 gets the "_gtk_reserved1" callback function.
func (x *MediaFileClass) GetGtkReserved1() func() {
	if x.xGtkReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved2 sets the "_gtk_reserved2" callback function.
func (x *MediaFileClass) OverrideGtkReserved2(cb func()) {
	if cb == nil {
		x.xGtkReserved2 = 0
	} else {
		x.xGtkReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved2 gets the "_gtk_reserved2" callback function.
func (x *MediaFileClass) GetGtkReserved2() func() {
	if x.xGtkReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved3 sets the "_gtk_reserved3" callback function.
func (x *MediaFileClass) OverrideGtkReserved3(cb func()) {
	if cb == nil {
		x.xGtkReserved3 = 0
	} else {
		x.xGtkReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved3 gets the "_gtk_reserved3" callback function.
func (x *MediaFileClass) GetGtkReserved3() func() {
	if x.xGtkReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved4 sets the "_gtk_reserved4" callback function.
func (x *MediaFileClass) OverrideGtkReserved4(cb func()) {
	if cb == nil {
		x.xGtkReserved4 = 0
	} else {
		x.xGtkReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved4 gets the "_gtk_reserved4" callback function.
func (x *MediaFileClass) GetGtkReserved4() func() {
	if x.xGtkReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved4)
	return func() {
		rawCallback()
	}
}

const (
	// The default extension point name for media file.
	MEDIA_FILE_EXTENSION_POINT_NAME string = "gtk-media-file"
)

// Implements the `GtkMediaStream` interface for files.
//
// This provides a simple way to play back video files with GTK.
//
// GTK provides a GIO extension point for `GtkMediaFile` implementations
// to allow for external implementations using various media frameworks.
//
// GTK itself includes an implementation using GStreamer.
type MediaFile struct {
	MediaStream
}

var xMediaFileGLibType func() types.GType

func MediaFileGLibType() types.GType {
	return xMediaFileGLibType()
}

func MediaFileNewFromInternalPtr(ptr uintptr) *MediaFile {
	cls := &MediaFile{}
	cls.Ptr = ptr
	return cls
}

var xNewMediaFile func() uintptr

// Creates a new empty media file.
func NewMediaFile() *MediaFile {
	var cls *MediaFile

	cret := xNewMediaFile()

	if cret == 0 {
		return nil
	}
	cls = &MediaFile{}
	cls.Ptr = cret
	return cls
}

var xNewMediaFileForFile func(uintptr) uintptr

// Creates a new media file to play @file.
func NewMediaFileForFile(FileVar gio.File) *MediaFile {
	var cls *MediaFile

	cret := xNewMediaFileForFile(FileVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &MediaFile{}
	cls.Ptr = cret
	return cls
}

var xNewMediaFileForFilename func(string) uintptr

// Creates a new media file for the given filename.
//
// This is a utility function that converts the given @filename
// to a `GFile` and calls [ctor@Gtk.MediaFile.new_for_file].
func NewMediaFileForFilename(FilenameVar string) *MediaFile {
	var cls *MediaFile

	cret := xNewMediaFileForFilename(FilenameVar)

	if cret == 0 {
		return nil
	}
	cls = &MediaFile{}
	cls.Ptr = cret
	return cls
}

var xNewMediaFileForInputStream func(uintptr) uintptr

// Creates a new media file to play @stream.
//
// If you want the resulting media to be seekable,
// the stream should implement the `GSeekable` interface.
func NewMediaFileForInputStream(StreamVar *gio.InputStream) *MediaFile {
	var cls *MediaFile

	cret := xNewMediaFileForInputStream(StreamVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &MediaFile{}
	cls.Ptr = cret
	return cls
}

var xNewMediaFileForResource func(string) uintptr

// Creates a new new media file for the given resource.
//
// This is a utility function that converts the given @resource
// to a `GFile` and calls [ctor@Gtk.MediaFile.new_for_file].
func NewMediaFileForResource(ResourcePathVar string) *MediaFile {
	var cls *MediaFile

	cret := xNewMediaFileForResource(ResourcePathVar)

	if cret == 0 {
		return nil
	}
	cls = &MediaFile{}
	cls.Ptr = cret
	return cls
}

var xMediaFileClear func(uintptr)

// Resets the media file to be empty.
func (x *MediaFile) Clear() {

	xMediaFileClear(x.GoPointer())

}

var xMediaFileGetFile func(uintptr) uintptr

// Returns the file that @self is currently playing from.
//
// When @self is not playing or not playing from a file,
// %NULL is returned.
func (x *MediaFile) GetFile() *gio.FileBase {
	var cls *gio.FileBase

	cret := xMediaFileGetFile(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

var xMediaFileGetInputStream func(uintptr) uintptr

// Returns the stream that @self is currently playing from.
//
// When @self is not playing or not playing from a stream,
// %NULL is returned.
func (x *MediaFile) GetInputStream() *gio.InputStream {
	var cls *gio.InputStream

	cret := xMediaFileGetInputStream(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.InputStream{}
	cls.Ptr = cret
	return cls
}

var xMediaFileSetFile func(uintptr, uintptr)

// Sets the `GtkMediaFile` to play the given file.
//
// If any file is still playing, stop playing it.
func (x *MediaFile) SetFile(FileVar gio.File) {

	xMediaFileSetFile(x.GoPointer(), FileVar.GoPointer())

}

var xMediaFileSetFilename func(uintptr, uintptr)

// Sets the `GtkMediaFile` to play the given file.
//
// This is a utility function that converts the given @filename
// to a `GFile` and calls [method@Gtk.MediaFile.set_file].
func (x *MediaFile) SetFilename(FilenameVar *string) {

	xMediaFileSetFilename(x.GoPointer(), core.NullableStringToPtr(FilenameVar))

}

var xMediaFileSetInputStream func(uintptr, uintptr)

// Sets the `GtkMediaFile` to play the given stream.
//
// If anything is still playing, stop playing it.
//
// Full control about the @stream is assumed for the duration of
// playback. The stream will not be closed.
func (x *MediaFile) SetInputStream(StreamVar *gio.InputStream) {

	xMediaFileSetInputStream(x.GoPointer(), StreamVar.GoPointer())

}

var xMediaFileSetResource func(uintptr, uintptr)

// Sets the `GtkMediaFile` to play the given resource.
//
// This is a utility function that converts the given @resource_path
// to a `GFile` and calls [method@Gtk.MediaFile.set_file].
func (x *MediaFile) SetResource(ResourcePathVar *string) {

	xMediaFileSetResource(x.GoPointer(), core.NullableStringToPtr(ResourcePathVar))

}

func (c *MediaFile) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *MediaFile) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Compute a concrete size for the `GdkPaintable`.
//
// Applies the sizing algorithm outlined in the
// [CSS Image spec](https://drafts.csswg.org/css-images-3/#default-sizing)
// to the given @paintable. See that link for more details.
//
// It is not necessary to call this function when both @specified_width
// and @specified_height are known, but it is useful to call this
// function in GtkWidget:measure implementations to compute the
// other dimension when only one dimension is given.
func (x *MediaFile) ComputeConcreteSize(SpecifiedWidthVar float64, SpecifiedHeightVar float64, DefaultWidthVar float64, DefaultHeightVar float64, ConcreteWidthVar *float64, ConcreteHeightVar *float64) {

	gdk.XGdkPaintableComputeConcreteSize(x.GoPointer(), SpecifiedWidthVar, SpecifiedHeightVar, DefaultWidthVar, DefaultHeightVar, ConcreteWidthVar, ConcreteHeightVar)

}

// Gets an immutable paintable for the current contents displayed by @paintable.
//
// This is useful when you want to retain the current state of an animation,
// for example to take a screenshot of a running animation.
//
// If the @paintable is already immutable, it will return itself.
func (x *MediaFile) GetCurrentImage() *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := gdk.XGdkPaintableGetCurrentImage(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

// Get flags for the paintable.
//
// This is oftentimes useful for optimizations.
//
// See [flags@Gdk.PaintableFlags] for the flags and what they mean.
func (x *MediaFile) GetFlags() gdk.PaintableFlags {

	cret := gdk.XGdkPaintableGetFlags(x.GoPointer())
	return cret
}

// Gets the preferred aspect ratio the @paintable would like to be displayed at.
//
// The aspect ratio is the width divided by the height, so a value of 0.5
// means that the @paintable prefers to be displayed twice as high as it
// is wide. Consumers of this interface can use this to preserve aspect
// ratio when displaying the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// Usually when a @paintable returns nonzero values from
// [method@Gdk.Paintable.get_intrinsic_width] and
// [method@Gdk.Paintable.get_intrinsic_height] the aspect ratio
// should conform to those values, though that is not required.
//
// If the @paintable does not have a preferred aspect ratio,
// it returns 0. Negative values are never returned.
func (x *MediaFile) GetIntrinsicAspectRatio() float64 {

	cret := gdk.XGdkPaintableGetIntrinsicAspectRatio(x.GoPointer())
	return cret
}

// Gets the preferred height the @paintable would like to be displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw
// the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// If the @paintable does not have a preferred height, it returns 0.
// Negative values are never returned.
func (x *MediaFile) GetIntrinsicHeight() int {

	cret := gdk.XGdkPaintableGetIntrinsicHeight(x.GoPointer())
	return cret
}

// Gets the preferred width the @paintable would like to be displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw
// the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// If the @paintable does not have a preferred width, it returns 0.
// Negative values are never returned.
func (x *MediaFile) GetIntrinsicWidth() int {

	cret := gdk.XGdkPaintableGetIntrinsicWidth(x.GoPointer())
	return cret
}

// Called by implementations of `GdkPaintable` to invalidate their contents.
//
// Unless the contents are invalidated, implementations must guarantee that
// multiple calls of [method@Gdk.Paintable.snapshot] produce the same output.
//
// This function will emit the [signal@Gdk.Paintable::invalidate-contents]
// signal.
//
// If a @paintable reports the %GDK_PAINTABLE_STATIC_CONTENTS flag,
// it must not call this function.
func (x *MediaFile) InvalidateContents() {

	gdk.XGdkPaintableInvalidateContents(x.GoPointer())

}

// Called by implementations of `GdkPaintable` to invalidate their size.
//
// As long as the size is not invalidated, @paintable must return the same
// values for its intrinsic width, height and aspect ratio.
//
// This function will emit the [signal@Gdk.Paintable::invalidate-size]
// signal.
//
// If a @paintable reports the %GDK_PAINTABLE_STATIC_SIZE flag,
// it must not call this function.
func (x *MediaFile) InvalidateSize() {

	gdk.XGdkPaintableInvalidateSize(x.GoPointer())

}

// Snapshots the given paintable with the given @width and @height.
//
// The paintable is drawn at the current (0,0) offset of the @snapshot.
// If @width and @height are not larger than zero, this function will
// do nothing.
func (x *MediaFile) Snapshot(SnapshotVar *gdk.Snapshot, WidthVar float64, HeightVar float64) {

	gdk.XGdkPaintableSnapshot(x.GoPointer(), SnapshotVar.GoPointer(), WidthVar, HeightVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMediaFileGLibType, libs, "gtk_media_file_get_type")

	core.PuregoSafeRegister(&xNewMediaFile, libs, "gtk_media_file_new")
	core.PuregoSafeRegister(&xNewMediaFileForFile, libs, "gtk_media_file_new_for_file")
	core.PuregoSafeRegister(&xNewMediaFileForFilename, libs, "gtk_media_file_new_for_filename")
	core.PuregoSafeRegister(&xNewMediaFileForInputStream, libs, "gtk_media_file_new_for_input_stream")
	core.PuregoSafeRegister(&xNewMediaFileForResource, libs, "gtk_media_file_new_for_resource")

	core.PuregoSafeRegister(&xMediaFileClear, libs, "gtk_media_file_clear")
	core.PuregoSafeRegister(&xMediaFileGetFile, libs, "gtk_media_file_get_file")
	core.PuregoSafeRegister(&xMediaFileGetInputStream, libs, "gtk_media_file_get_input_stream")
	core.PuregoSafeRegister(&xMediaFileSetFile, libs, "gtk_media_file_set_file")
	core.PuregoSafeRegister(&xMediaFileSetFilename, libs, "gtk_media_file_set_filename")
	core.PuregoSafeRegister(&xMediaFileSetInputStream, libs, "gtk_media_file_set_input_stream")
	core.PuregoSafeRegister(&xMediaFileSetResource, libs, "gtk_media_file_set_resource")

}
