// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type MediaStreamClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xPlay uintptr

	xPause uintptr

	xSeek uintptr

	xUpdateAudio uintptr

	xRealize uintptr

	xUnrealize uintptr

	xGtkReserved1 uintptr

	xGtkReserved2 uintptr

	xGtkReserved3 uintptr

	xGtkReserved4 uintptr

	xGtkReserved5 uintptr

	xGtkReserved6 uintptr

	xGtkReserved7 uintptr

	xGtkReserved8 uintptr
}

func (x *MediaStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverridePlay sets the "play" callback function.
func (x *MediaStreamClass) OverridePlay(cb func(*MediaStream) bool) {
	if cb == nil {
		x.xPlay = 0
	} else {
		x.xPlay = purego.NewCallback(func(SelfVarp uintptr) bool {
			return cb(MediaStreamNewFromInternalPtr(SelfVarp))
		})
	}
}

// GetPlay gets the "play" callback function.
func (x *MediaStreamClass) GetPlay() func(*MediaStream) bool {
	if x.xPlay == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xPlay)
	return func(SelfVar *MediaStream) bool {
		return rawCallback(SelfVar.GoPointer())
	}
}

// OverridePause sets the "pause" callback function.
func (x *MediaStreamClass) OverridePause(cb func(*MediaStream)) {
	if cb == nil {
		x.xPause = 0
	} else {
		x.xPause = purego.NewCallback(func(SelfVarp uintptr) {
			cb(MediaStreamNewFromInternalPtr(SelfVarp))
		})
	}
}

// GetPause gets the "pause" callback function.
func (x *MediaStreamClass) GetPause() func(*MediaStream) {
	if x.xPause == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPause)
	return func(SelfVar *MediaStream) {
		rawCallback(SelfVar.GoPointer())
	}
}

// OverrideSeek sets the "seek" callback function.
func (x *MediaStreamClass) OverrideSeek(cb func(*MediaStream, int64)) {
	if cb == nil {
		x.xSeek = 0
	} else {
		x.xSeek = purego.NewCallback(func(SelfVarp uintptr, TimestampVarp int64) {
			cb(MediaStreamNewFromInternalPtr(SelfVarp), TimestampVarp)
		})
	}
}

// GetSeek gets the "seek" callback function.
func (x *MediaStreamClass) GetSeek() func(*MediaStream, int64) {
	if x.xSeek == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, TimestampVarp int64)
	purego.RegisterFunc(&rawCallback, x.xSeek)
	return func(SelfVar *MediaStream, TimestampVar int64) {
		rawCallback(SelfVar.GoPointer(), TimestampVar)
	}
}

// OverrideUpdateAudio sets the "update_audio" callback function.
func (x *MediaStreamClass) OverrideUpdateAudio(cb func(*MediaStream, bool, float64)) {
	if cb == nil {
		x.xUpdateAudio = 0
	} else {
		x.xUpdateAudio = purego.NewCallback(func(SelfVarp uintptr, MutedVarp bool, VolumeVarp float64) {
			cb(MediaStreamNewFromInternalPtr(SelfVarp), MutedVarp, VolumeVarp)
		})
	}
}

// GetUpdateAudio gets the "update_audio" callback function.
func (x *MediaStreamClass) GetUpdateAudio() func(*MediaStream, bool, float64) {
	if x.xUpdateAudio == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, MutedVarp bool, VolumeVarp float64)
	purego.RegisterFunc(&rawCallback, x.xUpdateAudio)
	return func(SelfVar *MediaStream, MutedVar bool, VolumeVar float64) {
		rawCallback(SelfVar.GoPointer(), MutedVar, VolumeVar)
	}
}

// OverrideRealize sets the "realize" callback function.
func (x *MediaStreamClass) OverrideRealize(cb func(*MediaStream, *gdk.Surface)) {
	if cb == nil {
		x.xRealize = 0
	} else {
		x.xRealize = purego.NewCallback(func(SelfVarp uintptr, SurfaceVarp uintptr) {
			cb(MediaStreamNewFromInternalPtr(SelfVarp), gdk.SurfaceNewFromInternalPtr(SurfaceVarp))
		})
	}
}

// GetRealize gets the "realize" callback function.
func (x *MediaStreamClass) GetRealize() func(*MediaStream, *gdk.Surface) {
	if x.xRealize == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, SurfaceVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRealize)
	return func(SelfVar *MediaStream, SurfaceVar *gdk.Surface) {
		rawCallback(SelfVar.GoPointer(), SurfaceVar.GoPointer())
	}
}

// OverrideUnrealize sets the "unrealize" callback function.
func (x *MediaStreamClass) OverrideUnrealize(cb func(*MediaStream, *gdk.Surface)) {
	if cb == nil {
		x.xUnrealize = 0
	} else {
		x.xUnrealize = purego.NewCallback(func(SelfVarp uintptr, SurfaceVarp uintptr) {
			cb(MediaStreamNewFromInternalPtr(SelfVarp), gdk.SurfaceNewFromInternalPtr(SurfaceVarp))
		})
	}
}

// GetUnrealize gets the "unrealize" callback function.
func (x *MediaStreamClass) GetUnrealize() func(*MediaStream, *gdk.Surface) {
	if x.xUnrealize == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, SurfaceVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnrealize)
	return func(SelfVar *MediaStream, SurfaceVar *gdk.Surface) {
		rawCallback(SelfVar.GoPointer(), SurfaceVar.GoPointer())
	}
}

// OverrideGtkReserved1 sets the "_gtk_reserved1" callback function.
func (x *MediaStreamClass) OverrideGtkReserved1(cb func()) {
	if cb == nil {
		x.xGtkReserved1 = 0
	} else {
		x.xGtkReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved1 gets the "_gtk_reserved1" callback function.
func (x *MediaStreamClass) GetGtkReserved1() func() {
	if x.xGtkReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved2 sets the "_gtk_reserved2" callback function.
func (x *MediaStreamClass) OverrideGtkReserved2(cb func()) {
	if cb == nil {
		x.xGtkReserved2 = 0
	} else {
		x.xGtkReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved2 gets the "_gtk_reserved2" callback function.
func (x *MediaStreamClass) GetGtkReserved2() func() {
	if x.xGtkReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved3 sets the "_gtk_reserved3" callback function.
func (x *MediaStreamClass) OverrideGtkReserved3(cb func()) {
	if cb == nil {
		x.xGtkReserved3 = 0
	} else {
		x.xGtkReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved3 gets the "_gtk_reserved3" callback function.
func (x *MediaStreamClass) GetGtkReserved3() func() {
	if x.xGtkReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved4 sets the "_gtk_reserved4" callback function.
func (x *MediaStreamClass) OverrideGtkReserved4(cb func()) {
	if cb == nil {
		x.xGtkReserved4 = 0
	} else {
		x.xGtkReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved4 gets the "_gtk_reserved4" callback function.
func (x *MediaStreamClass) GetGtkReserved4() func() {
	if x.xGtkReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved5 sets the "_gtk_reserved5" callback function.
func (x *MediaStreamClass) OverrideGtkReserved5(cb func()) {
	if cb == nil {
		x.xGtkReserved5 = 0
	} else {
		x.xGtkReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved5 gets the "_gtk_reserved5" callback function.
func (x *MediaStreamClass) GetGtkReserved5() func() {
	if x.xGtkReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved5)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved6 sets the "_gtk_reserved6" callback function.
func (x *MediaStreamClass) OverrideGtkReserved6(cb func()) {
	if cb == nil {
		x.xGtkReserved6 = 0
	} else {
		x.xGtkReserved6 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved6 gets the "_gtk_reserved6" callback function.
func (x *MediaStreamClass) GetGtkReserved6() func() {
	if x.xGtkReserved6 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved6)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved7 sets the "_gtk_reserved7" callback function.
func (x *MediaStreamClass) OverrideGtkReserved7(cb func()) {
	if cb == nil {
		x.xGtkReserved7 = 0
	} else {
		x.xGtkReserved7 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved7 gets the "_gtk_reserved7" callback function.
func (x *MediaStreamClass) GetGtkReserved7() func() {
	if x.xGtkReserved7 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved7)
	return func() {
		rawCallback()
	}
}

// OverrideGtkReserved8 sets the "_gtk_reserved8" callback function.
func (x *MediaStreamClass) OverrideGtkReserved8(cb func()) {
	if cb == nil {
		x.xGtkReserved8 = 0
	} else {
		x.xGtkReserved8 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGtkReserved8 gets the "_gtk_reserved8" callback function.
func (x *MediaStreamClass) GetGtkReserved8() func() {
	if x.xGtkReserved8 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGtkReserved8)
	return func() {
		rawCallback()
	}
}

// The integration point for media playback inside GTK.
//
// GTK provides an implementation of the `GtkMediaStream` interface that
// is called [class@Gtk.MediaFile].
//
// Apart from application-facing API for stream playback, `GtkMediaStream`
// has a number of APIs that are only useful for implementations and should
// not be used in applications:
// [method@Gtk.MediaStream.prepared],
// [method@Gtk.MediaStream.unprepared],
// [method@Gtk.MediaStream.update],
// [method@Gtk.MediaStream.ended],
// [method@Gtk.MediaStream.seek_success],
// [method@Gtk.MediaStream.seek_failed],
// [method@Gtk.MediaStream.gerror],
// [method@Gtk.MediaStream.error],
// [method@Gtk.MediaStream.error_valist].
type MediaStream struct {
	gobject.Object
}

var xMediaStreamGLibType func() types.GType

func MediaStreamGLibType() types.GType {
	return xMediaStreamGLibType()
}

func MediaStreamNewFromInternalPtr(ptr uintptr) *MediaStream {
	cls := &MediaStream{}
	cls.Ptr = ptr
	return cls
}

var xMediaStreamEnded func(uintptr)

// Pauses the media stream and marks it as ended.
//
// This is a hint only, calls to [method@Gtk.MediaStream.play]
// may still happen.
//
// The media stream must be prepared when this function is called.
func (x *MediaStream) Ended() {

	xMediaStreamEnded(x.GoPointer())

}

var xMediaStreamError func(uintptr, glib.Quark, int, string, ...interface{})

// Sets @self into an error state using a printf()-style format string.
//
// This is a utility function that calls [method@Gtk.MediaStream.gerror].
// See that function for details.
func (x *MediaStream) Error(DomainVar glib.Quark, CodeVar int, FormatVar string, varArgs ...interface{}) {

	xMediaStreamError(x.GoPointer(), DomainVar, CodeVar, FormatVar, varArgs...)

}

var xMediaStreamErrorValist func(uintptr, glib.Quark, int, string, []interface{})

// Sets @self into an error state using a printf()-style format string.
//
// This is a utility function that calls [method@Gtk.MediaStream.gerror].
// See that function for details.
func (x *MediaStream) ErrorValist(DomainVar glib.Quark, CodeVar int, FormatVar string, ArgsVar []interface{}) {

	xMediaStreamErrorValist(x.GoPointer(), DomainVar, CodeVar, FormatVar, ArgsVar)

}

var xMediaStreamGerror func(uintptr, *glib.Error)

// Sets @self into an error state.
//
// This will pause the stream (you can check for an error
// via [method@Gtk.MediaStream.get_error] in your
// GtkMediaStream.pause() implementation), abort pending
// seeks and mark the stream as prepared.
//
// if the stream is already in an error state, this call
// will be ignored and the existing error will be retained.
//
// To unset an error, the stream must be reset via a call to
// [method@Gtk.MediaStream.unprepared].
func (x *MediaStream) Gerror(ErrorVar *glib.Error) {

	xMediaStreamGerror(x.GoPointer(), ErrorVar)

}

var xMediaStreamGetDuration func(uintptr) int64

// Gets the duration of the stream.
//
// If the duration is not known, 0 will be returned.
func (x *MediaStream) GetDuration() int64 {

	cret := xMediaStreamGetDuration(x.GoPointer())

	return cret
}

var xMediaStreamGetEnded func(uintptr) bool

// Returns whether the streams playback is finished.
func (x *MediaStream) GetEnded() bool {

	cret := xMediaStreamGetEnded(x.GoPointer())

	return cret
}

var xMediaStreamGetError func(uintptr) *glib.Error

// If the stream is in an error state, returns the `GError`
// explaining that state.
//
// Any type of error can be reported here depending on the
// implementation of the media stream.
//
// A media stream in an error cannot be operated on, calls
// like [method@Gtk.MediaStream.play] or
// [method@Gtk.MediaStream.seek] will not have any effect.
//
// `GtkMediaStream` itself does not provide a way to unset
// an error, but implementations may provide options. For example,
// a [class@Gtk.MediaFile] will unset errors when a new source is
// set, e.g. with [method@Gtk.MediaFile.set_file].
func (x *MediaStream) GetError() *glib.Error {

	cret := xMediaStreamGetError(x.GoPointer())

	return cret
}

var xMediaStreamGetLoop func(uintptr) bool

// Returns whether the stream is set to loop.
//
// See [method@Gtk.MediaStream.set_loop] for details.
func (x *MediaStream) GetLoop() bool {

	cret := xMediaStreamGetLoop(x.GoPointer())

	return cret
}

var xMediaStreamGetMuted func(uintptr) bool

// Returns whether the audio for the stream is muted.
//
// See [method@Gtk.MediaStream.set_muted] for details.
func (x *MediaStream) GetMuted() bool {

	cret := xMediaStreamGetMuted(x.GoPointer())

	return cret
}

var xMediaStreamGetPlaying func(uintptr) bool

// Return whether the stream is currently playing.
func (x *MediaStream) GetPlaying() bool {

	cret := xMediaStreamGetPlaying(x.GoPointer())

	return cret
}

var xMediaStreamGetTimestamp func(uintptr) int64

// Returns the current presentation timestamp in microseconds.
func (x *MediaStream) GetTimestamp() int64 {

	cret := xMediaStreamGetTimestamp(x.GoPointer())

	return cret
}

var xMediaStreamGetVolume func(uintptr) float64

// Returns the volume of the audio for the stream.
//
// See [method@Gtk.MediaStream.set_volume] for details.
func (x *MediaStream) GetVolume() float64 {

	cret := xMediaStreamGetVolume(x.GoPointer())

	return cret
}

var xMediaStreamHasAudio func(uintptr) bool

// Returns whether the stream has audio.
func (x *MediaStream) HasAudio() bool {

	cret := xMediaStreamHasAudio(x.GoPointer())

	return cret
}

var xMediaStreamHasVideo func(uintptr) bool

// Returns whether the stream has video.
func (x *MediaStream) HasVideo() bool {

	cret := xMediaStreamHasVideo(x.GoPointer())

	return cret
}

var xMediaStreamIsPrepared func(uintptr) bool

// Returns whether the stream has finished initializing.
//
// At this point the existence of audio and video is known.
func (x *MediaStream) IsPrepared() bool {

	cret := xMediaStreamIsPrepared(x.GoPointer())

	return cret
}

var xMediaStreamIsSeekable func(uintptr) bool

// Checks if a stream may be seekable.
//
// This is meant to be a hint. Streams may not allow seeking even if
// this function returns %TRUE. However, if this function returns
// %FALSE, streams are guaranteed to not be seekable and user interfaces
// may hide controls that allow seeking.
//
// It is allowed to call [method@Gtk.MediaStream.seek] on a non-seekable
// stream, though it will not do anything.
func (x *MediaStream) IsSeekable() bool {

	cret := xMediaStreamIsSeekable(x.GoPointer())

	return cret
}

var xMediaStreamIsSeeking func(uintptr) bool

// Checks if there is currently a seek operation going on.
func (x *MediaStream) IsSeeking() bool {

	cret := xMediaStreamIsSeeking(x.GoPointer())

	return cret
}

var xMediaStreamPause func(uintptr)

// Pauses playback of the stream.
//
// If the stream is not playing, do nothing.
func (x *MediaStream) Pause() {

	xMediaStreamPause(x.GoPointer())

}

var xMediaStreamPlay func(uintptr)

// Starts playing the stream.
//
// If the stream is in error or already playing, do nothing.
func (x *MediaStream) Play() {

	xMediaStreamPlay(x.GoPointer())

}

var xMediaStreamPrepared func(uintptr, bool, bool, bool, int64)

// Same as gtk_media_stream_stream_prepared().
func (x *MediaStream) Prepared(HasAudioVar bool, HasVideoVar bool, SeekableVar bool, DurationVar int64) {

	xMediaStreamPrepared(x.GoPointer(), HasAudioVar, HasVideoVar, SeekableVar, DurationVar)

}

var xMediaStreamRealize func(uintptr, uintptr)

// Called by users to attach the media stream to a `GdkSurface` they manage.
//
// The stream can then access the resources of @surface for its
// rendering purposes. In particular, media streams might want to
// create a `GdkGLContext` or sync to the `GdkFrameClock`.
//
// Whoever calls this function is responsible for calling
// [method@Gtk.MediaStream.unrealize] before either the stream
// or @surface get destroyed.
//
// Multiple calls to this function may happen from different
// users of the video, even with the same @surface. Each of these
// calls must be followed by its own call to
// [method@Gtk.MediaStream.unrealize].
//
// It is not required to call this function to make a media stream work.
func (x *MediaStream) Realize(SurfaceVar *gdk.Surface) {

	xMediaStreamRealize(x.GoPointer(), SurfaceVar.GoPointer())

}

var xMediaStreamSeek func(uintptr, int64)

// Start a seek operation on @self to @timestamp.
//
// If @timestamp is out of range, it will be clamped.
//
// Seek operations may not finish instantly. While a
// seek operation is in process, the [property@Gtk.MediaStream:seeking]
// property will be set.
//
// When calling gtk_media_stream_seek() during an
// ongoing seek operation, the new seek will override
// any pending seek.
func (x *MediaStream) Seek(TimestampVar int64) {

	xMediaStreamSeek(x.GoPointer(), TimestampVar)

}

var xMediaStreamSeekFailed func(uintptr)

// Ends a seek operation started via GtkMediaStream.seek() as a failure.
//
// This will not cause an error on the stream and will assume that
// playback continues as if no seek had happened.
//
// See [method@Gtk.MediaStream.seek_success] for the other way of
// ending a seek.
func (x *MediaStream) SeekFailed() {

	xMediaStreamSeekFailed(x.GoPointer())

}

var xMediaStreamSeekSuccess func(uintptr)

// Ends a seek operation started via GtkMediaStream.seek() successfully.
//
// This function will unset the GtkMediaStream:ended property
// if it was set.
//
// See [method@Gtk.MediaStream.seek_failed] for the other way of
// ending a seek.
func (x *MediaStream) SeekSuccess() {

	xMediaStreamSeekSuccess(x.GoPointer())

}

var xMediaStreamSetLoop func(uintptr, bool)

// Sets whether the stream should loop.
//
// In this case, it will attempt to restart playback
// from the beginning instead of stopping at the end.
//
// Not all streams may support looping, in particular
// non-seekable streams. Those streams will ignore the
// loop setting and just end.
func (x *MediaStream) SetLoop(LoopVar bool) {

	xMediaStreamSetLoop(x.GoPointer(), LoopVar)

}

var xMediaStreamSetMuted func(uintptr, bool)

// Sets whether the audio stream should be muted.
//
// Muting a stream will cause no audio to be played, but it
// does not modify the volume. This means that muting and
// then unmuting the stream will restore the volume settings.
//
// If the stream has no audio, calling this function will
// still work but it will not have an audible effect.
func (x *MediaStream) SetMuted(MutedVar bool) {

	xMediaStreamSetMuted(x.GoPointer(), MutedVar)

}

var xMediaStreamSetPlaying func(uintptr, bool)

// Starts or pauses playback of the stream.
func (x *MediaStream) SetPlaying(PlayingVar bool) {

	xMediaStreamSetPlaying(x.GoPointer(), PlayingVar)

}

var xMediaStreamSetVolume func(uintptr, float64)

// Sets the volume of the audio stream.
//
// This function call will work even if the stream is muted.
//
// The given @volume should range from 0.0 for silence to 1.0
// for as loud as possible. Values outside of this range will
// be clamped to the nearest value.
//
// If the stream has no audio or is muted, calling this function
// will still work but it will not have an immediate audible effect.
// When the stream is unmuted, the new volume setting will take effect.
func (x *MediaStream) SetVolume(VolumeVar float64) {

	xMediaStreamSetVolume(x.GoPointer(), VolumeVar)

}

var xMediaStreamStreamEnded func(uintptr)

// Pauses the media stream and marks it as ended.
//
// This is a hint only, calls to [method@Gtk.MediaStream.play]
// may still happen.
//
// The media stream must be prepared when this function is called.
func (x *MediaStream) StreamEnded() {

	xMediaStreamStreamEnded(x.GoPointer())

}

var xMediaStreamStreamPrepared func(uintptr, bool, bool, bool, int64)

// Called by `GtkMediaStream` implementations to advertise the stream
// being ready to play and providing details about the stream.
//
// Note that the arguments are hints. If the stream implementation
// cannot determine the correct values, it is better to err on the
// side of caution and return %TRUE. User interfaces will use those
// values to determine what controls to show.
//
// This function may not be called again until the stream has been
// reset via [method@Gtk.MediaStream.stream_unprepared].
func (x *MediaStream) StreamPrepared(HasAudioVar bool, HasVideoVar bool, SeekableVar bool, DurationVar int64) {

	xMediaStreamStreamPrepared(x.GoPointer(), HasAudioVar, HasVideoVar, SeekableVar, DurationVar)

}

var xMediaStreamStreamUnprepared func(uintptr)

// Resets a given media stream implementation.
//
// [method@Gtk.MediaStream.stream_prepared] can then be called again.
//
// This function will also reset any error state the stream was in.
func (x *MediaStream) StreamUnprepared() {

	xMediaStreamStreamUnprepared(x.GoPointer())

}

var xMediaStreamUnprepared func(uintptr)

// Same as gtk_media_stream_stream_unprepared().
func (x *MediaStream) Unprepared() {

	xMediaStreamUnprepared(x.GoPointer())

}

var xMediaStreamUnrealize func(uintptr, uintptr)

// Undoes a previous call to gtk_media_stream_realize().
//
// This causes the stream to release all resources it had
// allocated from @surface.
func (x *MediaStream) Unrealize(SurfaceVar *gdk.Surface) {

	xMediaStreamUnrealize(x.GoPointer(), SurfaceVar.GoPointer())

}

var xMediaStreamUpdate func(uintptr, int64)

// Media stream implementations should regularly call this
// function to update the timestamp reported by the stream.
//
// It is up to implementations to call this at the frequency
// they deem appropriate.
//
// The media stream must be prepared when this function is called.
func (x *MediaStream) Update(TimestampVar int64) {

	xMediaStreamUpdate(x.GoPointer(), TimestampVar)

}

func (c *MediaStream) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *MediaStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// GetPropertyDuration gets the "duration" property.
// The stream's duration in microseconds or 0 if unknown.
func (x *MediaStream) GetPropertyDuration() int64 {
	var v gobject.Value
	x.GetProperty("duration", &v)
	return v.GetInt64()
}

// GetPropertyEnded gets the "ended" property.
// Set when playback has finished.
func (x *MediaStream) GetPropertyEnded() bool {
	var v gobject.Value
	x.GetProperty("ended", &v)
	return v.GetBoolean()
}

// GetPropertyError gets the "error" property.
// %NULL for a properly working stream or the `GError`
// that the stream is in.
func (x *MediaStream) GetPropertyError() uintptr {
	var v gobject.Value
	x.GetProperty("error", &v)
	return v.GetPointer()
}

// GetPropertyHasAudio gets the "has-audio" property.
// Whether the stream contains audio.
func (x *MediaStream) GetPropertyHasAudio() bool {
	var v gobject.Value
	x.GetProperty("has-audio", &v)
	return v.GetBoolean()
}

// GetPropertyHasVideo gets the "has-video" property.
// Whether the stream contains video.
func (x *MediaStream) GetPropertyHasVideo() bool {
	var v gobject.Value
	x.GetProperty("has-video", &v)
	return v.GetBoolean()
}

// SetPropertyLoop sets the "loop" property.
// Try to restart the media from the beginning once it ended.
func (x *MediaStream) SetPropertyLoop(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("loop", &v)
}

// GetPropertyLoop gets the "loop" property.
// Try to restart the media from the beginning once it ended.
func (x *MediaStream) GetPropertyLoop() bool {
	var v gobject.Value
	x.GetProperty("loop", &v)
	return v.GetBoolean()
}

// SetPropertyMuted sets the "muted" property.
// Whether the audio stream should be muted.
func (x *MediaStream) SetPropertyMuted(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("muted", &v)
}

// GetPropertyMuted gets the "muted" property.
// Whether the audio stream should be muted.
func (x *MediaStream) GetPropertyMuted() bool {
	var v gobject.Value
	x.GetProperty("muted", &v)
	return v.GetBoolean()
}

// SetPropertyPlaying sets the "playing" property.
// Whether the stream is currently playing.
func (x *MediaStream) SetPropertyPlaying(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("playing", &v)
}

// GetPropertyPlaying gets the "playing" property.
// Whether the stream is currently playing.
func (x *MediaStream) GetPropertyPlaying() bool {
	var v gobject.Value
	x.GetProperty("playing", &v)
	return v.GetBoolean()
}

// GetPropertyPrepared gets the "prepared" property.
// Whether the stream has finished initializing and existence of
// audio and video is known.
func (x *MediaStream) GetPropertyPrepared() bool {
	var v gobject.Value
	x.GetProperty("prepared", &v)
	return v.GetBoolean()
}

// GetPropertySeekable gets the "seekable" property.
// Set unless the stream is known to not support seeking.
func (x *MediaStream) GetPropertySeekable() bool {
	var v gobject.Value
	x.GetProperty("seekable", &v)
	return v.GetBoolean()
}

// GetPropertySeeking gets the "seeking" property.
// Set while a seek is in progress.
func (x *MediaStream) GetPropertySeeking() bool {
	var v gobject.Value
	x.GetProperty("seeking", &v)
	return v.GetBoolean()
}

// GetPropertyTimestamp gets the "timestamp" property.
// The current presentation timestamp in microseconds.
func (x *MediaStream) GetPropertyTimestamp() int64 {
	var v gobject.Value
	x.GetProperty("timestamp", &v)
	return v.GetInt64()
}

// SetPropertyVolume sets the "volume" property.
// Volume of the audio stream.
func (x *MediaStream) SetPropertyVolume(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("volume", &v)
}

// GetPropertyVolume gets the "volume" property.
// Volume of the audio stream.
func (x *MediaStream) GetPropertyVolume() float64 {
	var v gobject.Value
	x.GetProperty("volume", &v)
	return v.GetDouble()
}

// Compute a concrete size for the `GdkPaintable`.
//
// Applies the sizing algorithm outlined in the
// [CSS Image spec](https://drafts.csswg.org/css-images-3/#default-sizing)
// to the given @paintable. See that link for more details.
//
// It is not necessary to call this function when both @specified_width
// and @specified_height are known, but it is useful to call this
// function in GtkWidget:measure implementations to compute the
// other dimension when only one dimension is given.
func (x *MediaStream) ComputeConcreteSize(SpecifiedWidthVar float64, SpecifiedHeightVar float64, DefaultWidthVar float64, DefaultHeightVar float64, ConcreteWidthVar *float64, ConcreteHeightVar *float64) {

	gdk.XGdkPaintableComputeConcreteSize(x.GoPointer(), SpecifiedWidthVar, SpecifiedHeightVar, DefaultWidthVar, DefaultHeightVar, ConcreteWidthVar, ConcreteHeightVar)

}

// Gets an immutable paintable for the current contents displayed by @paintable.
//
// This is useful when you want to retain the current state of an animation,
// for example to take a screenshot of a running animation.
//
// If the @paintable is already immutable, it will return itself.
func (x *MediaStream) GetCurrentImage() *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := gdk.XGdkPaintableGetCurrentImage(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

// Get flags for the paintable.
//
// This is oftentimes useful for optimizations.
//
// See [flags@Gdk.PaintableFlags] for the flags and what they mean.
func (x *MediaStream) GetFlags() gdk.PaintableFlags {

	cret := gdk.XGdkPaintableGetFlags(x.GoPointer())

	return cret
}

// Gets the preferred aspect ratio the @paintable would like to be displayed at.
//
// The aspect ratio is the width divided by the height, so a value of 0.5
// means that the @paintable prefers to be displayed twice as high as it
// is wide. Consumers of this interface can use this to preserve aspect
// ratio when displaying the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// Usually when a @paintable returns nonzero values from
// [method@Gdk.Paintable.get_intrinsic_width] and
// [method@Gdk.Paintable.get_intrinsic_height] the aspect ratio
// should conform to those values, though that is not required.
//
// If the @paintable does not have a preferred aspect ratio,
// it returns 0. Negative values are never returned.
func (x *MediaStream) GetIntrinsicAspectRatio() float64 {

	cret := gdk.XGdkPaintableGetIntrinsicAspectRatio(x.GoPointer())

	return cret
}

// Gets the preferred height the @paintable would like to be displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw
// the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// If the @paintable does not have a preferred height, it returns 0.
// Negative values are never returned.
func (x *MediaStream) GetIntrinsicHeight() int {

	cret := gdk.XGdkPaintableGetIntrinsicHeight(x.GoPointer())

	return cret
}

// Gets the preferred width the @paintable would like to be displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw
// the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// If the @paintable does not have a preferred width, it returns 0.
// Negative values are never returned.
func (x *MediaStream) GetIntrinsicWidth() int {

	cret := gdk.XGdkPaintableGetIntrinsicWidth(x.GoPointer())

	return cret
}

// Called by implementations of `GdkPaintable` to invalidate their contents.
//
// Unless the contents are invalidated, implementations must guarantee that
// multiple calls of [method@Gdk.Paintable.snapshot] produce the same output.
//
// This function will emit the [signal@Gdk.Paintable::invalidate-contents]
// signal.
//
// If a @paintable reports the %GDK_PAINTABLE_STATIC_CONTENTS flag,
// it must not call this function.
func (x *MediaStream) InvalidateContents() {

	gdk.XGdkPaintableInvalidateContents(x.GoPointer())

}

// Called by implementations of `GdkPaintable` to invalidate their size.
//
// As long as the size is not invalidated, @paintable must return the same
// values for its intrinsic width, height and aspect ratio.
//
// This function will emit the [signal@Gdk.Paintable::invalidate-size]
// signal.
//
// If a @paintable reports the %GDK_PAINTABLE_STATIC_SIZE flag,
// it must not call this function.
func (x *MediaStream) InvalidateSize() {

	gdk.XGdkPaintableInvalidateSize(x.GoPointer())

}

// Snapshots the given paintable with the given @width and @height.
//
// The paintable is drawn at the current (0,0) offset of the @snapshot.
// If @width and @height are not larger than zero, this function will
// do nothing.
func (x *MediaStream) Snapshot(SnapshotVar *gdk.Snapshot, WidthVar float64, HeightVar float64) {

	gdk.XGdkPaintableSnapshot(x.GoPointer(), SnapshotVar.GoPointer(), WidthVar, HeightVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMediaStreamGLibType, libs, "gtk_media_stream_get_type")

	core.PuregoSafeRegister(&xMediaStreamEnded, libs, "gtk_media_stream_ended")
	core.PuregoSafeRegister(&xMediaStreamError, libs, "gtk_media_stream_error")
	core.PuregoSafeRegister(&xMediaStreamErrorValist, libs, "gtk_media_stream_error_valist")
	core.PuregoSafeRegister(&xMediaStreamGerror, libs, "gtk_media_stream_gerror")
	core.PuregoSafeRegister(&xMediaStreamGetDuration, libs, "gtk_media_stream_get_duration")
	core.PuregoSafeRegister(&xMediaStreamGetEnded, libs, "gtk_media_stream_get_ended")
	core.PuregoSafeRegister(&xMediaStreamGetError, libs, "gtk_media_stream_get_error")
	core.PuregoSafeRegister(&xMediaStreamGetLoop, libs, "gtk_media_stream_get_loop")
	core.PuregoSafeRegister(&xMediaStreamGetMuted, libs, "gtk_media_stream_get_muted")
	core.PuregoSafeRegister(&xMediaStreamGetPlaying, libs, "gtk_media_stream_get_playing")
	core.PuregoSafeRegister(&xMediaStreamGetTimestamp, libs, "gtk_media_stream_get_timestamp")
	core.PuregoSafeRegister(&xMediaStreamGetVolume, libs, "gtk_media_stream_get_volume")
	core.PuregoSafeRegister(&xMediaStreamHasAudio, libs, "gtk_media_stream_has_audio")
	core.PuregoSafeRegister(&xMediaStreamHasVideo, libs, "gtk_media_stream_has_video")
	core.PuregoSafeRegister(&xMediaStreamIsPrepared, libs, "gtk_media_stream_is_prepared")
	core.PuregoSafeRegister(&xMediaStreamIsSeekable, libs, "gtk_media_stream_is_seekable")
	core.PuregoSafeRegister(&xMediaStreamIsSeeking, libs, "gtk_media_stream_is_seeking")
	core.PuregoSafeRegister(&xMediaStreamPause, libs, "gtk_media_stream_pause")
	core.PuregoSafeRegister(&xMediaStreamPlay, libs, "gtk_media_stream_play")
	core.PuregoSafeRegister(&xMediaStreamPrepared, libs, "gtk_media_stream_prepared")
	core.PuregoSafeRegister(&xMediaStreamRealize, libs, "gtk_media_stream_realize")
	core.PuregoSafeRegister(&xMediaStreamSeek, libs, "gtk_media_stream_seek")
	core.PuregoSafeRegister(&xMediaStreamSeekFailed, libs, "gtk_media_stream_seek_failed")
	core.PuregoSafeRegister(&xMediaStreamSeekSuccess, libs, "gtk_media_stream_seek_success")
	core.PuregoSafeRegister(&xMediaStreamSetLoop, libs, "gtk_media_stream_set_loop")
	core.PuregoSafeRegister(&xMediaStreamSetMuted, libs, "gtk_media_stream_set_muted")
	core.PuregoSafeRegister(&xMediaStreamSetPlaying, libs, "gtk_media_stream_set_playing")
	core.PuregoSafeRegister(&xMediaStreamSetVolume, libs, "gtk_media_stream_set_volume")
	core.PuregoSafeRegister(&xMediaStreamStreamEnded, libs, "gtk_media_stream_stream_ended")
	core.PuregoSafeRegister(&xMediaStreamStreamPrepared, libs, "gtk_media_stream_stream_prepared")
	core.PuregoSafeRegister(&xMediaStreamStreamUnprepared, libs, "gtk_media_stream_stream_unprepared")
	core.PuregoSafeRegister(&xMediaStreamUnprepared, libs, "gtk_media_stream_unprepared")
	core.PuregoSafeRegister(&xMediaStreamUnrealize, libs, "gtk_media_stream_unrealize")
	core.PuregoSafeRegister(&xMediaStreamUpdate, libs, "gtk_media_stream_update")

}
