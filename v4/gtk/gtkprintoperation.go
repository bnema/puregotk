// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The type of function that is passed to
// gtk_print_run_page_setup_dialog_async().
//
// This function will be called when the page setup dialog
// is dismissed, and also serves as destroy notify for @data.
type PageSetupDoneFunc func(uintptr, uintptr)

type PrintOperationClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xDone uintptr

	xBeginPrint uintptr

	xPaginate uintptr

	xRequestPageSetup uintptr

	xDrawPage uintptr

	xEndPrint uintptr

	xStatusChanged uintptr

	xCreateCustomWidget uintptr

	xCustomWidgetApply uintptr

	xPreview uintptr

	xUpdateCustomWidget uintptr

	Padding [8]uintptr
}

func (x *PrintOperationClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideDone sets the "done" callback function.
// Signal emitted when the print operation run has finished
//
//	doing everything required for printing.
func (x *PrintOperationClass) OverrideDone(cb func(*PrintOperation, PrintOperationResult)) {
	if cb == nil {
		x.xDone = 0
	} else {
		x.xDone = purego.NewCallback(func(OperationVarp uintptr, ResultVarp PrintOperationResult) {
			cb(PrintOperationNewFromInternalPtr(OperationVarp), ResultVarp)
		})
	}
}

// GetDone gets the "done" callback function.
// Signal emitted when the print operation run has finished
//
//	doing everything required for printing.
func (x *PrintOperationClass) GetDone() func(*PrintOperation, PrintOperationResult) {
	if x.xDone == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, ResultVarp PrintOperationResult)
	purego.RegisterFunc(&rawCallback, x.xDone)
	return func(OperationVar *PrintOperation, ResultVar PrintOperationResult) {
		rawCallback(OperationVar.GoPointer(), ResultVar)
	}
}

// OverrideBeginPrint sets the "begin_print" callback function.
// Signal emitted after the user has finished changing
//
//	print settings in the dialog, before the actual rendering starts.
func (x *PrintOperationClass) OverrideBeginPrint(cb func(*PrintOperation, *PrintContext)) {
	if cb == nil {
		x.xBeginPrint = 0
	} else {
		x.xBeginPrint = purego.NewCallback(func(OperationVarp uintptr, ContextVarp uintptr) {
			cb(PrintOperationNewFromInternalPtr(OperationVarp), PrintContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetBeginPrint gets the "begin_print" callback function.
// Signal emitted after the user has finished changing
//
//	print settings in the dialog, before the actual rendering starts.
func (x *PrintOperationClass) GetBeginPrint() func(*PrintOperation, *PrintContext) {
	if x.xBeginPrint == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xBeginPrint)
	return func(OperationVar *PrintOperation, ContextVar *PrintContext) {
		rawCallback(OperationVar.GoPointer(), ContextVar.GoPointer())
	}
}

// OverridePaginate sets the "paginate" callback function.
// Signal emitted after the “begin-print” signal, but
//
//	before the actual rendering starts.
func (x *PrintOperationClass) OverridePaginate(cb func(*PrintOperation, *PrintContext) bool) {
	if cb == nil {
		x.xPaginate = 0
	} else {
		x.xPaginate = purego.NewCallback(func(OperationVarp uintptr, ContextVarp uintptr) bool {
			return cb(PrintOperationNewFromInternalPtr(OperationVarp), PrintContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetPaginate gets the "paginate" callback function.
// Signal emitted after the “begin-print” signal, but
//
//	before the actual rendering starts.
func (x *PrintOperationClass) GetPaginate() func(*PrintOperation, *PrintContext) bool {
	if x.xPaginate == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, ContextVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xPaginate)
	return func(OperationVar *PrintOperation, ContextVar *PrintContext) bool {
		return rawCallback(OperationVar.GoPointer(), ContextVar.GoPointer())
	}
}

// OverrideRequestPageSetup sets the "request_page_setup" callback function.
// Emitted once for every page that is printed,
//
//	to give the application a chance to modify the page setup.
func (x *PrintOperationClass) OverrideRequestPageSetup(cb func(*PrintOperation, *PrintContext, int, *PageSetup)) {
	if cb == nil {
		x.xRequestPageSetup = 0
	} else {
		x.xRequestPageSetup = purego.NewCallback(func(OperationVarp uintptr, ContextVarp uintptr, PageNrVarp int, SetupVarp uintptr) {
			cb(PrintOperationNewFromInternalPtr(OperationVarp), PrintContextNewFromInternalPtr(ContextVarp), PageNrVarp, PageSetupNewFromInternalPtr(SetupVarp))
		})
	}
}

// GetRequestPageSetup gets the "request_page_setup" callback function.
// Emitted once for every page that is printed,
//
//	to give the application a chance to modify the page setup.
func (x *PrintOperationClass) GetRequestPageSetup() func(*PrintOperation, *PrintContext, int, *PageSetup) {
	if x.xRequestPageSetup == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, ContextVarp uintptr, PageNrVarp int, SetupVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRequestPageSetup)
	return func(OperationVar *PrintOperation, ContextVar *PrintContext, PageNrVar int, SetupVar *PageSetup) {
		rawCallback(OperationVar.GoPointer(), ContextVar.GoPointer(), PageNrVar, SetupVar.GoPointer())
	}
}

// OverrideDrawPage sets the "draw_page" callback function.
// Signal emitted for every page that is printed.
func (x *PrintOperationClass) OverrideDrawPage(cb func(*PrintOperation, *PrintContext, int)) {
	if cb == nil {
		x.xDrawPage = 0
	} else {
		x.xDrawPage = purego.NewCallback(func(OperationVarp uintptr, ContextVarp uintptr, PageNrVarp int) {
			cb(PrintOperationNewFromInternalPtr(OperationVarp), PrintContextNewFromInternalPtr(ContextVarp), PageNrVarp)
		})
	}
}

// GetDrawPage gets the "draw_page" callback function.
// Signal emitted for every page that is printed.
func (x *PrintOperationClass) GetDrawPage() func(*PrintOperation, *PrintContext, int) {
	if x.xDrawPage == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, ContextVarp uintptr, PageNrVarp int)
	purego.RegisterFunc(&rawCallback, x.xDrawPage)
	return func(OperationVar *PrintOperation, ContextVar *PrintContext, PageNrVar int) {
		rawCallback(OperationVar.GoPointer(), ContextVar.GoPointer(), PageNrVar)
	}
}

// OverrideEndPrint sets the "end_print" callback function.
// Signal emitted after all pages have been rendered.
func (x *PrintOperationClass) OverrideEndPrint(cb func(*PrintOperation, *PrintContext)) {
	if cb == nil {
		x.xEndPrint = 0
	} else {
		x.xEndPrint = purego.NewCallback(func(OperationVarp uintptr, ContextVarp uintptr) {
			cb(PrintOperationNewFromInternalPtr(OperationVarp), PrintContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetEndPrint gets the "end_print" callback function.
// Signal emitted after all pages have been rendered.
func (x *PrintOperationClass) GetEndPrint() func(*PrintOperation, *PrintContext) {
	if x.xEndPrint == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, ContextVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEndPrint)
	return func(OperationVar *PrintOperation, ContextVar *PrintContext) {
		rawCallback(OperationVar.GoPointer(), ContextVar.GoPointer())
	}
}

// OverrideStatusChanged sets the "status_changed" callback function.
// Emitted at between the various phases of the print
//
//	operation.
func (x *PrintOperationClass) OverrideStatusChanged(cb func(*PrintOperation)) {
	if cb == nil {
		x.xStatusChanged = 0
	} else {
		x.xStatusChanged = purego.NewCallback(func(OperationVarp uintptr) {
			cb(PrintOperationNewFromInternalPtr(OperationVarp))
		})
	}
}

// GetStatusChanged gets the "status_changed" callback function.
// Emitted at between the various phases of the print
//
//	operation.
func (x *PrintOperationClass) GetStatusChanged() func(*PrintOperation) {
	if x.xStatusChanged == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xStatusChanged)
	return func(OperationVar *PrintOperation) {
		rawCallback(OperationVar.GoPointer())
	}
}

// OverrideCreateCustomWidget sets the "create_custom_widget" callback function.
// Signal emitted when displaying the print dialog.
func (x *PrintOperationClass) OverrideCreateCustomWidget(cb func(*PrintOperation) *Widget) {
	if cb == nil {
		x.xCreateCustomWidget = 0
	} else {
		x.xCreateCustomWidget = purego.NewCallback(func(OperationVarp uintptr) uintptr {
			ret := cb(PrintOperationNewFromInternalPtr(OperationVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetCreateCustomWidget gets the "create_custom_widget" callback function.
// Signal emitted when displaying the print dialog.
func (x *PrintOperationClass) GetCreateCustomWidget() func(*PrintOperation) *Widget {
	if x.xCreateCustomWidget == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xCreateCustomWidget)
	return func(OperationVar *PrintOperation) *Widget {
		rawRet := rawCallback(OperationVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &Widget{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCustomWidgetApply sets the "custom_widget_apply" callback function.
// Signal emitted right before “begin-print” if
//
//	you added a custom widget in the “create-custom-widget” handler.
func (x *PrintOperationClass) OverrideCustomWidgetApply(cb func(*PrintOperation, *Widget)) {
	if cb == nil {
		x.xCustomWidgetApply = 0
	} else {
		x.xCustomWidgetApply = purego.NewCallback(func(OperationVarp uintptr, WidgetVarp uintptr) {
			cb(PrintOperationNewFromInternalPtr(OperationVarp), WidgetNewFromInternalPtr(WidgetVarp))
		})
	}
}

// GetCustomWidgetApply gets the "custom_widget_apply" callback function.
// Signal emitted right before “begin-print” if
//
//	you added a custom widget in the “create-custom-widget” handler.
func (x *PrintOperationClass) GetCustomWidgetApply() func(*PrintOperation, *Widget) {
	if x.xCustomWidgetApply == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, WidgetVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCustomWidgetApply)
	return func(OperationVar *PrintOperation, WidgetVar *Widget) {
		rawCallback(OperationVar.GoPointer(), WidgetVar.GoPointer())
	}
}

// OverridePreview sets the "preview" callback function.
// Signal emitted when a preview is requested from the
//
//	native dialog.
func (x *PrintOperationClass) OverridePreview(cb func(*PrintOperation, PrintOperationPreview, *PrintContext, *Window) bool) {
	if cb == nil {
		x.xPreview = 0
	} else {
		x.xPreview = purego.NewCallback(func(OperationVarp uintptr, PreviewVarp uintptr, ContextVarp uintptr, ParentVarp uintptr) bool {
			return cb(PrintOperationNewFromInternalPtr(OperationVarp), &PrintOperationPreviewBase{Ptr: PreviewVarp}, PrintContextNewFromInternalPtr(ContextVarp), WindowNewFromInternalPtr(ParentVarp))
		})
	}
}

// GetPreview gets the "preview" callback function.
// Signal emitted when a preview is requested from the
//
//	native dialog.
func (x *PrintOperationClass) GetPreview() func(*PrintOperation, PrintOperationPreview, *PrintContext, *Window) bool {
	if x.xPreview == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, PreviewVarp uintptr, ContextVarp uintptr, ParentVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xPreview)
	return func(OperationVar *PrintOperation, PreviewVar PrintOperationPreview, ContextVar *PrintContext, ParentVar *Window) bool {
		return rawCallback(OperationVar.GoPointer(), PreviewVar.GoPointer(), ContextVar.GoPointer(), ParentVar.GoPointer())
	}
}

// OverrideUpdateCustomWidget sets the "update_custom_widget" callback function.
// Emitted after change of selected printer.
func (x *PrintOperationClass) OverrideUpdateCustomWidget(cb func(*PrintOperation, *Widget, *PageSetup, *PrintSettings)) {
	if cb == nil {
		x.xUpdateCustomWidget = 0
	} else {
		x.xUpdateCustomWidget = purego.NewCallback(func(OperationVarp uintptr, WidgetVarp uintptr, SetupVarp uintptr, SettingsVarp uintptr) {
			cb(PrintOperationNewFromInternalPtr(OperationVarp), WidgetNewFromInternalPtr(WidgetVarp), PageSetupNewFromInternalPtr(SetupVarp), PrintSettingsNewFromInternalPtr(SettingsVarp))
		})
	}
}

// GetUpdateCustomWidget gets the "update_custom_widget" callback function.
// Emitted after change of selected printer.
func (x *PrintOperationClass) GetUpdateCustomWidget() func(*PrintOperation, *Widget, *PageSetup, *PrintSettings) {
	if x.xUpdateCustomWidget == 0 {
		return nil
	}
	var rawCallback func(OperationVarp uintptr, WidgetVarp uintptr, SetupVarp uintptr, SettingsVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUpdateCustomWidget)
	return func(OperationVar *PrintOperation, WidgetVar *Widget, SetupVar *PageSetup, SettingsVar *PrintSettings) {
		rawCallback(OperationVar.GoPointer(), WidgetVar.GoPointer(), SetupVar.GoPointer(), SettingsVar.GoPointer())
	}
}

type PrintOperationPrivate struct {
	_ structs.HostLayout
}

func (x *PrintOperationPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError int

var xPrintErrorGLibType func() types.GType

func PrintErrorGLibType() types.GType {
	return xPrintErrorGLibType()
}

const (

	// An unspecified error occurred.
	PrintErrorGeneralValue PrintError = 0
	// An internal error occurred.
	PrintErrorInternalErrorValue PrintError = 1
	// A memory allocation failed.
	PrintErrorNomemValue PrintError = 2
	// An error occurred while loading a page setup
	//   or paper size from a key file.
	PrintErrorInvalidFileValue PrintError = 3
)

// Determines what action the print operation should perform.
//
// A parameter of this typs is passed to [method@Gtk.PrintOperation.run].
type PrintOperationAction int

var xPrintOperationActionGLibType func() types.GType

func PrintOperationActionGLibType() types.GType {
	return xPrintOperationActionGLibType()
}

const (

	// Show the print dialog.
	PrintOperationActionPrintDialogValue PrintOperationAction = 0
	// Start to print without showing
	//   the print dialog, based on the current print settings, if possible.
	//   Depending on the platform, a print dialog might appear anyway.
	PrintOperationActionPrintValue PrintOperationAction = 1
	// Show the print preview.
	PrintOperationActionPreviewValue PrintOperationAction = 2
	// Export to a file. This requires
	//   the export-filename property to be set.
	PrintOperationActionExportValue PrintOperationAction = 3
)

// The result of a print operation.
//
// A value of this type is returned by [method@Gtk.PrintOperation.run].
type PrintOperationResult int

var xPrintOperationResultGLibType func() types.GType

func PrintOperationResultGLibType() types.GType {
	return xPrintOperationResultGLibType()
}

const (

	// An error has occurred.
	PrintOperationResultErrorValue PrintOperationResult = 0
	// The print settings should be stored.
	PrintOperationResultApplyValue PrintOperationResult = 1
	// The print operation has been canceled,
	//   the print settings should not be stored.
	PrintOperationResultCancelValue PrintOperationResult = 2
	// The print operation is not complete
	//   yet. This value will only be returned when running asynchronously.
	PrintOperationResultInProgressValue PrintOperationResult = 3
)

// The status gives a rough indication of the completion of a running
// print operation.
type PrintStatus int

var xPrintStatusGLibType func() types.GType

func PrintStatusGLibType() types.GType {
	return xPrintStatusGLibType()
}

const (

	// The printing has not started yet; this
	//   status is set initially, and while the print dialog is shown.
	PrintStatusInitialValue PrintStatus = 0
	// This status is set while the begin-print
	//   signal is emitted and during pagination.
	PrintStatusPreparingValue PrintStatus = 1
	// This status is set while the
	//   pages are being rendered.
	PrintStatusGeneratingDataValue PrintStatus = 2
	// The print job is being sent off to the
	//   printer.
	PrintStatusSendingDataValue PrintStatus = 3
	// The print job has been sent to the printer,
	//   but is not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPendingValue PrintStatus = 4
	// Some problem has occurred during
	//   printing, e.g. a paper jam.
	PrintStatusPendingIssueValue PrintStatus = 5
	// The printer is processing the print job.
	PrintStatusPrintingValue PrintStatus = 6
	// The printing has been completed successfully.
	PrintStatusFinishedValue PrintStatus = 7
	// The printing has been aborted.
	PrintStatusFinishedAbortedValue PrintStatus = 8
)

var xPrintErrorQuark func() glib.Quark

// Registers an error quark for `GtkPrintOperation` if necessary.
func PrintErrorQuark() glib.Quark {

	cret := xPrintErrorQuark()
	return cret
}

var xPrintRunPageSetupDialog func(uintptr, uintptr, uintptr) uintptr

// Runs a page setup dialog, letting the user modify the values from @page_setup.
//
// If the user cancels the dialog, the returned `GtkPageSetup` is identical
// to the passed in @page_setup, otherwise it contains the modifications
// done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page
// setup dialog. See [func@Gtk.print_run_page_setup_dialog_async] if this is
// a problem.
func PrintRunPageSetupDialog(ParentVar *Window, PageSetupVar *PageSetup, SettingsVar *PrintSettings) *PageSetup {
	var cls *PageSetup

	cret := xPrintRunPageSetupDialog(ParentVar.GoPointer(), PageSetupVar.GoPointer(), SettingsVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &PageSetup{}
	cls.Ptr = cret
	return cls
}

var xPrintRunPageSetupDialogAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Runs a page setup dialog, letting the user modify the values from @page_setup.
//
// In contrast to [func@Gtk.print_run_page_setup_dialog], this function  returns
// after showing the page setup dialog on platforms that support this, and calls
// @done_cb from a signal handler for the ::response signal of the dialog.
func PrintRunPageSetupDialogAsync(ParentVar *Window, PageSetupVar *PageSetup, SettingsVar *PrintSettings, DoneCbVar *PageSetupDoneFunc, DataVar uintptr) {

	var DoneCbVarRef uintptr
	if DoneCbVar != nil {
		DoneCbVarPtr := uintptr(unsafe.Pointer(DoneCbVar))
		if cbRefPtr, ok := glib.GetCallback(DoneCbVarPtr); ok {
			DoneCbVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr) {
				cbFn := *DoneCbVar
				cbFn(arg0, arg1)
			}
			DoneCbVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DoneCbVarPtr, DoneCbVarRef)
		}
	}

	xPrintRunPageSetupDialogAsync(ParentVar.GoPointer(), PageSetupVar.GoPointer(), SettingsVar.GoPointer(), DoneCbVarRef, DataVar)

}

// High-level, portable printing API.
//
// It looks a bit different than other GTK dialogs such as the
// `GtkFileChooser`, since some platforms don’t expose enough
// infrastructure to implement a good print dialog. On such
// platforms, `GtkPrintOperation` uses the native print dialog.
// On platforms which do not provide a native print dialog, GTK
// uses its own, see [class@Gtk.PrintUnixDialog].
//
// The typical way to use the high-level printing API is to create
// a `GtkPrintOperation` object with [ctor@Gtk.PrintOperation.new]
// when the user selects to print. Then you set some properties on it,
// e.g. the page size, any [class@Gtk.PrintSettings] from previous print
// operations, the number of pages, the current page, etc.
//
// Then you start the print operation by calling [method@Gtk.PrintOperation.run].
// It will then show a dialog, let the user select a printer and options.
// When the user finished the dialog, various signals will be emitted on
// the `GtkPrintOperation`, the main one being
// [signal@Gtk.PrintOperation::draw-page], which you are supposed to handle
// and render the page on the provided [class@Gtk.PrintContext] using Cairo.
//
// # The high-level printing API
//
// ```c
// static GtkPrintSettings *settings = NULL;
//
// static void
// do_print (void)
//
//	{
//	  GtkPrintOperation *print;
//	  GtkPrintOperationResult res;
//
//	  print = gtk_print_operation_new ();
//
//	  if (settings != NULL)
//	    gtk_print_operation_set_print_settings (print, settings);
//
//	  g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//	  g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//	  res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//	                                 GTK_WINDOW (main_window), NULL);
//
//	  if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//	    {
//	      if (settings != NULL)
//	        g_object_unref (settings);
//	      settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//	    }
//
//	  g_object_unref (print);
//	}
//
// ```
//
// By default `GtkPrintOperation` uses an external application to do
// print preview. To implement a custom print preview, an application
// must connect to the preview signal. The functions
// [method@Gtk.PrintOperationPreview.render_page],
// [method@Gtk.PrintOperationPreview.end_preview] and
// [method@Gtk.PrintOperationPreview.is_selected]
// are useful when implementing a print preview.
type PrintOperation struct {
	gobject.Object
}

var xPrintOperationGLibType func() types.GType

func PrintOperationGLibType() types.GType {
	return xPrintOperationGLibType()
}

func PrintOperationNewFromInternalPtr(ptr uintptr) *PrintOperation {
	cls := &PrintOperation{}
	cls.Ptr = ptr
	return cls
}

var xNewPrintOperation func() uintptr

// Creates a new `GtkPrintOperation`.
func NewPrintOperation() *PrintOperation {
	var cls *PrintOperation

	cret := xNewPrintOperation()

	if cret == 0 {
		return nil
	}
	cls = &PrintOperation{}
	cls.Ptr = cret
	return cls
}

var xPrintOperationCancel func(uintptr)

// Cancels a running print operation.
//
// This function may be called from a [signal@Gtk.PrintOperation::begin-print],
// [signal@Gtk.PrintOperation::paginate] or [signal@Gtk.PrintOperation::draw-page]
// signal handler to stop the currently running print operation.
func (x *PrintOperation) Cancel() {

	xPrintOperationCancel(x.GoPointer())

}

var xPrintOperationDrawPageFinish func(uintptr)

// Signal that drawing of particular page is complete.
//
// It is called after completion of page drawing (e.g. drawing
// in another thread). If [method@Gtk.PrintOperation.set_defer_drawing]
// was called before, then this function has to be called by application.
// Otherwise it is called by GTK itself.
func (x *PrintOperation) DrawPageFinish() {

	xPrintOperationDrawPageFinish(x.GoPointer())

}

var xPrintOperationGetDefaultPageSetup func(uintptr) uintptr

// Returns the default page setup.
func (x *PrintOperation) GetDefaultPageSetup() *PageSetup {
	var cls *PageSetup

	cret := xPrintOperationGetDefaultPageSetup(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &PageSetup{}
	cls.Ptr = cret
	return cls
}

var xPrintOperationGetEmbedPageSetup func(uintptr) bool

// Gets whether page setup selection combos are embedded
func (x *PrintOperation) GetEmbedPageSetup() bool {

	cret := xPrintOperationGetEmbedPageSetup(x.GoPointer())
	return cret
}

var xPrintOperationGetError func(uintptr)

// Call this when the result of a print operation is
// %GTK_PRINT_OPERATION_RESULT_ERROR.
//
// It can be called either after [method@Gtk.PrintOperation.run]
// returns, or in the [signal@Gtk.PrintOperation::done] signal
// handler.
//
// The returned `GError` will contain more details on what went wrong.
func (x *PrintOperation) GetError() error {
	var cerr *glib.Error

	xPrintOperationGetError(x.GoPointer())
	if cerr == nil {
		return nil
	}
	return cerr

}

var xPrintOperationGetHasSelection func(uintptr) bool

// Gets whether there is a selection.
func (x *PrintOperation) GetHasSelection() bool {

	cret := xPrintOperationGetHasSelection(x.GoPointer())
	return cret
}

var xPrintOperationGetNPagesToPrint func(uintptr) int

// Returns the number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (%GTK_PRINT_STATUS_PREPARING), so this function should never be
// called before the data generation phase (%GTK_PRINT_STATUS_GENERATING_DATA).
// You can connect to the [signal@Gtk.PrintOperation::status-changed]
// signal and call gtk_print_operation_get_n_pages_to_print() when
// print status is %GTK_PRINT_STATUS_GENERATING_DATA.
//
// This is typically used to track the progress of print operation.
func (x *PrintOperation) GetNPagesToPrint() int {

	cret := xPrintOperationGetNPagesToPrint(x.GoPointer())
	return cret
}

var xPrintOperationGetPrintSettings func(uintptr) uintptr

// Returns the current print settings.
//
// Note that the return value is %NULL until either
// [method@Gtk.PrintOperation.set_print_settings] or
// [method@Gtk.PrintOperation.run] have been called.
func (x *PrintOperation) GetPrintSettings() *PrintSettings {
	var cls *PrintSettings

	cret := xPrintOperationGetPrintSettings(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &PrintSettings{}
	cls.Ptr = cret
	return cls
}

var xPrintOperationGetStatus func(uintptr) PrintStatus

// Returns the status of the print operation.
//
// Also see [method@Gtk.PrintOperation.get_status_string].
func (x *PrintOperation) GetStatus() PrintStatus {

	cret := xPrintOperationGetStatus(x.GoPointer())
	return cret
}

var xPrintOperationGetStatusString func(uintptr) string

// Returns a string representation of the status of the
// print operation.
//
// The string is translated and suitable for displaying
// the print status e.g. in a `GtkStatusbar`.
//
// Use [method@Gtk.PrintOperation.get_status] to obtain
// a status value that is suitable for programmatic use.
func (x *PrintOperation) GetStatusString() string {

	cret := xPrintOperationGetStatusString(x.GoPointer())
	return cret
}

var xPrintOperationGetSupportSelection func(uintptr) bool

// Gets whether the application supports print of selection
func (x *PrintOperation) GetSupportSelection() bool {

	cret := xPrintOperationGetSupportSelection(x.GoPointer())
	return cret
}

var xPrintOperationIsFinished func(uintptr) bool

// A convenience function to find out if the print operation
// is finished.
//
// a print operation is finished if its status is either
// %GTK_PRINT_STATUS_FINISHED or %GTK_PRINT_STATUS_FINISHED_ABORTED.
//
// Note: when you enable print status tracking the print operation
// can be in a non-finished state even after done has been called, as
// the operation status then tracks the print job status on the printer.
func (x *PrintOperation) IsFinished() bool {

	cret := xPrintOperationIsFinished(x.GoPointer())
	return cret
}

var xPrintOperationRun func(uintptr, PrintOperationAction, uintptr, **glib.Error) PrintOperationResult

// Runs the print operation.
//
// Normally that this function does not return until the rendering
// of all pages is complete. You can connect to the
// [signal@Gtk.PrintOperation::status-changed] signal on @op to obtain
// some information about the progress of the print operation.
//
// Furthermore, it may use a recursive mainloop to show the print dialog.
//
// If you set the [Gtk.PrintOperation:allow-async] property, the operation
// will run asynchronously if this is supported on the platform. The
// [signal@Gtk.PrintOperation::done] signal will be emitted with the result
// of the operation when the it is done (i.e. when the dialog is canceled,
// or when the print succeeds or fails).
//
// ```c
// if (settings != NULL)
//
//	gtk_print_operation_set_print_settings (print, settings);
//
// if (page_setup != NULL)
//
//	gtk_print_operation_set_default_page_setup (print, page_setup);
//
// g_signal_connect (print, "begin-print",
//
//	G_CALLBACK (begin_print), &amp;data);
//
// g_signal_connect (print, "draw-page",
//
//	G_CALLBACK (draw_page), &amp;data);
//
// res = gtk_print_operation_run (print,
//
//	GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//	parent,
//	&amp;error);
//
// if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
//
//	 {
//	   error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
//	  			                     GTK_DIALOG_DESTROY_WITH_PARENT,
//						     GTK_MESSAGE_ERROR,
//						     GTK_BUTTONS_CLOSE,
//						     "Error printing file:\n%s",
//						     error-&gt;message);
//	   g_signal_connect (error_dialog, "response",
//	                     G_CALLBACK (gtk_window_destroy), NULL);
//	   gtk_window_present (GTK_WINDOW (error_dialog));
//	   g_error_free (error);
//	 }
//
// else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//
//	{
//	  if (settings != NULL)
//
// g_object_unref (settings);
//
//	  settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//	}
//
// ```
//
// Note that gtk_print_operation_run() can only be called once on a
// given `GtkPrintOperation`.
func (x *PrintOperation) Run(ActionVar PrintOperationAction, ParentVar *Window) (PrintOperationResult, error) {
	var cerr *glib.Error

	cret := xPrintOperationRun(x.GoPointer(), ActionVar, ParentVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPrintOperationSetAllowAsync func(uintptr, bool)

// Sets whether gtk_print_operation_run() may return
// before the print operation is completed.
//
// Note that some platforms may not allow asynchronous
// operation.
func (x *PrintOperation) SetAllowAsync(AllowAsyncVar bool) {

	xPrintOperationSetAllowAsync(x.GoPointer(), AllowAsyncVar)

}

var xPrintOperationSetCurrentPage func(uintptr, int)

// Sets the current page.
//
// If this is called before [method@Gtk.PrintOperation.run],
// the user will be able to select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
func (x *PrintOperation) SetCurrentPage(CurrentPageVar int) {

	xPrintOperationSetCurrentPage(x.GoPointer(), CurrentPageVar)

}

var xPrintOperationSetCustomTabLabel func(uintptr, string)

// Sets the label for the tab holding custom widgets.
func (x *PrintOperation) SetCustomTabLabel(LabelVar string) {

	xPrintOperationSetCustomTabLabel(x.GoPointer(), LabelVar)

}

var xPrintOperationSetDefaultPageSetup func(uintptr, uintptr)

// Makes @default_page_setup the default page setup for @op.
//
// This page setup will be used by [method@Gtk.PrintOperation.run],
// but it can be overridden on a per-page basis by connecting
// to the [signal@Gtk.PrintOperation::request-page-setup] signal.
func (x *PrintOperation) SetDefaultPageSetup(DefaultPageSetupVar *PageSetup) {

	xPrintOperationSetDefaultPageSetup(x.GoPointer(), DefaultPageSetupVar.GoPointer())

}

var xPrintOperationSetDeferDrawing func(uintptr)

// Sets up the `GtkPrintOperation` to wait for calling of
// [method@Gtk.PrintOperation.draw_page_finish from application.
//
// This can be used for drawing page in another thread.
//
// This function must be called in the callback of the
// [signal@Gtk.PrintOperation::draw-page] signal.
func (x *PrintOperation) SetDeferDrawing() {

	xPrintOperationSetDeferDrawing(x.GoPointer())

}

var xPrintOperationSetEmbedPageSetup func(uintptr, bool)

// Embed page size combo box and orientation combo box into page setup page.
//
// Selected page setup is stored as default page setup in `GtkPrintOperation`.
func (x *PrintOperation) SetEmbedPageSetup(EmbedVar bool) {

	xPrintOperationSetEmbedPageSetup(x.GoPointer(), EmbedVar)

}

var xPrintOperationSetExportFilename func(uintptr, string)

// Sets up the `GtkPrintOperation` to generate a file instead
// of showing the print dialog.
//
// The intended use of this function is for implementing
// “Export to PDF” actions. Currently, PDF is the only supported
// format.
//
// “Print to PDF” support is independent of this and is done
// by letting the user pick the “Print to PDF” item from the list
// of printers in the print dialog.
func (x *PrintOperation) SetExportFilename(FilenameVar string) {

	xPrintOperationSetExportFilename(x.GoPointer(), FilenameVar)

}

var xPrintOperationSetHasSelection func(uintptr, bool)

// Sets whether there is a selection to print.
//
// Application has to set number of pages to which the selection
// will draw by [method@Gtk.PrintOperation.set_n_pages] in a handler
// for the [signal@Gtk.PrintOperation::begin-print] signal.
func (x *PrintOperation) SetHasSelection(HasSelectionVar bool) {

	xPrintOperationSetHasSelection(x.GoPointer(), HasSelectionVar)

}

var xPrintOperationSetJobName func(uintptr, string)

// Sets the name of the print job.
//
// The name is used to identify the job (e.g. in monitoring
// applications like eggcups).
//
// If you don’t set a job name, GTK picks a default one by
// numbering successive print jobs.
func (x *PrintOperation) SetJobName(JobNameVar string) {

	xPrintOperationSetJobName(x.GoPointer(), JobNameVar)

}

var xPrintOperationSetNPages func(uintptr, int)

// Sets the number of pages in the document.
//
// This must be set to a positive number before the rendering
// starts. It may be set in a [signal@Gtk.PrintOperation::begin-print]
// signal handler.
//
// Note that the page numbers passed to the
// [signal@Gtk.PrintOperation::request-page-setup]
// and [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e.
// if the user chooses to print all pages, the last ::draw-page signal
// will be for page @n_pages - 1.
func (x *PrintOperation) SetNPages(NPagesVar int) {

	xPrintOperationSetNPages(x.GoPointer(), NPagesVar)

}

var xPrintOperationSetPrintSettings func(uintptr, uintptr)

// Sets the print settings for @op.
//
// This is typically used to re-establish print settings
// from a previous print operation, see [method@Gtk.PrintOperation.run].
func (x *PrintOperation) SetPrintSettings(PrintSettingsVar *PrintSettings) {

	xPrintOperationSetPrintSettings(x.GoPointer(), PrintSettingsVar.GoPointer())

}

var xPrintOperationSetShowProgress func(uintptr, bool)

// If @show_progress is %TRUE, the print operation will show
// a progress dialog during the print operation.
func (x *PrintOperation) SetShowProgress(ShowProgressVar bool) {

	xPrintOperationSetShowProgress(x.GoPointer(), ShowProgressVar)

}

var xPrintOperationSetSupportSelection func(uintptr, bool)

// Sets whether selection is supported by `GtkPrintOperation`.
func (x *PrintOperation) SetSupportSelection(SupportSelectionVar bool) {

	xPrintOperationSetSupportSelection(x.GoPointer(), SupportSelectionVar)

}

var xPrintOperationSetTrackPrintStatus func(uintptr, bool)

// If track_status is %TRUE, the print operation will try to continue
// report on the status of the print job in the printer queues and printer.
//
// This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
//
// This function is often implemented using some form of polling,
// so it should not be enabled unless needed.
func (x *PrintOperation) SetTrackPrintStatus(TrackStatusVar bool) {

	xPrintOperationSetTrackPrintStatus(x.GoPointer(), TrackStatusVar)

}

var xPrintOperationSetUnit func(uintptr, Unit)

// Sets up the transformation for the cairo context obtained from
// `GtkPrintContext` in such a way that distances are measured in
// units of @unit.
func (x *PrintOperation) SetUnit(UnitVar Unit) {

	xPrintOperationSetUnit(x.GoPointer(), UnitVar)

}

var xPrintOperationSetUseFullPage func(uintptr, bool)

// If @full_page is %TRUE, the transformation for the cairo context
// obtained from `GtkPrintContext` puts the origin at the top left
// corner of the page.
//
// This may not be the top left corner of the sheet, depending on page
// orientation and the number of pages per sheet). Otherwise, the origin
// is at the top left corner of the imageable area (i.e. inside the margins).
func (x *PrintOperation) SetUseFullPage(FullPageVar bool) {

	xPrintOperationSetUseFullPage(x.GoPointer(), FullPageVar)

}

func (c *PrintOperation) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *PrintOperation) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAllowAsync sets the "allow-async" property.
// Determines whether the print operation may run asynchronously or not.
//
// Some systems don't support asynchronous printing, but those that do
// will return %GTK_PRINT_OPERATION_RESULT_IN_PROGRESS as the status, and
// emit the [signal@Gtk.PrintOperation::done] signal when the operation
// is actually done.
//
// The Windows port does not support asynchronous operation at all (this
// is unlikely to change). On other platforms, all actions except for
// %GTK_PRINT_OPERATION_ACTION_EXPORT support asynchronous operation.
func (x *PrintOperation) SetPropertyAllowAsync(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("allow-async", &v)
}

// GetPropertyAllowAsync gets the "allow-async" property.
// Determines whether the print operation may run asynchronously or not.
//
// Some systems don't support asynchronous printing, but those that do
// will return %GTK_PRINT_OPERATION_RESULT_IN_PROGRESS as the status, and
// emit the [signal@Gtk.PrintOperation::done] signal when the operation
// is actually done.
//
// The Windows port does not support asynchronous operation at all (this
// is unlikely to change). On other platforms, all actions except for
// %GTK_PRINT_OPERATION_ACTION_EXPORT support asynchronous operation.
func (x *PrintOperation) GetPropertyAllowAsync() bool {
	var v gobject.Value
	x.GetProperty("allow-async", &v)
	return v.GetBoolean()
}

// SetPropertyCurrentPage sets the "current-page" property.
// The current page in the document.
//
// If this is set before [method@Gtk.PrintOperation.run],
// the user will be able to select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
func (x *PrintOperation) SetPropertyCurrentPage(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("current-page", &v)
}

// GetPropertyCurrentPage gets the "current-page" property.
// The current page in the document.
//
// If this is set before [method@Gtk.PrintOperation.run],
// the user will be able to select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
func (x *PrintOperation) GetPropertyCurrentPage() int {
	var v gobject.Value
	x.GetProperty("current-page", &v)
	return v.GetInt()
}

// SetPropertyCustomTabLabel sets the "custom-tab-label" property.
// Used as the label of the tab containing custom widgets.
//
// Note that this property may be ignored on some platforms.
//
// If this is %NULL, GTK uses a default label.
func (x *PrintOperation) SetPropertyCustomTabLabel(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("custom-tab-label", &v)
}

// GetPropertyCustomTabLabel gets the "custom-tab-label" property.
// Used as the label of the tab containing custom widgets.
//
// Note that this property may be ignored on some platforms.
//
// If this is %NULL, GTK uses a default label.
func (x *PrintOperation) GetPropertyCustomTabLabel() string {
	var v gobject.Value
	x.GetProperty("custom-tab-label", &v)
	return v.GetString()
}

// SetPropertyEmbedPageSetup sets the "embed-page-setup" property.
// If %TRUE, page size combo box and orientation combo box
// are embedded into page setup page.
func (x *PrintOperation) SetPropertyEmbedPageSetup(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("embed-page-setup", &v)
}

// GetPropertyEmbedPageSetup gets the "embed-page-setup" property.
// If %TRUE, page size combo box and orientation combo box
// are embedded into page setup page.
func (x *PrintOperation) GetPropertyEmbedPageSetup() bool {
	var v gobject.Value
	x.GetProperty("embed-page-setup", &v)
	return v.GetBoolean()
}

// SetPropertyExportFilename sets the "export-filename" property.
// The name of a file to generate instead of showing the print dialog.
//
// Currently, PDF is the only supported format.
//
// The intended use of this property is for implementing
// “Export to PDF” actions.
//
// “Print to PDF” support is independent of this and is done
// by letting the user pick the “Print to PDF” item from the
// list of printers in the print dialog.
func (x *PrintOperation) SetPropertyExportFilename(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("export-filename", &v)
}

// GetPropertyExportFilename gets the "export-filename" property.
// The name of a file to generate instead of showing the print dialog.
//
// Currently, PDF is the only supported format.
//
// The intended use of this property is for implementing
// “Export to PDF” actions.
//
// “Print to PDF” support is independent of this and is done
// by letting the user pick the “Print to PDF” item from the
// list of printers in the print dialog.
func (x *PrintOperation) GetPropertyExportFilename() string {
	var v gobject.Value
	x.GetProperty("export-filename", &v)
	return v.GetString()
}

// SetPropertyHasSelection sets the "has-selection" property.
// Determines whether there is a selection in your application.
//
// This can allow your application to print the selection.
// This is typically used to make a "Selection" button sensitive.
func (x *PrintOperation) SetPropertyHasSelection(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("has-selection", &v)
}

// GetPropertyHasSelection gets the "has-selection" property.
// Determines whether there is a selection in your application.
//
// This can allow your application to print the selection.
// This is typically used to make a "Selection" button sensitive.
func (x *PrintOperation) GetPropertyHasSelection() bool {
	var v gobject.Value
	x.GetProperty("has-selection", &v)
	return v.GetBoolean()
}

// SetPropertyJobName sets the "job-name" property.
// A string used to identify the job (e.g. in monitoring
// applications like eggcups).
//
// If you don't set a job name, GTK picks a default one
// by numbering successive print jobs.
func (x *PrintOperation) SetPropertyJobName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("job-name", &v)
}

// GetPropertyJobName gets the "job-name" property.
// A string used to identify the job (e.g. in monitoring
// applications like eggcups).
//
// If you don't set a job name, GTK picks a default one
// by numbering successive print jobs.
func (x *PrintOperation) GetPropertyJobName() string {
	var v gobject.Value
	x.GetProperty("job-name", &v)
	return v.GetString()
}

// SetPropertyNPages sets the "n-pages" property.
// The number of pages in the document.
//
// This must be set to a positive number before the rendering
// starts. It may be set in a [signal@Gtk.PrintOperation::begin-print]
// signal handler.
//
// Note that the page numbers passed to the
// [signal@Gtk.PrintOperation::request-page-setup] and
// [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e.
// if the user chooses to print all pages, the last ::draw-page signal
// will be for page @n_pages - 1.
func (x *PrintOperation) SetPropertyNPages(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("n-pages", &v)
}

// GetPropertyNPages gets the "n-pages" property.
// The number of pages in the document.
//
// This must be set to a positive number before the rendering
// starts. It may be set in a [signal@Gtk.PrintOperation::begin-print]
// signal handler.
//
// Note that the page numbers passed to the
// [signal@Gtk.PrintOperation::request-page-setup] and
// [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e.
// if the user chooses to print all pages, the last ::draw-page signal
// will be for page @n_pages - 1.
func (x *PrintOperation) GetPropertyNPages() int {
	var v gobject.Value
	x.GetProperty("n-pages", &v)
	return v.GetInt()
}

// GetPropertyNPagesToPrint gets the "n-pages-to-print" property.
// The number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (%GTK_PRINT_STATUS_PREPARING), so this value should never be
// get before the data generation phase (%GTK_PRINT_STATUS_GENERATING_DATA).
// You can connect to the [signal@Gtk.PrintOperation::status-changed] signal
// and call [method@Gtk.PrintOperation.get_n_pages_to_print] when
// print status is %GTK_PRINT_STATUS_GENERATING_DATA.
//
// This is typically used to track the progress of print operation.
func (x *PrintOperation) GetPropertyNPagesToPrint() int {
	var v gobject.Value
	x.GetProperty("n-pages-to-print", &v)
	return v.GetInt()
}

// SetPropertyShowProgress sets the "show-progress" property.
// Determines whether to show a progress dialog during the
// print operation.
func (x *PrintOperation) SetPropertyShowProgress(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("show-progress", &v)
}

// GetPropertyShowProgress gets the "show-progress" property.
// Determines whether to show a progress dialog during the
// print operation.
func (x *PrintOperation) GetPropertyShowProgress() bool {
	var v gobject.Value
	x.GetProperty("show-progress", &v)
	return v.GetBoolean()
}

// GetPropertyStatusString gets the "status-string" property.
// A string representation of the status of the print operation.
//
// The string is translated and suitable for displaying the print
// status e.g. in a `GtkStatusbar`.
//
// See the [property@Gtk.PrintOperation:status] property for a status
// value that is suitable for programmatic use.
func (x *PrintOperation) GetPropertyStatusString() string {
	var v gobject.Value
	x.GetProperty("status-string", &v)
	return v.GetString()
}

// SetPropertySupportSelection sets the "support-selection" property.
// If %TRUE, the print operation will support print of selection.
//
// This allows the print dialog to show a "Selection" button.
func (x *PrintOperation) SetPropertySupportSelection(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("support-selection", &v)
}

// GetPropertySupportSelection gets the "support-selection" property.
// If %TRUE, the print operation will support print of selection.
//
// This allows the print dialog to show a "Selection" button.
func (x *PrintOperation) GetPropertySupportSelection() bool {
	var v gobject.Value
	x.GetProperty("support-selection", &v)
	return v.GetBoolean()
}

// SetPropertyTrackPrintStatus sets the "track-print-status" property.
// If %TRUE, the print operation will try to continue report on
// the status of the print job in the printer queues and printer.
//
// This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
// However, this is often implemented using polling, and should
// not be enabled unless needed.
func (x *PrintOperation) SetPropertyTrackPrintStatus(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("track-print-status", &v)
}

// GetPropertyTrackPrintStatus gets the "track-print-status" property.
// If %TRUE, the print operation will try to continue report on
// the status of the print job in the printer queues and printer.
//
// This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
// However, this is often implemented using polling, and should
// not be enabled unless needed.
func (x *PrintOperation) GetPropertyTrackPrintStatus() bool {
	var v gobject.Value
	x.GetProperty("track-print-status", &v)
	return v.GetBoolean()
}

// SetPropertyUseFullPage sets the "use-full-page" property.
// If %TRUE, the transformation for the cairo context obtained
// from `GtkPrintContext` puts the origin at the top left corner
// of the page.
//
// This may not be the top left corner of the sheet, depending on
// page orientation and the number of pages per sheet. Otherwise,
// the origin is at the top left corner of the imageable area (i.e.
// inside the margins).
func (x *PrintOperation) SetPropertyUseFullPage(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("use-full-page", &v)
}

// GetPropertyUseFullPage gets the "use-full-page" property.
// If %TRUE, the transformation for the cairo context obtained
// from `GtkPrintContext` puts the origin at the top left corner
// of the page.
//
// This may not be the top left corner of the sheet, depending on
// page orientation and the number of pages per sheet. Otherwise,
// the origin is at the top left corner of the imageable area (i.e.
// inside the margins).
func (x *PrintOperation) GetPropertyUseFullPage() bool {
	var v gobject.Value
	x.GetProperty("use-full-page", &v)
	return v.GetBoolean()
}

// Emitted after the user has finished changing print settings
// in the dialog, before the actual rendering starts.
//
// A typical use for ::begin-print is to use the parameters from the
// [class@Gtk.PrintContext] and paginate the document accordingly,
// and then set the number of pages with
// [method@Gtk.PrintOperation.set_n_pages].
func (x *PrintOperation) ConnectBeginPrint(cb *func(PrintOperation, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "begin-print", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ContextVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "begin-print", cbRefPtr)
}

// Emitted when displaying the print dialog.
//
// If you return a widget in a handler for this signal it will be
// added to a custom tab in the print dialog. You typically return a
// container widget with multiple widgets in it.
//
// The print dialog owns the returned widget, and its lifetime is not
// controlled by the application. However, the widget is guaranteed
// to stay around until the [signal@Gtk.PrintOperation::custom-widget-apply]
// signal is emitted on the operation. Then you can read out any
// information you need from the widgets.
func (x *PrintOperation) ConnectCreateCustomWidget(cb *func(PrintOperation) gobject.Object) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "create-custom-widget", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) uintptr {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		CreateCustomWidgetCls := cbFn(fa)
		return CreateCustomWidgetCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "create-custom-widget", cbRefPtr)
}

// Emitted right before ::begin-print if you added
// a custom widget in the ::create-custom-widget handler.
//
// When you get this signal you should read the information from the
// custom widgets, as the widgets are not guaranteed to be around at a
// later time.
func (x *PrintOperation) ConnectCustomWidgetApply(cb *func(PrintOperation, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "custom-widget-apply", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, WidgetVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, WidgetVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "custom-widget-apply", cbRefPtr)
}

// Emitted when the print operation run has finished doing
// everything required for printing.
//
// @result gives you information about what happened during the run.
// If @result is %GTK_PRINT_OPERATION_RESULT_ERROR then you can call
// [method@Gtk.PrintOperation.get_error] for more information.
//
// If you enabled print status tracking then
// [method@Gtk.PrintOperation.is_finished] may still return %FALSE
// after the ::done signal was emitted.
func (x *PrintOperation) ConnectDone(cb *func(PrintOperation, PrintOperationResult)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "done", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ResultVarp PrintOperationResult) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ResultVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "done", cbRefPtr)
}

// Emitted for every page that is printed.
//
// The signal handler must render the @page_nr's page onto the cairo
// context obtained from @context using
// [method@Gtk.PrintContext.get_cairo_context].
//
// ```c
// static void
// draw_page (GtkPrintOperation *operation,
//
//	GtkPrintContext   *context,
//	int                page_nr,
//	gpointer           user_data)
//
//	{
//	  cairo_t *cr;
//	  PangoLayout *layout;
//	  double width, text_height;
//	  int layout_height;
//	  PangoFontDescription *desc;
//
//	  cr = gtk_print_context_get_cairo_context (context);
//	  width = gtk_print_context_get_width (context);
//
//	  cairo_rectangle (cr, 0, 0, width, HEADER_HEIGHT);
//
//	  cairo_set_source_rgb (cr, 0.8, 0.8, 0.8);
//	  cairo_fill (cr);
//
//	  layout = gtk_print_context_create_pango_layout (context);
//
//	  desc = pango_font_description_from_string ("sans 14");
//	  pango_layout_set_font_description (layout, desc);
//	  pango_font_description_free (desc);
//
//	  pango_layout_set_text (layout, "some text", -1);
//	  pango_layout_set_width (layout, width * PANGO_SCALE);
//	  pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
//
//	  pango_layout_get_size (layout, NULL, &amp;layout_height);
//	  text_height = (double)layout_height / PANGO_SCALE;
//
//	  cairo_move_to (cr, width / 2,  (HEADER_HEIGHT - text_height) / 2);
//	  pango_cairo_show_layout (cr, layout);
//
//	  g_object_unref (layout);
//	}
//
// ```
//
// Use [method@Gtk.PrintOperation.set_use_full_page] and
// [method@Gtk.PrintOperation.set_unit] before starting the print
// operation to set up the transformation of the cairo context
// according to your needs.
func (x *PrintOperation) ConnectDrawPage(cb *func(PrintOperation, uintptr, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "draw-page", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr, PageNrVarp int) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ContextVarp, PageNrVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "draw-page", cbRefPtr)
}

// Emitted after all pages have been rendered.
//
// A handler for this signal can clean up any resources that have
// been allocated in the [signal@Gtk.PrintOperation::begin-print] handler.
func (x *PrintOperation) ConnectEndPrint(cb *func(PrintOperation, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "end-print", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ContextVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "end-print", cbRefPtr)
}

// Emitted after the ::begin-print signal, but before the actual rendering
// starts.
//
// It keeps getting emitted until a connected signal handler returns %TRUE.
//
// The ::paginate signal is intended to be used for paginating a document
// in small chunks, to avoid blocking the user interface for a long
// time. The signal handler should update the number of pages using
// [method@Gtk.PrintOperation.set_n_pages], and return %TRUE if the document
// has been completely paginated.
//
// If you don't need to do pagination in chunks, you can simply do
// it all in the ::begin-print handler, and set the number of pages
// from there.
func (x *PrintOperation) ConnectPaginate(cb *func(PrintOperation, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "paginate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr) bool {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ContextVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "paginate", cbRefPtr)
}

// Gets emitted when a preview is requested from the native dialog.
//
// The default handler for this signal uses an external viewer
// application to preview.
//
// To implement a custom print preview, an application must return
// %TRUE from its handler for this signal. In order to use the
// provided @context for the preview implementation, it must be
// given a suitable cairo context with
// [method@Gtk.PrintContext.set_cairo_context].
//
// The custom preview implementation can use
// [method@Gtk.PrintOperationPreview.is_selected] and
// [method@Gtk.PrintOperationPreview.render_page] to find pages which
// are selected for print and render them. The preview must be
// finished by calling [method@Gtk.PrintOperationPreview.end_preview]
// (typically in response to the user clicking a close button).
func (x *PrintOperation) ConnectPreview(cb *func(PrintOperation, uintptr, uintptr, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "preview", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PreviewVarp uintptr, ContextVarp uintptr, ParentVarp uintptr) bool {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, PreviewVarp, ContextVarp, ParentVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "preview", cbRefPtr)
}

// Emitted once for every page that is printed.
//
// This gives the application a chance to modify the page setup.
// Any changes done to @setup will be in force only for printing
// this page.
func (x *PrintOperation) ConnectRequestPageSetup(cb *func(PrintOperation, uintptr, int, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-page-setup", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr, PageNrVarp int, SetupVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ContextVarp, PageNrVarp, SetupVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "request-page-setup", cbRefPtr)
}

// Emitted at between the various phases of the print operation.
//
// See [enum@Gtk.PrintStatus] for the phases that are being discriminated.
// Use [method@Gtk.PrintOperation.get_status] to find out the current
// status.
func (x *PrintOperation) ConnectStatusChanged(cb *func(PrintOperation)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "status-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "status-changed", cbRefPtr)
}

// Emitted after change of selected printer.
//
// The actual page setup and print settings are passed to the custom
// widget, which can actualize itself according to this change.
func (x *PrintOperation) ConnectUpdateCustomWidget(cb *func(PrintOperation, uintptr, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "update-custom-widget", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, WidgetVarp uintptr, SetupVarp uintptr, SettingsVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, WidgetVarp, SetupVarp, SettingsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "update-custom-widget", cbRefPtr)
}

// Ends a preview.
//
// This function must be called to finish a custom print preview.
func (x *PrintOperation) EndPreview() {

	XGtkPrintOperationPreviewEndPreview(x.GoPointer())

}

// Returns whether the given page is included in the set of pages that
// have been selected for printing.
func (x *PrintOperation) IsSelected(PageNrVar int) bool {

	cret := XGtkPrintOperationPreviewIsSelected(x.GoPointer(), PageNrVar)
	return cret
}

// Renders a page to the preview.
//
// This is using the print context that was passed to the
// [signal@Gtk.PrintOperation::preview] handler together
// with @preview.
//
// A custom print preview should use this function to render
// the currently selected page.
//
// Note that this function requires a suitable cairo context to
// be associated with the print context.
func (x *PrintOperation) RenderPage(PageNrVar int) {

	XGtkPrintOperationPreviewRenderPage(x.GoPointer(), PageNrVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPrintErrorGLibType, libs, "gtk_print_error_get_type")

	core.PuregoSafeRegister(&xPrintOperationActionGLibType, libs, "gtk_print_operation_action_get_type")

	core.PuregoSafeRegister(&xPrintOperationResultGLibType, libs, "gtk_print_operation_result_get_type")

	core.PuregoSafeRegister(&xPrintStatusGLibType, libs, "gtk_print_status_get_type")

	core.PuregoSafeRegister(&xPrintErrorQuark, libs, "gtk_print_error_quark")
	core.PuregoSafeRegister(&xPrintRunPageSetupDialog, libs, "gtk_print_run_page_setup_dialog")
	core.PuregoSafeRegister(&xPrintRunPageSetupDialogAsync, libs, "gtk_print_run_page_setup_dialog_async")

	core.PuregoSafeRegister(&xPrintOperationGLibType, libs, "gtk_print_operation_get_type")

	core.PuregoSafeRegister(&xNewPrintOperation, libs, "gtk_print_operation_new")

	core.PuregoSafeRegister(&xPrintOperationCancel, libs, "gtk_print_operation_cancel")
	core.PuregoSafeRegister(&xPrintOperationDrawPageFinish, libs, "gtk_print_operation_draw_page_finish")
	core.PuregoSafeRegister(&xPrintOperationGetDefaultPageSetup, libs, "gtk_print_operation_get_default_page_setup")
	core.PuregoSafeRegister(&xPrintOperationGetEmbedPageSetup, libs, "gtk_print_operation_get_embed_page_setup")
	core.PuregoSafeRegister(&xPrintOperationGetError, libs, "gtk_print_operation_get_error")
	core.PuregoSafeRegister(&xPrintOperationGetHasSelection, libs, "gtk_print_operation_get_has_selection")
	core.PuregoSafeRegister(&xPrintOperationGetNPagesToPrint, libs, "gtk_print_operation_get_n_pages_to_print")
	core.PuregoSafeRegister(&xPrintOperationGetPrintSettings, libs, "gtk_print_operation_get_print_settings")
	core.PuregoSafeRegister(&xPrintOperationGetStatus, libs, "gtk_print_operation_get_status")
	core.PuregoSafeRegister(&xPrintOperationGetStatusString, libs, "gtk_print_operation_get_status_string")
	core.PuregoSafeRegister(&xPrintOperationGetSupportSelection, libs, "gtk_print_operation_get_support_selection")
	core.PuregoSafeRegister(&xPrintOperationIsFinished, libs, "gtk_print_operation_is_finished")
	core.PuregoSafeRegister(&xPrintOperationRun, libs, "gtk_print_operation_run")
	core.PuregoSafeRegister(&xPrintOperationSetAllowAsync, libs, "gtk_print_operation_set_allow_async")
	core.PuregoSafeRegister(&xPrintOperationSetCurrentPage, libs, "gtk_print_operation_set_current_page")
	core.PuregoSafeRegister(&xPrintOperationSetCustomTabLabel, libs, "gtk_print_operation_set_custom_tab_label")
	core.PuregoSafeRegister(&xPrintOperationSetDefaultPageSetup, libs, "gtk_print_operation_set_default_page_setup")
	core.PuregoSafeRegister(&xPrintOperationSetDeferDrawing, libs, "gtk_print_operation_set_defer_drawing")
	core.PuregoSafeRegister(&xPrintOperationSetEmbedPageSetup, libs, "gtk_print_operation_set_embed_page_setup")
	core.PuregoSafeRegister(&xPrintOperationSetExportFilename, libs, "gtk_print_operation_set_export_filename")
	core.PuregoSafeRegister(&xPrintOperationSetHasSelection, libs, "gtk_print_operation_set_has_selection")
	core.PuregoSafeRegister(&xPrintOperationSetJobName, libs, "gtk_print_operation_set_job_name")
	core.PuregoSafeRegister(&xPrintOperationSetNPages, libs, "gtk_print_operation_set_n_pages")
	core.PuregoSafeRegister(&xPrintOperationSetPrintSettings, libs, "gtk_print_operation_set_print_settings")
	core.PuregoSafeRegister(&xPrintOperationSetShowProgress, libs, "gtk_print_operation_set_show_progress")
	core.PuregoSafeRegister(&xPrintOperationSetSupportSelection, libs, "gtk_print_operation_set_support_selection")
	core.PuregoSafeRegister(&xPrintOperationSetTrackPrintStatus, libs, "gtk_print_operation_set_track_print_status")
	core.PuregoSafeRegister(&xPrintOperationSetUnit, libs, "gtk_print_operation_set_unit")
	core.PuregoSafeRegister(&xPrintOperationSetUseFullPage, libs, "gtk_print_operation_set_use_full_page")

}
