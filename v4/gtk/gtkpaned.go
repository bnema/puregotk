// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Arranges its children in two panes, horizontally or vertically.
//
// &lt;picture&gt;
//
//	&lt;source srcset="panes-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkPaned" src="panes.png"&gt;
//
// &lt;/picture&gt;
//
// The division between the two panes is adjustable by the user
// by dragging a handle.
//
// Child widgets are added to the panes of the widget with
// [method@Gtk.Paned.set_start_child] and [method@Gtk.Paned.set_end_child].
// The division between the two children is set by default from the size
// requests of the children, but it can be adjusted by the user.
//
// A paned widget draws a separator between the two child widgets and a
// small handle that the user can drag to adjust the division. It does not
// draw any relief around the children or around the separator. (The space
// in which the separator is called the gutter.) Often, it is useful to put
// each child inside a [class@Gtk.Frame] so that the gutter appears as a
// ridge. No separator is drawn if one of the children is missing.
//
// Each child has two options that can be set, "resize" and "shrink". If
// "resize" is true then, when the `GtkPaned` is resized, that child will
// expand or shrink along with the paned widget. If "shrink" is true, then
// that child can be made smaller than its requisition by the user.
// Setting "shrink" to false allows the application to set a minimum size.
// If "resize" is false for both children, then this is treated as if
// "resize" is true for both children.
//
// The application can set the position of the slider as if it were set
// by the user, by calling [method@Gtk.Paned.set_position].
//
// # Shortcuts and Gestures
//
// The following signals have default keybindings:
//
// - [signal@Gtk.Paned::accept-position]
// - [signal@Gtk.Paned::cancel-position]
// - [signal@Gtk.Paned::cycle-child-focus]
// - [signal@Gtk.Paned::cycle-handle-focus]
// - [signal@Gtk.Paned::move-handle]
// - [signal@Gtk.Paned::toggle-handle-focus]
//
// # CSS nodes
//
// ```
// paned
// ├── &lt;child&gt;
// ├── separator[.wide]
// ╰── &lt;child&gt;
// ```
//
// `GtkPaned` has a main CSS node with name paned, and a subnode for
// the separator with name separator. The subnode gets a .wide style
// class when the paned is supposed to be wide.
//
// In horizontal orientation, the nodes are arranged based on the text
// direction, so in left-to-right mode, :first-child will select the
// leftmost child, while it will select the rightmost child in
// RTL layouts.
//
// ## Creating a paned widget with minimum sizes.
//
// ```c
// GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
// GtkWidget *frame1 = gtk_frame_new (NULL);
// GtkWidget *frame2 = gtk_frame_new (NULL);
//
// gtk_widget_set_size_request (hpaned, 200, -1);
//
// gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
// gtk_paned_set_resize_start_child (GTK_PANED (hpaned), TRUE);
// gtk_paned_set_shrink_start_child (GTK_PANED (hpaned), FALSE);
// gtk_widget_set_size_request (frame1, 50, -1);
//
// gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
// gtk_paned_set_resize_end_child (GTK_PANED (hpaned), FALSE);
// gtk_paned_set_shrink_end_child (GTK_PANED (hpaned), FALSE);
// gtk_widget_set_size_request (frame2, 50, -1);
// ```
type Paned struct {
	Widget
}

var xPanedGLibType func() types.GType

func PanedGLibType() types.GType {
	return xPanedGLibType()
}

func PanedNewFromInternalPtr(ptr uintptr) *Paned {
	cls := &Paned{}
	cls.Ptr = ptr
	return cls
}

var xNewPaned func(Orientation) uintptr

// Creates a new `GtkPaned` widget.
func NewPaned(OrientationVar Orientation) *Paned {
	var cls *Paned

	cret := xNewPaned(OrientationVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Paned{}
	cls.Ptr = cret
	return cls
}

var xPanedGetEndChild func(uintptr) uintptr

// Retrieves the end child of the given `GtkPaned`.
func (x *Paned) GetEndChild() *Widget {
	var cls *Widget

	cret := xPanedGetEndChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xPanedGetPosition func(uintptr) int

// Obtains the position of the divider between the two panes.
func (x *Paned) GetPosition() int {

	cret := xPanedGetPosition(x.GoPointer())

	return cret
}

var xPanedGetResizeEndChild func(uintptr) bool

// Returns whether the [property@Gtk.Paned:end-child] can be resized.
func (x *Paned) GetResizeEndChild() bool {

	cret := xPanedGetResizeEndChild(x.GoPointer())

	return cret
}

var xPanedGetResizeStartChild func(uintptr) bool

// Returns whether the [property@Gtk.Paned:start-child] can be resized.
func (x *Paned) GetResizeStartChild() bool {

	cret := xPanedGetResizeStartChild(x.GoPointer())

	return cret
}

var xPanedGetShrinkEndChild func(uintptr) bool

// Returns whether the [property@Gtk.Paned:end-child] can shrink.
func (x *Paned) GetShrinkEndChild() bool {

	cret := xPanedGetShrinkEndChild(x.GoPointer())

	return cret
}

var xPanedGetShrinkStartChild func(uintptr) bool

// Returns whether the [property@Gtk.Paned:start-child] can shrink.
func (x *Paned) GetShrinkStartChild() bool {

	cret := xPanedGetShrinkStartChild(x.GoPointer())

	return cret
}

var xPanedGetStartChild func(uintptr) uintptr

// Retrieves the start child of the given `GtkPaned`.
func (x *Paned) GetStartChild() *Widget {
	var cls *Widget

	cret := xPanedGetStartChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xPanedGetWideHandle func(uintptr) bool

// Gets whether the separator should be wide.
func (x *Paned) GetWideHandle() bool {

	cret := xPanedGetWideHandle(x.GoPointer())

	return cret
}

var xPanedSetEndChild func(uintptr, uintptr)

// Sets the end child of @paned to @child.
//
// If @child is `NULL`, the existing child will be removed.
func (x *Paned) SetEndChild(ChildVar *Widget) {

	xPanedSetEndChild(x.GoPointer(), ChildVar.GoPointer())

}

var xPanedSetPosition func(uintptr, int)

// Sets the position of the divider between the two panes.
func (x *Paned) SetPosition(PositionVar int) {

	xPanedSetPosition(x.GoPointer(), PositionVar)

}

var xPanedSetResizeEndChild func(uintptr, bool)

// Sets whether the [property@Gtk.Paned:end-child] can be resized.
func (x *Paned) SetResizeEndChild(ResizeVar bool) {

	xPanedSetResizeEndChild(x.GoPointer(), ResizeVar)

}

var xPanedSetResizeStartChild func(uintptr, bool)

// Sets whether the [property@Gtk.Paned:start-child] can be resized.
func (x *Paned) SetResizeStartChild(ResizeVar bool) {

	xPanedSetResizeStartChild(x.GoPointer(), ResizeVar)

}

var xPanedSetShrinkEndChild func(uintptr, bool)

// Sets whether the [property@Gtk.Paned:end-child] can shrink.
func (x *Paned) SetShrinkEndChild(ResizeVar bool) {

	xPanedSetShrinkEndChild(x.GoPointer(), ResizeVar)

}

var xPanedSetShrinkStartChild func(uintptr, bool)

// Sets whether the [property@Gtk.Paned:start-child] can shrink.
func (x *Paned) SetShrinkStartChild(ResizeVar bool) {

	xPanedSetShrinkStartChild(x.GoPointer(), ResizeVar)

}

var xPanedSetStartChild func(uintptr, uintptr)

// Sets the start child of @paned to @child.
//
// If @child is `NULL`, the existing child will be removed.
func (x *Paned) SetStartChild(ChildVar *Widget) {

	xPanedSetStartChild(x.GoPointer(), ChildVar.GoPointer())

}

var xPanedSetWideHandle func(uintptr, bool)

// Sets whether the separator should be wide.
func (x *Paned) SetWideHandle(WideVar bool) {

	xPanedSetWideHandle(x.GoPointer(), WideVar)

}

func (c *Paned) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Paned) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// GetPropertyMaxPosition gets the "max-position" property.
// The largest possible value for the [property@Gtk.Paned:position]
// property.
//
// This property is derived from the size and shrinkability
// of the widget's children.
func (x *Paned) GetPropertyMaxPosition() int {
	var v gobject.Value
	x.GetProperty("max-position", &v)
	return v.GetInt()
}

// GetPropertyMinPosition gets the "min-position" property.
// The smallest possible value for the [property@Gtk.Paned:position]
// property.
//
// This property is derived from the size and shrinkability
// of the widget's children.
func (x *Paned) GetPropertyMinPosition() int {
	var v gobject.Value
	x.GetProperty("min-position", &v)
	return v.GetInt()
}

// SetPropertyPosition sets the "position" property.
// Position of the separator in pixels, from the left/top.
func (x *Paned) SetPropertyPosition(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("position", &v)
}

// GetPropertyPosition gets the "position" property.
// Position of the separator in pixels, from the left/top.
func (x *Paned) GetPropertyPosition() int {
	var v gobject.Value
	x.GetProperty("position", &v)
	return v.GetInt()
}

// SetPropertyPositionSet sets the "position-set" property.
// Whether the [property@Gtk.Paned:position] property has been set.
func (x *Paned) SetPropertyPositionSet(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("position-set", &v)
}

// GetPropertyPositionSet gets the "position-set" property.
// Whether the [property@Gtk.Paned:position] property has been set.
func (x *Paned) GetPropertyPositionSet() bool {
	var v gobject.Value
	x.GetProperty("position-set", &v)
	return v.GetBoolean()
}

// SetPropertyResizeEndChild sets the "resize-end-child" property.
// Determines whether the second child expands and shrinks
// along with the paned widget.
func (x *Paned) SetPropertyResizeEndChild(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("resize-end-child", &v)
}

// GetPropertyResizeEndChild gets the "resize-end-child" property.
// Determines whether the second child expands and shrinks
// along with the paned widget.
func (x *Paned) GetPropertyResizeEndChild() bool {
	var v gobject.Value
	x.GetProperty("resize-end-child", &v)
	return v.GetBoolean()
}

// SetPropertyResizeStartChild sets the "resize-start-child" property.
// Determines whether the first child expands and shrinks
// along with the paned widget.
func (x *Paned) SetPropertyResizeStartChild(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("resize-start-child", &v)
}

// GetPropertyResizeStartChild gets the "resize-start-child" property.
// Determines whether the first child expands and shrinks
// along with the paned widget.
func (x *Paned) GetPropertyResizeStartChild() bool {
	var v gobject.Value
	x.GetProperty("resize-start-child", &v)
	return v.GetBoolean()
}

// SetPropertyShrinkEndChild sets the "shrink-end-child" property.
// Determines whether the second child can be made smaller
// than its requisition.
func (x *Paned) SetPropertyShrinkEndChild(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("shrink-end-child", &v)
}

// GetPropertyShrinkEndChild gets the "shrink-end-child" property.
// Determines whether the second child can be made smaller
// than its requisition.
func (x *Paned) GetPropertyShrinkEndChild() bool {
	var v gobject.Value
	x.GetProperty("shrink-end-child", &v)
	return v.GetBoolean()
}

// SetPropertyShrinkStartChild sets the "shrink-start-child" property.
// Determines whether the first child can be made smaller
// than its requisition.
func (x *Paned) SetPropertyShrinkStartChild(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("shrink-start-child", &v)
}

// GetPropertyShrinkStartChild gets the "shrink-start-child" property.
// Determines whether the first child can be made smaller
// than its requisition.
func (x *Paned) GetPropertyShrinkStartChild() bool {
	var v gobject.Value
	x.GetProperty("shrink-start-child", &v)
	return v.GetBoolean()
}

// SetPropertyWideHandle sets the "wide-handle" property.
// Whether the `GtkPaned` should provide a stronger visual separation.
//
// For example, this could be set when a paned contains two
// [class@Gtk.Notebook]s, whose tab rows would otherwise merge visually.
func (x *Paned) SetPropertyWideHandle(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("wide-handle", &v)
}

// GetPropertyWideHandle gets the "wide-handle" property.
// Whether the `GtkPaned` should provide a stronger visual separation.
//
// For example, this could be set when a paned contains two
// [class@Gtk.Notebook]s, whose tab rows would otherwise merge visually.
func (x *Paned) GetPropertyWideHandle() bool {
	var v gobject.Value
	x.GetProperty("wide-handle", &v)
	return v.GetBoolean()
}

// Emitted to accept the current position of the handle when
// moving it using key bindings.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is &lt;kbd&gt;Return&lt;/kbd&gt; or
// &lt;kbd&gt;Space&lt;/kbd&gt;.
func (x *Paned) ConnectAcceptPosition(cb *func(Paned) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "accept-position", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := Paned{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "accept-position", cbRefPtr)
}

// Emitted to cancel moving the position of the handle using key
// bindings.
//
// The position of the handle will be reset to the value prior to
// moving it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is &lt;kbd&gt;Escape&lt;/kbd&gt;.
func (x *Paned) ConnectCancelPosition(cb *func(Paned) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "cancel-position", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := Paned{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "cancel-position", cbRefPtr)
}

// Emitted to cycle the focus between the children of the paned.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default binding is &lt;kbd&gt;F6&lt;/kbd&gt;.
func (x *Paned) ConnectCycleChildFocus(cb *func(Paned, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "cycle-child-focus", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ReversedVarp bool) bool {
		fa := Paned{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ReversedVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "cycle-child-focus", cbRefPtr)
}

// Emitted to cycle whether the paned should grab focus to allow
// the user to change position of the handle by using key bindings.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is &lt;kbd&gt;F8&lt;/kbd&gt;.
func (x *Paned) ConnectCycleHandleFocus(cb *func(Paned, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "cycle-handle-focus", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ReversedVarp bool) bool {
		fa := Paned{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ReversedVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "cycle-handle-focus", cbRefPtr)
}

// Emitted to move the handle with key bindings.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;←&lt;/kbd&gt;,
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;,
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;,
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;↓&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;,
// &lt;kbd&gt;PgUp&lt;/kbd&gt;, &lt;kbd&gt;PgDn&lt;/kbd&gt;, &lt;kbd&gt;Home&lt;/kbd&gt;, &lt;kbd&gt;End&lt;/kbd&gt;.
func (x *Paned) ConnectMoveHandle(cb *func(Paned, ScrollType) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-handle", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ScrollTypeVarp ScrollType) bool {
		fa := Paned{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ScrollTypeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "move-handle", cbRefPtr)
}

// Emitted to accept the current position of the handle and then
// move focus to the next widget in the focus chain.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default binding is &lt;kbd&gt;Tab&lt;/kbd&gt;.
func (x *Paned) ConnectToggleHandleFocus(cb *func(Paned) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "toggle-handle-focus", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := Paned{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "toggle-handle-focus", cbRefPtr)
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *Paned) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *Paned) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *Paned) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())

	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *Paned) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *Paned) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)

	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *Paned) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *Paned) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *Paned) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)

	return cret
}

// Resets the accessible property to its default value.
func (x *Paned) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *Paned) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *Paned) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *Paned) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *Paned) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *Paned) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Paned) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Paned) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Paned) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Paned) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Paned) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Paned) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *Paned) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())

	return cret
}

// Retrieves the orientation of the @orientable.
func (x *Paned) GetOrientation() Orientation {

	cret := XGtkOrientableGetOrientation(x.GoPointer())

	return cret
}

// Sets the orientation of the @orientable.
func (x *Paned) SetOrientation(OrientationVar Orientation) {

	XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPanedGLibType, libs, "gtk_paned_get_type")

	core.PuregoSafeRegister(&xNewPaned, libs, "gtk_paned_new")

	core.PuregoSafeRegister(&xPanedGetEndChild, libs, "gtk_paned_get_end_child")
	core.PuregoSafeRegister(&xPanedGetPosition, libs, "gtk_paned_get_position")
	core.PuregoSafeRegister(&xPanedGetResizeEndChild, libs, "gtk_paned_get_resize_end_child")
	core.PuregoSafeRegister(&xPanedGetResizeStartChild, libs, "gtk_paned_get_resize_start_child")
	core.PuregoSafeRegister(&xPanedGetShrinkEndChild, libs, "gtk_paned_get_shrink_end_child")
	core.PuregoSafeRegister(&xPanedGetShrinkStartChild, libs, "gtk_paned_get_shrink_start_child")
	core.PuregoSafeRegister(&xPanedGetStartChild, libs, "gtk_paned_get_start_child")
	core.PuregoSafeRegister(&xPanedGetWideHandle, libs, "gtk_paned_get_wide_handle")
	core.PuregoSafeRegister(&xPanedSetEndChild, libs, "gtk_paned_set_end_child")
	core.PuregoSafeRegister(&xPanedSetPosition, libs, "gtk_paned_set_position")
	core.PuregoSafeRegister(&xPanedSetResizeEndChild, libs, "gtk_paned_set_resize_end_child")
	core.PuregoSafeRegister(&xPanedSetResizeStartChild, libs, "gtk_paned_set_resize_start_child")
	core.PuregoSafeRegister(&xPanedSetShrinkEndChild, libs, "gtk_paned_set_shrink_end_child")
	core.PuregoSafeRegister(&xPanedSetShrinkStartChild, libs, "gtk_paned_set_shrink_start_child")
	core.PuregoSafeRegister(&xPanedSetStartChild, libs, "gtk_paned_set_start_child")
	core.PuregoSafeRegister(&xPanedSetWideHandle, libs, "gtk_paned_set_wide_handle")

}
