// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type BuilderCScopeClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *BuilderCScopeClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The virtual function table to implement for `GtkBuilderScope` implementations.
// Default implementations for each function do exist, but they usually just fail,
// so it is suggested that implementations implement all of them.
type BuilderScopeInterface struct {
	_ structs.HostLayout

	GIface uintptr

	xGetTypeFromName uintptr

	xGetTypeFromFunction uintptr

	xCreateClosure uintptr
}

func (x *BuilderScopeInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetTypeFromName sets the "get_type_from_name" callback function.
// Try to lookup a `GType` via the its name. See
//
//	gtk_builder_get_type_from_name() for more details.
//	The C implementation will use g_type_from_name() and if that fails try to guess the
//	correct function name for registering the type and then use dlsym() to load it.
//	The default implementation just tries g_type_from_name() and otherwise fails.
func (x *BuilderScopeInterface) OverrideGetTypeFromName(cb func(BuilderScope, *Builder, string) types.GType) {
	if cb == nil {
		x.xGetTypeFromName = 0
	} else {
		x.xGetTypeFromName = purego.NewCallback(func(SelfVarp uintptr, BuilderVarp uintptr, TypeNameVarp string) types.GType {
			return cb(&BuilderScopeBase{Ptr: SelfVarp}, BuilderNewFromInternalPtr(BuilderVarp), TypeNameVarp)
		})
	}
}

// GetGetTypeFromName gets the "get_type_from_name" callback function.
// Try to lookup a `GType` via the its name. See
//
//	gtk_builder_get_type_from_name() for more details.
//	The C implementation will use g_type_from_name() and if that fails try to guess the
//	correct function name for registering the type and then use dlsym() to load it.
//	The default implementation just tries g_type_from_name() and otherwise fails.
func (x *BuilderScopeInterface) GetGetTypeFromName() func(BuilderScope, *Builder, string) types.GType {
	if x.xGetTypeFromName == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, BuilderVarp uintptr, TypeNameVarp string) types.GType
	purego.RegisterFunc(&rawCallback, x.xGetTypeFromName)
	return func(SelfVar BuilderScope, BuilderVar *Builder, TypeNameVar string) types.GType {
		return rawCallback(SelfVar.GoPointer(), BuilderVar.GoPointer(), TypeNameVar)
	}
}

// OverrideGetTypeFromFunction sets the "get_type_from_function" callback function.
// Try to lookup a `GType` via the given function name, specified
//
//	explicitly in a GtkBuilder file, like via the "type-func" attribute in the `&lt;object&gt;` tag.
//	This function is very rarely used.
//	The C implementation will use dlsym() and call the resulting function as a `GTypeFunc`.
//	The default implementation will fail and just return %G_TYPE_INVALID.
func (x *BuilderScopeInterface) OverrideGetTypeFromFunction(cb func(BuilderScope, *Builder, string) types.GType) {
	if cb == nil {
		x.xGetTypeFromFunction = 0
	} else {
		x.xGetTypeFromFunction = purego.NewCallback(func(SelfVarp uintptr, BuilderVarp uintptr, FunctionNameVarp string) types.GType {
			return cb(&BuilderScopeBase{Ptr: SelfVarp}, BuilderNewFromInternalPtr(BuilderVarp), FunctionNameVarp)
		})
	}
}

// GetGetTypeFromFunction gets the "get_type_from_function" callback function.
// Try to lookup a `GType` via the given function name, specified
//
//	explicitly in a GtkBuilder file, like via the "type-func" attribute in the `&lt;object&gt;` tag.
//	This function is very rarely used.
//	The C implementation will use dlsym() and call the resulting function as a `GTypeFunc`.
//	The default implementation will fail and just return %G_TYPE_INVALID.
func (x *BuilderScopeInterface) GetGetTypeFromFunction() func(BuilderScope, *Builder, string) types.GType {
	if x.xGetTypeFromFunction == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, BuilderVarp uintptr, FunctionNameVarp string) types.GType
	purego.RegisterFunc(&rawCallback, x.xGetTypeFromFunction)
	return func(SelfVar BuilderScope, BuilderVar *Builder, FunctionNameVar string) types.GType {
		return rawCallback(SelfVar.GoPointer(), BuilderVar.GoPointer(), FunctionNameVar)
	}
}

// OverrideCreateClosure sets the "create_closure" callback function.
// Create a closure with the given arguments. See gtk_builder_create_closure()
//
//	for more details on those.
//	The C implementation will try to use dlsym() to locate the function name and then
//	g_cclosure_new() to create a closure for the symbol.
//	The default implementation just fails and returns %NULL.
func (x *BuilderScopeInterface) OverrideCreateClosure(cb func(BuilderScope, *Builder, string, BuilderClosureFlags, *gobject.Object) *gobject.Closure) {
	if cb == nil {
		x.xCreateClosure = 0
	} else {
		x.xCreateClosure = purego.NewCallback(func(SelfVarp uintptr, BuilderVarp uintptr, FunctionNameVarp string, FlagsVarp BuilderClosureFlags, ObjectVarp uintptr) *gobject.Closure {
			return cb(&BuilderScopeBase{Ptr: SelfVarp}, BuilderNewFromInternalPtr(BuilderVarp), FunctionNameVarp, FlagsVarp, gobject.ObjectNewFromInternalPtr(ObjectVarp))
		})
	}
}

// GetCreateClosure gets the "create_closure" callback function.
// Create a closure with the given arguments. See gtk_builder_create_closure()
//
//	for more details on those.
//	The C implementation will try to use dlsym() to locate the function name and then
//	g_cclosure_new() to create a closure for the symbol.
//	The default implementation just fails and returns %NULL.
func (x *BuilderScopeInterface) GetCreateClosure() func(BuilderScope, *Builder, string, BuilderClosureFlags, *gobject.Object) *gobject.Closure {
	if x.xCreateClosure == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, BuilderVarp uintptr, FunctionNameVarp string, FlagsVarp BuilderClosureFlags, ObjectVarp uintptr) *gobject.Closure
	purego.RegisterFunc(&rawCallback, x.xCreateClosure)
	return func(SelfVar BuilderScope, BuilderVar *Builder, FunctionNameVar string, FlagsVar BuilderClosureFlags, ObjectVar *gobject.Object) *gobject.Closure {
		return rawCallback(SelfVar.GoPointer(), BuilderVar.GoPointer(), FunctionNameVar, FlagsVar, ObjectVar.GoPointer())
	}
}

// Provides language binding support to `GtkBuilder`.
//
// The goal of `GtkBuilderScope` is to look up programming-language-specific
// values for strings that are given in a `GtkBuilder` UI file.
//
// The primary intended audience is bindings that want to provide deeper
// integration of `GtkBuilder` into the language.
//
// A `GtkBuilderScope` instance may be used with multiple `GtkBuilder` objects,
// even at once.
//
// By default, GTK will use its own implementation of `GtkBuilderScope`
// for the C language which can be created via [ctor@Gtk.BuilderCScope.new].
//
// If you implement `GtkBuilderScope` for a language binding, you
// may want to (partially) derive from or fall back to a [class@Gtk.BuilderCScope],
// as that class implements support for automatic lookups from C symbols.
type BuilderScope interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
}

var xBuilderScopeGLibType func() types.GType

func BuilderScopeGLibType() types.GType {
	return xBuilderScopeGLibType()
}

type BuilderScopeBase struct {
	Ptr uintptr
}

func (x *BuilderScopeBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *BuilderScopeBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// The list of flags that can be passed to gtk_builder_create_closure().
//
// New values may be added in the future for new features, so external
// implementations of [iface@Gtk.BuilderScope] should test the flags
// for unknown values and raise a %GTK_BUILDER_ERROR_INVALID_ATTRIBUTE error
// when they encounter one.
type BuilderClosureFlags int

var xBuilderClosureFlagsGLibType func() types.GType

func BuilderClosureFlagsGLibType() types.GType {
	return xBuilderClosureFlagsGLibType()
}

const (

	// The closure should be created swapped. See
	//   g_cclosure_new_swap() for details.
	BuilderClosureSwappedValue BuilderClosureFlags = 1
)

// A `GtkBuilderScope` implementation for the C language.
//
// `GtkBuilderCScope` instances use symbols explicitly added to @builder
// with prior calls to [method@Gtk.BuilderCScope.add_callback_symbol].
// If developers want to do that, they are encouraged to create their
// own scopes for that purpose.
//
// In the case that symbols are not explicitly added; GTK will uses
// `GModule`’s introspective features (by opening the module %NULL) to
// look at the application’s symbol table. From here it tries to match
// the signal function names given in the interface description with
// symbols in the application.
//
// Note that unless [method@Gtk.BuilderCScope.add_callback_symbol] is
// called for all signal callbacks which are referenced by the loaded XML,
// this functionality will require that `GModule` be supported on the platform.
type BuilderCScope struct {
	gobject.Object
}

var xBuilderCScopeGLibType func() types.GType

func BuilderCScopeGLibType() types.GType {
	return xBuilderCScopeGLibType()
}

func BuilderCScopeNewFromInternalPtr(ptr uintptr) *BuilderCScope {
	cls := &BuilderCScope{}
	cls.Ptr = ptr
	return cls
}

var xNewBuilderCScope func() uintptr

// Creates a new `GtkBuilderCScope` object to use with future
// `GtkBuilder` instances.
//
// Calling this function is only necessary if you want to add
// custom callbacks via [method@Gtk.BuilderCScope.add_callback_symbol].
func NewBuilderCScope() *BuilderCScope {
	var cls *BuilderCScope

	cret := xNewBuilderCScope()

	if cret == 0 {
		return nil
	}
	cls = &BuilderCScope{}
	cls.Ptr = cret
	return cls
}

var xBuilderCScopeAddCallbackSymbol func(uintptr, string, uintptr)

// Adds the @callback_symbol to the scope of @builder under the
// given @callback_name.
//
// Using this function overrides the behavior of
// [method@Gtk.Builder.create_closure] for any callback symbols that
// are added. Using this method allows for better encapsulation as it
// does not require that callback symbols be declared in the global
// namespace.
func (x *BuilderCScope) AddCallbackSymbol(CallbackNameVar string, CallbackSymbolVar *gobject.Callback) {

	xBuilderCScopeAddCallbackSymbol(x.GoPointer(), CallbackNameVar, glib.NewCallback(CallbackSymbolVar))

}

var xBuilderCScopeAddCallbackSymbols func(uintptr, string, uintptr, ...interface{})

// A convenience function to add many callbacks.
//
// This is equivalent to calling [method@Gtk.BuilderCScope.add_callback_symbol]
// for each symbol.
func (x *BuilderCScope) AddCallbackSymbols(FirstCallbackNameVar string, FirstCallbackSymbolVar *gobject.Callback, varArgs ...interface{}) {

	xBuilderCScopeAddCallbackSymbols(x.GoPointer(), FirstCallbackNameVar, glib.NewCallback(FirstCallbackSymbolVar), varArgs...)

}

var xBuilderCScopeLookupCallbackSymbol func(uintptr, string) uintptr

// Fetches a symbol previously added with
// gtk_builder_cscope_add_callback_symbol().
func (x *BuilderCScope) LookupCallbackSymbol(CallbackNameVar string) uintptr {

	cret := xBuilderCScopeLookupCallbackSymbol(x.GoPointer(), CallbackNameVar)
	return cret
}

func (c *BuilderCScope) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *BuilderCScope) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xBuilderClosureFlagsGLibType, libs, "gtk_builder_closure_flags_get_type")

	core.PuregoSafeRegister(&xBuilderCScopeGLibType, libs, "gtk_builder_cscope_get_type")

	core.PuregoSafeRegister(&xNewBuilderCScope, libs, "gtk_builder_cscope_new")

	core.PuregoSafeRegister(&xBuilderCScopeAddCallbackSymbol, libs, "gtk_builder_cscope_add_callback_symbol")
	core.PuregoSafeRegister(&xBuilderCScopeAddCallbackSymbols, libs, "gtk_builder_cscope_add_callback_symbols")
	core.PuregoSafeRegister(&xBuilderCScopeLookupCallbackSymbol, libs, "gtk_builder_cscope_lookup_callback_symbol")

	core.PuregoSafeRegister(&xBuilderScopeGLibType, libs, "gtk_builder_scope_get_type")

}
