// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The list of virtual functions for the `GtkSectionModel` interface.
// No function must be implemented, but unless `GtkSectionModel::get_section()`
// is implemented, the whole model will just be a single section.
type SectionModelInterface struct {
	_ structs.HostLayout

	GIface uintptr

	xGetSection uintptr
}

func (x *SectionModelInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetSection sets the callback function.
// Return the section that covers the given position. If
//
//	the position is outside the number of items, returns a single range from
//	n_items to G_MAXUINT
func (x *SectionModelInterface) OverrideGetSection(cb func(SectionModel, uint, uint, uint)) {
	if cb == nil {
		x.xGetSection = 0
	} else {
		x.xGetSection = purego.NewCallback(func(SelfVarp uintptr, PositionVarp uint, OutStartVarp uint, OutEndVarp uint) {
			cb(&SectionModelBase{Ptr: SelfVarp}, PositionVarp, OutStartVarp, OutEndVarp)
		})
	}
}

// GetGetSection gets the callback function.
// Return the section that covers the given position. If
//
//	the position is outside the number of items, returns a single range from
//	n_items to G_MAXUINT
func (x *SectionModelInterface) GetGetSection() func(SectionModel, uint, uint, uint) {
	if x.xGetSection == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, PositionVarp uint, OutStartVarp uint, OutEndVarp uint)
	purego.RegisterFunc(&rawCallback, x.xGetSection)
	return func(SelfVar SectionModel, PositionVar uint, OutStartVar uint, OutEndVar uint) {
		rawCallback(SelfVar.GoPointer(), PositionVar, OutStartVar, OutEndVar)
	}
}

// An interface that adds support for sections to list models.
//
// A `GtkSectionModel` groups successive items into so-called sections. List widgets
// like `GtkListView` and `GtkGridView` then allow displaying section headers for
// these sections by installing a header factory.
//
// Many GTK list models support sections inherently, or they pass through the sections
// of a model they are wrapping.
//
// When the section groupings of a model change, the model will emit the
// [signal@Gtk.SectionModel::sections-changed] signal by calling the
// [method@Gtk.SectionModel.sections_changed] function. All sections in the given range
// then need to be queried again.
// The [signal@Gio.ListModel::items-changed] signal has the same effect, all sections in
// that range are invalidated, too.
type SectionModel interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	GetSection(PositionVar uint, OutStartVar uint, OutEndVar uint)
	SectionsChanged(PositionVar uint, NItemsVar uint)
}

var xSectionModelGLibType func() types.GType

func SectionModelGLibType() types.GType {
	return xSectionModelGLibType()
}

type SectionModelBase struct {
	Ptr uintptr
}

func (x *SectionModelBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *SectionModelBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Query the section that covers the given position. The number of
// items in the section can be computed by `out_end - out_start`.
//
// If the position is larger than the number of items, a single
// range from n_items to G_MAXUINT will be returned.
func (x *SectionModelBase) GetSection(PositionVar uint, OutStartVar uint, OutEndVar uint) {

	XGtkSectionModelGetSection(x.GoPointer(), PositionVar, OutStartVar, OutEndVar)

}

// This function emits the [signal@Gtk.SectionModel::sections-changed]
// signal to notify about changes to sections.
//
// It must cover all positions that used to be a section start or that
// are now a section start. It does not have to cover all positions for
// which the section has changed.
//
// The [signal@Gio.ListModel::items-changed] implies the effect of the
// [signal@Gtk.SectionModel::sections-changed] signal for all the items
// it covers.
//
// It is recommended that when changes to the items cause section changes
// in a larger range, that the larger range is included in the emission
// of the [signal@Gio.ListModel::items-changed] instead of emitting
// two signals.
func (x *SectionModelBase) SectionsChanged(PositionVar uint, NItemsVar uint) {

	XGtkSectionModelSectionsChanged(x.GoPointer(), PositionVar, NItemsVar)

}

var XGtkSectionModelGetSection func(uintptr, uint, uint, uint)
var XGtkSectionModelSectionsChanged func(uintptr, uint, uint)

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSectionModelGLibType, libs, "gtk_section_model_get_type")

	core.PuregoSafeRegister(&XGtkSectionModelGetSection, libs, "gtk_section_model_get_section")
	core.PuregoSafeRegister(&XGtkSectionModelSectionsChanged, libs, "gtk_section_model_sections_changed")

}
