// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type EditableInterface struct {
	_ structs.HostLayout

	BaseIface uintptr

	xInsertText uintptr

	xDeleteText uintptr

	xChanged uintptr

	xGetText uintptr

	xDoInsertText uintptr

	xDoDeleteText uintptr

	xGetSelectionBounds uintptr

	xSetSelectionBounds uintptr

	xGetDelegate uintptr
}

func (x *EditableInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideInsertText sets the "insert_text" callback function.
func (x *EditableInterface) OverrideInsertText(cb func(Editable, string, int, int)) {
	if cb == nil {
		x.xInsertText = 0
	} else {
		x.xInsertText = purego.NewCallback(func(EditableVarp uintptr, TextVarp string, LengthVarp int, PositionVarp int) {
			cb(&EditableBase{Ptr: EditableVarp}, TextVarp, LengthVarp, PositionVarp)
		})
	}
}

// GetInsertText gets the "insert_text" callback function.
func (x *EditableInterface) GetInsertText() func(Editable, string, int, int) {
	if x.xInsertText == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr, TextVarp string, LengthVarp int, PositionVarp int)
	purego.RegisterFunc(&rawCallback, x.xInsertText)
	return func(EditableVar Editable, TextVar string, LengthVar int, PositionVar int) {
		rawCallback(EditableVar.GoPointer(), TextVar, LengthVar, PositionVar)
	}
}

// OverrideDeleteText sets the "delete_text" callback function.
func (x *EditableInterface) OverrideDeleteText(cb func(Editable, int, int)) {
	if cb == nil {
		x.xDeleteText = 0
	} else {
		x.xDeleteText = purego.NewCallback(func(EditableVarp uintptr, StartPosVarp int, EndPosVarp int) {
			cb(&EditableBase{Ptr: EditableVarp}, StartPosVarp, EndPosVarp)
		})
	}
}

// GetDeleteText gets the "delete_text" callback function.
func (x *EditableInterface) GetDeleteText() func(Editable, int, int) {
	if x.xDeleteText == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr, StartPosVarp int, EndPosVarp int)
	purego.RegisterFunc(&rawCallback, x.xDeleteText)
	return func(EditableVar Editable, StartPosVar int, EndPosVar int) {
		rawCallback(EditableVar.GoPointer(), StartPosVar, EndPosVar)
	}
}

// OverrideChanged sets the "changed" callback function.
func (x *EditableInterface) OverrideChanged(cb func(Editable)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(EditableVarp uintptr) {
			cb(&EditableBase{Ptr: EditableVarp})
		})
	}
}

// GetChanged gets the "changed" callback function.
func (x *EditableInterface) GetChanged() func(Editable) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(EditableVar Editable) {
		rawCallback(EditableVar.GoPointer())
	}
}

// OverrideGetText sets the "get_text" callback function.
func (x *EditableInterface) OverrideGetText(cb func(Editable) string) {
	if cb == nil {
		x.xGetText = 0
	} else {
		x.xGetText = purego.NewCallback(func(EditableVarp uintptr) string {
			return cb(&EditableBase{Ptr: EditableVarp})
		})
	}
}

// GetGetText gets the "get_text" callback function.
func (x *EditableInterface) GetGetText() func(Editable) string {
	if x.xGetText == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetText)
	return func(EditableVar Editable) string {
		return rawCallback(EditableVar.GoPointer())
	}
}

// OverrideDoInsertText sets the "do_insert_text" callback function.
func (x *EditableInterface) OverrideDoInsertText(cb func(Editable, string, int, int)) {
	if cb == nil {
		x.xDoInsertText = 0
	} else {
		x.xDoInsertText = purego.NewCallback(func(EditableVarp uintptr, TextVarp string, LengthVarp int, PositionVarp int) {
			cb(&EditableBase{Ptr: EditableVarp}, TextVarp, LengthVarp, PositionVarp)
		})
	}
}

// GetDoInsertText gets the "do_insert_text" callback function.
func (x *EditableInterface) GetDoInsertText() func(Editable, string, int, int) {
	if x.xDoInsertText == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr, TextVarp string, LengthVarp int, PositionVarp int)
	purego.RegisterFunc(&rawCallback, x.xDoInsertText)
	return func(EditableVar Editable, TextVar string, LengthVar int, PositionVar int) {
		rawCallback(EditableVar.GoPointer(), TextVar, LengthVar, PositionVar)
	}
}

// OverrideDoDeleteText sets the "do_delete_text" callback function.
func (x *EditableInterface) OverrideDoDeleteText(cb func(Editable, int, int)) {
	if cb == nil {
		x.xDoDeleteText = 0
	} else {
		x.xDoDeleteText = purego.NewCallback(func(EditableVarp uintptr, StartPosVarp int, EndPosVarp int) {
			cb(&EditableBase{Ptr: EditableVarp}, StartPosVarp, EndPosVarp)
		})
	}
}

// GetDoDeleteText gets the "do_delete_text" callback function.
func (x *EditableInterface) GetDoDeleteText() func(Editable, int, int) {
	if x.xDoDeleteText == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr, StartPosVarp int, EndPosVarp int)
	purego.RegisterFunc(&rawCallback, x.xDoDeleteText)
	return func(EditableVar Editable, StartPosVar int, EndPosVar int) {
		rawCallback(EditableVar.GoPointer(), StartPosVar, EndPosVar)
	}
}

// OverrideGetSelectionBounds sets the "get_selection_bounds" callback function.
func (x *EditableInterface) OverrideGetSelectionBounds(cb func(Editable, *int, *int) bool) {
	if cb == nil {
		x.xGetSelectionBounds = 0
	} else {
		x.xGetSelectionBounds = purego.NewCallback(func(EditableVarp uintptr, StartPosVarp *int, EndPosVarp *int) bool {
			return cb(&EditableBase{Ptr: EditableVarp}, StartPosVarp, EndPosVarp)
		})
	}
}

// GetGetSelectionBounds gets the "get_selection_bounds" callback function.
func (x *EditableInterface) GetGetSelectionBounds() func(Editable, *int, *int) bool {
	if x.xGetSelectionBounds == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr, StartPosVarp *int, EndPosVarp *int) bool
	purego.RegisterFunc(&rawCallback, x.xGetSelectionBounds)
	return func(EditableVar Editable, StartPosVar *int, EndPosVar *int) bool {
		return rawCallback(EditableVar.GoPointer(), StartPosVar, EndPosVar)
	}
}

// OverrideSetSelectionBounds sets the "set_selection_bounds" callback function.
func (x *EditableInterface) OverrideSetSelectionBounds(cb func(Editable, int, int)) {
	if cb == nil {
		x.xSetSelectionBounds = 0
	} else {
		x.xSetSelectionBounds = purego.NewCallback(func(EditableVarp uintptr, StartPosVarp int, EndPosVarp int) {
			cb(&EditableBase{Ptr: EditableVarp}, StartPosVarp, EndPosVarp)
		})
	}
}

// GetSetSelectionBounds gets the "set_selection_bounds" callback function.
func (x *EditableInterface) GetSetSelectionBounds() func(Editable, int, int) {
	if x.xSetSelectionBounds == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr, StartPosVarp int, EndPosVarp int)
	purego.RegisterFunc(&rawCallback, x.xSetSelectionBounds)
	return func(EditableVar Editable, StartPosVar int, EndPosVar int) {
		rawCallback(EditableVar.GoPointer(), StartPosVar, EndPosVar)
	}
}

// OverrideGetDelegate sets the "get_delegate" callback function.
func (x *EditableInterface) OverrideGetDelegate(cb func(Editable) *EditableBase) {
	if cb == nil {
		x.xGetDelegate = 0
	} else {
		x.xGetDelegate = purego.NewCallback(func(EditableVarp uintptr) uintptr {
			ret := cb(&EditableBase{Ptr: EditableVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetDelegate gets the "get_delegate" callback function.
func (x *EditableInterface) GetGetDelegate() func(Editable) *EditableBase {
	if x.xGetDelegate == 0 {
		return nil
	}
	var rawCallback func(EditableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetDelegate)
	return func(EditableVar Editable) *EditableBase {
		rawRet := rawCallback(EditableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &EditableBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// Interface for single-line text editing widgets.
//
// Typical examples of editable widgets are [class@Gtk.Entry] and
// [class@Gtk.SpinButton]. It contains functions for generically manipulating
// an editable widget, a large number of action signals used for key bindings,
// and several signals that an application can connect to modify the behavior
// of a widget.
//
// As an example of the latter usage, by connecting the following handler to
// [signal@Gtk.Editable::insert-text], an application can convert all entry
// into a widget into uppercase.
//
// ## Forcing entry to uppercase.
//
// ```c
// #include &lt;ctype.h&gt;
//
// void
// insert_text_handler (GtkEditable *editable,
//
//	const char  *text,
//	int          length,
//	int         *position,
//	gpointer     data)
//
//	{
//	  char *result = g_utf8_strup (text, length);
//
//	  g_signal_handlers_block_by_func (editable,
//	                               (gpointer) insert_text_handler, data);
//	  gtk_editable_insert_text (editable, result, length, position);
//	  g_signal_handlers_unblock_by_func (editable,
//	                                     (gpointer) insert_text_handler, data);
//
//	  g_signal_stop_emission_by_name (editable, "insert_text");
//
//	  g_free (result);
//	}
//
// ```
//
// ## Implementing GtkEditable
//
// The most likely scenario for implementing `GtkEditable` on your own widget
// is that you will embed a `GtkText` inside a complex widget, and want to
// delegate the editable functionality to that text widget. `GtkEditable`
// provides some utility functions to make this easy.
//
// In your class_init function, call [func@Gtk.Editable.install_properties],
// passing the first available property ID:
//
// ```c
// static void
// my_class_init (MyClass *class)
//
//	{
//	  ...
//	  g_object_class_install_properties (object_class, NUM_PROPERTIES, props);
//	  gtk_editable_install_properties (object_clas, NUM_PROPERTIES);
//	  ...
//	}
//
// ```
//
// In your interface_init function for the `GtkEditable` interface, provide
// an implementation for the get_delegate vfunc that returns your text widget:
//
// ```c
// GtkEditable *
// get_editable_delegate (GtkEditable *editable)
//
//	{
//	  return GTK_EDITABLE (MY_WIDGET (editable)-&gt;text_widget);
//	}
//
// static void
// my_editable_init (GtkEditableInterface *iface)
//
//	{
//	  iface-&gt;get_delegate = get_editable_delegate;
//	}
//
// ```
//
// You don't need to provide any other vfuncs. The default implementations
// work by forwarding to the delegate that the GtkEditableInterface.get_delegate()
// vfunc returns.
//
// In your instance_init function, create your text widget, and then call
// [method@Gtk.Editable.init_delegate]:
//
// ```c
// static void
// my_widget_init (MyWidget *self)
//
//	{
//	  ...
//	  self-&gt;text_widget = gtk_text_new ();
//	  gtk_editable_init_delegate (GTK_EDITABLE (self));
//	  ...
//	}
//
// ```
//
// In your dispose function, call [method@Gtk.Editable.finish_delegate] before
// destroying your text widget:
//
// ```c
// static void
// my_widget_dispose (GObject *object)
//
//	{
//	  ...
//	  gtk_editable_finish_delegate (GTK_EDITABLE (self));
//	  g_clear_pointer (&amp;self-&gt;text_widget, gtk_widget_unparent);
//	  ...
//	}
//
// ```
//
// Finally, use [func@Gtk.Editable.delegate_set_property] in your `set_property`
// function (and similar for `get_property`), to set the editable properties:
//
// ```c
//
//	...
//	if (gtk_editable_delegate_set_property (object, prop_id, value, pspec))
//	  return;
//
//	switch (prop_id)
//	...
//
// ```
//
// It is important to note that if you create a `GtkEditable` that uses
// a delegate, the low level [signal@Gtk.Editable::insert-text] and
// [signal@Gtk.Editable::delete-text] signals will be propagated from the
// "wrapper" editable to the delegate, but they will not be propagated from
// the delegate to the "wrapper" editable, as they would cause an infinite
// recursion. If you wish to connect to the [signal@Gtk.Editable::insert-text]
// and [signal@Gtk.Editable::delete-text] signals, you will need to connect
// to them on the delegate obtained via [method@Gtk.Editable.get_delegate].
type Editable interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	DelegateGetAccessiblePlatformState(StateVar AccessiblePlatformState) bool
	DeleteSelection()
	DeleteText(StartPosVar int, EndPosVar int)
	FinishDelegate()
	GetAlignment() float32
	GetChars(StartPosVar int, EndPosVar int) string
	GetDelegate() *EditableBase
	GetEditable() bool
	GetEnableUndo() bool
	GetMaxWidthChars() int
	GetPosition() int
	GetSelectionBounds(StartPosVar *int, EndPosVar *int) bool
	GetText() string
	GetWidthChars() int
	InitDelegate()
	InsertText(TextVar string, LengthVar int, PositionVar int)
	SelectRegion(StartPosVar int, EndPosVar int)
	SetAlignment(XalignVar float32)
	SetEditable(IsEditableVar bool)
	SetEnableUndo(EnableUndoVar bool)
	SetMaxWidthChars(NCharsVar int)
	SetPosition(PositionVar int)
	SetText(TextVar string)
	SetWidthChars(NCharsVar int)
}

var xEditableGLibType func() types.GType

func EditableGLibType() types.GType {
	return xEditableGLibType()
}

type EditableBase struct {
	Ptr uintptr
}

func (x *EditableBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *EditableBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Retrieves the accessible platform state from the editable delegate.
//
// This is an helper function to retrieve the accessible state for
// `GtkEditable` interface implementations using a delegate pattern.
//
// You should call this function in your editable widget implementation
// of the [vfunc@Gtk.Accessible.get_platform_state] virtual function, for
// instance:
//
// ```c
// static void
// accessible_interface_init (GtkAccessibleInterface *iface)
//
//	{
//	  iface-&gt;get_platform_state = your_editable_get_accessible_platform_state;
//	}
//
// static gboolean
// your_editable_get_accessible_platform_state (GtkAccessible *accessible,
//
//	GtkAccessiblePlatformState state)
//
//	{
//	  return gtk_editable_delegate_get_accessible_platform_state (GTK_EDITABLE (accessible), state);
//	}
//
// ```
//
// Note that the widget which is the delegate *must* be a direct child of
// this widget, otherwise your implementation of [vfunc@Gtk.Accessible.get_platform_state]
// might not even be called, as the platform change will originate from
// the parent of the delegate, and, as a result, will not work properly.
//
// So, if you can't ensure the direct child condition, you should give the
// delegate the %GTK_ACCESSIBLE_ROLE_TEXT_BOX role, or you can
// change your tree to allow this function to work.
func (x *EditableBase) DelegateGetAccessiblePlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkEditableDelegateGetAccessiblePlatformState(x.GoPointer(), StateVar)
	return cret
}

// Deletes the currently selected text of the editable.
//
// This call doesnâ€™t do anything if there is no selected text.
func (x *EditableBase) DeleteSelection() {

	XGtkEditableDeleteSelection(x.GoPointer())

}

// Deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters deleted are those from @start_pos to
// the end of the text.
//
// Note that the positions are specified in characters, not bytes.
func (x *EditableBase) DeleteText(StartPosVar int, EndPosVar int) {

	XGtkEditableDeleteText(x.GoPointer(), StartPosVar, EndPosVar)

}

// Undoes the setup done by [method@Gtk.Editable.init_delegate].
//
// This is a helper function that should be called from dispose,
// before removing the delegate object.
func (x *EditableBase) FinishDelegate() {

	XGtkEditableFinishDelegate(x.GoPointer())

}

// Gets the alignment of the editable.
func (x *EditableBase) GetAlignment() float32 {

	cret := XGtkEditableGetAlignment(x.GoPointer())
	return cret
}

// Retrieves a sequence of characters.
//
// The characters that are retrieved are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is negative,
// then the characters retrieved are those characters from @start_pos to
// the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *EditableBase) GetChars(StartPosVar int, EndPosVar int) string {

	cret := XGtkEditableGetChars(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Gets the `GtkEditable` that @editable is delegating its
// implementation to.
//
// Typically, the delegate is a [class@Gtk.Text] widget.
func (x *EditableBase) GetDelegate() *EditableBase {
	var cls *EditableBase

	cret := XGtkEditableGetDelegate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditableBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves whether @editable is editable.
func (x *EditableBase) GetEditable() bool {

	cret := XGtkEditableGetEditable(x.GoPointer())
	return cret
}

// Gets if undo/redo actions are enabled for @editable
func (x *EditableBase) GetEnableUndo() bool {

	cret := XGtkEditableGetEnableUndo(x.GoPointer())
	return cret
}

// Retrieves the desired maximum width of @editable, in characters.
func (x *EditableBase) GetMaxWidthChars() int {

	cret := XGtkEditableGetMaxWidthChars(x.GoPointer())
	return cret
}

// Retrieves the current position of the cursor relative
// to the start of the content of the editable.
//
// Note that this position is in characters, not in bytes.
func (x *EditableBase) GetPosition() int {

	cret := XGtkEditableGetPosition(x.GoPointer())
	return cret
}

// Retrieves the selection bound of the editable.
//
// @start_pos will be filled with the start of the selection and
// @end_pos with end. If no text was selected both will be identical
// and %FALSE will be returned.
//
// Note that positions are specified in characters, not bytes.
func (x *EditableBase) GetSelectionBounds(StartPosVar *int, EndPosVar *int) bool {

	cret := XGtkEditableGetSelectionBounds(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Retrieves the contents of @editable.
//
// The returned string is owned by GTK and must not be modified or freed.
func (x *EditableBase) GetText() string {

	cret := XGtkEditableGetText(x.GoPointer())
	return cret
}

// Gets the number of characters of space reserved
// for the contents of the editable.
func (x *EditableBase) GetWidthChars() int {

	cret := XGtkEditableGetWidthChars(x.GoPointer())
	return cret
}

// Sets up a delegate for `GtkEditable`.
//
// This is assuming that the get_delegate vfunc in the `GtkEditable`
// interface has been set up for the @editable's type.
//
// This is a helper function that should be called in instance init,
// after creating the delegate object.
func (x *EditableBase) InitDelegate() {

	XGtkEditableInitDelegate(x.GoPointer())

}

// Inserts @length bytes of @text into the contents of the
// widget, at position @position.
//
// Note that the position is in characters, not in bytes.
// The function updates @position to point after the newly
// inserted text.
func (x *EditableBase) InsertText(TextVar string, LengthVar int, PositionVar int) {

	XGtkEditableInsertText(x.GoPointer(), TextVar, LengthVar, PositionVar)

}

// Selects a region of text.
//
// The characters that are selected are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters selected are those characters from
// @start_pos to  the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *EditableBase) SelectRegion(StartPosVar int, EndPosVar int) {

	XGtkEditableSelectRegion(x.GoPointer(), StartPosVar, EndPosVar)

}

// Sets the alignment for the contents of the editable.
//
// This controls the horizontal positioning of the contents when
// the displayed text is shorter than the width of the editable.
func (x *EditableBase) SetAlignment(XalignVar float32) {

	XGtkEditableSetAlignment(x.GoPointer(), XalignVar)

}

// Determines if the user can edit the text in the editable widget.
func (x *EditableBase) SetEditable(IsEditableVar bool) {

	XGtkEditableSetEditable(x.GoPointer(), IsEditableVar)

}

// If enabled, changes to @editable will be saved for undo/redo
// actions.
//
// This results in an additional copy of text changes and are not
// stored in secure memory. As such, undo is forcefully disabled
// when [property@Gtk.Text:visibility] is set to %FALSE.
func (x *EditableBase) SetEnableUndo(EnableUndoVar bool) {

	XGtkEditableSetEnableUndo(x.GoPointer(), EnableUndoVar)

}

// Sets the desired maximum width in characters of @editable.
func (x *EditableBase) SetMaxWidthChars(NCharsVar int) {

	XGtkEditableSetMaxWidthChars(x.GoPointer(), NCharsVar)

}

// Sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0)
// index in the contents of the editable. The value must be less than
// or equal to the number of characters in the editable. A value of -1
// indicates that the position should be set after the last character
// of the editable. Note that @position is in characters, not in bytes.
func (x *EditableBase) SetPosition(PositionVar int) {

	XGtkEditableSetPosition(x.GoPointer(), PositionVar)

}

// Sets the text in the editable to the given value.
//
// This is replacing the current contents.
func (x *EditableBase) SetText(TextVar string) {

	XGtkEditableSetText(x.GoPointer(), TextVar)

}

// Changes the size request of the editable to be about the
// right size for @n_chars characters.
//
// Note that it changes the size request, the size can still
// be affected by how you pack the widget into containers.
// If @n_chars is -1, the size reverts to the default size.
func (x *EditableBase) SetWidthChars(NCharsVar int) {

	XGtkEditableSetWidthChars(x.GoPointer(), NCharsVar)

}

// GetPropertyCursorPosition gets the "cursor-position" property.
// The current position of the insertion cursor in chars.
func (x *EditableBase) GetPropertyCursorPosition() int {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("cursor-position", &v)
	return v.GetInt()
}

// SetPropertyEditable sets the "editable" property.
// Whether the entry contents can be edited.
func (x *EditableBase) SetPropertyEditable(value bool) {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	obj.SetProperty("editable", &v)
}

// GetPropertyEditable gets the "editable" property.
// Whether the entry contents can be edited.
func (x *EditableBase) GetPropertyEditable() bool {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("editable", &v)
	return v.GetBoolean()
}

// SetPropertyEnableUndo sets the "enable-undo" property.
// If undo/redo should be enabled for the editable.
func (x *EditableBase) SetPropertyEnableUndo(value bool) {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	obj.SetProperty("enable-undo", &v)
}

// GetPropertyEnableUndo gets the "enable-undo" property.
// If undo/redo should be enabled for the editable.
func (x *EditableBase) GetPropertyEnableUndo() bool {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("enable-undo", &v)
	return v.GetBoolean()
}

// SetPropertyMaxWidthChars sets the "max-width-chars" property.
// The desired maximum width of the entry, in characters.
func (x *EditableBase) SetPropertyMaxWidthChars(value int) {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	obj.SetProperty("max-width-chars", &v)
}

// GetPropertyMaxWidthChars gets the "max-width-chars" property.
// The desired maximum width of the entry, in characters.
func (x *EditableBase) GetPropertyMaxWidthChars() int {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("max-width-chars", &v)
	return v.GetInt()
}

// GetPropertySelectionBound gets the "selection-bound" property.
// The position of the opposite end of the selection from the cursor in chars.
func (x *EditableBase) GetPropertySelectionBound() int {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("selection-bound", &v)
	return v.GetInt()
}

// SetPropertyText sets the "text" property.
// The contents of the entry.
func (x *EditableBase) SetPropertyText(value string) {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	obj.SetProperty("text", &v)
}

// GetPropertyText gets the "text" property.
// The contents of the entry.
func (x *EditableBase) GetPropertyText() string {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("text", &v)
	return v.GetString()
}

// SetPropertyWidthChars sets the "width-chars" property.
// Number of characters to leave space for in the entry.
func (x *EditableBase) SetPropertyWidthChars(value int) {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	obj.SetProperty("width-chars", &v)
}

// GetPropertyWidthChars gets the "width-chars" property.
// Number of characters to leave space for in the entry.
func (x *EditableBase) GetPropertyWidthChars() int {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("width-chars", &v)
	return v.GetInt()
}

// SetPropertyXalign sets the "xalign" property.
// The horizontal alignment, from 0 (left) to 1 (right).
//
// Reversed for RTL layouts.
func (x *EditableBase) SetPropertyXalign(value float32) {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	v.Init(gobject.TypeFloatVal)
	v.SetFloat(value)
	obj.SetProperty("xalign", &v)
}

// GetPropertyXalign gets the "xalign" property.
// The horizontal alignment, from 0 (left) to 1 (right).
//
// Reversed for RTL layouts.
func (x *EditableBase) GetPropertyXalign() float32 {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("xalign", &v)
	return v.GetFloat()
}

var XGtkEditableDelegateGetAccessiblePlatformState func(uintptr, AccessiblePlatformState) bool
var XGtkEditableDeleteSelection func(uintptr)
var XGtkEditableDeleteText func(uintptr, int, int)
var XGtkEditableFinishDelegate func(uintptr)
var XGtkEditableGetAlignment func(uintptr) float32
var XGtkEditableGetChars func(uintptr, int, int) string
var XGtkEditableGetDelegate func(uintptr) uintptr
var XGtkEditableGetEditable func(uintptr) bool
var XGtkEditableGetEnableUndo func(uintptr) bool
var XGtkEditableGetMaxWidthChars func(uintptr) int
var XGtkEditableGetPosition func(uintptr) int
var XGtkEditableGetSelectionBounds func(uintptr, *int, *int) bool
var XGtkEditableGetText func(uintptr) string
var XGtkEditableGetWidthChars func(uintptr) int
var XGtkEditableInitDelegate func(uintptr)
var XGtkEditableInsertText func(uintptr, string, int, int)
var XGtkEditableSelectRegion func(uintptr, int, int)
var XGtkEditableSetAlignment func(uintptr, float32)
var XGtkEditableSetEditable func(uintptr, bool)
var XGtkEditableSetEnableUndo func(uintptr, bool)
var XGtkEditableSetMaxWidthChars func(uintptr, int)
var XGtkEditableSetPosition func(uintptr, int)
var XGtkEditableSetText func(uintptr, string)
var XGtkEditableSetWidthChars func(uintptr, int)

// The identifiers for [iface@Gtk.Editable] properties.
//
// See [func@Gtk.Editable.install_properties] for details on how to
// implement the `GtkEditable` interface.
type EditableProperties int

var xEditablePropertiesGLibType func() types.GType

func EditablePropertiesGLibType() types.GType {
	return xEditablePropertiesGLibType()
}

const (

	// the property id for [property@Gtk.Editable:text]
	EditablePropTextValue EditableProperties = 0
	// the property id for [property@Gtk.Editable:cursor-position]
	EditablePropCursorPositionValue EditableProperties = 1
	// the property id for [property@Gtk.Editable:selection-bound]
	EditablePropSelectionBoundValue EditableProperties = 2
	// the property id for [property@Gtk.Editable:editable]
	EditablePropEditableValue EditableProperties = 3
	// the property id for [property@Gtk.Editable:width-chars]
	EditablePropWidthCharsValue EditableProperties = 4
	// the property id for [property@Gtk.Editable:max-width-chars]
	EditablePropMaxWidthCharsValue EditableProperties = 5
	// the property id for [property@Gtk.Editable:xalign]
	EditablePropXalignValue EditableProperties = 6
	// the property id for [property@Gtk.Editable:enable-undo]
	EditablePropEnableUndoValue EditableProperties = 7
	// the number of properties
	EditableNumPropertiesValue EditableProperties = 8
)

var xEditableDelegateGetProperty func(uintptr, uint, *gobject.Value, uintptr) bool

// Gets a property of the `GtkEditable` delegate for @object.
//
// This is helper function that should be called in the `get_property`
// function of your `GtkEditable` implementation, before handling your
// own properties.
func EditableDelegateGetProperty(ObjectVar *gobject.Object, PropIdVar uint, ValueVar *gobject.Value, PspecVar *gobject.ParamSpec) bool {

	cret := xEditableDelegateGetProperty(ObjectVar.GoPointer(), PropIdVar, ValueVar, PspecVar.GoPointer())
	return cret
}

var xEditableDelegateSetProperty func(uintptr, uint, *gobject.Value, uintptr) bool

// Sets a property on the `GtkEditable` delegate for @object.
//
// This is a helper function that should be called in the `set_property`
// function of your `GtkEditable` implementation, before handling your
// own properties.
func EditableDelegateSetProperty(ObjectVar *gobject.Object, PropIdVar uint, ValueVar *gobject.Value, PspecVar *gobject.ParamSpec) bool {

	cret := xEditableDelegateSetProperty(ObjectVar.GoPointer(), PropIdVar, ValueVar, PspecVar.GoPointer())
	return cret
}

var xEditableInstallProperties func(*gobject.ObjectClass, uint) uint

// Overrides the `GtkEditable` properties for @class.
//
// This is a helper function that should be called in class_init,
// after installing your own properties.
//
// Note that your class must have "text", "cursor-position",
// "selection-bound", "editable", "width-chars", "max-width-chars",
// "xalign" and "enable-undo" properties for this function to work.
//
// To handle the properties in your set_property and get_property
// functions, you can either use [func@Gtk.Editable.delegate_set_property]
// and [func@Gtk.Editable.delegate_get_property] (if you are using
// a delegate), or remember the @first_prop offset and add it to the
// values in the [enum@Gtk.EditableProperties] enumeration to get the
// property IDs for these properties.
func EditableInstallProperties(ObjectClassVar *gobject.ObjectClass, FirstPropVar uint) uint {

	cret := xEditableInstallProperties(ObjectClassVar, FirstPropVar)
	return cret
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xEditablePropertiesGLibType, libs, "gtk_editable_properties_get_type")

	core.PuregoSafeRegister(&xEditableDelegateGetProperty, libs, "gtk_editable_delegate_get_property")
	core.PuregoSafeRegister(&xEditableDelegateSetProperty, libs, "gtk_editable_delegate_set_property")
	core.PuregoSafeRegister(&xEditableInstallProperties, libs, "gtk_editable_install_properties")

	core.PuregoSafeRegister(&xEditableGLibType, libs, "gtk_editable_get_type")

	core.PuregoSafeRegister(&XGtkEditableDelegateGetAccessiblePlatformState, libs, "gtk_editable_delegate_get_accessible_platform_state")
	core.PuregoSafeRegister(&XGtkEditableDeleteSelection, libs, "gtk_editable_delete_selection")
	core.PuregoSafeRegister(&XGtkEditableDeleteText, libs, "gtk_editable_delete_text")
	core.PuregoSafeRegister(&XGtkEditableFinishDelegate, libs, "gtk_editable_finish_delegate")
	core.PuregoSafeRegister(&XGtkEditableGetAlignment, libs, "gtk_editable_get_alignment")
	core.PuregoSafeRegister(&XGtkEditableGetChars, libs, "gtk_editable_get_chars")
	core.PuregoSafeRegister(&XGtkEditableGetDelegate, libs, "gtk_editable_get_delegate")
	core.PuregoSafeRegister(&XGtkEditableGetEditable, libs, "gtk_editable_get_editable")
	core.PuregoSafeRegister(&XGtkEditableGetEnableUndo, libs, "gtk_editable_get_enable_undo")
	core.PuregoSafeRegister(&XGtkEditableGetMaxWidthChars, libs, "gtk_editable_get_max_width_chars")
	core.PuregoSafeRegister(&XGtkEditableGetPosition, libs, "gtk_editable_get_position")
	core.PuregoSafeRegister(&XGtkEditableGetSelectionBounds, libs, "gtk_editable_get_selection_bounds")
	core.PuregoSafeRegister(&XGtkEditableGetText, libs, "gtk_editable_get_text")
	core.PuregoSafeRegister(&XGtkEditableGetWidthChars, libs, "gtk_editable_get_width_chars")
	core.PuregoSafeRegister(&XGtkEditableInitDelegate, libs, "gtk_editable_init_delegate")
	core.PuregoSafeRegister(&XGtkEditableInsertText, libs, "gtk_editable_insert_text")
	core.PuregoSafeRegister(&XGtkEditableSelectRegion, libs, "gtk_editable_select_region")
	core.PuregoSafeRegister(&XGtkEditableSetAlignment, libs, "gtk_editable_set_alignment")
	core.PuregoSafeRegister(&XGtkEditableSetEditable, libs, "gtk_editable_set_editable")
	core.PuregoSafeRegister(&XGtkEditableSetEnableUndo, libs, "gtk_editable_set_enable_undo")
	core.PuregoSafeRegister(&XGtkEditableSetMaxWidthChars, libs, "gtk_editable_set_max_width_chars")
	core.PuregoSafeRegister(&XGtkEditableSetPosition, libs, "gtk_editable_set_position")
	core.PuregoSafeRegister(&XGtkEditableSetText, libs, "gtk_editable_set_text")
	core.PuregoSafeRegister(&XGtkEditableSetWidthChars, libs, "gtk_editable_set_width_chars")

}
