// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type FilterListModelClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *FilterListModelClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A list model that filters the elements of another model.
//
// It hides some elements from the underlying model according to
// criteria given by a `GtkFilter`.
//
// The model can be set up to do incremental filtering, so that
// filtering long lists doesn't block the UI. See
// [method@Gtk.FilterListModel.set_incremental] for details.
//
// `GtkFilterListModel` passes through sections from the underlying model.
type FilterListModel struct {
	gobject.Object
}

var xFilterListModelGLibType func() types.GType

func FilterListModelGLibType() types.GType {
	return xFilterListModelGLibType()
}

func FilterListModelNewFromInternalPtr(ptr uintptr) *FilterListModel {
	cls := &FilterListModel{}
	cls.Ptr = ptr
	return cls
}

var xNewFilterListModel func(uintptr, uintptr) uintptr

// Creates a new `GtkFilterListModel` that will filter @model using the given
// @filter.
func NewFilterListModel(ModelVar gio.ListModel, FilterVar *Filter) *FilterListModel {
	var cls *FilterListModel

	cret := xNewFilterListModel(ModelVar.GoPointer(), FilterVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FilterListModel{}
	cls.Ptr = cret
	return cls
}

var xFilterListModelGetFilter func(uintptr) uintptr

// Gets the `GtkFilter` currently set on @self.
func (x *FilterListModel) GetFilter() *Filter {
	var cls *Filter

	cret := xFilterListModelGetFilter(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Filter{}
	cls.Ptr = cret
	return cls
}

var xFilterListModelGetIncremental func(uintptr) bool

// Returns whether incremental filtering is enabled.
//
// See [method@Gtk.FilterListModel.set_incremental].
func (x *FilterListModel) GetIncremental() bool {

	cret := xFilterListModelGetIncremental(x.GoPointer())
	return cret
}

var xFilterListModelGetModel func(uintptr) uintptr

// Gets the model currently filtered or %NULL if none.
func (x *FilterListModel) GetModel() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xFilterListModelGetModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xFilterListModelGetPending func(uintptr) uint

// Returns the number of items that have not been filtered yet.
//
// You can use this value to check if @self is busy filtering by
// comparing the return value to 0 or you can compute the percentage
// of the filter remaining by dividing the return value by the total
// number of items in the underlying model:
//
// ```c
// pending = gtk_filter_list_model_get_pending (self);
// model = gtk_filter_list_model_get_model (self);
// percentage = pending / (double) g_list_model_get_n_items (model);
// ```
//
// If no filter operation is ongoing - in particular when
// [property@Gtk.FilterListModel:incremental] is %FALSE - this
// function returns 0.
func (x *FilterListModel) GetPending() uint {

	cret := xFilterListModelGetPending(x.GoPointer())
	return cret
}

var xFilterListModelGetWatchItems func(uintptr) bool

// Returns whether watching items is enabled.
//
// See [method@Gtk.FilterListModel.set_watch_items].
func (x *FilterListModel) GetWatchItems() bool {

	cret := xFilterListModelGetWatchItems(x.GoPointer())
	return cret
}

var xFilterListModelSetFilter func(uintptr, uintptr)

// Sets the filter used to filter items.
func (x *FilterListModel) SetFilter(FilterVar *Filter) {

	xFilterListModelSetFilter(x.GoPointer(), FilterVar.GoPointer())

}

var xFilterListModelSetIncremental func(uintptr, bool)

// Sets the filter model to do an incremental sort.
//
// When incremental filtering is enabled, the `GtkFilterListModel` will not
// run filters immediately, but will instead queue an idle handler that
// incrementally filters the items and adds them to the list. This of course
// means that items are not instantly added to the list, but only appear
// incrementally.
//
// When your filter blocks the UI while filtering, you might consider
// turning this on. Depending on your model and filters, this may become
// interesting around 10,000 to 100,000 items.
//
// By default, incremental filtering is disabled.
//
// See [method@Gtk.FilterListModel.get_pending] for progress information
// about an ongoing incremental filtering operation.
func (x *FilterListModel) SetIncremental(IncrementalVar bool) {

	xFilterListModelSetIncremental(x.GoPointer(), IncrementalVar)

}

var xFilterListModelSetModel func(uintptr, uintptr)

// Sets the model to be filtered.
//
// Note that GTK makes no effort to ensure that @model conforms to
// the item type of @self. It assumes that the caller knows what they
// are doing and have set up an appropriate filter to ensure that item
// types match.
func (x *FilterListModel) SetModel(ModelVar gio.ListModel) {

	xFilterListModelSetModel(x.GoPointer(), ModelVar.GoPointer())

}

var xFilterListModelSetWatchItems func(uintptr, bool)

// Sets the filter model to monitor properties of its items.
//
// This allows implementations of [class@Gtk.Filter] that support expression
// watching to react to property changes. This property has no effect if the
// current filter doesn't support watching items.
//
// By default, watching items is disabled.
func (x *FilterListModel) SetWatchItems(WatchItemsVar bool) {

	xFilterListModelSetWatchItems(x.GoPointer(), WatchItemsVar)

}

func (c *FilterListModel) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *FilterListModel) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyIncremental sets the "incremental" property.
// If the model should filter items incrementally.
func (x *FilterListModel) SetPropertyIncremental(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("incremental", &v)
}

// GetPropertyIncremental gets the "incremental" property.
// If the model should filter items incrementally.
func (x *FilterListModel) GetPropertyIncremental() bool {
	var v gobject.Value
	x.GetProperty("incremental", &v)
	return v.GetBoolean()
}

// GetPropertyNItems gets the "n-items" property.
// The number of items. See [method@Gio.ListModel.get_n_items].
func (x *FilterListModel) GetPropertyNItems() uint {
	var v gobject.Value
	x.GetProperty("n-items", &v)
	return v.GetUint()
}

// GetPropertyPending gets the "pending" property.
// Number of items not yet filtered.
func (x *FilterListModel) GetPropertyPending() uint {
	var v gobject.Value
	x.GetProperty("pending", &v)
	return v.GetUint()
}

// SetPropertyWatchItems sets the "watch-items" property.
// Monitor the list items for changes. It may impact performance.
func (x *FilterListModel) SetPropertyWatchItems(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("watch-items", &v)
}

// GetPropertyWatchItems gets the "watch-items" property.
// Monitor the list items for changes. It may impact performance.
func (x *FilterListModel) GetPropertyWatchItems() bool {
	var v gobject.Value
	x.GetProperty("watch-items", &v)
	return v.GetBoolean()
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// See also: g_list_model_get_n_items()
func (x *FilterListModel) GetItem(PositionVar uint) uintptr {

	cret := gio.XGListModelGetItem(x.GoPointer(), PositionVar)
	return cret
}

// Gets the type of the items in @list.
//
// All items returned from g_list_model_get_item() are of the type
// returned by this function, or a subtype, or if the type is an
// interface, they are an implementation of that interface.
//
// The item type of a #GListModel can not change during the life of the
// model.
func (x *FilterListModel) GetItemType() types.GType {

	cret := gio.XGListModelGetItemType(x.GoPointer())
	return cret
}

// Gets the number of items in @list.
//
// Depending on the model implementation, calling this function may be
// less efficient than iterating the list with increasing values for
// @position until g_list_model_get_item() returns %NULL.
func (x *FilterListModel) GetNItems() uint {

	cret := gio.XGListModelGetNItems(x.GoPointer())
	return cret
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// This function is meant to be used by language bindings in place
// of g_list_model_get_item().
//
// See also: g_list_model_get_n_items()
func (x *FilterListModel) GetObject(PositionVar uint) *gobject.Object {
	var cls *gobject.Object

	cret := gio.XGListModelGetObject(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Emits the #GListModel::items-changed signal on @list.
//
// This function should only be called by classes implementing
// #GListModel. It has to be called after the internal representation
// of @list has been updated, because handlers connected to this signal
// might query the new state of the list.
//
// Implementations must only make changes to the model (as visible to
// its consumer) in places that will not cause problems for that
// consumer.  For models that are driven directly by a write API (such
// as #GListStore), changes can be reported in response to uses of that
// API.  For models that represent remote data, changes should only be
// made from a fresh mainloop dispatch.  It is particularly not
// permitted to make changes in response to a call to the #GListModel
// consumer API.
//
// Stated another way: in general, it is assumed that code making a
// series of accesses to the model via the API, without returning to the
// mainloop, and without calling other code, will continue to view the
// same contents of the model.
func (x *FilterListModel) ItemsChanged(PositionVar uint, RemovedVar uint, AddedVar uint) {

	gio.XGListModelItemsChanged(x.GoPointer(), PositionVar, RemovedVar, AddedVar)

}

// Query the section that covers the given position. The number of
// items in the section can be computed by `out_end - out_start`.
//
// If the position is larger than the number of items, a single
// range from n_items to G_MAXUINT will be returned.
func (x *FilterListModel) GetSection(PositionVar uint, OutStartVar *uint, OutEndVar *uint) {

	XGtkSectionModelGetSection(x.GoPointer(), PositionVar, OutStartVar, OutEndVar)

}

// This function emits the [signal@Gtk.SectionModel::sections-changed]
// signal to notify about changes to sections.
//
// It must cover all positions that used to be a section start or that
// are now a section start. It does not have to cover all positions for
// which the section has changed.
//
// The [signal@Gio.ListModel::items-changed] implies the effect of the
// [signal@Gtk.SectionModel::sections-changed] signal for all the items
// it covers.
//
// It is recommended that when changes to the items cause section changes
// in a larger range, that the larger range is included in the emission
// of the [signal@Gio.ListModel::items-changed] instead of emitting
// two signals.
func (x *FilterListModel) SectionsChanged(PositionVar uint, NItemsVar uint) {

	XGtkSectionModelSectionsChanged(x.GoPointer(), PositionVar, NItemsVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xFilterListModelGLibType, libs, "gtk_filter_list_model_get_type")

	core.PuregoSafeRegister(&xNewFilterListModel, libs, "gtk_filter_list_model_new")

	core.PuregoSafeRegister(&xFilterListModelGetFilter, libs, "gtk_filter_list_model_get_filter")
	core.PuregoSafeRegister(&xFilterListModelGetIncremental, libs, "gtk_filter_list_model_get_incremental")
	core.PuregoSafeRegister(&xFilterListModelGetModel, libs, "gtk_filter_list_model_get_model")
	core.PuregoSafeRegister(&xFilterListModelGetPending, libs, "gtk_filter_list_model_get_pending")
	core.PuregoSafeRegister(&xFilterListModelGetWatchItems, libs, "gtk_filter_list_model_get_watch_items")
	core.PuregoSafeRegister(&xFilterListModelSetFilter, libs, "gtk_filter_list_model_set_filter")
	core.PuregoSafeRegister(&xFilterListModelSetIncremental, libs, "gtk_filter_list_model_set_incremental")
	core.PuregoSafeRegister(&xFilterListModelSetModel, libs, "gtk_filter_list_model_set_model")
	core.PuregoSafeRegister(&xFilterListModelSetWatchItems, libs, "gtk_filter_list_model_set_watch_items")

}
