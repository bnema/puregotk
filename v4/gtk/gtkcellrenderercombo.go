// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Renders a combobox in a cell
//
// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
// which it is derived. But while `GtkCellRendererText` offers a simple entry to
// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
// widget to edit the text. The values to display in the combo box are taken from
// the tree model specified in the `GtkCellRendererCombo`:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the combo
// box and sets it to display the column specified by its
// `GtkCellRendererCombo`:text-column property. Further properties of the combo box
// can be set in a handler for the `GtkCellRenderer::editing-started` signal.
type CellRendererCombo struct {
	CellRendererText
}

var xCellRendererComboGLibType func() types.GType

func CellRendererComboGLibType() types.GType {
	return xCellRendererComboGLibType()
}

func CellRendererComboNewFromInternalPtr(ptr uintptr) *CellRendererCombo {
	cls := &CellRendererCombo{}
	cls.Ptr = ptr
	return cls
}

var xNewCellRendererCombo func() uintptr

// Creates a new `GtkCellRendererCombo`.
// Adjust how text is drawn using object properties.
// Object properties can be set globally (with g_object_set()).
// Also, with `GtkTreeViewColumn`, you can bind a property to a value
// in a `GtkTreeModel`. For example, you can bind the “text” property
// on the cell renderer to a string value in the model, thus rendering
// a different string in each row of the `GtkTreeView`.
func NewCellRendererCombo() *CellRendererCombo {
	var cls *CellRendererCombo

	cret := xNewCellRendererCombo()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellRendererCombo{}
	cls.Ptr = cret
	return cls
}

func (c *CellRendererCombo) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *CellRendererCombo) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyHasEntry sets the "has-entry" property.
// If %TRUE, the cell renderer will include an entry and allow to enter
// values other than the ones in the popup list.
func (x *CellRendererCombo) SetPropertyHasEntry(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("has-entry", &v)
}

// GetPropertyHasEntry gets the "has-entry" property.
// If %TRUE, the cell renderer will include an entry and allow to enter
// values other than the ones in the popup list.
func (x *CellRendererCombo) GetPropertyHasEntry() bool {
	var v gobject.Value
	x.GetProperty("has-entry", &v)
	return v.GetBoolean()
}

// SetPropertyTextColumn sets the "text-column" property.
// Specifies the model column which holds the possible values for the
// combo box.
//
// Note that this refers to the model specified in the model property,
// not the model backing the tree view to which
// this cell renderer is attached.
//
// `GtkCellRendererCombo` automatically adds a text cell renderer for
// this column to its combo box.
func (x *CellRendererCombo) SetPropertyTextColumn(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("text-column", &v)
}

// GetPropertyTextColumn gets the "text-column" property.
// Specifies the model column which holds the possible values for the
// combo box.
//
// Note that this refers to the model specified in the model property,
// not the model backing the tree view to which
// this cell renderer is attached.
//
// `GtkCellRendererCombo` automatically adds a text cell renderer for
// this column to its combo box.
func (x *CellRendererCombo) GetPropertyTextColumn() int {
	var v gobject.Value
	x.GetProperty("text-column", &v)
	return v.GetInt()
}

// This signal is emitted each time after the user selected an item in
// the combo box, either by using the mouse or the arrow keys.  Contrary
// to GtkComboBox, GtkCellRendererCombo::changed is not emitted for
// changes made to a selected item in the entry.  The argument @new_iter
// corresponds to the newly selected item in the combo box and it is relative
// to the GtkTreeModel set via the model property on GtkCellRendererCombo.
//
// Note that as soon as you change the model displayed in the tree view,
// the tree view will immediately cease the editing operating.  This
// means that you most probably want to refrain from changing the model
// until the combo cell renderer emits the edited or editing_canceled signal.
func (x *CellRendererCombo) ConnectChanged(cb *func(CellRendererCombo, string, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PathStringVarp string, NewIterVarp uintptr) {
		fa := CellRendererCombo{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PathStringVarp, NewIterVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCellRendererComboGLibType, libs, "gtk_cell_renderer_combo_get_type")

	core.PuregoSafeRegister(&xNewCellRendererCombo, libs, "gtk_cell_renderer_combo_new")

}
