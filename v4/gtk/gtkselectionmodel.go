// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The list of virtual functions for the `GtkSelectionModel` interface.
// No function must be implemented, but unless `GtkSelectionModel::is_selected()`
// is implemented, it will not be possible to select items in the set.
//
// The model does not need to implement any functions to support either
// selecting or unselecting items. Of course, if the model does not do that,
// it means that users cannot select or unselect items in a list widget
// using the model.
//
// All selection functions fall back to `GtkSelectionModel::set_selection()`
// so it is sufficient to implement just that function for full selection
// support.
type SelectionModelInterface struct {
	_ structs.HostLayout

	GIface uintptr

	xIsSelected uintptr

	xGetSelectionInRange uintptr

	xSelectItem uintptr

	xUnselectItem uintptr

	xSelectRange uintptr

	xUnselectRange uintptr

	xSelectAll uintptr

	xUnselectAll uintptr

	xSetSelection uintptr
}

func (x *SelectionModelInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideIsSelected sets the "is_selected" callback function.
// Return if the item at the given position is selected.
func (x *SelectionModelInterface) OverrideIsSelected(cb func(SelectionModel, uint) bool) {
	if cb == nil {
		x.xIsSelected = 0
	} else {
		x.xIsSelected = purego.NewCallback(func(ModelVarp uintptr, PositionVarp uint) bool {
			return cb(&SelectionModelBase{Ptr: ModelVarp}, PositionVarp)
		})
	}
}

// GetIsSelected gets the "is_selected" callback function.
// Return if the item at the given position is selected.
func (x *SelectionModelInterface) GetIsSelected() func(SelectionModel, uint) bool {
	if x.xIsSelected == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr, PositionVarp uint) bool
	purego.RegisterFunc(&rawCallback, x.xIsSelected)
	return func(ModelVar SelectionModel, PositionVar uint) bool {
		return rawCallback(ModelVar.GoPointer(), PositionVar)
	}
}

// OverrideGetSelectionInRange sets the "get_selection_in_range" callback function.
// Return a bitset with all currently selected
//
//	items in the given range. By default, this function will call
//	`GtkSelectionModel::is_selected()` on all items in the given range.
func (x *SelectionModelInterface) OverrideGetSelectionInRange(cb func(SelectionModel, uint, uint) *Bitset) {
	if cb == nil {
		x.xGetSelectionInRange = 0
	} else {
		x.xGetSelectionInRange = purego.NewCallback(func(ModelVarp uintptr, PositionVarp uint, NItemsVarp uint) *Bitset {
			return cb(&SelectionModelBase{Ptr: ModelVarp}, PositionVarp, NItemsVarp)
		})
	}
}

// GetGetSelectionInRange gets the "get_selection_in_range" callback function.
// Return a bitset with all currently selected
//
//	items in the given range. By default, this function will call
//	`GtkSelectionModel::is_selected()` on all items in the given range.
func (x *SelectionModelInterface) GetGetSelectionInRange() func(SelectionModel, uint, uint) *Bitset {
	if x.xGetSelectionInRange == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr, PositionVarp uint, NItemsVarp uint) *Bitset
	purego.RegisterFunc(&rawCallback, x.xGetSelectionInRange)
	return func(ModelVar SelectionModel, PositionVar uint, NItemsVar uint) *Bitset {
		return rawCallback(ModelVar.GoPointer(), PositionVar, NItemsVar)
	}
}

// OverrideSelectItem sets the "select_item" callback function.
// Select the item in the given position. If the operation
//
//	is known to fail, return %FALSE.
func (x *SelectionModelInterface) OverrideSelectItem(cb func(SelectionModel, uint, bool) bool) {
	if cb == nil {
		x.xSelectItem = 0
	} else {
		x.xSelectItem = purego.NewCallback(func(ModelVarp uintptr, PositionVarp uint, UnselectRestVarp bool) bool {
			return cb(&SelectionModelBase{Ptr: ModelVarp}, PositionVarp, UnselectRestVarp)
		})
	}
}

// GetSelectItem gets the "select_item" callback function.
// Select the item in the given position. If the operation
//
//	is known to fail, return %FALSE.
func (x *SelectionModelInterface) GetSelectItem() func(SelectionModel, uint, bool) bool {
	if x.xSelectItem == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr, PositionVarp uint, UnselectRestVarp bool) bool
	purego.RegisterFunc(&rawCallback, x.xSelectItem)
	return func(ModelVar SelectionModel, PositionVar uint, UnselectRestVar bool) bool {
		return rawCallback(ModelVar.GoPointer(), PositionVar, UnselectRestVar)
	}
}

// OverrideUnselectItem sets the "unselect_item" callback function.
// Unselect the item in the given position. If the
//
//	operation is known to fail, return %FALSE.
func (x *SelectionModelInterface) OverrideUnselectItem(cb func(SelectionModel, uint) bool) {
	if cb == nil {
		x.xUnselectItem = 0
	} else {
		x.xUnselectItem = purego.NewCallback(func(ModelVarp uintptr, PositionVarp uint) bool {
			return cb(&SelectionModelBase{Ptr: ModelVarp}, PositionVarp)
		})
	}
}

// GetUnselectItem gets the "unselect_item" callback function.
// Unselect the item in the given position. If the
//
//	operation is known to fail, return %FALSE.
func (x *SelectionModelInterface) GetUnselectItem() func(SelectionModel, uint) bool {
	if x.xUnselectItem == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr, PositionVarp uint) bool
	purego.RegisterFunc(&rawCallback, x.xUnselectItem)
	return func(ModelVar SelectionModel, PositionVar uint) bool {
		return rawCallback(ModelVar.GoPointer(), PositionVar)
	}
}

// OverrideSelectRange sets the "select_range" callback function.
// Select all items in the given range. If the operation
//
//	is unsupported or known to fail for all items, return %FALSE.
func (x *SelectionModelInterface) OverrideSelectRange(cb func(SelectionModel, uint, uint, bool) bool) {
	if cb == nil {
		x.xSelectRange = 0
	} else {
		x.xSelectRange = purego.NewCallback(func(ModelVarp uintptr, PositionVarp uint, NItemsVarp uint, UnselectRestVarp bool) bool {
			return cb(&SelectionModelBase{Ptr: ModelVarp}, PositionVarp, NItemsVarp, UnselectRestVarp)
		})
	}
}

// GetSelectRange gets the "select_range" callback function.
// Select all items in the given range. If the operation
//
//	is unsupported or known to fail for all items, return %FALSE.
func (x *SelectionModelInterface) GetSelectRange() func(SelectionModel, uint, uint, bool) bool {
	if x.xSelectRange == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr, PositionVarp uint, NItemsVarp uint, UnselectRestVarp bool) bool
	purego.RegisterFunc(&rawCallback, x.xSelectRange)
	return func(ModelVar SelectionModel, PositionVar uint, NItemsVar uint, UnselectRestVar bool) bool {
		return rawCallback(ModelVar.GoPointer(), PositionVar, NItemsVar, UnselectRestVar)
	}
}

// OverrideUnselectRange sets the "unselect_range" callback function.
// Unselect all items in the given range. If the
//
//	operation is unsupported or known to fail for all items, return
//	%FALSE.
func (x *SelectionModelInterface) OverrideUnselectRange(cb func(SelectionModel, uint, uint) bool) {
	if cb == nil {
		x.xUnselectRange = 0
	} else {
		x.xUnselectRange = purego.NewCallback(func(ModelVarp uintptr, PositionVarp uint, NItemsVarp uint) bool {
			return cb(&SelectionModelBase{Ptr: ModelVarp}, PositionVarp, NItemsVarp)
		})
	}
}

// GetUnselectRange gets the "unselect_range" callback function.
// Unselect all items in the given range. If the
//
//	operation is unsupported or known to fail for all items, return
//	%FALSE.
func (x *SelectionModelInterface) GetUnselectRange() func(SelectionModel, uint, uint) bool {
	if x.xUnselectRange == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr, PositionVarp uint, NItemsVarp uint) bool
	purego.RegisterFunc(&rawCallback, x.xUnselectRange)
	return func(ModelVar SelectionModel, PositionVar uint, NItemsVar uint) bool {
		return rawCallback(ModelVar.GoPointer(), PositionVar, NItemsVar)
	}
}

// OverrideSelectAll sets the "select_all" callback function.
// Select all items in the model. If the operation is
//
//	unsupported or known to fail for all items, return %FALSE.
func (x *SelectionModelInterface) OverrideSelectAll(cb func(SelectionModel) bool) {
	if cb == nil {
		x.xSelectAll = 0
	} else {
		x.xSelectAll = purego.NewCallback(func(ModelVarp uintptr) bool {
			return cb(&SelectionModelBase{Ptr: ModelVarp})
		})
	}
}

// GetSelectAll gets the "select_all" callback function.
// Select all items in the model. If the operation is
//
//	unsupported or known to fail for all items, return %FALSE.
func (x *SelectionModelInterface) GetSelectAll() func(SelectionModel) bool {
	if x.xSelectAll == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSelectAll)
	return func(ModelVar SelectionModel) bool {
		return rawCallback(ModelVar.GoPointer())
	}
}

// OverrideUnselectAll sets the "unselect_all" callback function.
// Unselect all items in the model. If the operation is
//
//	unsupported or known to fail for all items, return %FALSE.
func (x *SelectionModelInterface) OverrideUnselectAll(cb func(SelectionModel) bool) {
	if cb == nil {
		x.xUnselectAll = 0
	} else {
		x.xUnselectAll = purego.NewCallback(func(ModelVarp uintptr) bool {
			return cb(&SelectionModelBase{Ptr: ModelVarp})
		})
	}
}

// GetUnselectAll gets the "unselect_all" callback function.
// Unselect all items in the model. If the operation is
//
//	unsupported or known to fail for all items, return %FALSE.
func (x *SelectionModelInterface) GetUnselectAll() func(SelectionModel) bool {
	if x.xUnselectAll == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xUnselectAll)
	return func(ModelVar SelectionModel) bool {
		return rawCallback(ModelVar.GoPointer())
	}
}

// OverrideSetSelection sets the "set_selection" callback function.
// Set selection state of all items in mask to selected.
//
//	See gtk_selection_model_set_selection() for a detailed explanation
//	of this function.
func (x *SelectionModelInterface) OverrideSetSelection(cb func(SelectionModel, *Bitset, *Bitset) bool) {
	if cb == nil {
		x.xSetSelection = 0
	} else {
		x.xSetSelection = purego.NewCallback(func(ModelVarp uintptr, SelectedVarp *Bitset, MaskVarp *Bitset) bool {
			return cb(&SelectionModelBase{Ptr: ModelVarp}, SelectedVarp, MaskVarp)
		})
	}
}

// GetSetSelection gets the "set_selection" callback function.
// Set selection state of all items in mask to selected.
//
//	See gtk_selection_model_set_selection() for a detailed explanation
//	of this function.
func (x *SelectionModelInterface) GetSetSelection() func(SelectionModel, *Bitset, *Bitset) bool {
	if x.xSetSelection == 0 {
		return nil
	}
	var rawCallback func(ModelVarp uintptr, SelectedVarp *Bitset, MaskVarp *Bitset) bool
	purego.RegisterFunc(&rawCallback, x.xSetSelection)
	return func(ModelVar SelectionModel, SelectedVar *Bitset, MaskVar *Bitset) bool {
		return rawCallback(ModelVar.GoPointer(), SelectedVar, MaskVar)
	}
}

// An interface that adds support for selection to list models.
//
// This support is then used by widgets using list models to add the ability
// to select and unselect various items.
//
// GTK provides default implementations of the most common selection modes such
// as [class@Gtk.SingleSelection], so you will only need to implement this
// interface if you want detailed control about how selections should be handled.
//
// A `GtkSelectionModel` supports a single boolean per item indicating if an item is
// selected or not. This can be queried via [method@Gtk.SelectionModel.is_selected].
// When the selected state of one or more items changes, the model will emit the
// [signal@Gtk.SelectionModel::selection-changed] signal by calling the
// [method@Gtk.SelectionModel.selection_changed] function. The positions given
// in that signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the
// [signal@Gio.ListModel::items-changed] signal are selected or not is up to the
// implementation.
//
// Note that items added via [signal@Gio.ListModel::items-changed] may already
// be selected and no [signal@Gtk.SelectionModel::selection-changed] will be
// emitted for them. So to track which items are selected, it is necessary to
// listen to both signals.
//
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow users
// to select and unselect items. However, `GtkSelectionModel`s are free to only
// implement them partially or not at all. In that case the widgets will not
// support the unimplemented operations.
//
// When selecting or unselecting is supported by a model, the return values of
// the selection functions do *not* indicate if selection or unselection happened.
// They are only meant to indicate complete failure, like when this mode of
// selecting is not supported by the model.
//
// Selections may happen asynchronously, so the only reliable way to find out
// when an item was selected is to listen to the signals that indicate selection.
type SelectionModel interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	GetSelection() *Bitset
	GetSelectionInRange(PositionVar uint, NItemsVar uint) *Bitset
	IsSelected(PositionVar uint) bool
	SelectAll() bool
	SelectItem(PositionVar uint, UnselectRestVar bool) bool
	SelectRange(PositionVar uint, NItemsVar uint, UnselectRestVar bool) bool
	SelectionChanged(PositionVar uint, NItemsVar uint)
	SetSelection(SelectedVar *Bitset, MaskVar *Bitset) bool
	UnselectAll() bool
	UnselectItem(PositionVar uint) bool
	UnselectRange(PositionVar uint, NItemsVar uint) bool
}

var xSelectionModelGLibType func() types.GType

func SelectionModelGLibType() types.GType {
	return xSelectionModelGLibType()
}

type SelectionModelBase struct {
	Ptr uintptr
}

func (x *SelectionModelBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *SelectionModelBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Gets the set containing all currently selected items in the model.
//
// This function may be slow, so if you are only interested in single item,
// consider using [method@Gtk.SelectionModel.is_selected] or if you are only
// interested in a few, consider [method@Gtk.SelectionModel.get_selection_in_range].
func (x *SelectionModelBase) GetSelection() *Bitset {

	cret := XGtkSelectionModelGetSelection(x.GoPointer())

	return cret
}

// Gets the set of selected items in a range.
//
// This function is an optimization for
// [method@Gtk.SelectionModel.get_selection] when you are only
// interested in part of the model's selected state. A common use
// case is in response to the [signal@Gtk.SelectionModel::selection-changed]
// signal.
func (x *SelectionModelBase) GetSelectionInRange(PositionVar uint, NItemsVar uint) *Bitset {

	cret := XGtkSelectionModelGetSelectionInRange(x.GoPointer(), PositionVar, NItemsVar)

	return cret
}

// Checks if the given item is selected.
func (x *SelectionModelBase) IsSelected(PositionVar uint) bool {

	cret := XGtkSelectionModelIsSelected(x.GoPointer(), PositionVar)

	return cret
}

// Requests to select all items in the model.
func (x *SelectionModelBase) SelectAll() bool {

	cret := XGtkSelectionModelSelectAll(x.GoPointer())

	return cret
}

// Requests to select an item in the model.
func (x *SelectionModelBase) SelectItem(PositionVar uint, UnselectRestVar bool) bool {

	cret := XGtkSelectionModelSelectItem(x.GoPointer(), PositionVar, UnselectRestVar)

	return cret
}

// Requests to select a range of items in the model.
func (x *SelectionModelBase) SelectRange(PositionVar uint, NItemsVar uint, UnselectRestVar bool) bool {

	cret := XGtkSelectionModelSelectRange(x.GoPointer(), PositionVar, NItemsVar, UnselectRestVar)

	return cret
}

// Helper function for implementations of `GtkSelectionModel`.
//
// Call this when the selection changes to emit the
// [signal@Gtk.SelectionModel::selection-changed] signal.
func (x *SelectionModelBase) SelectionChanged(PositionVar uint, NItemsVar uint) {

	XGtkSelectionModelSelectionChanged(x.GoPointer(), PositionVar, NItemsVar)

}

// Make selection changes.
//
// This is the most advanced selection updating method that allows
// the most fine-grained control over selection changes. If you can,
// you should try the simpler versions, as implementations are more
// likely to implement support for those.
//
// Requests that the selection state of all positions set in @mask
// be updated to the respective value in the @selected bitmask.
//
// In pseudocode, it would look something like this:
//
// ```c
// for (i = 0; i &lt; n_items; i++)
//
//	{
//	  // don't change values not in the mask
//	  if (!gtk_bitset_contains (mask, i))
//	    continue;
//
//	  if (gtk_bitset_contains (selected, i))
//	    select_item (i);
//	  else
//	    unselect_item (i);
//	}
//
// gtk_selection_model_selection_changed (model,
//
//	first_changed_item,
//	n_changed_items);
//
// ```
//
// @mask and @selected must not be modified. They may refer to the
// same bitset, which would mean that every item in the set should
// be selected.
func (x *SelectionModelBase) SetSelection(SelectedVar *Bitset, MaskVar *Bitset) bool {

	cret := XGtkSelectionModelSetSelection(x.GoPointer(), SelectedVar, MaskVar)

	return cret
}

// Requests to unselect all items in the model.
func (x *SelectionModelBase) UnselectAll() bool {

	cret := XGtkSelectionModelUnselectAll(x.GoPointer())

	return cret
}

// Requests to unselect an item in the model.
func (x *SelectionModelBase) UnselectItem(PositionVar uint) bool {

	cret := XGtkSelectionModelUnselectItem(x.GoPointer(), PositionVar)

	return cret
}

// Requests to unselect a range of items in the model.
func (x *SelectionModelBase) UnselectRange(PositionVar uint, NItemsVar uint) bool {

	cret := XGtkSelectionModelUnselectRange(x.GoPointer(), PositionVar, NItemsVar)

	return cret
}

var XGtkSelectionModelGetSelection func(uintptr) *Bitset
var XGtkSelectionModelGetSelectionInRange func(uintptr, uint, uint) *Bitset
var XGtkSelectionModelIsSelected func(uintptr, uint) bool
var XGtkSelectionModelSelectAll func(uintptr) bool
var XGtkSelectionModelSelectItem func(uintptr, uint, bool) bool
var XGtkSelectionModelSelectRange func(uintptr, uint, uint, bool) bool
var XGtkSelectionModelSelectionChanged func(uintptr, uint, uint)
var XGtkSelectionModelSetSelection func(uintptr, *Bitset, *Bitset) bool
var XGtkSelectionModelUnselectAll func(uintptr) bool
var XGtkSelectionModelUnselectItem func(uintptr, uint) bool
var XGtkSelectionModelUnselectRange func(uintptr, uint, uint) bool

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSelectionModelGLibType, libs, "gtk_selection_model_get_type")

	core.PuregoSafeRegister(&XGtkSelectionModelGetSelection, libs, "gtk_selection_model_get_selection")
	core.PuregoSafeRegister(&XGtkSelectionModelGetSelectionInRange, libs, "gtk_selection_model_get_selection_in_range")
	core.PuregoSafeRegister(&XGtkSelectionModelIsSelected, libs, "gtk_selection_model_is_selected")
	core.PuregoSafeRegister(&XGtkSelectionModelSelectAll, libs, "gtk_selection_model_select_all")
	core.PuregoSafeRegister(&XGtkSelectionModelSelectItem, libs, "gtk_selection_model_select_item")
	core.PuregoSafeRegister(&XGtkSelectionModelSelectRange, libs, "gtk_selection_model_select_range")
	core.PuregoSafeRegister(&XGtkSelectionModelSelectionChanged, libs, "gtk_selection_model_selection_changed")
	core.PuregoSafeRegister(&XGtkSelectionModelSetSelection, libs, "gtk_selection_model_set_selection")
	core.PuregoSafeRegister(&XGtkSelectionModelUnselectAll, libs, "gtk_selection_model_unselect_all")
	core.PuregoSafeRegister(&XGtkSelectionModelUnselectItem, libs, "gtk_selection_model_unselect_item")
	core.PuregoSafeRegister(&XGtkSelectionModelUnselectRange, libs, "gtk_selection_model_unselect_range")

}
