// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type TreeDragDestIface struct {
	_ structs.HostLayout

	GIface uintptr

	xDragDataReceived uintptr

	xRowDropPossible uintptr
}

func (x *TreeDragDestIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideDragDataReceived sets the "drag_data_received" callback function.
// Asks the `GtkTreeDragDest` to insert a row
//
//	before the path dest, deriving the contents of the row from
//	selection_data.
func (x *TreeDragDestIface) OverrideDragDataReceived(cb func(TreeDragDest, *TreePath, *gobject.Value) bool) {
	if cb == nil {
		x.xDragDataReceived = 0
	} else {
		x.xDragDataReceived = purego.NewCallback(func(DragDestVarp uintptr, DestVarp *TreePath, ValueVarp *gobject.Value) bool {
			return cb(&TreeDragDestBase{Ptr: DragDestVarp}, DestVarp, ValueVarp)
		})
	}
}

// GetDragDataReceived gets the "drag_data_received" callback function.
// Asks the `GtkTreeDragDest` to insert a row
//
//	before the path dest, deriving the contents of the row from
//	selection_data.
func (x *TreeDragDestIface) GetDragDataReceived() func(TreeDragDest, *TreePath, *gobject.Value) bool {
	if x.xDragDataReceived == 0 {
		return nil
	}
	var rawCallback func(DragDestVarp uintptr, DestVarp *TreePath, ValueVarp *gobject.Value) bool
	purego.RegisterFunc(&rawCallback, x.xDragDataReceived)
	return func(DragDestVar TreeDragDest, DestVar *TreePath, ValueVar *gobject.Value) bool {
		return rawCallback(DragDestVar.GoPointer(), DestVar, ValueVar)
	}
}

// OverrideRowDropPossible sets the "row_drop_possible" callback function.
// Determines whether a drop is possible before
//
//	the given dest_path, at the same depth as dest_path.
func (x *TreeDragDestIface) OverrideRowDropPossible(cb func(TreeDragDest, *TreePath, *gobject.Value) bool) {
	if cb == nil {
		x.xRowDropPossible = 0
	} else {
		x.xRowDropPossible = purego.NewCallback(func(DragDestVarp uintptr, DestPathVarp *TreePath, ValueVarp *gobject.Value) bool {
			return cb(&TreeDragDestBase{Ptr: DragDestVarp}, DestPathVarp, ValueVarp)
		})
	}
}

// GetRowDropPossible gets the "row_drop_possible" callback function.
// Determines whether a drop is possible before
//
//	the given dest_path, at the same depth as dest_path.
func (x *TreeDragDestIface) GetRowDropPossible() func(TreeDragDest, *TreePath, *gobject.Value) bool {
	if x.xRowDropPossible == 0 {
		return nil
	}
	var rawCallback func(DragDestVarp uintptr, DestPathVarp *TreePath, ValueVarp *gobject.Value) bool
	purego.RegisterFunc(&rawCallback, x.xRowDropPossible)
	return func(DragDestVar TreeDragDest, DestPathVar *TreePath, ValueVar *gobject.Value) bool {
		return rawCallback(DragDestVar.GoPointer(), DestPathVar, ValueVar)
	}
}

type TreeDragSourceIface struct {
	_ structs.HostLayout

	GIface uintptr

	xRowDraggable uintptr

	xDragDataGet uintptr

	xDragDataDelete uintptr
}

func (x *TreeDragSourceIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideRowDraggable sets the "row_draggable" callback function.
// Asks the `GtkTreeDragSource` whether a particular
//
//	row can be used as the source of a DND operation.
func (x *TreeDragSourceIface) OverrideRowDraggable(cb func(TreeDragSource, *TreePath) bool) {
	if cb == nil {
		x.xRowDraggable = 0
	} else {
		x.xRowDraggable = purego.NewCallback(func(DragSourceVarp uintptr, PathVarp *TreePath) bool {
			return cb(&TreeDragSourceBase{Ptr: DragSourceVarp}, PathVarp)
		})
	}
}

// GetRowDraggable gets the "row_draggable" callback function.
// Asks the `GtkTreeDragSource` whether a particular
//
//	row can be used as the source of a DND operation.
func (x *TreeDragSourceIface) GetRowDraggable() func(TreeDragSource, *TreePath) bool {
	if x.xRowDraggable == 0 {
		return nil
	}
	var rawCallback func(DragSourceVarp uintptr, PathVarp *TreePath) bool
	purego.RegisterFunc(&rawCallback, x.xRowDraggable)
	return func(DragSourceVar TreeDragSource, PathVar *TreePath) bool {
		return rawCallback(DragSourceVar.GoPointer(), PathVar)
	}
}

// OverrideDragDataGet sets the "drag_data_get" callback function.
// Asks the `GtkTreeDragSource` to fill in
//
//	selection_data with a representation of the row at path.
func (x *TreeDragSourceIface) OverrideDragDataGet(cb func(TreeDragSource, *TreePath) *gdk.ContentProvider) {
	if cb == nil {
		x.xDragDataGet = 0
	} else {
		x.xDragDataGet = purego.NewCallback(func(DragSourceVarp uintptr, PathVarp *TreePath) uintptr {
			ret := cb(&TreeDragSourceBase{Ptr: DragSourceVarp}, PathVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetDragDataGet gets the "drag_data_get" callback function.
// Asks the `GtkTreeDragSource` to fill in
//
//	selection_data with a representation of the row at path.
func (x *TreeDragSourceIface) GetDragDataGet() func(TreeDragSource, *TreePath) *gdk.ContentProvider {
	if x.xDragDataGet == 0 {
		return nil
	}
	var rawCallback func(DragSourceVarp uintptr, PathVarp *TreePath) uintptr
	purego.RegisterFunc(&rawCallback, x.xDragDataGet)
	return func(DragSourceVar TreeDragSource, PathVar *TreePath) *gdk.ContentProvider {
		rawRet := rawCallback(DragSourceVar.GoPointer(), PathVar)
		if rawRet == 0 {
			return nil
		}
		ret := &gdk.ContentProvider{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideDragDataDelete sets the "drag_data_delete" callback function.
// Asks the `GtkTreeDragSource` to delete the row at
//
//	path, because it was moved somewhere else via drag-and-drop.
func (x *TreeDragSourceIface) OverrideDragDataDelete(cb func(TreeDragSource, *TreePath) bool) {
	if cb == nil {
		x.xDragDataDelete = 0
	} else {
		x.xDragDataDelete = purego.NewCallback(func(DragSourceVarp uintptr, PathVarp *TreePath) bool {
			return cb(&TreeDragSourceBase{Ptr: DragSourceVarp}, PathVarp)
		})
	}
}

// GetDragDataDelete gets the "drag_data_delete" callback function.
// Asks the `GtkTreeDragSource` to delete the row at
//
//	path, because it was moved somewhere else via drag-and-drop.
func (x *TreeDragSourceIface) GetDragDataDelete() func(TreeDragSource, *TreePath) bool {
	if x.xDragDataDelete == 0 {
		return nil
	}
	var rawCallback func(DragSourceVarp uintptr, PathVarp *TreePath) bool
	purego.RegisterFunc(&rawCallback, x.xDragDataDelete)
	return func(DragSourceVar TreeDragSource, PathVar *TreePath) bool {
		return rawCallback(DragSourceVar.GoPointer(), PathVar)
	}
}

// Interface for Drag-and-Drop destinations in `GtkTreeView`.
type TreeDragDest interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	DragDataReceived(DestVar *TreePath, ValueVar *gobject.Value) bool
	RowDropPossible(DestPathVar *TreePath, ValueVar *gobject.Value) bool
}

var xTreeDragDestGLibType func() types.GType

func TreeDragDestGLibType() types.GType {
	return xTreeDragDestGLibType()
}

type TreeDragDestBase struct {
	Ptr uintptr
}

func (x *TreeDragDestBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *TreeDragDestBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Asks the `GtkTreeDragDest` to insert a row before the path @dest,
// deriving the contents of the row from @value. If @dest is
// outside the tree so that inserting before it is impossible, %FALSE
// will be returned. Also, %FALSE may be returned if the new row is
// not created for some model-specific reason.  Should robustly handle
// a @dest no longer found in the model!
func (x *TreeDragDestBase) DragDataReceived(DestVar *TreePath, ValueVar *gobject.Value) bool {

	cret := XGtkTreeDragDestDragDataReceived(x.GoPointer(), DestVar, ValueVar)

	return cret
}

// Determines whether a drop is possible before the given @dest_path,
// at the same depth as @dest_path. i.e., can we drop the data in
// @value at that location. @dest_path does not have to
// exist; the return value will almost certainly be %FALSE if the
// parent of @dest_path doesn’t exist, though.
func (x *TreeDragDestBase) RowDropPossible(DestPathVar *TreePath, ValueVar *gobject.Value) bool {

	cret := XGtkTreeDragDestRowDropPossible(x.GoPointer(), DestPathVar, ValueVar)

	return cret
}

var XGtkTreeDragDestDragDataReceived func(uintptr, *TreePath, *gobject.Value) bool
var XGtkTreeDragDestRowDropPossible func(uintptr, *TreePath, *gobject.Value) bool

// Interface for Drag-and-Drop destinations in `GtkTreeView`.
type TreeDragSource interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	DragDataDelete(PathVar *TreePath) bool
	DragDataGet(PathVar *TreePath) *gdk.ContentProvider
	RowDraggable(PathVar *TreePath) bool
}

var xTreeDragSourceGLibType func() types.GType

func TreeDragSourceGLibType() types.GType {
	return xTreeDragSourceGLibType()
}

type TreeDragSourceBase struct {
	Ptr uintptr
}

func (x *TreeDragSourceBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *TreeDragSourceBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Asks the `GtkTreeDragSource` to delete the row at @path, because
// it was moved somewhere else via drag-and-drop. Returns %FALSE
// if the deletion fails because @path no longer exists, or for
// some model-specific reason. Should robustly handle a @path no
// longer found in the model!
func (x *TreeDragSourceBase) DragDataDelete(PathVar *TreePath) bool {

	cret := XGtkTreeDragSourceDragDataDelete(x.GoPointer(), PathVar)

	return cret
}

// Asks the `GtkTreeDragSource` to return a `GdkContentProvider` representing
// the row at @path. Should robustly handle a @path no
// longer found in the model!
func (x *TreeDragSourceBase) DragDataGet(PathVar *TreePath) *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := XGtkTreeDragSourceDragDataGet(x.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

// Asks the `GtkTreeDragSource` whether a particular row can be used as
// the source of a DND operation. If the source doesn’t implement
// this interface, the row is assumed draggable.
func (x *TreeDragSourceBase) RowDraggable(PathVar *TreePath) bool {

	cret := XGtkTreeDragSourceRowDraggable(x.GoPointer(), PathVar)

	return cret
}

var XGtkTreeDragSourceDragDataDelete func(uintptr, *TreePath) bool
var XGtkTreeDragSourceDragDataGet func(uintptr, *TreePath) uintptr
var XGtkTreeDragSourceRowDraggable func(uintptr, *TreePath) bool

var xTreeCreateRowDragContent func(uintptr, *TreePath) uintptr

// Creates a content provider for dragging @path from @tree_model.
func TreeCreateRowDragContent(TreeModelVar TreeModel, PathVar *TreePath) *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := xTreeCreateRowDragContent(TreeModelVar.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xTreeGetRowDragData func(*gobject.Value, **TreeModel, **TreePath) bool

// Obtains a @tree_model and @path from value of target type
// %GTK_TYPE_TREE_ROW_DATA.
//
// The returned path must be freed with gtk_tree_path_free().
func TreeGetRowDragData(ValueVar *gobject.Value, TreeModelVar **TreeModel, PathVar **TreePath) bool {

	cret := xTreeGetRowDragData(ValueVar, TreeModelVar, PathVar)

	return cret
}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTreeCreateRowDragContent, libs, "gtk_tree_create_row_drag_content")
	core.PuregoSafeRegister(&xTreeGetRowDragData, libs, "gtk_tree_get_row_drag_data")

	core.PuregoSafeRegister(&xTreeDragDestGLibType, libs, "gtk_tree_drag_dest_get_type")

	core.PuregoSafeRegister(&XGtkTreeDragDestDragDataReceived, libs, "gtk_tree_drag_dest_drag_data_received")
	core.PuregoSafeRegister(&XGtkTreeDragDestRowDropPossible, libs, "gtk_tree_drag_dest_row_drop_possible")

	core.PuregoSafeRegister(&xTreeDragSourceGLibType, libs, "gtk_tree_drag_source_get_type")

	core.PuregoSafeRegister(&XGtkTreeDragSourceDragDataDelete, libs, "gtk_tree_drag_source_drag_data_delete")
	core.PuregoSafeRegister(&XGtkTreeDragSourceDragDataGet, libs, "gtk_tree_drag_source_drag_data_get")
	core.PuregoSafeRegister(&XGtkTreeDragSourceRowDraggable, libs, "gtk_tree_drag_source_row_draggable")

}
