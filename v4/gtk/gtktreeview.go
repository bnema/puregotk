// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Function type for determining whether @column can be dropped in a
// particular spot (as determined by @prev_column and @next_column).  In
// left to right locales, @prev_column is on the left of the potential drop
// spot, and @next_column is on the right.  In right to left mode, this is
// reversed.  This function should return %TRUE if the spot is a valid drop
// spot.  Please note that returning %TRUE does not actually indicate that
// the column drop was made, but is meant only to indicate a possible drop
// spot to the user.
type TreeViewColumnDropFunc func(uintptr, uintptr, uintptr, uintptr, uintptr) bool

// Function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(uintptr, *TreePath, uintptr)

// Function type for determining whether the row pointed to by @iter should
// be rendered as a separator. A common way to implement this is to have a
// boolean column in the model, whose values the `GtkTreeViewRowSeparatorFunc`
// returns.
type TreeViewRowSeparatorFunc func(uintptr, *TreeIter, uintptr) bool

// A function used for checking whether a row in @model matches
// a search key string entered by the user. Note the return value
// is reversed from what you would normally expect, though it
// has some similarity to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(uintptr, int, string, *TreeIter, uintptr) bool

type TreeViewClass struct {
	_ structs.HostLayout

	ParentClass WidgetClass

	xRowActivated uintptr

	xTestExpandRow uintptr

	xTestCollapseRow uintptr

	xRowExpanded uintptr

	xRowCollapsed uintptr

	xColumnsChanged uintptr

	xCursorChanged uintptr

	xMoveCursor uintptr

	xSelectAll uintptr

	xUnselectAll uintptr

	xSelectCursorRow uintptr

	xToggleCursorRow uintptr

	xExpandCollapseCursorRow uintptr

	xSelectCursorParent uintptr

	xStartInteractiveSearch uintptr

	Reserved [16]uintptr
}

func (x *TreeViewClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideRowActivated sets the "row_activated" callback function.
func (x *TreeViewClass) OverrideRowActivated(cb func(*TreeView, *TreePath, *TreeViewColumn)) {
	if cb == nil {
		x.xRowActivated = 0
	} else {
		x.xRowActivated = purego.NewCallback(func(TreeViewVarp uintptr, PathVarp *TreePath, ColumnVarp uintptr) {
			cb(TreeViewNewFromInternalPtr(TreeViewVarp), PathVarp, TreeViewColumnNewFromInternalPtr(ColumnVarp))
		})
	}
}

// GetRowActivated gets the "row_activated" callback function.
func (x *TreeViewClass) GetRowActivated() func(*TreeView, *TreePath, *TreeViewColumn) {
	if x.xRowActivated == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr, PathVarp *TreePath, ColumnVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRowActivated)
	return func(TreeViewVar *TreeView, PathVar *TreePath, ColumnVar *TreeViewColumn) {
		rawCallback(TreeViewVar.GoPointer(), PathVar, ColumnVar.GoPointer())
	}
}

// OverrideTestExpandRow sets the "test_expand_row" callback function.
func (x *TreeViewClass) OverrideTestExpandRow(cb func(*TreeView, *TreeIter, *TreePath) bool) {
	if cb == nil {
		x.xTestExpandRow = 0
	} else {
		x.xTestExpandRow = purego.NewCallback(func(TreeViewVarp uintptr, IterVarp *TreeIter, PathVarp *TreePath) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp), IterVarp, PathVarp)
		})
	}
}

// GetTestExpandRow gets the "test_expand_row" callback function.
func (x *TreeViewClass) GetTestExpandRow() func(*TreeView, *TreeIter, *TreePath) bool {
	if x.xTestExpandRow == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr, IterVarp *TreeIter, PathVarp *TreePath) bool
	purego.RegisterFunc(&rawCallback, x.xTestExpandRow)
	return func(TreeViewVar *TreeView, IterVar *TreeIter, PathVar *TreePath) bool {
		return rawCallback(TreeViewVar.GoPointer(), IterVar, PathVar)
	}
}

// OverrideTestCollapseRow sets the "test_collapse_row" callback function.
func (x *TreeViewClass) OverrideTestCollapseRow(cb func(*TreeView, *TreeIter, *TreePath) bool) {
	if cb == nil {
		x.xTestCollapseRow = 0
	} else {
		x.xTestCollapseRow = purego.NewCallback(func(TreeViewVarp uintptr, IterVarp *TreeIter, PathVarp *TreePath) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp), IterVarp, PathVarp)
		})
	}
}

// GetTestCollapseRow gets the "test_collapse_row" callback function.
func (x *TreeViewClass) GetTestCollapseRow() func(*TreeView, *TreeIter, *TreePath) bool {
	if x.xTestCollapseRow == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr, IterVarp *TreeIter, PathVarp *TreePath) bool
	purego.RegisterFunc(&rawCallback, x.xTestCollapseRow)
	return func(TreeViewVar *TreeView, IterVar *TreeIter, PathVar *TreePath) bool {
		return rawCallback(TreeViewVar.GoPointer(), IterVar, PathVar)
	}
}

// OverrideRowExpanded sets the "row_expanded" callback function.
func (x *TreeViewClass) OverrideRowExpanded(cb func(*TreeView, *TreeIter, *TreePath)) {
	if cb == nil {
		x.xRowExpanded = 0
	} else {
		x.xRowExpanded = purego.NewCallback(func(TreeViewVarp uintptr, IterVarp *TreeIter, PathVarp *TreePath) {
			cb(TreeViewNewFromInternalPtr(TreeViewVarp), IterVarp, PathVarp)
		})
	}
}

// GetRowExpanded gets the "row_expanded" callback function.
func (x *TreeViewClass) GetRowExpanded() func(*TreeView, *TreeIter, *TreePath) {
	if x.xRowExpanded == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr, IterVarp *TreeIter, PathVarp *TreePath)
	purego.RegisterFunc(&rawCallback, x.xRowExpanded)
	return func(TreeViewVar *TreeView, IterVar *TreeIter, PathVar *TreePath) {
		rawCallback(TreeViewVar.GoPointer(), IterVar, PathVar)
	}
}

// OverrideRowCollapsed sets the "row_collapsed" callback function.
func (x *TreeViewClass) OverrideRowCollapsed(cb func(*TreeView, *TreeIter, *TreePath)) {
	if cb == nil {
		x.xRowCollapsed = 0
	} else {
		x.xRowCollapsed = purego.NewCallback(func(TreeViewVarp uintptr, IterVarp *TreeIter, PathVarp *TreePath) {
			cb(TreeViewNewFromInternalPtr(TreeViewVarp), IterVarp, PathVarp)
		})
	}
}

// GetRowCollapsed gets the "row_collapsed" callback function.
func (x *TreeViewClass) GetRowCollapsed() func(*TreeView, *TreeIter, *TreePath) {
	if x.xRowCollapsed == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr, IterVarp *TreeIter, PathVarp *TreePath)
	purego.RegisterFunc(&rawCallback, x.xRowCollapsed)
	return func(TreeViewVar *TreeView, IterVar *TreeIter, PathVar *TreePath) {
		rawCallback(TreeViewVar.GoPointer(), IterVar, PathVar)
	}
}

// OverrideColumnsChanged sets the "columns_changed" callback function.
func (x *TreeViewClass) OverrideColumnsChanged(cb func(*TreeView)) {
	if cb == nil {
		x.xColumnsChanged = 0
	} else {
		x.xColumnsChanged = purego.NewCallback(func(TreeViewVarp uintptr) {
			cb(TreeViewNewFromInternalPtr(TreeViewVarp))
		})
	}
}

// GetColumnsChanged gets the "columns_changed" callback function.
func (x *TreeViewClass) GetColumnsChanged() func(*TreeView) {
	if x.xColumnsChanged == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xColumnsChanged)
	return func(TreeViewVar *TreeView) {
		rawCallback(TreeViewVar.GoPointer())
	}
}

// OverrideCursorChanged sets the "cursor_changed" callback function.
func (x *TreeViewClass) OverrideCursorChanged(cb func(*TreeView)) {
	if cb == nil {
		x.xCursorChanged = 0
	} else {
		x.xCursorChanged = purego.NewCallback(func(TreeViewVarp uintptr) {
			cb(TreeViewNewFromInternalPtr(TreeViewVarp))
		})
	}
}

// GetCursorChanged gets the "cursor_changed" callback function.
func (x *TreeViewClass) GetCursorChanged() func(*TreeView) {
	if x.xCursorChanged == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCursorChanged)
	return func(TreeViewVar *TreeView) {
		rawCallback(TreeViewVar.GoPointer())
	}
}

// OverrideMoveCursor sets the "move_cursor" callback function.
func (x *TreeViewClass) OverrideMoveCursor(cb func(*TreeView, MovementStep, int, bool, bool) bool) {
	if cb == nil {
		x.xMoveCursor = 0
	} else {
		x.xMoveCursor = purego.NewCallback(func(TreeViewVarp uintptr, StepVarp MovementStep, CountVarp int, ExtendVarp bool, ModifyVarp bool) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp), StepVarp, CountVarp, ExtendVarp, ModifyVarp)
		})
	}
}

// GetMoveCursor gets the "move_cursor" callback function.
func (x *TreeViewClass) GetMoveCursor() func(*TreeView, MovementStep, int, bool, bool) bool {
	if x.xMoveCursor == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr, StepVarp MovementStep, CountVarp int, ExtendVarp bool, ModifyVarp bool) bool
	purego.RegisterFunc(&rawCallback, x.xMoveCursor)
	return func(TreeViewVar *TreeView, StepVar MovementStep, CountVar int, ExtendVar bool, ModifyVar bool) bool {
		return rawCallback(TreeViewVar.GoPointer(), StepVar, CountVar, ExtendVar, ModifyVar)
	}
}

// OverrideSelectAll sets the "select_all" callback function.
func (x *TreeViewClass) OverrideSelectAll(cb func(*TreeView) bool) {
	if cb == nil {
		x.xSelectAll = 0
	} else {
		x.xSelectAll = purego.NewCallback(func(TreeViewVarp uintptr) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp))
		})
	}
}

// GetSelectAll gets the "select_all" callback function.
func (x *TreeViewClass) GetSelectAll() func(*TreeView) bool {
	if x.xSelectAll == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSelectAll)
	return func(TreeViewVar *TreeView) bool {
		return rawCallback(TreeViewVar.GoPointer())
	}
}

// OverrideUnselectAll sets the "unselect_all" callback function.
func (x *TreeViewClass) OverrideUnselectAll(cb func(*TreeView) bool) {
	if cb == nil {
		x.xUnselectAll = 0
	} else {
		x.xUnselectAll = purego.NewCallback(func(TreeViewVarp uintptr) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp))
		})
	}
}

// GetUnselectAll gets the "unselect_all" callback function.
func (x *TreeViewClass) GetUnselectAll() func(*TreeView) bool {
	if x.xUnselectAll == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xUnselectAll)
	return func(TreeViewVar *TreeView) bool {
		return rawCallback(TreeViewVar.GoPointer())
	}
}

// OverrideSelectCursorRow sets the "select_cursor_row" callback function.
func (x *TreeViewClass) OverrideSelectCursorRow(cb func(*TreeView, bool) bool) {
	if cb == nil {
		x.xSelectCursorRow = 0
	} else {
		x.xSelectCursorRow = purego.NewCallback(func(TreeViewVarp uintptr, StartEditingVarp bool) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp), StartEditingVarp)
		})
	}
}

// GetSelectCursorRow gets the "select_cursor_row" callback function.
func (x *TreeViewClass) GetSelectCursorRow() func(*TreeView, bool) bool {
	if x.xSelectCursorRow == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr, StartEditingVarp bool) bool
	purego.RegisterFunc(&rawCallback, x.xSelectCursorRow)
	return func(TreeViewVar *TreeView, StartEditingVar bool) bool {
		return rawCallback(TreeViewVar.GoPointer(), StartEditingVar)
	}
}

// OverrideToggleCursorRow sets the "toggle_cursor_row" callback function.
func (x *TreeViewClass) OverrideToggleCursorRow(cb func(*TreeView) bool) {
	if cb == nil {
		x.xToggleCursorRow = 0
	} else {
		x.xToggleCursorRow = purego.NewCallback(func(TreeViewVarp uintptr) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp))
		})
	}
}

// GetToggleCursorRow gets the "toggle_cursor_row" callback function.
func (x *TreeViewClass) GetToggleCursorRow() func(*TreeView) bool {
	if x.xToggleCursorRow == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xToggleCursorRow)
	return func(TreeViewVar *TreeView) bool {
		return rawCallback(TreeViewVar.GoPointer())
	}
}

// OverrideExpandCollapseCursorRow sets the "expand_collapse_cursor_row" callback function.
func (x *TreeViewClass) OverrideExpandCollapseCursorRow(cb func(*TreeView, bool, bool, bool) bool) {
	if cb == nil {
		x.xExpandCollapseCursorRow = 0
	} else {
		x.xExpandCollapseCursorRow = purego.NewCallback(func(TreeViewVarp uintptr, LogicalVarp bool, ExpandVarp bool, OpenAllVarp bool) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp), LogicalVarp, ExpandVarp, OpenAllVarp)
		})
	}
}

// GetExpandCollapseCursorRow gets the "expand_collapse_cursor_row" callback function.
func (x *TreeViewClass) GetExpandCollapseCursorRow() func(*TreeView, bool, bool, bool) bool {
	if x.xExpandCollapseCursorRow == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr, LogicalVarp bool, ExpandVarp bool, OpenAllVarp bool) bool
	purego.RegisterFunc(&rawCallback, x.xExpandCollapseCursorRow)
	return func(TreeViewVar *TreeView, LogicalVar bool, ExpandVar bool, OpenAllVar bool) bool {
		return rawCallback(TreeViewVar.GoPointer(), LogicalVar, ExpandVar, OpenAllVar)
	}
}

// OverrideSelectCursorParent sets the "select_cursor_parent" callback function.
func (x *TreeViewClass) OverrideSelectCursorParent(cb func(*TreeView) bool) {
	if cb == nil {
		x.xSelectCursorParent = 0
	} else {
		x.xSelectCursorParent = purego.NewCallback(func(TreeViewVarp uintptr) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp))
		})
	}
}

// GetSelectCursorParent gets the "select_cursor_parent" callback function.
func (x *TreeViewClass) GetSelectCursorParent() func(*TreeView) bool {
	if x.xSelectCursorParent == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSelectCursorParent)
	return func(TreeViewVar *TreeView) bool {
		return rawCallback(TreeViewVar.GoPointer())
	}
}

// OverrideStartInteractiveSearch sets the "start_interactive_search" callback function.
func (x *TreeViewClass) OverrideStartInteractiveSearch(cb func(*TreeView) bool) {
	if cb == nil {
		x.xStartInteractiveSearch = 0
	} else {
		x.xStartInteractiveSearch = purego.NewCallback(func(TreeViewVarp uintptr) bool {
			return cb(TreeViewNewFromInternalPtr(TreeViewVarp))
		})
	}
}

// GetStartInteractiveSearch gets the "start_interactive_search" callback function.
func (x *TreeViewClass) GetStartInteractiveSearch() func(*TreeView) bool {
	if x.xStartInteractiveSearch == 0 {
		return nil
	}
	var rawCallback func(TreeViewVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xStartInteractiveSearch)
	return func(TreeViewVar *TreeView) bool {
		return rawCallback(TreeViewVar.GoPointer())
	}
}

// An enum for determining where a dropped row goes.
type TreeViewDropPosition int

var xTreeViewDropPositionGLibType func() types.GType

func TreeViewDropPositionGLibType() types.GType {
	return xTreeViewDropPositionGLibType()
}

const (

	// dropped row is inserted before
	TreeViewDropBeforeValue TreeViewDropPosition = 0
	// dropped row is inserted after
	TreeViewDropAfterValue TreeViewDropPosition = 1
	// dropped row becomes a child or is inserted before
	TreeViewDropIntoOrBeforeValue TreeViewDropPosition = 2
	// dropped row becomes a child or is inserted after
	TreeViewDropIntoOrAfterValue TreeViewDropPosition = 3
)

// A widget for displaying both trees and lists
//
// &lt;picture&gt;
//
//	&lt;source srcset="list-and-tree-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkTreeView" src="list-and-tree.png"&gt;
//
// &lt;/picture&gt;
//
// Widget that displays any object that implements the [iface@Gtk.TreeModel] interface.
//
// Please refer to the [tree widget conceptual overview](section-tree-widget.html)
// for an overview of all the objects and data types related to the tree
// widget and how they work together.
//
// ## Coordinate systems in GtkTreeView API
//
// Several different coordinate systems are exposed in the `GtkTreeView` API.
// These are:
//
// ![](tree-view-coordinates.png)
//
// - Widget coordinates: Coordinates relative to the widget (usually `widget-&gt;window`).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
//
//   - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
//     coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems.  The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use [method@Gtk.TreeView.convert_widget_to_bin_window_coords]
// (and vice versa), for the latter [method@Gtk.TreeView.convert_bin_window_to_tree_coords]
// (and vice versa).
//
// ## `GtkTreeView` as `GtkBuildable`
//
// The `GtkTreeView` implementation of the `GtkBuildable` interface accepts
// [class@Gtk.TreeViewColumn] objects as `&lt;child&gt;` elements and exposes the
// internal [class@Gtk.TreeSelection] in UI definitions.
//
// An example of a UI definition fragment with `GtkTreeView`:
//
// ```xml
// &lt;object class="GtkTreeView" id="treeview"&gt;
//
//	&lt;property name="model"&gt;liststore1&lt;/property&gt;
//	&lt;child&gt;
//	  &lt;object class="GtkTreeViewColumn" id="test-column"&gt;
//	    &lt;property name="title"&gt;Test&lt;/property&gt;
//	    &lt;child&gt;
//	      &lt;object class="GtkCellRendererText" id="test-renderer"/&gt;
//	      &lt;attributes&gt;
//	        &lt;attribute name="text"&gt;1&lt;/attribute&gt;
//	      &lt;/attributes&gt;
//	    &lt;/child&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//	&lt;child internal-child="selection"&gt;
//	  &lt;object class="GtkTreeSelection" id="selection"&gt;
//	    &lt;signal name="changed" handler="on_treeview_selection_changed"/&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//
// &lt;/object&gt;
// ```
//
// ## CSS nodes
//
// ```
// treeview.view
// ├── header
// │   ├── button
// │   │   ╰── [sort-indicator]
// ┊   ┊
// │   ╰── button
// │       ╰── [sort-indicator]
// │
// ├── [rubberband]
// ╰── [dndtarget]
// ```
//
// `GtkTreeView` has a main CSS node with name `treeview` and style class `.view`.
// It has a subnode with name `header`, which is the parent for all the column
// header widgets' CSS nodes.
//
// Each column header consists of a `button`, which among other content, has a
// child with name `sort-indicator`, which carries the `.ascending` or `.descending`
// style classes when the column header should show a sort indicator. The CSS
// is expected to provide a suitable image using the `-gtk-icon-source` property.
//
// For rubberband selection, a subnode with name `rubberband` is used.
//
// For the drop target location during DND, a subnode with name `dndtarget` is used.
type TreeView struct {
	Widget
}

var xTreeViewGLibType func() types.GType

func TreeViewGLibType() types.GType {
	return xTreeViewGLibType()
}

func TreeViewNewFromInternalPtr(ptr uintptr) *TreeView {
	cls := &TreeView{}
	cls.Ptr = ptr
	return cls
}

var xNewTreeView func() uintptr

// Creates a new `GtkTreeView` widget.
func NewTreeView() *TreeView {
	var cls *TreeView

	cret := xNewTreeView()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeView{}
	cls.Ptr = cret
	return cls
}

var xNewTreeViewWithModel func(uintptr) uintptr

// Creates a new `GtkTreeView` widget with the model initialized to @model.
func NewTreeViewWithModel(ModelVar TreeModel) *TreeView {
	var cls *TreeView

	cret := xNewTreeViewWithModel(ModelVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeView{}
	cls.Ptr = cret
	return cls
}

var xTreeViewAppendColumn func(uintptr, uintptr) int

// Appends @column to the list of columns. If @tree_view has “fixed_height”
// mode enabled, then @column must have its “sizing” property set to be
// GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) AppendColumn(ColumnVar *TreeViewColumn) int {

	cret := xTreeViewAppendColumn(x.GoPointer(), ColumnVar.GoPointer())
	return cret
}

var xTreeViewCollapseAll func(uintptr)

// Recursively collapses all visible, expanded nodes in @tree_view.
func (x *TreeView) CollapseAll() {

	xTreeViewCollapseAll(x.GoPointer())

}

var xTreeViewCollapseRow func(uintptr, *TreePath) bool

// Collapses a row (hides its child rows, if they exist).
func (x *TreeView) CollapseRow(PathVar *TreePath) bool {

	cret := xTreeViewCollapseRow(x.GoPointer(), PathVar)
	return cret
}

var xTreeViewColumnsAutosize func(uintptr)

// Resizes all columns to their optimal width. Only works after the
// treeview has been realized.
func (x *TreeView) ColumnsAutosize() {

	xTreeViewColumnsAutosize(x.GoPointer())

}

var xTreeViewConvertBinWindowToTreeCoords func(uintptr, int, int, *int, *int)

// Converts bin_window coordinates to coordinates for the
// tree (the full scrollable area of the tree).
func (x *TreeView) ConvertBinWindowToTreeCoords(BxVar int, ByVar int, TxVar *int, TyVar *int) {

	xTreeViewConvertBinWindowToTreeCoords(x.GoPointer(), BxVar, ByVar, TxVar, TyVar)

}

var xTreeViewConvertBinWindowToWidgetCoords func(uintptr, int, int, *int, *int)

// Converts bin_window coordinates to widget relative coordinates.
func (x *TreeView) ConvertBinWindowToWidgetCoords(BxVar int, ByVar int, WxVar *int, WyVar *int) {

	xTreeViewConvertBinWindowToWidgetCoords(x.GoPointer(), BxVar, ByVar, WxVar, WyVar)

}

var xTreeViewConvertTreeToBinWindowCoords func(uintptr, int, int, *int, *int)

// Converts tree coordinates (coordinates in full scrollable area of the tree)
// to bin_window coordinates.
func (x *TreeView) ConvertTreeToBinWindowCoords(TxVar int, TyVar int, BxVar *int, ByVar *int) {

	xTreeViewConvertTreeToBinWindowCoords(x.GoPointer(), TxVar, TyVar, BxVar, ByVar)

}

var xTreeViewConvertTreeToWidgetCoords func(uintptr, int, int, *int, *int)

// Converts tree coordinates (coordinates in full scrollable area of the tree)
// to widget coordinates.
func (x *TreeView) ConvertTreeToWidgetCoords(TxVar int, TyVar int, WxVar *int, WyVar *int) {

	xTreeViewConvertTreeToWidgetCoords(x.GoPointer(), TxVar, TyVar, WxVar, WyVar)

}

var xTreeViewConvertWidgetToBinWindowCoords func(uintptr, int, int, *int, *int)

// Converts widget coordinates to coordinates for the bin_window.
func (x *TreeView) ConvertWidgetToBinWindowCoords(WxVar int, WyVar int, BxVar *int, ByVar *int) {

	xTreeViewConvertWidgetToBinWindowCoords(x.GoPointer(), WxVar, WyVar, BxVar, ByVar)

}

var xTreeViewConvertWidgetToTreeCoords func(uintptr, int, int, *int, *int)

// Converts widget coordinates to coordinates for the
// tree (the full scrollable area of the tree).
func (x *TreeView) ConvertWidgetToTreeCoords(WxVar int, WyVar int, TxVar *int, TyVar *int) {

	xTreeViewConvertWidgetToTreeCoords(x.GoPointer(), WxVar, WyVar, TxVar, TyVar)

}

var xTreeViewCreateRowDragIcon func(uintptr, *TreePath) uintptr

// Creates a `cairo_surface_t` representation of the row at @path.
// This image is used for a drag icon.
func (x *TreeView) CreateRowDragIcon(PathVar *TreePath) *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := xTreeViewCreateRowDragIcon(x.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

var xTreeViewEnableModelDragDest func(uintptr, *gdk.ContentFormats, gdk.DragAction)

// Turns @tree_view into a drop destination for automatic DND. Calling
// this method sets `GtkTreeView`:reorderable to %FALSE.
func (x *TreeView) EnableModelDragDest(FormatsVar *gdk.ContentFormats, ActionsVar gdk.DragAction) {

	xTreeViewEnableModelDragDest(x.GoPointer(), FormatsVar, ActionsVar)

}

var xTreeViewEnableModelDragSource func(uintptr, gdk.ModifierType, *gdk.ContentFormats, gdk.DragAction)

// Turns @tree_view into a drag source for automatic DND. Calling this
// method sets `GtkTreeView`:reorderable to %FALSE.
func (x *TreeView) EnableModelDragSource(StartButtonMaskVar gdk.ModifierType, FormatsVar *gdk.ContentFormats, ActionsVar gdk.DragAction) {

	xTreeViewEnableModelDragSource(x.GoPointer(), StartButtonMaskVar, FormatsVar, ActionsVar)

}

var xTreeViewExpandAll func(uintptr)

// Recursively expands all nodes in the @tree_view.
func (x *TreeView) ExpandAll() {

	xTreeViewExpandAll(x.GoPointer())

}

var xTreeViewExpandRow func(uintptr, *TreePath, bool) bool

// Opens the row so its children are visible.
func (x *TreeView) ExpandRow(PathVar *TreePath, OpenAllVar bool) bool {

	cret := xTreeViewExpandRow(x.GoPointer(), PathVar, OpenAllVar)
	return cret
}

var xTreeViewExpandToPath func(uintptr, *TreePath)

// Expands the row at @path. This will also expand all parent rows of
// @path as necessary.
func (x *TreeView) ExpandToPath(PathVar *TreePath) {

	xTreeViewExpandToPath(x.GoPointer(), PathVar)

}

var xTreeViewGetActivateOnSingleClick func(uintptr) bool

// Gets the setting set by gtk_tree_view_set_activate_on_single_click().
func (x *TreeView) GetActivateOnSingleClick() bool {

	cret := xTreeViewGetActivateOnSingleClick(x.GoPointer())
	return cret
}

var xTreeViewGetBackgroundArea func(uintptr, *TreePath, uintptr, *gdk.Rectangle)

// Fills the bounding rectangle in bin_window coordinates for the cell at the
// row specified by @path and the column specified by @column.  If @path is
// %NULL, or points to a node not found in the tree, the @y and @height fields of
// the rectangle will be filled with 0. If @column is %NULL, the @x and @width
// fields will be filled with 0.  The returned rectangle is equivalent to the
// @background_area passed to gtk_cell_renderer_render().  These background
// areas tile to cover the entire bin window.  Contrast with the @cell_area,
// returned by gtk_tree_view_get_cell_area(), which returns only the cell
// itself, excluding surrounding borders and the tree expander area.
func (x *TreeView) GetBackgroundArea(PathVar *TreePath, ColumnVar *TreeViewColumn, RectVar *gdk.Rectangle) {

	xTreeViewGetBackgroundArea(x.GoPointer(), PathVar, ColumnVar.GoPointer(), RectVar)

}

var xTreeViewGetCellArea func(uintptr, *TreePath, uintptr, *gdk.Rectangle)

// Fills the bounding rectangle in bin_window coordinates for the cell at the
// row specified by @path and the column specified by @column.  If @path is
// %NULL, or points to a path not currently displayed, the @y and @height fields
// of the rectangle will be filled with 0. If @column is %NULL, the @x and @width
// fields will be filled with 0.  The sum of all cell rects does not cover the
// entire tree; there are extra pixels in between rows, for example. The
// returned rectangle is equivalent to the @cell_area passed to
// gtk_cell_renderer_render().  This function is only valid if @tree_view is
// realized.
func (x *TreeView) GetCellArea(PathVar *TreePath, ColumnVar *TreeViewColumn, RectVar *gdk.Rectangle) {

	xTreeViewGetCellArea(x.GoPointer(), PathVar, ColumnVar.GoPointer(), RectVar)

}

var xTreeViewGetColumn func(uintptr, int) uintptr

// Gets the `GtkTreeViewColumn` at the given position in the #tree_view.
func (x *TreeView) GetColumn(NVar int) *TreeViewColumn {
	var cls *TreeViewColumn

	cret := xTreeViewGetColumn(x.GoPointer(), NVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeViewColumn{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetColumns func(uintptr) *glib.List

// Returns a `GList` of all the `GtkTreeViewColumn`s currently in @tree_view.
// The returned list must be freed with g_list_free ().
func (x *TreeView) GetColumns() *glib.List {

	cret := xTreeViewGetColumns(x.GoPointer())
	return cret
}

var xTreeViewGetCursor func(uintptr, **TreePath, **TreeViewColumn)

// Fills in @path and @focus_column with the current path and focus column.  If
// the cursor isn’t currently set, then *@path will be %NULL.  If no column
// currently has focus, then *@focus_column will be %NULL.
//
// The returned `GtkTreePath` must be freed with gtk_tree_path_free() when
// you are done with it.
func (x *TreeView) GetCursor(PathVar **TreePath, FocusColumnVar **TreeViewColumn) {

	xTreeViewGetCursor(x.GoPointer(), PathVar, FocusColumnVar)

}

var xTreeViewGetDestRowAtPos func(uintptr, int, int, **TreePath, *TreeViewDropPosition) bool

// Determines the destination row for a given position.  @drag_x and
// @drag_y are expected to be in widget coordinates.  This function is only
// meaningful if @tree_view is realized.  Therefore this function will always
// return %FALSE if @tree_view is not realized or does not have a model.
func (x *TreeView) GetDestRowAtPos(DragXVar int, DragYVar int, PathVar **TreePath, PosVar *TreeViewDropPosition) bool {

	cret := xTreeViewGetDestRowAtPos(x.GoPointer(), DragXVar, DragYVar, PathVar, PosVar)
	return cret
}

var xTreeViewGetDragDestRow func(uintptr, **TreePath, *TreeViewDropPosition)

// Gets information about the row that is highlighted for feedback.
func (x *TreeView) GetDragDestRow(PathVar **TreePath, PosVar *TreeViewDropPosition) {

	xTreeViewGetDragDestRow(x.GoPointer(), PathVar, PosVar)

}

var xTreeViewGetEnableSearch func(uintptr) bool

// Returns whether or not the tree allows to start interactive searching
// by typing in text.
func (x *TreeView) GetEnableSearch() bool {

	cret := xTreeViewGetEnableSearch(x.GoPointer())
	return cret
}

var xTreeViewGetEnableTreeLines func(uintptr) bool

// Returns whether or not tree lines are drawn in @tree_view.
func (x *TreeView) GetEnableTreeLines() bool {

	cret := xTreeViewGetEnableTreeLines(x.GoPointer())
	return cret
}

var xTreeViewGetExpanderColumn func(uintptr) uintptr

// Returns the column that is the current expander column,
// or %NULL if none has been set.
// This column has the expander arrow drawn next to it.
func (x *TreeView) GetExpanderColumn() *TreeViewColumn {
	var cls *TreeViewColumn

	cret := xTreeViewGetExpanderColumn(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeViewColumn{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetFixedHeightMode func(uintptr) bool

// Returns whether fixed height mode is turned on for @tree_view.
func (x *TreeView) GetFixedHeightMode() bool {

	cret := xTreeViewGetFixedHeightMode(x.GoPointer())
	return cret
}

var xTreeViewGetGridLines func(uintptr) TreeViewGridLines

// Returns which grid lines are enabled in @tree_view.
func (x *TreeView) GetGridLines() TreeViewGridLines {

	cret := xTreeViewGetGridLines(x.GoPointer())
	return cret
}

var xTreeViewGetHeadersClickable func(uintptr) bool

// Returns whether all header columns are clickable.
func (x *TreeView) GetHeadersClickable() bool {

	cret := xTreeViewGetHeadersClickable(x.GoPointer())
	return cret
}

var xTreeViewGetHeadersVisible func(uintptr) bool

// Returns %TRUE if the headers on the @tree_view are visible.
func (x *TreeView) GetHeadersVisible() bool {

	cret := xTreeViewGetHeadersVisible(x.GoPointer())
	return cret
}

var xTreeViewGetHoverExpand func(uintptr) bool

// Returns whether hover expansion mode is turned on for @tree_view.
func (x *TreeView) GetHoverExpand() bool {

	cret := xTreeViewGetHoverExpand(x.GoPointer())
	return cret
}

var xTreeViewGetHoverSelection func(uintptr) bool

// Returns whether hover selection mode is turned on for @tree_view.
func (x *TreeView) GetHoverSelection() bool {

	cret := xTreeViewGetHoverSelection(x.GoPointer())
	return cret
}

var xTreeViewGetLevelIndentation func(uintptr) int

// Returns the amount, in pixels, of extra indentation for child levels
// in @tree_view.
func (x *TreeView) GetLevelIndentation() int {

	cret := xTreeViewGetLevelIndentation(x.GoPointer())
	return cret
}

var xTreeViewGetModel func(uintptr) uintptr

// Returns the model the `GtkTreeView` is based on.  Returns %NULL if the
// model is unset.
func (x *TreeView) GetModel() *TreeModelBase {
	var cls *TreeModelBase

	cret := xTreeViewGetModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeModelBase{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetNColumns func(uintptr) uint

// Queries the number of columns in the given @tree_view.
func (x *TreeView) GetNColumns() uint {

	cret := xTreeViewGetNColumns(x.GoPointer())
	return cret
}

var xTreeViewGetPathAtPos func(uintptr, int, int, **TreePath, **TreeViewColumn, *int, *int) bool

// Finds the path at the point (@x, @y), relative to bin_window coordinates.
// That is, @x and @y are relative to an events coordinates. Widget-relative
// coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
// things like popup menus. If @path is non-%NULL, then it will be filled
// with the `GtkTreePath` at that point.  This path should be freed with
// gtk_tree_path_free().  If @column is non-%NULL, then it will be filled
// with the column at that point.  @cell_x and @cell_y return the coordinates
// relative to the cell background (i.e. the @background_area passed to
// gtk_cell_renderer_render()).  This function is only meaningful if
// @tree_view is realized.  Therefore this function will always return %FALSE
// if @tree_view is not realized or does not have a model.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
func (x *TreeView) GetPathAtPos(XVar int, YVar int, PathVar **TreePath, ColumnVar **TreeViewColumn, CellXVar *int, CellYVar *int) bool {

	cret := xTreeViewGetPathAtPos(x.GoPointer(), XVar, YVar, PathVar, ColumnVar, CellXVar, CellYVar)
	return cret
}

var xTreeViewGetReorderable func(uintptr) bool

// Retrieves whether the user can reorder the tree via drag-and-drop. See
// gtk_tree_view_set_reorderable().
func (x *TreeView) GetReorderable() bool {

	cret := xTreeViewGetReorderable(x.GoPointer())
	return cret
}

var xTreeViewGetRowSeparatorFunc func(uintptr) uintptr

// Returns the current row separator function.
func (x *TreeView) GetRowSeparatorFunc() uintptr {

	cret := xTreeViewGetRowSeparatorFunc(x.GoPointer())
	return cret
}

var xTreeViewGetRubberBanding func(uintptr) bool

// Returns whether rubber banding is turned on for @tree_view.  If the
// selection mode is %GTK_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
func (x *TreeView) GetRubberBanding() bool {

	cret := xTreeViewGetRubberBanding(x.GoPointer())
	return cret
}

var xTreeViewGetSearchColumn func(uintptr) int

// Gets the column searched on by the interactive search code.
func (x *TreeView) GetSearchColumn() int {

	cret := xTreeViewGetSearchColumn(x.GoPointer())
	return cret
}

var xTreeViewGetSearchEntry func(uintptr) uintptr

// Returns the `GtkEntry` which is currently in use as interactive search
// entry for @tree_view.  In case the built-in entry is being used, %NULL
// will be returned.
func (x *TreeView) GetSearchEntry() *EditableBase {
	var cls *EditableBase

	cret := xTreeViewGetSearchEntry(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditableBase{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetSearchEqualFunc func(uintptr) uintptr

// Returns the compare function currently in use.
func (x *TreeView) GetSearchEqualFunc() uintptr {

	cret := xTreeViewGetSearchEqualFunc(x.GoPointer())
	return cret
}

var xTreeViewGetSelection func(uintptr) uintptr

// Gets the `GtkTreeSelection` associated with @tree_view.
func (x *TreeView) GetSelection() *TreeSelection {
	var cls *TreeSelection

	cret := xTreeViewGetSelection(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeSelection{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetShowExpanders func(uintptr) bool

// Returns whether or not expanders are drawn in @tree_view.
func (x *TreeView) GetShowExpanders() bool {

	cret := xTreeViewGetShowExpanders(x.GoPointer())
	return cret
}

var xTreeViewGetTooltipColumn func(uintptr) int

// Returns the column of @tree_view’s model which is being used for
// displaying tooltips on @tree_view’s rows.
func (x *TreeView) GetTooltipColumn() int {

	cret := xTreeViewGetTooltipColumn(x.GoPointer())
	return cret
}

var xTreeViewGetTooltipContext func(uintptr, int, int, bool, **TreeModel, **TreePath, *TreeIter) bool

// This function is supposed to be used in a ::query-tooltip
// signal handler for `GtkTreeView`. The @x, @y and @keyboard_tip values
// which are received in the signal handler, should be passed to this
// function without modification.
//
// The return value indicates whether there is a tree view row at the given
// coordinates (%TRUE) or not (%FALSE) for mouse tooltips. For keyboard
// tooltips the row returned will be the cursor row. When %TRUE, then any of
// @model, @path and @iter which have been provided will be set to point to
// that row and the corresponding model. @x and @y will always be converted
// to be relative to @tree_view’s bin_window if @keyboard_tooltip is %FALSE.
func (x *TreeView) GetTooltipContext(XVar int, YVar int, KeyboardTipVar bool, ModelVar **TreeModel, PathVar **TreePath, IterVar *TreeIter) bool {

	cret := xTreeViewGetTooltipContext(x.GoPointer(), XVar, YVar, KeyboardTipVar, ModelVar, PathVar, IterVar)
	return cret
}

var xTreeViewGetVisibleRange func(uintptr, **TreePath, **TreePath) bool

// Sets @start_path and @end_path to be the first and last visible path.
// Note that there may be invisible paths in between.
//
// The paths should be freed with gtk_tree_path_free() after use.
func (x *TreeView) GetVisibleRange(StartPathVar **TreePath, EndPathVar **TreePath) bool {

	cret := xTreeViewGetVisibleRange(x.GoPointer(), StartPathVar, EndPathVar)
	return cret
}

var xTreeViewGetVisibleRect func(uintptr, *gdk.Rectangle)

// Fills @visible_rect with the currently-visible region of the
// buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords().
// Tree coordinates start at 0,0 for row 0 of the tree, and cover the entire
// scrollable area of the tree.
func (x *TreeView) GetVisibleRect(VisibleRectVar *gdk.Rectangle) {

	xTreeViewGetVisibleRect(x.GoPointer(), VisibleRectVar)

}

var xTreeViewInsertColumn func(uintptr, uintptr, int) int

// This inserts the @column into the @tree_view at @position.  If @position is
// -1, then the column is inserted at the end. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property
// set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) InsertColumn(ColumnVar *TreeViewColumn, PositionVar int) int {

	cret := xTreeViewInsertColumn(x.GoPointer(), ColumnVar.GoPointer(), PositionVar)
	return cret
}

var xTreeViewInsertColumnWithAttributes func(uintptr, int, string, uintptr, ...interface{}) int

// Creates a new `GtkTreeViewColumn` and inserts it into the @tree_view at
// @position.  If @position is -1, then the newly created column is inserted at
// the end.  The column is initialized with the attributes given. If @tree_view
// has “fixed_height” mode enabled, then the new column will have its sizing
// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) InsertColumnWithAttributes(PositionVar int, TitleVar string, CellVar *CellRenderer, varArgs ...interface{}) int {

	cret := xTreeViewInsertColumnWithAttributes(x.GoPointer(), PositionVar, TitleVar, CellVar.GoPointer(), varArgs...)
	return cret
}

var xTreeViewInsertColumnWithDataFunc func(uintptr, int, string, uintptr, uintptr, uintptr, uintptr) int

// Convenience function that inserts a new column into the `GtkTreeView`
// with the given cell renderer and a `GtkTreeCellDataFunc` to set cell renderer
// attributes (normally using data from the model). See also
// gtk_tree_view_column_set_cell_data_func(), gtk_tree_view_column_pack_start().
// If @tree_view has “fixed_height” mode enabled, then the new column will have its
// “sizing” property set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) InsertColumnWithDataFunc(PositionVar int, TitleVar string, CellVar *CellRenderer, FuncVar *TreeCellDataFunc, DataVar uintptr, DnotifyVar *glib.DestroyNotify) int {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := glib.GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr, arg3 *TreeIter, arg4 uintptr) {
				cbFn := *FuncVar
				cbFn(arg0, arg1, arg2, arg3, arg4)
			}
			FuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(FuncVarPtr, FuncVarRef, FuncVar)
		}
	}

	var DnotifyVarRef uintptr
	if DnotifyVar != nil {
		DnotifyVarPtr := uintptr(unsafe.Pointer(DnotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DnotifyVarPtr); ok {
			DnotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DnotifyVar
				cbFn(arg0)
			}
			DnotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DnotifyVarPtr, DnotifyVarRef, DnotifyVar)
		}
	}

	cret := xTreeViewInsertColumnWithDataFunc(x.GoPointer(), PositionVar, TitleVar, CellVar.GoPointer(), FuncVarRef, DataVar, DnotifyVarRef)
	return cret
}

var xTreeViewIsBlankAtPos func(uintptr, int, int, **TreePath, **TreeViewColumn, *int, *int) bool

// Determine whether the point (@x, @y) in @tree_view is blank, that is no
// cell content nor an expander arrow is drawn at the location. If so, the
// location can be considered as the background. You might wish to take
// special action on clicks on the background, such as clearing a current
// selection, having a custom context menu or starting rubber banding.
//
// The @x and @y coordinate that are provided must be relative to bin_window
// coordinates.  Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// The @path, @column, @cell_x and @cell_y arguments will be filled in
// likewise as for gtk_tree_view_get_path_at_pos().  Please see
// gtk_tree_view_get_path_at_pos() for more information.
func (x *TreeView) IsBlankAtPos(XVar int, YVar int, PathVar **TreePath, ColumnVar **TreeViewColumn, CellXVar *int, CellYVar *int) bool {

	cret := xTreeViewIsBlankAtPos(x.GoPointer(), XVar, YVar, PathVar, ColumnVar, CellXVar, CellYVar)
	return cret
}

var xTreeViewIsRubberBandingActive func(uintptr) bool

// Returns whether a rubber banding operation is currently being done
// in @tree_view.
func (x *TreeView) IsRubberBandingActive() bool {

	cret := xTreeViewIsRubberBandingActive(x.GoPointer())
	return cret
}

var xTreeViewMapExpandedRows func(uintptr, uintptr, uintptr)

// Calls @func on all expanded rows.
func (x *TreeView) MapExpandedRows(FuncVar *TreeViewMappingFunc, DataVar uintptr) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := glib.GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 *TreePath, arg2 uintptr) {
				cbFn := *FuncVar
				cbFn(arg0, arg1, arg2)
			}
			FuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(FuncVarPtr, FuncVarRef, FuncVar)
		}
	}

	xTreeViewMapExpandedRows(x.GoPointer(), FuncVarRef, DataVar)

}

var xTreeViewMoveColumnAfter func(uintptr, uintptr, uintptr)

// Moves @column to be after to @base_column.  If @base_column is %NULL, then
// @column is placed in the first position.
func (x *TreeView) MoveColumnAfter(ColumnVar *TreeViewColumn, BaseColumnVar *TreeViewColumn) {

	xTreeViewMoveColumnAfter(x.GoPointer(), ColumnVar.GoPointer(), BaseColumnVar.GoPointer())

}

var xTreeViewRemoveColumn func(uintptr, uintptr) int

// Removes @column from @tree_view.
func (x *TreeView) RemoveColumn(ColumnVar *TreeViewColumn) int {

	cret := xTreeViewRemoveColumn(x.GoPointer(), ColumnVar.GoPointer())
	return cret
}

var xTreeViewRowActivated func(uintptr, *TreePath, uintptr)

// Activates the cell determined by @path and @column.
func (x *TreeView) RowActivated(PathVar *TreePath, ColumnVar *TreeViewColumn) {

	xTreeViewRowActivated(x.GoPointer(), PathVar, ColumnVar.GoPointer())

}

var xTreeViewRowExpanded func(uintptr, *TreePath) bool

// Returns %TRUE if the node pointed to by @path is expanded in @tree_view.
func (x *TreeView) RowExpanded(PathVar *TreePath) bool {

	cret := xTreeViewRowExpanded(x.GoPointer(), PathVar)
	return cret
}

var xTreeViewScrollToCell func(uintptr, *TreePath, uintptr, bool, float32, float32)

// Moves the alignments of @tree_view to the position specified by @column and
// @path.  If @column is %NULL, then no horizontal scrolling occurs.  Likewise,
// if @path is %NULL no vertical scrolling occurs.  At a minimum, one of @column
// or @path need to be non-%NULL.  @row_align determines where the row is
// placed, and @col_align determines where @column is placed.  Both are expected
// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
// right/bottom alignment, 0.5 means center.
//
// If @use_align is %FALSE, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen.
// This means that the cell will be scrolled to the edge closest to its current
// position.  If the cell is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and @path is a valid row on the
// model.  If the model changes before the @tree_view is realized, the centered
// path will be modified to reflect this change.
func (x *TreeView) ScrollToCell(PathVar *TreePath, ColumnVar *TreeViewColumn, UseAlignVar bool, RowAlignVar float32, ColAlignVar float32) {

	xTreeViewScrollToCell(x.GoPointer(), PathVar, ColumnVar.GoPointer(), UseAlignVar, RowAlignVar, ColAlignVar)

}

var xTreeViewScrollToPoint func(uintptr, int, int)

// Scrolls the tree view such that the top-left corner of the visible
// area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
// in tree coordinates.  The @tree_view must be realized before
// this function is called.  If it isn't, you probably want to be
// using gtk_tree_view_scroll_to_cell().
//
// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
func (x *TreeView) ScrollToPoint(TreeXVar int, TreeYVar int) {

	xTreeViewScrollToPoint(x.GoPointer(), TreeXVar, TreeYVar)

}

var xTreeViewSetActivateOnSingleClick func(uintptr, bool)

// Cause the `GtkTreeView`::row-activated signal to be emitted
// on a single click instead of a double click.
func (x *TreeView) SetActivateOnSingleClick(SingleVar bool) {

	xTreeViewSetActivateOnSingleClick(x.GoPointer(), SingleVar)

}

var xTreeViewSetColumnDragFunction func(uintptr, uintptr, uintptr, uintptr)

// Sets a user function for determining where a column may be dropped when
// dragged.  This function is called on every column pair in turn at the
// beginning of a column drag to determine where a drop can take place.  The
// arguments passed to @func are: the @tree_view, the `GtkTreeViewColumn` being
// dragged, the two `GtkTreeViewColumn`s determining the drop spot, and
// @user_data.  If either of the `GtkTreeViewColumn` arguments for the drop spot
// are %NULL, then they indicate an edge.  If @func is set to be %NULL, then
// @tree_view reverts to the default behavior of allowing all columns to be
// dropped everywhere.
func (x *TreeView) SetColumnDragFunction(FuncVar *TreeViewColumnDropFunc, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := glib.GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr, arg3 uintptr, arg4 uintptr) bool {
				cbFn := *FuncVar
				return cbFn(arg0, arg1, arg2, arg3, arg4)
			}
			FuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(FuncVarPtr, FuncVarRef, FuncVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	xTreeViewSetColumnDragFunction(x.GoPointer(), FuncVarRef, UserDataVar, DestroyVarRef)

}

var xTreeViewSetCursor func(uintptr, *TreePath, uintptr, bool)

// Sets the current keyboard focus to be at @path, and selects it.  This is
// useful when you want to focus the user’s attention on a particular row.  If
// @focus_column is not %NULL, then focus is given to the column specified by
// it. Additionally, if @focus_column is specified, and @start_editing is
// %TRUE, then editing should be started in the specified cell.
// This function is often followed by @gtk_widget_grab_focus (@tree_view)
// in order to give keyboard focus to the widget.  Please note that editing
// can only happen when the widget is realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
func (x *TreeView) SetCursor(PathVar *TreePath, FocusColumnVar *TreeViewColumn, StartEditingVar bool) {

	xTreeViewSetCursor(x.GoPointer(), PathVar, FocusColumnVar.GoPointer(), StartEditingVar)

}

var xTreeViewSetCursorOnCell func(uintptr, *TreePath, uintptr, uintptr, bool)

// Sets the current keyboard focus to be at @path, and selects it.  This is
// useful when you want to focus the user’s attention on a particular row.  If
// @focus_column is not %NULL, then focus is given to the column specified by
// it. If @focus_column and @focus_cell are not %NULL, and @focus_column
// contains 2 or more editable or activatable cells, then focus is given to
// the cell specified by @focus_cell. Additionally, if @focus_column is
// specified, and @start_editing is %TRUE, then editing should be started in
// the specified cell.  This function is often followed by
// @gtk_widget_grab_focus (@tree_view) in order to give keyboard focus to the
// widget.  Please note that editing can only happen when the widget is
// realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
func (x *TreeView) SetCursorOnCell(PathVar *TreePath, FocusColumnVar *TreeViewColumn, FocusCellVar *CellRenderer, StartEditingVar bool) {

	xTreeViewSetCursorOnCell(x.GoPointer(), PathVar, FocusColumnVar.GoPointer(), FocusCellVar.GoPointer(), StartEditingVar)

}

var xTreeViewSetDragDestRow func(uintptr, *TreePath, TreeViewDropPosition)

// Sets the row that is highlighted for feedback.
// If @path is %NULL, an existing highlight is removed.
func (x *TreeView) SetDragDestRow(PathVar *TreePath, PosVar TreeViewDropPosition) {

	xTreeViewSetDragDestRow(x.GoPointer(), PathVar, PosVar)

}

var xTreeViewSetEnableSearch func(uintptr, bool)

// If @enable_search is set, then the user can type in text to search through
// the tree interactively (this is sometimes called "typeahead find").
//
// Note that even if this is %FALSE, the user can still initiate a search
// using the “start-interactive-search” key binding.
func (x *TreeView) SetEnableSearch(EnableSearchVar bool) {

	xTreeViewSetEnableSearch(x.GoPointer(), EnableSearchVar)

}

var xTreeViewSetEnableTreeLines func(uintptr, bool)

// Sets whether to draw lines interconnecting the expanders in @tree_view.
// This does not have any visible effects for lists.
func (x *TreeView) SetEnableTreeLines(EnabledVar bool) {

	xTreeViewSetEnableTreeLines(x.GoPointer(), EnabledVar)

}

var xTreeViewSetExpanderColumn func(uintptr, uintptr)

// Sets the column to draw the expander arrow at. It must be in @tree_view.
// If @column is %NULL, then the expander arrow is always at the first
// visible column.
//
// If you do not want expander arrow to appear in your tree, set the
// expander column to a hidden column.
func (x *TreeView) SetExpanderColumn(ColumnVar *TreeViewColumn) {

	xTreeViewSetExpanderColumn(x.GoPointer(), ColumnVar.GoPointer())

}

var xTreeViewSetFixedHeightMode func(uintptr, bool)

// Enables or disables the fixed height mode of @tree_view.
// Fixed height mode speeds up `GtkTreeView` by assuming that all
// rows have the same height.
// Only enable this option if all rows are the same height and all
// columns are of type %GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) SetFixedHeightMode(EnableVar bool) {

	xTreeViewSetFixedHeightMode(x.GoPointer(), EnableVar)

}

var xTreeViewSetGridLines func(uintptr, TreeViewGridLines)

// Sets which grid lines to draw in @tree_view.
func (x *TreeView) SetGridLines(GridLinesVar TreeViewGridLines) {

	xTreeViewSetGridLines(x.GoPointer(), GridLinesVar)

}

var xTreeViewSetHeadersClickable func(uintptr, bool)

// Allow the column title buttons to be clicked.
func (x *TreeView) SetHeadersClickable(SettingVar bool) {

	xTreeViewSetHeadersClickable(x.GoPointer(), SettingVar)

}

var xTreeViewSetHeadersVisible func(uintptr, bool)

// Sets the visibility state of the headers.
func (x *TreeView) SetHeadersVisible(HeadersVisibleVar bool) {

	xTreeViewSetHeadersVisible(x.GoPointer(), HeadersVisibleVar)

}

var xTreeViewSetHoverExpand func(uintptr, bool)

// Enables or disables the hover expansion mode of @tree_view.
// Hover expansion makes rows expand or collapse if the pointer
// moves over them.
func (x *TreeView) SetHoverExpand(ExpandVar bool) {

	xTreeViewSetHoverExpand(x.GoPointer(), ExpandVar)

}

var xTreeViewSetHoverSelection func(uintptr, bool)

// Enables or disables the hover selection mode of @tree_view.
// Hover selection makes the selected row follow the pointer.
// Currently, this works only for the selection modes
// %GTK_SELECTION_SINGLE and %GTK_SELECTION_BROWSE.
func (x *TreeView) SetHoverSelection(HoverVar bool) {

	xTreeViewSetHoverSelection(x.GoPointer(), HoverVar)

}

var xTreeViewSetLevelIndentation func(uintptr, int)

// Sets the amount of extra indentation for child levels to use in @tree_view
// in addition to the default indentation.  The value should be specified in
// pixels, a value of 0 disables this feature and in this case only the default
// indentation will be used.
// This does not have any visible effects for lists.
func (x *TreeView) SetLevelIndentation(IndentationVar int) {

	xTreeViewSetLevelIndentation(x.GoPointer(), IndentationVar)

}

var xTreeViewSetModel func(uintptr, uintptr)

// Sets the model for a `GtkTreeView`.  If the @tree_view already has a model
// set, it will remove it before setting the new model.  If @model is %NULL,
// then it will unset the old model.
func (x *TreeView) SetModel(ModelVar TreeModel) {

	xTreeViewSetModel(x.GoPointer(), ModelVar.GoPointer())

}

var xTreeViewSetReorderable func(uintptr, bool)

// This function is a convenience function to allow you to reorder
// models that support the `GtkTreeDragSourceIface` and the
// `GtkTreeDragDestIface`.  Both `GtkTreeStore` and `GtkListStore` support
// these.  If @reorderable is %TRUE, then the user can reorder the
// model by dragging and dropping rows. The developer can listen to
// these changes by connecting to the model’s `GtkTreeModel::row-inserted`
// and `GtkTreeModel::row-deleted` signals. The reordering is implemented
// by setting up the tree view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any
// other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed.  If more control is needed, you should probably
// handle drag and drop manually.
func (x *TreeView) SetReorderable(ReorderableVar bool) {

	xTreeViewSetReorderable(x.GoPointer(), ReorderableVar)

}

var xTreeViewSetRowSeparatorFunc func(uintptr, uintptr, uintptr, uintptr)

// Sets the row separator function, which is used to determine
// whether a row should be drawn as a separator. If the row separator
// function is %NULL, no separators are drawn. This is the default value.
func (x *TreeView) SetRowSeparatorFunc(FuncVar *TreeViewRowSeparatorFunc, DataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := glib.GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 *TreeIter, arg2 uintptr) bool {
				cbFn := *FuncVar
				return cbFn(arg0, arg1, arg2)
			}
			FuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(FuncVarPtr, FuncVarRef, FuncVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	xTreeViewSetRowSeparatorFunc(x.GoPointer(), FuncVarRef, DataVar, DestroyVarRef)

}

var xTreeViewSetRubberBanding func(uintptr, bool)

// Enables or disables rubber banding in @tree_view.  If the selection mode
// is %GTK_SELECTION_MULTIPLE, rubber banding will allow the user to select
// multiple rows by dragging the mouse.
func (x *TreeView) SetRubberBanding(EnableVar bool) {

	xTreeViewSetRubberBanding(x.GoPointer(), EnableVar)

}

var xTreeViewSetSearchColumn func(uintptr, int)

// Sets @column as the column where the interactive search code should
// search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search”
// key binding to bring up search popup. The enable-search property controls
// whether simply typing text will also start an interactive search.
//
// Note that @column refers to a column of the current model. The search
// column is reset to -1 when the model is changed.
func (x *TreeView) SetSearchColumn(ColumnVar int) {

	xTreeViewSetSearchColumn(x.GoPointer(), ColumnVar)

}

var xTreeViewSetSearchEntry func(uintptr, uintptr)

// Sets the entry which the interactive search code will use for this
// @tree_view.  This is useful when you want to provide a search entry
// in our interface at all time at a fixed position.  Passing %NULL for
// @entry will make the interactive search code use the built-in popup
// entry again.
func (x *TreeView) SetSearchEntry(EntryVar Editable) {

	xTreeViewSetSearchEntry(x.GoPointer(), EntryVar.GoPointer())

}

var xTreeViewSetSearchEqualFunc func(uintptr, uintptr, uintptr, uintptr)

// Sets the compare function for the interactive search capabilities; note
// that somewhat like strcmp() returning 0 for equality
// `GtkTreeView`SearchEqualFunc returns %FALSE on matches.
func (x *TreeView) SetSearchEqualFunc(SearchEqualFuncVar *TreeViewSearchEqualFunc, SearchUserDataVar uintptr, SearchDestroyVar *glib.DestroyNotify) {

	var SearchEqualFuncVarRef uintptr
	if SearchEqualFuncVar != nil {
		SearchEqualFuncVarPtr := uintptr(unsafe.Pointer(SearchEqualFuncVar))
		if cbRefPtr, ok := glib.GetCallback(SearchEqualFuncVarPtr); ok {
			SearchEqualFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 int, arg2 string, arg3 *TreeIter, arg4 uintptr) bool {
				cbFn := *SearchEqualFuncVar
				return cbFn(arg0, arg1, arg2, arg3, arg4)
			}
			SearchEqualFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(SearchEqualFuncVarPtr, SearchEqualFuncVarRef, SearchEqualFuncVar)
		}
	}

	var SearchDestroyVarRef uintptr
	if SearchDestroyVar != nil {
		SearchDestroyVarPtr := uintptr(unsafe.Pointer(SearchDestroyVar))
		if cbRefPtr, ok := glib.GetCallback(SearchDestroyVarPtr); ok {
			SearchDestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *SearchDestroyVar
				cbFn(arg0)
			}
			SearchDestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(SearchDestroyVarPtr, SearchDestroyVarRef, SearchDestroyVar)
		}
	}

	xTreeViewSetSearchEqualFunc(x.GoPointer(), SearchEqualFuncVarRef, SearchUserDataVar, SearchDestroyVarRef)

}

var xTreeViewSetShowExpanders func(uintptr, bool)

// Sets whether to draw and enable expanders and indent child rows in
// @tree_view.  When disabled there will be no expanders visible in trees
// and there will be no way to expand and collapse rows by default.  Also
// note that hiding the expanders will disable the default indentation.  You
// can set a custom indentation in this case using
// gtk_tree_view_set_level_indentation().
// This does not have any visible effects for lists.
func (x *TreeView) SetShowExpanders(EnabledVar bool) {

	xTreeViewSetShowExpanders(x.GoPointer(), EnabledVar)

}

var xTreeViewSetTooltipCell func(uintptr, uintptr, *TreePath, uintptr, uintptr)

// Sets the tip area of @tooltip to the area @path, @column and @cell have
// in common.  For example if @path is %NULL and @column is set, the tip
// area will be set to the full area covered by @column.  See also
// gtk_tooltip_set_tip_area().
//
// Note that if @path is not specified and @cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the correct
// position.  In such cases @path must be set to the current node under the
// mouse cursor for this function to operate correctly.
//
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
func (x *TreeView) SetTooltipCell(TooltipVar *Tooltip, PathVar *TreePath, ColumnVar *TreeViewColumn, CellVar *CellRenderer) {

	xTreeViewSetTooltipCell(x.GoPointer(), TooltipVar.GoPointer(), PathVar, ColumnVar.GoPointer(), CellVar.GoPointer())

}

var xTreeViewSetTooltipColumn func(uintptr, int)

// If you only plan to have simple (text-only) tooltips on full rows, you
// can use this function to have `GtkTreeView` handle these automatically
// for you. @column should be set to the column in @tree_view’s model
// containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, `GtkWidget:has-tooltip` will be set to %TRUE and
// @tree_view will connect a `GtkWidget::query-tooltip` signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &amp;, &lt;, etc have to be escaped in the text.
func (x *TreeView) SetTooltipColumn(ColumnVar int) {

	xTreeViewSetTooltipColumn(x.GoPointer(), ColumnVar)

}

var xTreeViewSetTooltipRow func(uintptr, uintptr, *TreePath)

// Sets the tip area of @tooltip to be the area covered by the row at @path.
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
// See also gtk_tooltip_set_tip_area().
func (x *TreeView) SetTooltipRow(TooltipVar *Tooltip, PathVar *TreePath) {

	xTreeViewSetTooltipRow(x.GoPointer(), TooltipVar.GoPointer(), PathVar)

}

var xTreeViewUnsetRowsDragDest func(uintptr)

// Undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// `GtkTreeView`:reorderable to %FALSE.
func (x *TreeView) UnsetRowsDragDest() {

	xTreeViewUnsetRowsDragDest(x.GoPointer())

}

var xTreeViewUnsetRowsDragSource func(uintptr)

// Undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// `GtkTreeView`:reorderable to %FALSE.
func (x *TreeView) UnsetRowsDragSource() {

	xTreeViewUnsetRowsDragSource(x.GoPointer())

}

func (c *TreeView) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *TreeView) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyActivateOnSingleClick sets the "activate-on-single-click" property.
// The activate-on-single-click property specifies whether the "row-activated" signal
// will be emitted after a single click.
func (x *TreeView) SetPropertyActivateOnSingleClick(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("activate-on-single-click", &v)
}

// GetPropertyActivateOnSingleClick gets the "activate-on-single-click" property.
// The activate-on-single-click property specifies whether the "row-activated" signal
// will be emitted after a single click.
func (x *TreeView) GetPropertyActivateOnSingleClick() bool {
	var v gobject.Value
	x.GetProperty("activate-on-single-click", &v)
	return v.GetBoolean()
}

// SetPropertyEnableSearch sets the "enable-search" property.
func (x *TreeView) SetPropertyEnableSearch(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("enable-search", &v)
}

// GetPropertyEnableSearch gets the "enable-search" property.
func (x *TreeView) GetPropertyEnableSearch() bool {
	var v gobject.Value
	x.GetProperty("enable-search", &v)
	return v.GetBoolean()
}

// SetPropertyEnableTreeLines sets the "enable-tree-lines" property.
func (x *TreeView) SetPropertyEnableTreeLines(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("enable-tree-lines", &v)
}

// GetPropertyEnableTreeLines gets the "enable-tree-lines" property.
func (x *TreeView) GetPropertyEnableTreeLines() bool {
	var v gobject.Value
	x.GetProperty("enable-tree-lines", &v)
	return v.GetBoolean()
}

// SetPropertyFixedHeightMode sets the "fixed-height-mode" property.
// Setting the ::fixed-height-mode property to %TRUE speeds up
// `GtkTreeView` by assuming that all rows have the same height.
// Only enable this option if all rows are the same height.
// Please see gtk_tree_view_set_fixed_height_mode() for more
// information on this option.
func (x *TreeView) SetPropertyFixedHeightMode(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("fixed-height-mode", &v)
}

// GetPropertyFixedHeightMode gets the "fixed-height-mode" property.
// Setting the ::fixed-height-mode property to %TRUE speeds up
// `GtkTreeView` by assuming that all rows have the same height.
// Only enable this option if all rows are the same height.
// Please see gtk_tree_view_set_fixed_height_mode() for more
// information on this option.
func (x *TreeView) GetPropertyFixedHeightMode() bool {
	var v gobject.Value
	x.GetProperty("fixed-height-mode", &v)
	return v.GetBoolean()
}

// SetPropertyHeadersClickable sets the "headers-clickable" property.
func (x *TreeView) SetPropertyHeadersClickable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("headers-clickable", &v)
}

// GetPropertyHeadersClickable gets the "headers-clickable" property.
func (x *TreeView) GetPropertyHeadersClickable() bool {
	var v gobject.Value
	x.GetProperty("headers-clickable", &v)
	return v.GetBoolean()
}

// SetPropertyHeadersVisible sets the "headers-visible" property.
func (x *TreeView) SetPropertyHeadersVisible(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("headers-visible", &v)
}

// GetPropertyHeadersVisible gets the "headers-visible" property.
func (x *TreeView) GetPropertyHeadersVisible() bool {
	var v gobject.Value
	x.GetProperty("headers-visible", &v)
	return v.GetBoolean()
}

// SetPropertyHoverExpand sets the "hover-expand" property.
// Enables or disables the hover expansion mode of @tree_view.
// Hover expansion makes rows expand or collapse if the pointer moves
// over them.
//
// This mode is primarily intended for treeviews in popups, e.g.
// in `GtkComboBox` or `GtkEntryCompletion`.
func (x *TreeView) SetPropertyHoverExpand(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("hover-expand", &v)
}

// GetPropertyHoverExpand gets the "hover-expand" property.
// Enables or disables the hover expansion mode of @tree_view.
// Hover expansion makes rows expand or collapse if the pointer moves
// over them.
//
// This mode is primarily intended for treeviews in popups, e.g.
// in `GtkComboBox` or `GtkEntryCompletion`.
func (x *TreeView) GetPropertyHoverExpand() bool {
	var v gobject.Value
	x.GetProperty("hover-expand", &v)
	return v.GetBoolean()
}

// SetPropertyHoverSelection sets the "hover-selection" property.
// Enables or disables the hover selection mode of @tree_view.
// Hover selection makes the selected row follow the pointer.
// Currently, this works only for the selection modes
// %GTK_SELECTION_SINGLE and %GTK_SELECTION_BROWSE.
//
// This mode is primarily intended for treeviews in popups, e.g.
// in `GtkComboBox` or `GtkEntryCompletion`.
func (x *TreeView) SetPropertyHoverSelection(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("hover-selection", &v)
}

// GetPropertyHoverSelection gets the "hover-selection" property.
// Enables or disables the hover selection mode of @tree_view.
// Hover selection makes the selected row follow the pointer.
// Currently, this works only for the selection modes
// %GTK_SELECTION_SINGLE and %GTK_SELECTION_BROWSE.
//
// This mode is primarily intended for treeviews in popups, e.g.
// in `GtkComboBox` or `GtkEntryCompletion`.
func (x *TreeView) GetPropertyHoverSelection() bool {
	var v gobject.Value
	x.GetProperty("hover-selection", &v)
	return v.GetBoolean()
}

// SetPropertyLevelIndentation sets the "level-indentation" property.
// Extra indentation for each level.
func (x *TreeView) SetPropertyLevelIndentation(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("level-indentation", &v)
}

// GetPropertyLevelIndentation gets the "level-indentation" property.
// Extra indentation for each level.
func (x *TreeView) GetPropertyLevelIndentation() int {
	var v gobject.Value
	x.GetProperty("level-indentation", &v)
	return v.GetInt()
}

// SetPropertyReorderable sets the "reorderable" property.
func (x *TreeView) SetPropertyReorderable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("reorderable", &v)
}

// GetPropertyReorderable gets the "reorderable" property.
func (x *TreeView) GetPropertyReorderable() bool {
	var v gobject.Value
	x.GetProperty("reorderable", &v)
	return v.GetBoolean()
}

// SetPropertyRubberBanding sets the "rubber-banding" property.
func (x *TreeView) SetPropertyRubberBanding(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("rubber-banding", &v)
}

// GetPropertyRubberBanding gets the "rubber-banding" property.
func (x *TreeView) GetPropertyRubberBanding() bool {
	var v gobject.Value
	x.GetProperty("rubber-banding", &v)
	return v.GetBoolean()
}

// SetPropertySearchColumn sets the "search-column" property.
func (x *TreeView) SetPropertySearchColumn(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("search-column", &v)
}

// GetPropertySearchColumn gets the "search-column" property.
func (x *TreeView) GetPropertySearchColumn() int {
	var v gobject.Value
	x.GetProperty("search-column", &v)
	return v.GetInt()
}

// SetPropertyShowExpanders sets the "show-expanders" property.
// %TRUE if the view has expanders.
func (x *TreeView) SetPropertyShowExpanders(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("show-expanders", &v)
}

// GetPropertyShowExpanders gets the "show-expanders" property.
// %TRUE if the view has expanders.
func (x *TreeView) GetPropertyShowExpanders() bool {
	var v gobject.Value
	x.GetProperty("show-expanders", &v)
	return v.GetBoolean()
}

// SetPropertyTooltipColumn sets the "tooltip-column" property.
func (x *TreeView) SetPropertyTooltipColumn(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("tooltip-column", &v)
}

// GetPropertyTooltipColumn gets the "tooltip-column" property.
func (x *TreeView) GetPropertyTooltipColumn() int {
	var v gobject.Value
	x.GetProperty("tooltip-column", &v)
	return v.GetInt()
}

// The number of columns of the treeview has changed.
func (x *TreeView) ConnectColumnsChanged(cb *func(TreeView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "columns-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "columns-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The position of the cursor (focused cell) has changed.
func (x *TreeView) ConnectCursorChanged(cb *func(TreeView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "cursor-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "cursor-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func (x *TreeView) ConnectExpandCollapseCursorRow(cb *func(TreeView, bool, bool, bool) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "expand-collapse-cursor-row", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, ObjectVarp bool, P0Varp bool, P1Varp bool) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ObjectVarp, P0Varp, P1Varp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "expand-collapse-cursor-row", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The `GtkTreeView`::move-cursor signal is a [keybinding
// signal][class@Gtk.SignalAction] which gets emitted when the user
// presses one of the cursor keys.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor
// programmatically. In contrast to gtk_tree_view_set_cursor() and
// gtk_tree_view_set_cursor_on_cell() when moving horizontally
// `GtkTreeView`::move-cursor does not reset the current selection.
func (x *TreeView) ConnectMoveCursor(cb *func(TreeView, MovementStep, int, bool, bool) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, StepVarp MovementStep, DirectionVarp int, ExtendVarp bool, ModifyVarp bool) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, StepVarp, DirectionVarp, ExtendVarp, ModifyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The "row-activated" signal is emitted when the method
// [method@Gtk.TreeView.row_activated] is called.
//
// This signal is emitted when the user double-clicks a treeview row with the
// [property@Gtk.TreeView:activate-on-single-click] property set to %FALSE,
// or when the user single-clicks a row when that property set to %TRUE.
//
// This signal is also emitted when a non-editable row is selected and one
// of the keys: &lt;kbd&gt;Space&lt;/kbd&gt;, &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Space&lt;/kbd&gt;,
// &lt;kbd&gt;Return&lt;/kbd&gt; or &lt;kbd&gt;Enter&lt;/kbd&gt; is pressed.
//
// For selection handling refer to the
// [tree widget conceptual overview](section-tree-widget.html)
// as well as `GtkTreeSelection`.
func (x *TreeView) ConnectRowActivated(cb *func(TreeView, uintptr, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "row-activated", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, PathVarp uintptr, ColumnVarp uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PathVarp, ColumnVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "row-activated", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The given row has been collapsed (child nodes are hidden).
func (x *TreeView) ConnectRowCollapsed(cb *func(TreeView, uintptr, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "row-collapsed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, IterVarp uintptr, PathVarp uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IterVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "row-collapsed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The given row has been expanded (child nodes are shown).
func (x *TreeView) ConnectRowExpanded(cb *func(TreeView, uintptr, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "row-expanded", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, IterVarp uintptr, PathVarp uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IterVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "row-expanded", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func (x *TreeView) ConnectSelectAll(cb *func(TreeView) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "select-all", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "select-all", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func (x *TreeView) ConnectSelectCursorParent(cb *func(TreeView) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "select-cursor-parent", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "select-cursor-parent", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func (x *TreeView) ConnectSelectCursorRow(cb *func(TreeView, bool) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "select-cursor-row", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, ObjectVarp bool) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ObjectVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "select-cursor-row", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func (x *TreeView) ConnectStartInteractiveSearch(cb *func(TreeView) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "start-interactive-search", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "start-interactive-search", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The given row is about to be collapsed (hide its children nodes). Use this
// signal if you need to control the collapsibility of individual rows.
func (x *TreeView) ConnectTestCollapseRow(cb *func(TreeView, uintptr, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "test-collapse-row", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, IterVarp uintptr, PathVarp uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, IterVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "test-collapse-row", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The given row is about to be expanded (show its children nodes). Use this
// signal if you need to control the expandability of individual rows.
func (x *TreeView) ConnectTestExpandRow(cb *func(TreeView, uintptr, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "test-expand-row", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, IterVarp uintptr, PathVarp uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, IterVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "test-expand-row", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func (x *TreeView) ConnectToggleCursorRow(cb *func(TreeView) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "toggle-cursor-row", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "toggle-cursor-row", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func (x *TreeView) ConnectUnselectAll(cb *func(TreeView) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "unselect-all", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "unselect-all", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *TreeView) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *TreeView) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *TreeView) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *TreeView) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *TreeView) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *TreeView) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *TreeView) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *TreeView) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *TreeView) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *TreeView) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *TreeView) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *TreeView) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *TreeView) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *TreeView) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *TreeView) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TreeView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *TreeView) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TreeView) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *TreeView) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TreeView) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *TreeView) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Returns the size of a non-scrolling border around the
// outside of the scrollable.
//
// An example for this would be treeview headers. GTK can use
// this information to display overlaid graphics, like the
// overshoot indication, at the right position.
func (x *TreeView) GetBorder(BorderVar *Border) bool {

	cret := XGtkScrollableGetBorder(x.GoPointer(), BorderVar)
	return cret
}

// Retrieves the `GtkAdjustment` used for horizontal scrolling.
func (x *TreeView) GetHadjustment() *Adjustment {
	var cls *Adjustment

	cret := XGtkScrollableGetHadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

// Gets the horizontal `GtkScrollablePolicy`.
func (x *TreeView) GetHscrollPolicy() ScrollablePolicy {

	cret := XGtkScrollableGetHscrollPolicy(x.GoPointer())
	return cret
}

// Retrieves the `GtkAdjustment` used for vertical scrolling.
func (x *TreeView) GetVadjustment() *Adjustment {
	var cls *Adjustment

	cret := XGtkScrollableGetVadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

// Gets the vertical `GtkScrollablePolicy`.
func (x *TreeView) GetVscrollPolicy() ScrollablePolicy {

	cret := XGtkScrollableGetVscrollPolicy(x.GoPointer())
	return cret
}

// Sets the horizontal adjustment of the `GtkScrollable`.
func (x *TreeView) SetHadjustment(HadjustmentVar *Adjustment) {

	XGtkScrollableSetHadjustment(x.GoPointer(), HadjustmentVar.GoPointer())

}

// Sets the `GtkScrollablePolicy`.
//
// The policy determines whether horizontal scrolling should start
// below the minimum width or below the natural width.
func (x *TreeView) SetHscrollPolicy(PolicyVar ScrollablePolicy) {

	XGtkScrollableSetHscrollPolicy(x.GoPointer(), PolicyVar)

}

// Sets the vertical adjustment of the `GtkScrollable`.
func (x *TreeView) SetVadjustment(VadjustmentVar *Adjustment) {

	XGtkScrollableSetVadjustment(x.GoPointer(), VadjustmentVar.GoPointer())

}

// Sets the `GtkScrollablePolicy`.
//
// The policy determines whether vertical scrolling should start
// below the minimum height or below the natural height.
func (x *TreeView) SetVscrollPolicy(PolicyVar ScrollablePolicy) {

	XGtkScrollableSetVscrollPolicy(x.GoPointer(), PolicyVar)

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTreeViewDropPositionGLibType, libs, "gtk_tree_view_drop_position_get_type")

	core.PuregoSafeRegister(&xTreeViewGLibType, libs, "gtk_tree_view_get_type")

	core.PuregoSafeRegister(&xNewTreeView, libs, "gtk_tree_view_new")
	core.PuregoSafeRegister(&xNewTreeViewWithModel, libs, "gtk_tree_view_new_with_model")

	core.PuregoSafeRegister(&xTreeViewAppendColumn, libs, "gtk_tree_view_append_column")
	core.PuregoSafeRegister(&xTreeViewCollapseAll, libs, "gtk_tree_view_collapse_all")
	core.PuregoSafeRegister(&xTreeViewCollapseRow, libs, "gtk_tree_view_collapse_row")
	core.PuregoSafeRegister(&xTreeViewColumnsAutosize, libs, "gtk_tree_view_columns_autosize")
	core.PuregoSafeRegister(&xTreeViewConvertBinWindowToTreeCoords, libs, "gtk_tree_view_convert_bin_window_to_tree_coords")
	core.PuregoSafeRegister(&xTreeViewConvertBinWindowToWidgetCoords, libs, "gtk_tree_view_convert_bin_window_to_widget_coords")
	core.PuregoSafeRegister(&xTreeViewConvertTreeToBinWindowCoords, libs, "gtk_tree_view_convert_tree_to_bin_window_coords")
	core.PuregoSafeRegister(&xTreeViewConvertTreeToWidgetCoords, libs, "gtk_tree_view_convert_tree_to_widget_coords")
	core.PuregoSafeRegister(&xTreeViewConvertWidgetToBinWindowCoords, libs, "gtk_tree_view_convert_widget_to_bin_window_coords")
	core.PuregoSafeRegister(&xTreeViewConvertWidgetToTreeCoords, libs, "gtk_tree_view_convert_widget_to_tree_coords")
	core.PuregoSafeRegister(&xTreeViewCreateRowDragIcon, libs, "gtk_tree_view_create_row_drag_icon")
	core.PuregoSafeRegister(&xTreeViewEnableModelDragDest, libs, "gtk_tree_view_enable_model_drag_dest")
	core.PuregoSafeRegister(&xTreeViewEnableModelDragSource, libs, "gtk_tree_view_enable_model_drag_source")
	core.PuregoSafeRegister(&xTreeViewExpandAll, libs, "gtk_tree_view_expand_all")
	core.PuregoSafeRegister(&xTreeViewExpandRow, libs, "gtk_tree_view_expand_row")
	core.PuregoSafeRegister(&xTreeViewExpandToPath, libs, "gtk_tree_view_expand_to_path")
	core.PuregoSafeRegister(&xTreeViewGetActivateOnSingleClick, libs, "gtk_tree_view_get_activate_on_single_click")
	core.PuregoSafeRegister(&xTreeViewGetBackgroundArea, libs, "gtk_tree_view_get_background_area")
	core.PuregoSafeRegister(&xTreeViewGetCellArea, libs, "gtk_tree_view_get_cell_area")
	core.PuregoSafeRegister(&xTreeViewGetColumn, libs, "gtk_tree_view_get_column")
	core.PuregoSafeRegister(&xTreeViewGetColumns, libs, "gtk_tree_view_get_columns")
	core.PuregoSafeRegister(&xTreeViewGetCursor, libs, "gtk_tree_view_get_cursor")
	core.PuregoSafeRegister(&xTreeViewGetDestRowAtPos, libs, "gtk_tree_view_get_dest_row_at_pos")
	core.PuregoSafeRegister(&xTreeViewGetDragDestRow, libs, "gtk_tree_view_get_drag_dest_row")
	core.PuregoSafeRegister(&xTreeViewGetEnableSearch, libs, "gtk_tree_view_get_enable_search")
	core.PuregoSafeRegister(&xTreeViewGetEnableTreeLines, libs, "gtk_tree_view_get_enable_tree_lines")
	core.PuregoSafeRegister(&xTreeViewGetExpanderColumn, libs, "gtk_tree_view_get_expander_column")
	core.PuregoSafeRegister(&xTreeViewGetFixedHeightMode, libs, "gtk_tree_view_get_fixed_height_mode")
	core.PuregoSafeRegister(&xTreeViewGetGridLines, libs, "gtk_tree_view_get_grid_lines")
	core.PuregoSafeRegister(&xTreeViewGetHeadersClickable, libs, "gtk_tree_view_get_headers_clickable")
	core.PuregoSafeRegister(&xTreeViewGetHeadersVisible, libs, "gtk_tree_view_get_headers_visible")
	core.PuregoSafeRegister(&xTreeViewGetHoverExpand, libs, "gtk_tree_view_get_hover_expand")
	core.PuregoSafeRegister(&xTreeViewGetHoverSelection, libs, "gtk_tree_view_get_hover_selection")
	core.PuregoSafeRegister(&xTreeViewGetLevelIndentation, libs, "gtk_tree_view_get_level_indentation")
	core.PuregoSafeRegister(&xTreeViewGetModel, libs, "gtk_tree_view_get_model")
	core.PuregoSafeRegister(&xTreeViewGetNColumns, libs, "gtk_tree_view_get_n_columns")
	core.PuregoSafeRegister(&xTreeViewGetPathAtPos, libs, "gtk_tree_view_get_path_at_pos")
	core.PuregoSafeRegister(&xTreeViewGetReorderable, libs, "gtk_tree_view_get_reorderable")
	core.PuregoSafeRegister(&xTreeViewGetRowSeparatorFunc, libs, "gtk_tree_view_get_row_separator_func")
	core.PuregoSafeRegister(&xTreeViewGetRubberBanding, libs, "gtk_tree_view_get_rubber_banding")
	core.PuregoSafeRegister(&xTreeViewGetSearchColumn, libs, "gtk_tree_view_get_search_column")
	core.PuregoSafeRegister(&xTreeViewGetSearchEntry, libs, "gtk_tree_view_get_search_entry")
	core.PuregoSafeRegister(&xTreeViewGetSearchEqualFunc, libs, "gtk_tree_view_get_search_equal_func")
	core.PuregoSafeRegister(&xTreeViewGetSelection, libs, "gtk_tree_view_get_selection")
	core.PuregoSafeRegister(&xTreeViewGetShowExpanders, libs, "gtk_tree_view_get_show_expanders")
	core.PuregoSafeRegister(&xTreeViewGetTooltipColumn, libs, "gtk_tree_view_get_tooltip_column")
	core.PuregoSafeRegister(&xTreeViewGetTooltipContext, libs, "gtk_tree_view_get_tooltip_context")
	core.PuregoSafeRegister(&xTreeViewGetVisibleRange, libs, "gtk_tree_view_get_visible_range")
	core.PuregoSafeRegister(&xTreeViewGetVisibleRect, libs, "gtk_tree_view_get_visible_rect")
	core.PuregoSafeRegister(&xTreeViewInsertColumn, libs, "gtk_tree_view_insert_column")
	core.PuregoSafeRegister(&xTreeViewInsertColumnWithAttributes, libs, "gtk_tree_view_insert_column_with_attributes")
	core.PuregoSafeRegister(&xTreeViewInsertColumnWithDataFunc, libs, "gtk_tree_view_insert_column_with_data_func")
	core.PuregoSafeRegister(&xTreeViewIsBlankAtPos, libs, "gtk_tree_view_is_blank_at_pos")
	core.PuregoSafeRegister(&xTreeViewIsRubberBandingActive, libs, "gtk_tree_view_is_rubber_banding_active")
	core.PuregoSafeRegister(&xTreeViewMapExpandedRows, libs, "gtk_tree_view_map_expanded_rows")
	core.PuregoSafeRegister(&xTreeViewMoveColumnAfter, libs, "gtk_tree_view_move_column_after")
	core.PuregoSafeRegister(&xTreeViewRemoveColumn, libs, "gtk_tree_view_remove_column")
	core.PuregoSafeRegister(&xTreeViewRowActivated, libs, "gtk_tree_view_row_activated")
	core.PuregoSafeRegister(&xTreeViewRowExpanded, libs, "gtk_tree_view_row_expanded")
	core.PuregoSafeRegister(&xTreeViewScrollToCell, libs, "gtk_tree_view_scroll_to_cell")
	core.PuregoSafeRegister(&xTreeViewScrollToPoint, libs, "gtk_tree_view_scroll_to_point")
	core.PuregoSafeRegister(&xTreeViewSetActivateOnSingleClick, libs, "gtk_tree_view_set_activate_on_single_click")
	core.PuregoSafeRegister(&xTreeViewSetColumnDragFunction, libs, "gtk_tree_view_set_column_drag_function")
	core.PuregoSafeRegister(&xTreeViewSetCursor, libs, "gtk_tree_view_set_cursor")
	core.PuregoSafeRegister(&xTreeViewSetCursorOnCell, libs, "gtk_tree_view_set_cursor_on_cell")
	core.PuregoSafeRegister(&xTreeViewSetDragDestRow, libs, "gtk_tree_view_set_drag_dest_row")
	core.PuregoSafeRegister(&xTreeViewSetEnableSearch, libs, "gtk_tree_view_set_enable_search")
	core.PuregoSafeRegister(&xTreeViewSetEnableTreeLines, libs, "gtk_tree_view_set_enable_tree_lines")
	core.PuregoSafeRegister(&xTreeViewSetExpanderColumn, libs, "gtk_tree_view_set_expander_column")
	core.PuregoSafeRegister(&xTreeViewSetFixedHeightMode, libs, "gtk_tree_view_set_fixed_height_mode")
	core.PuregoSafeRegister(&xTreeViewSetGridLines, libs, "gtk_tree_view_set_grid_lines")
	core.PuregoSafeRegister(&xTreeViewSetHeadersClickable, libs, "gtk_tree_view_set_headers_clickable")
	core.PuregoSafeRegister(&xTreeViewSetHeadersVisible, libs, "gtk_tree_view_set_headers_visible")
	core.PuregoSafeRegister(&xTreeViewSetHoverExpand, libs, "gtk_tree_view_set_hover_expand")
	core.PuregoSafeRegister(&xTreeViewSetHoverSelection, libs, "gtk_tree_view_set_hover_selection")
	core.PuregoSafeRegister(&xTreeViewSetLevelIndentation, libs, "gtk_tree_view_set_level_indentation")
	core.PuregoSafeRegister(&xTreeViewSetModel, libs, "gtk_tree_view_set_model")
	core.PuregoSafeRegister(&xTreeViewSetReorderable, libs, "gtk_tree_view_set_reorderable")
	core.PuregoSafeRegister(&xTreeViewSetRowSeparatorFunc, libs, "gtk_tree_view_set_row_separator_func")
	core.PuregoSafeRegister(&xTreeViewSetRubberBanding, libs, "gtk_tree_view_set_rubber_banding")
	core.PuregoSafeRegister(&xTreeViewSetSearchColumn, libs, "gtk_tree_view_set_search_column")
	core.PuregoSafeRegister(&xTreeViewSetSearchEntry, libs, "gtk_tree_view_set_search_entry")
	core.PuregoSafeRegister(&xTreeViewSetSearchEqualFunc, libs, "gtk_tree_view_set_search_equal_func")
	core.PuregoSafeRegister(&xTreeViewSetShowExpanders, libs, "gtk_tree_view_set_show_expanders")
	core.PuregoSafeRegister(&xTreeViewSetTooltipCell, libs, "gtk_tree_view_set_tooltip_cell")
	core.PuregoSafeRegister(&xTreeViewSetTooltipColumn, libs, "gtk_tree_view_set_tooltip_column")
	core.PuregoSafeRegister(&xTreeViewSetTooltipRow, libs, "gtk_tree_view_set_tooltip_row")
	core.PuregoSafeRegister(&xTreeViewUnsetRowsDragDest, libs, "gtk_tree_view_unset_rows_drag_dest")
	core.PuregoSafeRegister(&xTreeViewUnsetRowsDragSource, libs, "gtk_tree_view_unset_rows_drag_source")

}
