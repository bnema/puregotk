// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gsk"
)

// A subclass of `GtkPopover` that implements menu behavior.
//
// &lt;picture&gt;
//
//	&lt;source srcset="menu-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="An example GtkPopoverMenu" src="menu.png"&gt;
//
// &lt;/picture&gt;
//
// `GtkPopoverMenu` treats its children like menus and allows switching
// between them. It can open submenus as traditional, nested submenus,
// or in a more touch-friendly sliding fashion.
// The property [property@Gtk.PopoverMenu:flags] controls this appearance.
//
// `GtkPopoverMenu` is meant to be used primarily with menu models,
// using [ctor@Gtk.PopoverMenu.new_from_model]. If you need to put
// other widgets such as a `GtkSpinButton` or a `GtkSwitch` into a popover,
// you can use [method@Gtk.PopoverMenu.add_child].
//
// For more dialog-like behavior, use a plain `GtkPopover`.
//
// ## Menu models
//
// The XML format understood by `GtkBuilder` for `GMenuModel` consists
// of a toplevel `&lt;menu&gt;` element, which contains one or more `&lt;item&gt;`
// elements. Each `&lt;item&gt;` element contains `&lt;attribute&gt;` and `&lt;link&gt;`
// elements with a mandatory name attribute. `&lt;link&gt;` elements have the
// same content model as `&lt;menu&gt;`. Instead of `&lt;link name="submenu"&gt;`
// or `&lt;link name="section"&gt;`, you can use `&lt;submenu&gt;` or `&lt;section&gt;`
// elements.
//
// ```xml
// &lt;menu id='app-menu'&gt;
//
//	&lt;section&gt;
//	  &lt;item&gt;
//	    &lt;attribute name='label' translatable='yes'&gt;_New Window&lt;/attribute&gt;
//	    &lt;attribute name='action'&gt;app.new&lt;/attribute&gt;
//	  &lt;/item&gt;
//	  &lt;item&gt;
//	    &lt;attribute name='label' translatable='yes'&gt;_About Sunny&lt;/attribute&gt;
//	    &lt;attribute name='action'&gt;app.about&lt;/attribute&gt;
//	  &lt;/item&gt;
//	  &lt;item&gt;
//	    &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;
//	    &lt;attribute name='action'&gt;app.quit&lt;/attribute&gt;
//	  &lt;/item&gt;
//	&lt;/section&gt;
//
// &lt;/menu&gt;
// ```
//
// Attribute values can be translated using gettext, like other `GtkBuilder`
// content. `&lt;attribute&gt;` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the `GtkBuilder` must have been given the gettext
// domain to use.
//
// The following attributes are used when constructing menu items:
//
//   - "label": a user-visible string to display
//   - "use-markup": whether the text in the menu item includes [Pango markup](https://docs.gtk.org/Pango/pango_markup.html)
//   - "action": the prefixed name of the action to trigger
//   - "target": the parameter to use when activating the action
//   - "icon" and "verb-icon": names of icons that may be displayed
//   - "submenu-action": name of an action that may be used to track
//     whether a submenu is open
//   - "hidden-when": a string used to determine when the item will be hidden.
//     Possible values include "action-disabled", "action-missing", "macos-menubar".
//     This is mainly useful for exported menus, see [method@Gtk.Application.set_menubar].
//   - "custom": a string used to match against the ID of a custom child added with
//     [method@Gtk.PopoverMenu.add_child], [method@Gtk.PopoverMenuBar.add_child],
//     or in the ui file with `&lt;child type="ID"&gt;`.
//
// The following attributes are used when constructing sections:
//
//   - "label": a user-visible string to use as section heading
//   - "display-hint": a string used to determine special formatting for the section.
//     Possible values include "horizontal-buttons", "circular-buttons" and
//     "inline-buttons". They all indicate that section should be
//     displayed as a horizontal row of buttons.
//   - "text-direction": a string used to determine the `GtkTextDirection` to use
//     when "display-hint" is set to "horizontal-buttons". Possible values
//     include "rtl", "ltr", and "none".
//
// The following attributes are used when constructing submenus:
//
//   - "label": a user-visible string to display
//   - "icon": icon name to display
//   - "gtk-macos-special": (macOS only, ignored by others) Add special meaning to a menu
//     in the macOS menu bar. See [Using GTK on Apple macOS](osx.html).
//
// Menu items will also show accelerators, which are usually associated
// with actions via [method@Gtk.Application.set_accels_for_action],
// [method@WidgetClass.add_binding_action] or
// [method@Gtk.ShortcutController.add_shortcut].
//
// # Shortcuts and Gestures
//
// `GtkPopoverMenu` supports the following keyboard shortcuts:
//
// - &lt;kbd&gt;Space&lt;/kbd&gt; activates the default widget.
//
// # CSS Nodes
//
// `GtkPopoverMenu` is just a subclass of `GtkPopover` that adds custom content
// to it, therefore it has the same CSS nodes. It is one of the cases that add
// a `.menu` style class to the main `popover` node.
//
// Menu items have nodes with name `button` and class `.model`. If a section
// display-hint is set, the section gets a node `box` with class `horizontal`
// plus a class with the same text as the display hint. Note that said box may
// not be the direct ancestor of the item `button`s. Thus, for example, to style
// items in an `inline-buttons` section, select `.inline-buttons button.model`.
// Other things that may be of interest to style in menus include `label` nodes.
//
// # Accessibility
//
// `GtkPopoverMenu` uses the [enum@Gtk.AccessibleRole.menu] role, and its
// items use the [enum@Gtk.AccessibleRole.menu_item],
// [enum@Gtk.AccessibleRole.checkbox] or [enum@Gtk.AccessibleRole.menu_item_radio]
// roles, depending on the action they are connected to.
type PopoverMenu struct {
	Popover
}

var xPopoverMenuGLibType func() types.GType

func PopoverMenuGLibType() types.GType {
	return xPopoverMenuGLibType()
}

func PopoverMenuNewFromInternalPtr(ptr uintptr) *PopoverMenu {
	cls := &PopoverMenu{}
	cls.Ptr = ptr
	return cls
}

var xNewPopoverMenuFromModel func(uintptr) uintptr

// Creates a `GtkPopoverMenu` and populates it according to @model.
//
// The created buttons are connected to actions found in the
// `GtkApplicationWindow` to which the popover belongs - typically
// by means of being attached to a widget that is contained within
// the `GtkApplicationWindow`s widget hierarchy.
//
// Actions can also be added using [method@Gtk.Widget.insert_action_group]
// on the menus attach widget or on any of its parent widgets.
//
// This function creates menus with sliding submenus.
// See [ctor@Gtk.PopoverMenu.new_from_model_full] for a way
// to control this.
func NewPopoverMenuFromModel(ModelVar *gio.MenuModel) *PopoverMenu {
	var cls *PopoverMenu

	cret := xNewPopoverMenuFromModel(ModelVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &PopoverMenu{}
	cls.Ptr = cret
	return cls
}

var xNewPopoverMenuFromModelFull func(uintptr, PopoverMenuFlags) uintptr

// Creates a `GtkPopoverMenu` and populates it according to @model.
//
// The created buttons are connected to actions found in the
// action groups that are accessible from the parent widget.
// This includes the `GtkApplicationWindow` to which the popover
// belongs. Actions can also be added using [method@Gtk.Widget.insert_action_group]
// on the parent widget or on any of its parent widgets.
func NewPopoverMenuFromModelFull(ModelVar *gio.MenuModel, FlagsVar PopoverMenuFlags) *PopoverMenu {
	var cls *PopoverMenu

	cret := xNewPopoverMenuFromModelFull(ModelVar.GoPointer(), FlagsVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &PopoverMenu{}
	cls.Ptr = cret
	return cls
}

var xPopoverMenuAddChild func(uintptr, uintptr, string) bool

// Adds a custom widget to a generated menu.
//
// For this to work, the menu model of @popover must have
// an item with a `custom` attribute that matches @id.
func (x *PopoverMenu) AddChild(ChildVar *Widget, IdVar string) bool {

	cret := xPopoverMenuAddChild(x.GoPointer(), ChildVar.GoPointer(), IdVar)
	return cret
}

var xPopoverMenuGetFlags func(uintptr) PopoverMenuFlags

// Returns the flags that @popover uses to create/display a menu from its model.
func (x *PopoverMenu) GetFlags() PopoverMenuFlags {

	cret := xPopoverMenuGetFlags(x.GoPointer())
	return cret
}

var xPopoverMenuGetMenuModel func(uintptr) uintptr

// Returns the menu model used to populate the popover.
func (x *PopoverMenu) GetMenuModel() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xPopoverMenuGetMenuModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xPopoverMenuRemoveChild func(uintptr, uintptr) bool

// Removes a widget that has previously been added with
// [method@Gtk.PopoverMenu.add_child]
func (x *PopoverMenu) RemoveChild(ChildVar *Widget) bool {

	cret := xPopoverMenuRemoveChild(x.GoPointer(), ChildVar.GoPointer())
	return cret
}

var xPopoverMenuSetFlags func(uintptr, PopoverMenuFlags)

// Sets the flags that @popover uses to create/display a menu from its model.
//
// If a model is set and the flags change, contents are rebuilt, so if setting
// properties individually, set flags before model to avoid a redundant rebuild.
func (x *PopoverMenu) SetFlags(FlagsVar PopoverMenuFlags) {

	xPopoverMenuSetFlags(x.GoPointer(), FlagsVar)

}

var xPopoverMenuSetMenuModel func(uintptr, uintptr)

// Sets a new menu model on @popover.
//
// The existing contents of @popover are removed, and
// the @popover is populated with new contents according
// to @model.
func (x *PopoverMenu) SetMenuModel(ModelVar *gio.MenuModel) {

	xPopoverMenuSetMenuModel(x.GoPointer(), ModelVar.GoPointer())

}

func (c *PopoverMenu) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *PopoverMenu) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyVisibleSubmenu sets the "visible-submenu" property.
// The name of the visible submenu.
func (x *PopoverMenu) SetPropertyVisibleSubmenu(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("visible-submenu", &v)
}

// GetPropertyVisibleSubmenu gets the "visible-submenu" property.
// The name of the visible submenu.
func (x *PopoverMenu) GetPropertyVisibleSubmenu() string {
	var v gobject.Value
	x.GetProperty("visible-submenu", &v)
	return v.GetString()
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *PopoverMenu) Announce(MessageVar string, PriorityVar AccessibleAnnouncementPriority) {

	XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *PopoverMenu) GetAccessibleParent() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *PopoverMenu) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *PopoverMenu) GetAtContext() *ATContext {
	var cls *ATContext

	cret := XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *PopoverMenu) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *PopoverMenu) GetFirstAccessibleChild() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *PopoverMenu) GetNextAccessibleSibling() *AccessibleBase {
	var cls *AccessibleBase

	cret := XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *PopoverMenu) GetPlatformState(StateVar AccessiblePlatformState) bool {

	cret := XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *PopoverMenu) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *PopoverMenu) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *PopoverMenu) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *PopoverMenu) SetAccessibleParent(ParentVar Accessible, NextSiblingVar Accessible) {

	XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *PopoverMenu) UpdateNextAccessibleSibling(NewSiblingVar Accessible) {

	XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *PopoverMenu) UpdatePlatformState(StateVar AccessiblePlatformState) {

	XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *PopoverMenu) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *PopoverMenu) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *PopoverMenu) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *PopoverMenu) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *PopoverMenu) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *PopoverMenu) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *PopoverMenu) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Returns the renderer that is used for this `GtkNative`.
func (x *PopoverMenu) GetRenderer() *gsk.Renderer {
	var cls *gsk.Renderer

	cret := XGtkNativeGetRenderer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gsk.Renderer{}
	cls.Ptr = cret
	return cls
}

// Returns the surface of this `GtkNative`.
func (x *PopoverMenu) GetSurface() *gdk.Surface {
	var cls *gdk.Surface

	cret := XGtkNativeGetSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Surface{}
	cls.Ptr = cret
	return cls
}

// Retrieves the surface transform of @self.
//
// This is the translation from @self's surface coordinates into
// @self's widget coordinates.
func (x *PopoverMenu) GetSurfaceTransform(XVar *float64, YVar *float64) {

	XGtkNativeGetSurfaceTransform(x.GoPointer(), XVar, YVar)

}

// Realizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *PopoverMenu) Realize() {

	XGtkNativeRealize(x.GoPointer())

}

// Unrealizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *PopoverMenu) Unrealize() {

	XGtkNativeUnrealize(x.GoPointer())

}

func init() {
	core.SetPackageName("GTK", "gtk4")
	core.SetSharedLibraries("GTK", []string{"libgtk-4.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GTK") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPopoverMenuGLibType, libs, "gtk_popover_menu_get_type")

	core.PuregoSafeRegister(&xNewPopoverMenuFromModel, libs, "gtk_popover_menu_new_from_model")
	core.PuregoSafeRegister(&xNewPopoverMenuFromModelFull, libs, "gtk_popover_menu_new_from_model_full")

	core.PuregoSafeRegister(&xPopoverMenuAddChild, libs, "gtk_popover_menu_add_child")
	core.PuregoSafeRegister(&xPopoverMenuGetFlags, libs, "gtk_popover_menu_get_flags")
	core.PuregoSafeRegister(&xPopoverMenuGetMenuModel, libs, "gtk_popover_menu_get_menu_model")
	core.PuregoSafeRegister(&xPopoverMenuRemoveChild, libs, "gtk_popover_menu_remove_child")
	core.PuregoSafeRegister(&xPopoverMenuSetFlags, libs, "gtk_popover_menu_set_flags")
	core.PuregoSafeRegister(&xPopoverMenuSetMenuModel, libs, "gtk_popover_menu_set_menu_model")

}
