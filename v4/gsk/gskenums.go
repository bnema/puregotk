// Package gsk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gsk

import "github.com/jwijenbergh/puregotk/v4/gobject/types"

// The blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the
// rendering pipeline.
//
// See &lt;https://www.w3.org/TR/compositing-1/#blending&gt; for more information
// on blending and blend modes.
type BlendMode int

var xBlendModeGLibType func() types.GType

func BlendModeGLibType() types.GType {
	return xBlendModeGLibType()
}

const (

	// The default blend mode, which specifies no blending
	BlendModeDefaultValue BlendMode = 0
	// The source color is multiplied by the destination
	//   and replaces the destination
	BlendModeMultiplyValue BlendMode = 1
	// Multiplies the complements of the destination and source
	//   color values, then complements the result.
	BlendModeScreenValue BlendMode = 2
	// Multiplies or screens the colors, depending on the
	//   destination color value. This is the inverse of hard-list
	BlendModeOverlayValue BlendMode = 3
	// Selects the darker of the destination and source colors
	BlendModeDarkenValue BlendMode = 4
	// Selects the lighter of the destination and source colors
	BlendModeLightenValue BlendMode = 5
	// Brightens the destination color to reflect the source color
	BlendModeColorDodgeValue BlendMode = 6
	// Darkens the destination color to reflect the source color
	BlendModeColorBurnValue BlendMode = 7
	// Multiplies or screens the colors, depending on the source color value
	BlendModeHardLightValue BlendMode = 8
	// Darkens or lightens the colors, depending on the source color value
	BlendModeSoftLightValue BlendMode = 9
	// Subtracts the darker of the two constituent colors from the lighter color
	BlendModeDifferenceValue BlendMode = 10
	// Produces an effect similar to that of the difference mode but lower in contrast
	BlendModeExclusionValue BlendMode = 11
	// Creates a color with the hue and saturation of the source color and the luminosity of the destination color
	BlendModeColorValue BlendMode = 12
	// Creates a color with the hue of the source color and the saturation and luminosity of the destination color
	BlendModeHueValue BlendMode = 13
	// Creates a color with the saturation of the source color and the hue and luminosity of the destination color
	BlendModeSaturationValue BlendMode = 14
	// Creates a color with the luminosity of the source color and the hue and saturation of the destination color
	BlendModeLuminosityValue BlendMode = 15
)

// The corner indices used by `GskRoundedRect`.
type Corner int

var xCornerGLibType func() types.GType

func CornerGLibType() types.GType {
	return xCornerGLibType()
}

const (

	// The top left corner
	CornerTopLeftValue Corner = 0
	// The top right corner
	CornerTopRightValue Corner = 1
	// The bottom right corner
	CornerBottomRightValue Corner = 2
	// The bottom left corner
	CornerBottomLeftValue Corner = 3
)

// Specifies how paths are filled.
//
// Whether or not a point is included in the fill is determined by taking
// a ray from that point to infinity and looking at intersections with the
// path. The ray can be in any direction, as long as it doesn't pass through
// the end point of a segment or have a tricky intersection such as
// intersecting tangent to the path.
//
// (Note that filling is not actually implemented in this way. This
// is just a description of the rule that is applied.)
//
// New entries may be added in future versions.
type FillRule int

var xFillRuleGLibType func() types.GType

func FillRuleGLibType() types.GType {
	return xFillRuleGLibType()
}

const (

	// If the path crosses the ray from
	//   left-to-right, counts +1. If the path crosses the ray
	//   from right to left, counts -1. (Left and right are determined
	//   from the perspective of looking along the ray from the starting
	//   point.) If the total count is non-zero, the point will be filled.
	FillRuleWindingValue FillRule = 0
	// Counts the total number of
	//   intersections, without regard to the orientation of the contour. If
	//   the total number of intersections is odd, the point will be
	//   filled.
	FillRuleEvenOddValue FillRule = 1
)

// Defines the types of the uniforms that `GskGLShaders` declare.
//
// It defines both what the type is called in the GLSL shader
// code, and what the corresponding C type is on the Gtk side.
type GLUniformType int

var xGLUniformTypeGLibType func() types.GType

func GLUniformTypeGLibType() types.GType {
	return xGLUniformTypeGLibType()
}

const (

	// No type, used for uninitialized or unspecified values.
	GlUniformTypeNoneValue GLUniformType = 0
	// A float uniform
	GlUniformTypeFloatValue GLUniformType = 1
	// A GLSL int / gint32 uniform
	GlUniformTypeIntValue GLUniformType = 2
	// A GLSL uint / guint32 uniform
	GlUniformTypeUintValue GLUniformType = 3
	// A GLSL bool / gboolean uniform
	GlUniformTypeBoolValue GLUniformType = 4
	// A GLSL vec2 / graphene_vec2_t uniform
	GlUniformTypeVec2Value GLUniformType = 5
	// A GLSL vec3 / graphene_vec3_t uniform
	GlUniformTypeVec3Value GLUniformType = 6
	// A GLSL vec4 / graphene_vec4_t uniform
	GlUniformTypeVec4Value GLUniformType = 7
)

// Specifies how to render the start and end points of contours or
// dashes when stroking.
//
// The default line cap style is `GSK_LINE_CAP_BUTT`.
//
// New entries may be added in future versions.
//
// &lt;figure&gt;
//
//	&lt;picture&gt;
//	  &lt;source srcset="caps-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	  &lt;img alt="Line Cap Styles" src="caps-light.png"&gt;
//	&lt;/picture&gt;
//	&lt;figcaption&gt;GSK_LINE_CAP_BUTT, GSK_LINE_CAP_ROUND, GSK_LINE_CAP_SQUARE&lt;/figcaption&gt;
//
// &lt;/figure&gt;
type LineCap int

var xLineCapGLibType func() types.GType

func LineCapGLibType() types.GType {
	return xLineCapGLibType()
}

const (

	// Start and stop the line exactly at the start
	//   and end point
	LineCapButtValue LineCap = 0
	// Use a round ending, the center of the circle
	//   is the start or end point
	LineCapRoundValue LineCap = 1
	// use squared ending, the center of the square
	//   is the start or end point
	LineCapSquareValue LineCap = 2
)

// Specifies how to render the junction of two lines when stroking.
//
// The default line join style is `GSK_LINE_JOIN_MITER`.
//
// New entries may be added in future versions.
//
// &lt;figure&gt;
//
//	&lt;picture&gt;
//	  &lt;source srcset="join-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	  &lt;img alt="Line Join Styles" src="join-light.png"&gt;
//	&lt;/picture&gt;
//	&lt;figcaption&gt;GSK_LINE_JOINT_MITER, GSK_LINE_JOINT_ROUND, GSK_LINE_JOIN_BEVEL&lt;/figcaption&gt;
//
// &lt;/figure&gt;
type LineJoin int

var xLineJoinGLibType func() types.GType

func LineJoinGLibType() types.GType {
	return xLineJoinGLibType()
}

const (

	// Use a sharp angled corner
	LineJoinMiterValue LineJoin = 0
	// Use a round join, the center of the circle is
	//   the join point
	LineJoinRoundValue LineJoin = 1
	// use a cut-off join, the join is cut off at half
	//   the line width from the joint point
	LineJoinBevelValue LineJoin = 2
)

// The mask modes available for mask nodes.
type MaskMode int

var xMaskModeGLibType func() types.GType

func MaskModeGLibType() types.GType {
	return xMaskModeGLibType()
}

const (

	// Use the alpha channel of the mask
	MaskModeAlphaValue MaskMode = 0
	// Use the inverted alpha channel of the mask
	MaskModeInvertedAlphaValue MaskMode = 1
	// Use the luminance of the mask,
	//     multiplied by mask alpha
	MaskModeLuminanceValue MaskMode = 2
	// Use the inverted luminance of the mask,
	//     multiplied by mask alpha
	MaskModeInvertedLuminanceValue MaskMode = 3
)

// Used to pick one of the four tangents at a given point on the path.
//
// Note that the directions for @GSK_PATH_FROM_START/@GSK_PATH_TO_END and
// @GSK_PATH_TO_START/@GSK_PATH_FROM_END will coincide for smooth points.
// Only sharp turns will exhibit four different directions.
//
// &lt;picture&gt;
//
//	&lt;source srcset="directions-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="Path Tangents" src="directions-light.png"&gt;
//
// &lt;/picture&gt;
type PathDirection int

var xPathDirectionGLibType func() types.GType

func PathDirectionGLibType() types.GType {
	return xPathDirectionGLibType()
}

const (

	// The tangent in path direction of the incoming side
	//   of the path
	PathFromStartValue PathDirection = 0
	// The tangent against path direction of the incoming side
	//   of the path
	PathToStartValue PathDirection = 1
	// The tangent in path direction of the outgoing side
	//   of the path
	PathToEndValue PathDirection = 2
	// The tangent against path direction of the outgoing
	//   side of the path
	PathFromEndValue PathDirection = 3
)

// Describes the segments of a `GskPath`.
//
// More values may be added in the future.
type PathOperation int

var xPathOperationGLibType func() types.GType

func PathOperationGLibType() types.GType {
	return xPathOperationGLibType()
}

const (

	// A move-to operation, with 1 point describing the target point.
	PathMoveValue PathOperation = 0
	// A close operation ending the current contour with a line back
	//   to the starting point. Two points describe the start and end of the line.
	PathCloseValue PathOperation = 1
	// A line-to operation, with 2 points describing the start and
	//   end point of a straight line.
	PathLineValue PathOperation = 2
	// A curve-to operation describing a quadratic Bézier curve
	//   with 3 points describing the start point, the control point and the end
	//   point of the curve.
	PathQuadValue PathOperation = 3
	// A curve-to operation describing a cubic Bézier curve with 4
	//   points describing the start point, the two control points and the end point
	//   of the curve.
	PathCubicValue PathOperation = 4
	// A rational quadratic Bézier curve with 3 points describing
	//   the start point, control point and end point of the curve. A weight for the
	//   curve will be passed, too.
	PathConicValue PathOperation = 5
)

// The type of a node determines what the node is rendering.
type RenderNodeType int

var xRenderNodeTypeGLibType func() types.GType

func RenderNodeTypeGLibType() types.GType {
	return xRenderNodeTypeGLibType()
}

const (

	// Error type. No node will ever have this type.
	NotARenderNodeValue RenderNodeType = 0
	// A node containing a stack of children
	ContainerNodeValue RenderNodeType = 1
	// A node drawing a `cairo_surface_t`
	CairoNodeValue RenderNodeType = 2
	// A node drawing a single color rectangle
	ColorNodeValue RenderNodeType = 3
	// A node drawing a linear gradient
	LinearGradientNodeValue RenderNodeType = 4
	// A node drawing a repeating linear gradient
	RepeatingLinearGradientNodeValue RenderNodeType = 5
	// A node drawing a radial gradient
	RadialGradientNodeValue RenderNodeType = 6
	// A node drawing a repeating radial gradient
	RepeatingRadialGradientNodeValue RenderNodeType = 7
	// A node drawing a conic gradient
	ConicGradientNodeValue RenderNodeType = 8
	// A node stroking a border around an area
	BorderNodeValue RenderNodeType = 9
	// A node drawing a `GdkTexture`
	TextureNodeValue RenderNodeType = 10
	// A node drawing an inset shadow
	InsetShadowNodeValue RenderNodeType = 11
	// A node drawing an outset shadow
	OutsetShadowNodeValue RenderNodeType = 12
	// A node that renders its child after applying a matrix transform
	TransformNodeValue RenderNodeType = 13
	// A node that changes the opacity of its child
	OpacityNodeValue RenderNodeType = 14
	// A node that applies a color matrix to every pixel
	ColorMatrixNodeValue RenderNodeType = 15
	// A node that repeats the child's contents
	RepeatNodeValue RenderNodeType = 16
	// A node that clips its child to a rectangular area
	ClipNodeValue RenderNodeType = 17
	// A node that clips its child to a rounded rectangle
	RoundedClipNodeValue RenderNodeType = 18
	// A node that draws a shadow below its child
	ShadowNodeValue RenderNodeType = 19
	// A node that blends two children together
	BlendNodeValue RenderNodeType = 20
	// A node that cross-fades between two children
	CrossFadeNodeValue RenderNodeType = 21
	// A node containing a glyph string
	TextNodeValue RenderNodeType = 22
	// A node that applies a blur
	BlurNodeValue RenderNodeType = 23
	// Debug information that does not affect the rendering
	DebugNodeValue RenderNodeType = 24
	// A node that uses OpenGL fragment shaders to render
	GlShaderNodeValue RenderNodeType = 25
	// A node drawing a `GdkTexture` scaled and filtered.
	TextureScaleNodeValue RenderNodeType = 26
	// A node that masks one child with another.
	MaskNodeValue RenderNodeType = 27
	// A node that fills a path.
	FillNodeValue RenderNodeType = 28
	// A node that strokes a path.
	StrokeNodeValue RenderNodeType = 29
	// A node that possibly redirects part of the scene graph to a subsurface.
	SubsurfaceNodeValue RenderNodeType = 30
	// A node that applies some function to each color component.
	ComponentTransferNodeValue RenderNodeType = 31
)

// The filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the
// rendering pipeline.
type ScalingFilter int

var xScalingFilterGLibType func() types.GType

func ScalingFilterGLibType() types.GType {
	return xScalingFilterGLibType()
}

const (

	// linear interpolation filter
	ScalingFilterLinearValue ScalingFilter = 0
	// nearest neighbor interpolation filter
	ScalingFilterNearestValue ScalingFilter = 1
	// linear interpolation along each axis,
	//   plus mipmap generation, with linear interpolation along the mipmap
	//   levels
	ScalingFilterTrilinearValue ScalingFilter = 2
)

// Errors that can happen during (de)serialization.
type SerializationError int

var xSerializationErrorGLibType func() types.GType

func SerializationErrorGLibType() types.GType {
	return xSerializationErrorGLibType()
}

const (

	// The format can not be identified
	SerializationUnsupportedFormatValue SerializationError = 0
	// The version of the data is not
	//   understood
	SerializationUnsupportedVersionValue SerializationError = 1
	// The given data may not exist in
	//   a proper serialization
	SerializationInvalidDataValue SerializationError = 2
)

// The categories of matrices relevant for GSK and GTK.
//
// Note that any category includes matrices of all later categories.
// So if you want to for example check if a matrix is a 2D matrix,
// `category &gt;= GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not
// conform to their categories. Otherwise, matrix operations done via
// multiplication will not worsen categories. So for the matrix
// multiplication `C = A * B`, `category(C) = MIN (category(A), category(B))`.
type TransformCategory int

var xTransformCategoryGLibType func() types.GType

func TransformCategoryGLibType() types.GType {
	return xTransformCategoryGLibType()
}

const (

	// The category of the matrix has not been
	//   determined.
	TransformCategoryUnknownValue TransformCategory = 0
	// Analyzing the matrix concluded that it does
	//   not fit in any other category.
	TransformCategoryAnyValue TransformCategory = 1
	// The matrix is a 3D matrix. This means that
	//   the w column (the last column) has the values (0, 0, 0, 1).
	TransformCategory3dValue TransformCategory = 2
	// The matrix is a 2D matrix. This is equivalent
	//   to graphene_matrix_is_2d() returning %TRUE. In particular, this
	//   means that Cairo can deal with the matrix.
	TransformCategory2dValue TransformCategory = 3
	// The matrix is a combination of 2D scale
	//   and 2D translation operations. In particular, this means that any
	//   rectangle can be transformed exactly using this matrix.
	TransformCategory2dAffineValue TransformCategory = 4
	// The matrix is a 2D translation.
	TransformCategory2dTranslateValue TransformCategory = 5
	// The matrix is the identity matrix.
	TransformCategoryIdentityValue TransformCategory = 6
)
