// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"fmt"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type AlertDialogClass struct {
	_ structs.HostLayout

	ParentClass DialogClass

	xResponse uintptr

	Padding [4]uintptr
}

func (x *AlertDialogClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideResponse sets the "response" callback function.
func (x *AlertDialogClass) OverrideResponse(cb func(*AlertDialog, string)) {
	if cb == nil {
		x.xResponse = 0
	} else {
		x.xResponse = purego.NewCallback(func(SelfVarp uintptr, ResponseVarp string) {
			cb(AlertDialogNewFromInternalPtr(SelfVarp), ResponseVarp)
		})
	}
}

// GetResponse gets the "response" callback function.
func (x *AlertDialogClass) GetResponse() func(*AlertDialog, string) {
	if x.xResponse == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, ResponseVarp string)
	purego.RegisterFunc(&rawCallback, x.xResponse)
	return func(SelfVar *AlertDialog, ResponseVar string) {
		rawCallback(SelfVar.GoPointer(), ResponseVar)
	}
}

// Describes the possible styles of [class@AlertDialog] response buttons.
//
// See [method@AlertDialog.set_response_appearance].
type ResponseAppearance int

var xResponseAppearanceGLibType func() types.GType

func ResponseAppearanceGLibType() types.GType {
	return xResponseAppearanceGLibType()
}

const (

	// the default appearance.
	ResponseDefaultValue ResponseAppearance = 0
	// used to denote important responses such as the
	//     affirmative action.
	ResponseSuggestedValue ResponseAppearance = 1
	// used to draw attention to the potentially damaging
	//     consequences of using the response. This appearance acts as a warning to
	//     the user.
	ResponseDestructiveValue ResponseAppearance = 2
)

// A dialog presenting a message or a question.
//
// &lt;picture&gt;
//
//	&lt;source srcset="alert-dialog-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="alert-dialog.png" alt="alert-dialog"&gt;
//
// &lt;/picture&gt;
//
// Alert dialogs have a heading, a body, an optional child widget, and one or
// multiple responses, each presented as a button.
//
// Each response has a unique string ID, and a button label. Additionally, each
// response can be enabled or disabled, and can have a suggested or destructive
// appearance.
//
// When one of the responses is activated, or the dialog is closed, the
// [signal@AlertDialog::response] signal will be emitted. This signal is
// detailed, and the detail, as well as the `response` parameter will be set to
// the ID of the activated response, or to the value of the
// [property@AlertDialog:close-response] property if the dialog had been closed
// without activating any of the responses.
//
// Response buttons can be presented horizontally or vertically depending on
// available space.
//
// When a response is activated, `AdwAlertDialog` is closed automatically.
//
// An example of using an alert dialog:
//
// ```c
// AdwDialog *dialog;
//
// dialog = adw_alert_dialog_new (_("Replace File?"), NULL);
//
// adw_alert_dialog_format_body (ADW_ALERT_DIALOG (dialog),
//
//	_("A file named “%s” already exists. Do you want to replace it?"),
//	filename);
//
// adw_alert_dialog_add_responses (ADW_ALERT_DIALOG (dialog),
//
//	"cancel",  _("_Cancel"),
//	"replace", _("_Replace"),
//	NULL);
//
// adw_alert_dialog_set_response_appearance (ADW_ALERT_DIALOG (dialog),
//
//	"replace",
//	ADW_RESPONSE_DESTRUCTIVE);
//
// adw_alert_dialog_set_default_response (ADW_ALERT_DIALOG (dialog), "cancel");
// adw_alert_dialog_set_close_response (ADW_ALERT_DIALOG (dialog), "cancel");
//
// g_signal_connect (dialog, "response", G_CALLBACK (response_cb), self);
//
// adw_dialog_present (dialog, parent);
// ```
//
// ## Async API
//
// `AdwAlertDialog` can also be used via the [method@AlertDialog.choose] method.
// This API follows the GIO async pattern, for example:
//
// ```c
// static void
// dialog_cb (AdwAlertDialog *dialog,
//
//	GAsyncResult   *result,
//	MyWindow       *self)
//
//	{
//	  const char *response = adw_alert_dialog_choose_finish (dialog, result);
//
//	  // ...
//	}
//
// static void
// show_dialog (MyWindow *self)
//
//	{
//	  AdwDialog *dialog;
//
//	  dialog = adw_alert_dialog_new (_("Replace File?"), NULL);
//
//	  adw_alert_dialog_format_body (ADW_ALERT_DIALOG (dialog),
//	                                _("A file named “%s” already exists. Do you want to replace it?"),
//	                                filename);
//
//	  adw_alert_dialog_add_responses (ADW_ALERT_DIALOG (dialog),
//	                                  "cancel",  _("_Cancel"),
//	                                  "replace", _("_Replace"),
//	                                  NULL);
//
//	  adw_alert_dialog_set_response_appearance (ADW_ALERT_DIALOG (dialog),
//	                                            "replace",
//	                                            ADW_RESPONSE_DESTRUCTIVE);
//
//	  adw_alert_dialog_set_default_response (ADW_ALERT_DIALOG (dialog), "cancel");
//	  adw_alert_dialog_set_close_response (ADW_ALERT_DIALOG (dialog), "cancel");
//
//	  adw_alert_dialog_choose (ADW_ALERT_DIALOG (dialog), GTK_WIDGET (self),
//	                           NULL, (GAsyncReadyCallback) dialog_cb, self);
//	}
//
// ```
//
// ## AdwAlertDialog as GtkBuildable
//
// `AdwAlertDialog` supports adding responses in UI definitions by via the
// `&lt;responses&gt;` element that may contain multiple `&lt;response&gt;` elements, each
// representing a response.
//
// Each of the `&lt;response&gt;` elements must have the `id` attribute specifying the
// response ID. The contents of the element are used as the response label.
//
// Response labels can be translated with the usual `translatable`, `context`
// and `comments` attributes.
//
// The `&lt;response&gt;` elements can also have `enabled` and/or `appearance`
// attributes. See [method@AlertDialog.set_response_enabled] and
// [method@AlertDialog.set_response_appearance] for details.
//
// Example of an `AdwAlertDialog` UI definition:
//
// ```xml
// &lt;object class="AdwAlertDialog" id="dialog"&gt;
//
//	&lt;property name="heading" translatable="yes"&gt;Save Changes?&lt;/property&gt;
//	&lt;property name="body" translatable="yes"&gt;Open documents contain unsaved changes. Changes which are not saved will be permanently lost.&lt;/property&gt;
//	&lt;property name="default-response"&gt;save&lt;/property&gt;
//	&lt;property name="close-response"&gt;cancel&lt;/property&gt;
//	&lt;signal name="response" handler="response_cb"/&gt;
//	&lt;responses&gt;
//	  &lt;response id="cancel" translatable="yes"&gt;_Cancel&lt;/response&gt;
//	  &lt;response id="discard" translatable="yes" appearance="destructive"&gt;_Discard&lt;/response&gt;
//	  &lt;response id="save" translatable="yes" appearance="suggested" enabled="false"&gt;_Save&lt;/response&gt;
//	&lt;/responses&gt;
//
// &lt;/object&gt;
// ```
type AlertDialog struct {
	Dialog
}

var xAlertDialogGLibType func() types.GType

func AlertDialogGLibType() types.GType {
	return xAlertDialogGLibType()
}

func AlertDialogNewFromInternalPtr(ptr uintptr) *AlertDialog {
	cls := &AlertDialog{}
	cls.Ptr = ptr
	return cls
}

var xNewAlertDialog func(uintptr, uintptr) uintptr

// Creates a new `AdwAlertDialog`.
//
// @heading and @body can be set to `NULL`. This can be useful if they need to
// be formatted or use markup. In that case, set them to `NULL` and call
// [method@AlertDialog.format_body] or similar methods afterwards:
//
// ```c
// AdwDialog *dialog;
//
// dialog = adw_alert_dialog_new (_("Replace File?"), NULL);
// adw_alert_dialog_format_body (ADW_ALERT_DIALOG (dialog),
//
//	_("A file named “%s” already exists.  Do you want to replace it?"),
//	filename);
//
// ```
func NewAlertDialog(HeadingVar *string, BodyVar *string) *AlertDialog {
	var cls *AlertDialog

	cret := xNewAlertDialog(core.NullableStringToPtr(HeadingVar), core.NullableStringToPtr(BodyVar))

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &AlertDialog{}
	cls.Ptr = cret
	return cls
}

var xAlertDialogAddResponse func(uintptr, string, string)

// Adds a response with @id and @label to @self.
//
// Responses are represented as buttons in the dialog.
//
// Response ID must be unique. It will be used in [signal@AlertDialog::response]
// to tell which response had been activated, as well as to inspect and modify
// the response later.
//
// An embedded underline in @label indicates a mnemonic.
//
// [method@AlertDialog.set_response_label] can be used to change the response
// label after it had been added.
//
// [method@AlertDialog.set_response_enabled] and
// [method@AlertDialog.set_response_appearance] can be used to customize the
// responses further.
func (x *AlertDialog) AddResponse(IdVar string, LabelVar string) {

	xAlertDialogAddResponse(x.GoPointer(), IdVar, LabelVar)

}

var xAlertDialogAddResponses func(uintptr, string, ...interface{})

// Adds multiple responses to @self.
//
// This is the same as calling [method@AlertDialog.add_response] repeatedly. The
// variable argument list should be `NULL`-terminated list of response IDs and
// labels.
//
// Example:
//
// ```c
// adw_alert_dialog_add_responses (dialog,
//
//	"cancel",  _("_Cancel"),
//	"discard", _("_Discard"),
//	"save",    _("_Save"),
//	NULL);
//
// ```
func (x *AlertDialog) AddResponses(FirstIdVar string, varArgs ...interface{}) {

	xAlertDialogAddResponses(x.GoPointer(), FirstIdVar, varArgs...)

}

var xAlertDialogChoose func(uintptr, uintptr, uintptr, uintptr, uintptr)

// This function shows @self to the user.
//
// If the window is an [class@Window] or [class@ApplicationWindow], the dialog
// will be shown within it. Otherwise, it will be a separate window.
func (x *AlertDialog) Choose(ParentVar *gtk.Widget, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xAlertDialogChoose(x.GoPointer(), ParentVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xAlertDialogChooseFinish func(uintptr, uintptr) string

// Finishes the [method@AlertDialog.choose] call and returns the response ID.
func (x *AlertDialog) ChooseFinish(ResultVar gio.AsyncResult) string {

	cret := xAlertDialogChooseFinish(x.GoPointer(), ResultVar.GoPointer())
	return cret
}

var xAlertDialogFormatBody func(uintptr, string, ...interface{})

// Sets the formatted body text of @self.
//
// See [property@AlertDialog:body].
func (x *AlertDialog) FormatBody(FormatVar string, varArgs ...interface{}) {

	xAlertDialogFormatBody(x.GoPointer(), FormatVar, varArgs...)

}

var xAlertDialogFormatBodyMarkup func(uintptr, string, ...interface{})

// Sets the formatted body text of @self with Pango markup.
//
// The @format is assumed to contain Pango markup.
//
// Special XML characters in the `printf()` arguments passed to this function
// will automatically be escaped as necessary, see
// [func@GLib.markup_printf_escaped].
//
// See [property@AlertDialog:body].
func (x *AlertDialog) FormatBodyMarkup(FormatVar string, varArgs ...interface{}) {

	xAlertDialogFormatBodyMarkup(x.GoPointer(), FormatVar, varArgs...)

}

var xAlertDialogFormatHeading func(uintptr, string, ...interface{})

// Sets the formatted heading of @self.
//
// See [property@AlertDialog:heading].
func (x *AlertDialog) FormatHeading(FormatVar string, varArgs ...interface{}) {

	xAlertDialogFormatHeading(x.GoPointer(), FormatVar, varArgs...)

}

var xAlertDialogFormatHeadingMarkup func(uintptr, string, ...interface{})

// Sets the formatted heading of @self with Pango markup.
//
// The @format is assumed to contain Pango markup.
//
// Special XML characters in the `printf()` arguments passed to this function
// will automatically be escaped as necessary, see
// [func@GLib.markup_printf_escaped].
//
// See [property@AlertDialog:heading].
func (x *AlertDialog) FormatHeadingMarkup(FormatVar string, varArgs ...interface{}) {

	xAlertDialogFormatHeadingMarkup(x.GoPointer(), FormatVar, varArgs...)

}

var xAlertDialogGetBody func(uintptr) string

// Gets the body text of @self.
func (x *AlertDialog) GetBody() string {

	cret := xAlertDialogGetBody(x.GoPointer())
	return cret
}

var xAlertDialogGetBodyUseMarkup func(uintptr) bool

// Gets whether the body text of @self includes Pango markup.
func (x *AlertDialog) GetBodyUseMarkup() bool {

	cret := xAlertDialogGetBodyUseMarkup(x.GoPointer())
	return cret
}

var xAlertDialogGetCloseResponse func(uintptr) string

// Gets the ID of the close response of @self.
func (x *AlertDialog) GetCloseResponse() string {

	cret := xAlertDialogGetCloseResponse(x.GoPointer())
	return cret
}

var xAlertDialogGetDefaultResponse func(uintptr) string

// Gets the ID of the default response of @self.
func (x *AlertDialog) GetDefaultResponse() string {

	cret := xAlertDialogGetDefaultResponse(x.GoPointer())
	return cret
}

var xAlertDialogGetExtraChild func(uintptr) uintptr

// Gets the child widget of @self.
func (x *AlertDialog) GetExtraChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xAlertDialogGetExtraChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xAlertDialogGetHeading func(uintptr) string

// Gets the heading of @self.
func (x *AlertDialog) GetHeading() string {

	cret := xAlertDialogGetHeading(x.GoPointer())
	return cret
}

var xAlertDialogGetHeadingUseMarkup func(uintptr) bool

// Gets whether the heading of @self includes Pango markup.
func (x *AlertDialog) GetHeadingUseMarkup() bool {

	cret := xAlertDialogGetHeadingUseMarkup(x.GoPointer())
	return cret
}

var xAlertDialogGetPreferWideLayout func(uintptr) bool

// Gets whether @self prefers wide layout.
func (x *AlertDialog) GetPreferWideLayout() bool {

	cret := xAlertDialogGetPreferWideLayout(x.GoPointer())
	return cret
}

var xAlertDialogGetResponseAppearance func(uintptr, string) ResponseAppearance

// Gets the appearance of @response.
//
// See [method@AlertDialog.set_response_appearance].
func (x *AlertDialog) GetResponseAppearance(ResponseVar string) ResponseAppearance {

	cret := xAlertDialogGetResponseAppearance(x.GoPointer(), ResponseVar)
	return cret
}

var xAlertDialogGetResponseEnabled func(uintptr, string) bool

// Gets whether @response is enabled.
//
// See [method@AlertDialog.set_response_enabled].
func (x *AlertDialog) GetResponseEnabled(ResponseVar string) bool {

	cret := xAlertDialogGetResponseEnabled(x.GoPointer(), ResponseVar)
	return cret
}

var xAlertDialogGetResponseLabel func(uintptr, string) string

// Gets the label of @response.
//
// See [method@AlertDialog.set_response_label].
func (x *AlertDialog) GetResponseLabel(ResponseVar string) string {

	cret := xAlertDialogGetResponseLabel(x.GoPointer(), ResponseVar)
	return cret
}

var xAlertDialogHasResponse func(uintptr, string) bool

// Gets whether @self has a response with the ID @response.
func (x *AlertDialog) HasResponse(ResponseVar string) bool {

	cret := xAlertDialogHasResponse(x.GoPointer(), ResponseVar)
	return cret
}

var xAlertDialogRemoveResponse func(uintptr, string)

// Removes a response from @self.
func (x *AlertDialog) RemoveResponse(IdVar string) {

	xAlertDialogRemoveResponse(x.GoPointer(), IdVar)

}

var xAlertDialogSetBody func(uintptr, string)

// Sets the body text of @self.
func (x *AlertDialog) SetBody(BodyVar string) {

	xAlertDialogSetBody(x.GoPointer(), BodyVar)

}

var xAlertDialogSetBodyUseMarkup func(uintptr, bool)

// Sets whether the body text of @self includes Pango markup.
//
// See [func@Pango.parse_markup].
func (x *AlertDialog) SetBodyUseMarkup(UseMarkupVar bool) {

	xAlertDialogSetBodyUseMarkup(x.GoPointer(), UseMarkupVar)

}

var xAlertDialogSetCloseResponse func(uintptr, string)

// Sets the ID of the close response of @self.
//
// It will be passed to [signal@AlertDialog::response] if the dialog is closed
// by pressing &lt;kbd&gt;Escape&lt;/kbd&gt; or with a system action.
//
// It doesn't have to correspond to any of the responses in the dialog.
//
// The default close response is `close`.
func (x *AlertDialog) SetCloseResponse(ResponseVar string) {

	xAlertDialogSetCloseResponse(x.GoPointer(), ResponseVar)

}

var xAlertDialogSetDefaultResponse func(uintptr, uintptr)

// Sets the ID of the default response of @self.
//
// The button corresponding to this response will be set as the default widget
// of @self.
//
// If not set, the default widget will not be set, and the last added response
// will be focused by default.
//
// See [property@Dialog:default-widget].
func (x *AlertDialog) SetDefaultResponse(ResponseVar *string) {

	xAlertDialogSetDefaultResponse(x.GoPointer(), core.NullableStringToPtr(ResponseVar))

}

var xAlertDialogSetExtraChild func(uintptr, uintptr)

// Sets the child widget of @self.
//
// The child widget is displayed below the heading and body.
func (x *AlertDialog) SetExtraChild(ChildVar *gtk.Widget) {

	xAlertDialogSetExtraChild(x.GoPointer(), ChildVar.GoPointer())

}

var xAlertDialogSetHeading func(uintptr, uintptr)

// Sets the heading of @self.
func (x *AlertDialog) SetHeading(HeadingVar *string) {

	xAlertDialogSetHeading(x.GoPointer(), core.NullableStringToPtr(HeadingVar))

}

var xAlertDialogSetHeadingUseMarkup func(uintptr, bool)

// Sets whether the heading of @self includes Pango markup.
//
// See [func@Pango.parse_markup].
func (x *AlertDialog) SetHeadingUseMarkup(UseMarkupVar bool) {

	xAlertDialogSetHeadingUseMarkup(x.GoPointer(), UseMarkupVar)

}

var xAlertDialogSetPreferWideLayout func(uintptr, bool)

// Sets whether @self prefers wide layout.
//
// Prefer horizontal button layout when possible, and wider dialog width
// otherwise.
func (x *AlertDialog) SetPreferWideLayout(PreferWideLayoutVar bool) {

	xAlertDialogSetPreferWideLayout(x.GoPointer(), PreferWideLayoutVar)

}

var xAlertDialogSetResponseAppearance func(uintptr, string, ResponseAppearance)

// Sets the appearance for @response.
//
// &lt;picture&gt;
//
//	&lt;source srcset="alert-dialog-appearance-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="alert-dialog-appearance.png" alt="alert-dialog-appearance"&gt;
//
// &lt;/picture&gt;
//
// Use `ADW_RESPONSE_SUGGESTED` to mark important responses such as the
// affirmative action, like the Save button in the example.
//
// Use `ADW_RESPONSE_DESTRUCTIVE` to draw attention to the potentially damaging
// consequences of using @response. This appearance acts as a warning to the
// user. The Discard button in the example is using this appearance.
//
// The default appearance is `ADW_RESPONSE_DEFAULT`.
//
// Negative responses like Cancel or Close should use the default appearance.
func (x *AlertDialog) SetResponseAppearance(ResponseVar string, AppearanceVar ResponseAppearance) {

	xAlertDialogSetResponseAppearance(x.GoPointer(), ResponseVar, AppearanceVar)

}

var xAlertDialogSetResponseEnabled func(uintptr, string, bool)

// Sets whether @response is enabled.
//
// If @response is not enabled, the corresponding button will have
// [property@Gtk.Widget:sensitive] set to `FALSE` and it can't be activated as
// a default response.
//
// @response can still be used as [property@AlertDialog:close-response] while
// it's not enabled.
//
// Responses are enabled by default.
func (x *AlertDialog) SetResponseEnabled(ResponseVar string, EnabledVar bool) {

	xAlertDialogSetResponseEnabled(x.GoPointer(), ResponseVar, EnabledVar)

}

var xAlertDialogSetResponseLabel func(uintptr, string, string)

// Sets the label of @response to @label.
//
// Labels are displayed on the dialog buttons. An embedded underline in @label
// indicates a mnemonic.
func (x *AlertDialog) SetResponseLabel(ResponseVar string, LabelVar string) {

	xAlertDialogSetResponseLabel(x.GoPointer(), ResponseVar, LabelVar)

}

func (c *AlertDialog) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *AlertDialog) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyBody sets the "body" property.
// The body text of the dialog.
func (x *AlertDialog) SetPropertyBody(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("body", &v)
}

// GetPropertyBody gets the "body" property.
// The body text of the dialog.
func (x *AlertDialog) GetPropertyBody() string {
	var v gobject.Value
	x.GetProperty("body", &v)
	return v.GetString()
}

// SetPropertyBodyUseMarkup sets the "body-use-markup" property.
// Whether the body text includes Pango markup.
//
// See [func@Pango.parse_markup].
func (x *AlertDialog) SetPropertyBodyUseMarkup(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("body-use-markup", &v)
}

// GetPropertyBodyUseMarkup gets the "body-use-markup" property.
// Whether the body text includes Pango markup.
//
// See [func@Pango.parse_markup].
func (x *AlertDialog) GetPropertyBodyUseMarkup() bool {
	var v gobject.Value
	x.GetProperty("body-use-markup", &v)
	return v.GetBoolean()
}

// SetPropertyCloseResponse sets the "close-response" property.
// The ID of the close response.
//
// It will be passed to [signal@AlertDialog::response] if the dialog is
// closed by pressing &lt;kbd&gt;Escape&lt;/kbd&gt; or with a system action.
//
// It doesn't have to correspond to any of the responses in the dialog.
//
// The default close response is `close`.
func (x *AlertDialog) SetPropertyCloseResponse(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("close-response", &v)
}

// GetPropertyCloseResponse gets the "close-response" property.
// The ID of the close response.
//
// It will be passed to [signal@AlertDialog::response] if the dialog is
// closed by pressing &lt;kbd&gt;Escape&lt;/kbd&gt; or with a system action.
//
// It doesn't have to correspond to any of the responses in the dialog.
//
// The default close response is `close`.
func (x *AlertDialog) GetPropertyCloseResponse() string {
	var v gobject.Value
	x.GetProperty("close-response", &v)
	return v.GetString()
}

// SetPropertyDefaultResponse sets the "default-response" property.
// The response ID of the default response.
//
// The button corresponding to this response will be set as the default widget
// of the dialog.
//
// If not set, the default widget will not be set, and the last added response
// will be focused by default.
//
// See [property@Dialog:default-widget].
func (x *AlertDialog) SetPropertyDefaultResponse(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("default-response", &v)
}

// GetPropertyDefaultResponse gets the "default-response" property.
// The response ID of the default response.
//
// The button corresponding to this response will be set as the default widget
// of the dialog.
//
// If not set, the default widget will not be set, and the last added response
// will be focused by default.
//
// See [property@Dialog:default-widget].
func (x *AlertDialog) GetPropertyDefaultResponse() string {
	var v gobject.Value
	x.GetProperty("default-response", &v)
	return v.GetString()
}

// SetPropertyHeading sets the "heading" property.
// The heading of the dialog.
func (x *AlertDialog) SetPropertyHeading(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("heading", &v)
}

// GetPropertyHeading gets the "heading" property.
// The heading of the dialog.
func (x *AlertDialog) GetPropertyHeading() string {
	var v gobject.Value
	x.GetProperty("heading", &v)
	return v.GetString()
}

// SetPropertyHeadingUseMarkup sets the "heading-use-markup" property.
// Whether the heading includes Pango markup.
//
// See [func@Pango.parse_markup].
func (x *AlertDialog) SetPropertyHeadingUseMarkup(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("heading-use-markup", &v)
}

// GetPropertyHeadingUseMarkup gets the "heading-use-markup" property.
// Whether the heading includes Pango markup.
//
// See [func@Pango.parse_markup].
func (x *AlertDialog) GetPropertyHeadingUseMarkup() bool {
	var v gobject.Value
	x.GetProperty("heading-use-markup", &v)
	return v.GetBoolean()
}

// SetPropertyPreferWideLayout sets the "prefer-wide-layout" property.
// Whether to prefer wide layout.
//
// Prefer horizontal button layout when possible, and wider dialog width
// otherwise.
func (x *AlertDialog) SetPropertyPreferWideLayout(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("prefer-wide-layout", &v)
}

// GetPropertyPreferWideLayout gets the "prefer-wide-layout" property.
// Whether to prefer wide layout.
//
// Prefer horizontal button layout when possible, and wider dialog width
// otherwise.
func (x *AlertDialog) GetPropertyPreferWideLayout() bool {
	var v gobject.Value
	x.GetProperty("prefer-wide-layout", &v)
	return v.GetBoolean()
}

// This signal is emitted when the dialog is closed.
//
// @response will be set to the response ID of the button that had been
// activated.
//
// if the dialog was closed by pressing &lt;kbd&gt;Escape&lt;/kbd&gt; or with a system
// action, @response will be set to the value of
// [property@AlertDialog:close-response].
func (x *AlertDialog) ConnectResponse(cb *func(AlertDialog, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "response", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ResponseVarp string) {
		fa := AlertDialog{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ResponseVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "response", cbRefPtr)
}

// ConnectResponseWithDetail connects to the "response" signal with a detail string.
// The detail is appended as "response::<detail>".
func (x *AlertDialog) ConnectResponseWithDetail(detail string, cb *func(AlertDialog, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	signalName := fmt.Sprintf("response::%s", detail)
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), signalName, cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ResponseVarp string) {
		fa := AlertDialog{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ResponseVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), signalName, cbRefPtr)
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *AlertDialog) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *AlertDialog) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *AlertDialog) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *AlertDialog) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *AlertDialog) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *AlertDialog) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *AlertDialog) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *AlertDialog) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *AlertDialog) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *AlertDialog) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *AlertDialog) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *AlertDialog) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *AlertDialog) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *AlertDialog) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *AlertDialog) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *AlertDialog) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *AlertDialog) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *AlertDialog) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *AlertDialog) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *AlertDialog) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *AlertDialog) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	core.SetPackageName("ADW", "libadwaita-1")
	core.SetSharedLibraries("ADW", []string{"libadwaita-1.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("ADW") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xResponseAppearanceGLibType, libs, "adw_response_appearance_get_type")

	core.PuregoSafeRegister(&xAlertDialogGLibType, libs, "adw_alert_dialog_get_type")

	core.PuregoSafeRegister(&xNewAlertDialog, libs, "adw_alert_dialog_new")

	core.PuregoSafeRegister(&xAlertDialogAddResponse, libs, "adw_alert_dialog_add_response")
	core.PuregoSafeRegister(&xAlertDialogAddResponses, libs, "adw_alert_dialog_add_responses")
	core.PuregoSafeRegister(&xAlertDialogChoose, libs, "adw_alert_dialog_choose")
	core.PuregoSafeRegister(&xAlertDialogChooseFinish, libs, "adw_alert_dialog_choose_finish")
	core.PuregoSafeRegister(&xAlertDialogFormatBody, libs, "adw_alert_dialog_format_body")
	core.PuregoSafeRegister(&xAlertDialogFormatBodyMarkup, libs, "adw_alert_dialog_format_body_markup")
	core.PuregoSafeRegister(&xAlertDialogFormatHeading, libs, "adw_alert_dialog_format_heading")
	core.PuregoSafeRegister(&xAlertDialogFormatHeadingMarkup, libs, "adw_alert_dialog_format_heading_markup")
	core.PuregoSafeRegister(&xAlertDialogGetBody, libs, "adw_alert_dialog_get_body")
	core.PuregoSafeRegister(&xAlertDialogGetBodyUseMarkup, libs, "adw_alert_dialog_get_body_use_markup")
	core.PuregoSafeRegister(&xAlertDialogGetCloseResponse, libs, "adw_alert_dialog_get_close_response")
	core.PuregoSafeRegister(&xAlertDialogGetDefaultResponse, libs, "adw_alert_dialog_get_default_response")
	core.PuregoSafeRegister(&xAlertDialogGetExtraChild, libs, "adw_alert_dialog_get_extra_child")
	core.PuregoSafeRegister(&xAlertDialogGetHeading, libs, "adw_alert_dialog_get_heading")
	core.PuregoSafeRegister(&xAlertDialogGetHeadingUseMarkup, libs, "adw_alert_dialog_get_heading_use_markup")
	core.PuregoSafeRegister(&xAlertDialogGetPreferWideLayout, libs, "adw_alert_dialog_get_prefer_wide_layout")
	core.PuregoSafeRegister(&xAlertDialogGetResponseAppearance, libs, "adw_alert_dialog_get_response_appearance")
	core.PuregoSafeRegister(&xAlertDialogGetResponseEnabled, libs, "adw_alert_dialog_get_response_enabled")
	core.PuregoSafeRegister(&xAlertDialogGetResponseLabel, libs, "adw_alert_dialog_get_response_label")
	core.PuregoSafeRegister(&xAlertDialogHasResponse, libs, "adw_alert_dialog_has_response")
	core.PuregoSafeRegister(&xAlertDialogRemoveResponse, libs, "adw_alert_dialog_remove_response")
	core.PuregoSafeRegister(&xAlertDialogSetBody, libs, "adw_alert_dialog_set_body")
	core.PuregoSafeRegister(&xAlertDialogSetBodyUseMarkup, libs, "adw_alert_dialog_set_body_use_markup")
	core.PuregoSafeRegister(&xAlertDialogSetCloseResponse, libs, "adw_alert_dialog_set_close_response")
	core.PuregoSafeRegister(&xAlertDialogSetDefaultResponse, libs, "adw_alert_dialog_set_default_response")
	core.PuregoSafeRegister(&xAlertDialogSetExtraChild, libs, "adw_alert_dialog_set_extra_child")
	core.PuregoSafeRegister(&xAlertDialogSetHeading, libs, "adw_alert_dialog_set_heading")
	core.PuregoSafeRegister(&xAlertDialogSetHeadingUseMarkup, libs, "adw_alert_dialog_set_heading_use_markup")
	core.PuregoSafeRegister(&xAlertDialogSetPreferWideLayout, libs, "adw_alert_dialog_set_prefer_wide_layout")
	core.PuregoSafeRegister(&xAlertDialogSetResponseAppearance, libs, "adw_alert_dialog_set_response_appearance")
	core.PuregoSafeRegister(&xAlertDialogSetResponseEnabled, libs, "adw_alert_dialog_set_response_enabled")
	core.PuregoSafeRegister(&xAlertDialogSetResponseLabel, libs, "adw_alert_dialog_set_response_label")

}
