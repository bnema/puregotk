// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type TimedAnimationClass struct {
	_ structs.HostLayout
}

func (x *TimedAnimationClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A time-based [class@Animation].
//
// `AdwTimedAnimation` implements a simple animation interpolating the given
// value from [property@TimedAnimation:value-from] to
// [property@TimedAnimation:value-to] over
// [property@TimedAnimation:duration] milliseconds using the curve described by
// [property@TimedAnimation:easing].
//
// If [property@TimedAnimation:reverse] is set to `TRUE`, `AdwTimedAnimation`
// will instead animate from [property@TimedAnimation:value-to] to
// [property@TimedAnimation:value-from], and the easing curve will be inverted.
//
// The animation can repeat a certain amount of times, or endlessly, depending
// on the [property@TimedAnimation:repeat-count] value. If
// [property@TimedAnimation:alternate] is set to `TRUE`, it will also change the
// direction every other iteration.
type TimedAnimation struct {
	Animation
}

var xTimedAnimationGLibType func() types.GType

func TimedAnimationGLibType() types.GType {
	return xTimedAnimationGLibType()
}

func TimedAnimationNewFromInternalPtr(ptr uintptr) *TimedAnimation {
	cls := &TimedAnimation{}
	cls.Ptr = ptr
	return cls
}

var xNewTimedAnimation func(uintptr, float64, float64, uint, uintptr) uintptr

// Creates a new `AdwTimedAnimation` on @widget to animate @target from @from
// to @to.
func NewTimedAnimation(WidgetVar *gtk.Widget, FromVar float64, ToVar float64, DurationVar uint, TargetVar *AnimationTarget) *TimedAnimation {
	var cls *TimedAnimation

	cret := xNewTimedAnimation(WidgetVar.GoPointer(), FromVar, ToVar, DurationVar, TargetVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TimedAnimation{}
	cls.Ptr = cret
	return cls
}

var xTimedAnimationGetAlternate func(uintptr) bool

// Gets whether @self changes direction on every iteration.
func (x *TimedAnimation) GetAlternate() bool {

	cret := xTimedAnimationGetAlternate(x.GoPointer())

	return cret
}

var xTimedAnimationGetDuration func(uintptr) uint

// Gets the duration of @self.
func (x *TimedAnimation) GetDuration() uint {

	cret := xTimedAnimationGetDuration(x.GoPointer())

	return cret
}

var xTimedAnimationGetEasing func(uintptr) Easing

// Gets the easing function @self uses.
func (x *TimedAnimation) GetEasing() Easing {

	cret := xTimedAnimationGetEasing(x.GoPointer())

	return cret
}

var xTimedAnimationGetRepeatCount func(uintptr) uint

// Gets the number of times @self will play.
func (x *TimedAnimation) GetRepeatCount() uint {

	cret := xTimedAnimationGetRepeatCount(x.GoPointer())

	return cret
}

var xTimedAnimationGetReverse func(uintptr) bool

// Gets whether @self plays backwards.
func (x *TimedAnimation) GetReverse() bool {

	cret := xTimedAnimationGetReverse(x.GoPointer())

	return cret
}

var xTimedAnimationGetValueFrom func(uintptr) float64

// Gets the value @self will animate from.
func (x *TimedAnimation) GetValueFrom() float64 {

	cret := xTimedAnimationGetValueFrom(x.GoPointer())

	return cret
}

var xTimedAnimationGetValueTo func(uintptr) float64

// Gets the value @self will animate to.
func (x *TimedAnimation) GetValueTo() float64 {

	cret := xTimedAnimationGetValueTo(x.GoPointer())

	return cret
}

var xTimedAnimationSetAlternate func(uintptr, bool)

// Sets whether @self changes direction on every iteration.
func (x *TimedAnimation) SetAlternate(AlternateVar bool) {

	xTimedAnimationSetAlternate(x.GoPointer(), AlternateVar)

}

var xTimedAnimationSetDuration func(uintptr, uint)

// Sets the duration of @self.
//
// If the animation repeats more than once, sets the duration of one iteration.
func (x *TimedAnimation) SetDuration(DurationVar uint) {

	xTimedAnimationSetDuration(x.GoPointer(), DurationVar)

}

var xTimedAnimationSetEasing func(uintptr, Easing)

// Sets the easing function @self will use.
//
// See [enum@Easing] for the description of specific easing functions.
func (x *TimedAnimation) SetEasing(EasingVar Easing) {

	xTimedAnimationSetEasing(x.GoPointer(), EasingVar)

}

var xTimedAnimationSetRepeatCount func(uintptr, uint)

// Sets the number of times @self will play.
//
// If set to 0, @self will repeat endlessly.
func (x *TimedAnimation) SetRepeatCount(RepeatCountVar uint) {

	xTimedAnimationSetRepeatCount(x.GoPointer(), RepeatCountVar)

}

var xTimedAnimationSetReverse func(uintptr, bool)

// Sets whether @self plays backwards.
func (x *TimedAnimation) SetReverse(ReverseVar bool) {

	xTimedAnimationSetReverse(x.GoPointer(), ReverseVar)

}

var xTimedAnimationSetValueFrom func(uintptr, float64)

// Sets the value @self will animate from.
//
// The animation will start at this value and end at
// [property@TimedAnimation:value-to].
//
// If [property@TimedAnimation:reverse] is `TRUE`, the animation will end at
// this value instead.
func (x *TimedAnimation) SetValueFrom(ValueVar float64) {

	xTimedAnimationSetValueFrom(x.GoPointer(), ValueVar)

}

var xTimedAnimationSetValueTo func(uintptr, float64)

// Sets the value @self will animate to.
//
// The animation will start at [property@TimedAnimation:value-from] and end at
// this value.
//
// If [property@TimedAnimation:reverse] is `TRUE`, the animation will start
// at this value instead.
func (x *TimedAnimation) SetValueTo(ValueVar float64) {

	xTimedAnimationSetValueTo(x.GoPointer(), ValueVar)

}

func (c *TimedAnimation) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *TimedAnimation) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAlternate sets the "alternate" property.
// Whether the animation changes direction on every iteration.
func (x *TimedAnimation) SetPropertyAlternate(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("alternate", &v)
}

// GetPropertyAlternate gets the "alternate" property.
// Whether the animation changes direction on every iteration.
func (x *TimedAnimation) GetPropertyAlternate() bool {
	var v gobject.Value
	x.GetProperty("alternate", &v)
	return v.GetBoolean()
}

// SetPropertyDuration sets the "duration" property.
// Duration of the animation, in milliseconds.
//
// Describes how much time the animation will take.
//
// If the animation repeats more than once, describes the duration of one
// iteration.
func (x *TimedAnimation) SetPropertyDuration(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("duration", &v)
}

// GetPropertyDuration gets the "duration" property.
// Duration of the animation, in milliseconds.
//
// Describes how much time the animation will take.
//
// If the animation repeats more than once, describes the duration of one
// iteration.
func (x *TimedAnimation) GetPropertyDuration() uint {
	var v gobject.Value
	x.GetProperty("duration", &v)
	return v.GetUint()
}

// SetPropertyRepeatCount sets the "repeat-count" property.
// Number of times the animation will play.
//
// If set to 0, the animation will repeat endlessly.
func (x *TimedAnimation) SetPropertyRepeatCount(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("repeat-count", &v)
}

// GetPropertyRepeatCount gets the "repeat-count" property.
// Number of times the animation will play.
//
// If set to 0, the animation will repeat endlessly.
func (x *TimedAnimation) GetPropertyRepeatCount() uint {
	var v gobject.Value
	x.GetProperty("repeat-count", &v)
	return v.GetUint()
}

// SetPropertyReverse sets the "reverse" property.
// Whether the animation plays backwards.
func (x *TimedAnimation) SetPropertyReverse(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("reverse", &v)
}

// GetPropertyReverse gets the "reverse" property.
// Whether the animation plays backwards.
func (x *TimedAnimation) GetPropertyReverse() bool {
	var v gobject.Value
	x.GetProperty("reverse", &v)
	return v.GetBoolean()
}

// SetPropertyValueFrom sets the "value-from" property.
// The value to animate from.
//
// The animation will start at this value and end at
// [property@TimedAnimation:value-to].
//
// If [property@TimedAnimation:reverse] is `TRUE`, the animation will end at
// this value instead.
func (x *TimedAnimation) SetPropertyValueFrom(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("value-from", &v)
}

// GetPropertyValueFrom gets the "value-from" property.
// The value to animate from.
//
// The animation will start at this value and end at
// [property@TimedAnimation:value-to].
//
// If [property@TimedAnimation:reverse] is `TRUE`, the animation will end at
// this value instead.
func (x *TimedAnimation) GetPropertyValueFrom() float64 {
	var v gobject.Value
	x.GetProperty("value-from", &v)
	return v.GetDouble()
}

// SetPropertyValueTo sets the "value-to" property.
// The value to animate to.
//
// The animation will start at [property@TimedAnimation:value-from] and end at
// this value.
//
// If [property@TimedAnimation:reverse] is `TRUE`, the animation will start
// at this value instead.
func (x *TimedAnimation) SetPropertyValueTo(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("value-to", &v)
}

// GetPropertyValueTo gets the "value-to" property.
// The value to animate to.
//
// The animation will start at [property@TimedAnimation:value-from] and end at
// this value.
//
// If [property@TimedAnimation:reverse] is `TRUE`, the animation will start
// at this value instead.
func (x *TimedAnimation) GetPropertyValueTo() float64 {
	var v gobject.Value
	x.GetProperty("value-to", &v)
	return v.GetDouble()
}

func init() {
	core.SetPackageName("ADW", "libadwaita-1")
	core.SetSharedLibraries("ADW", []string{"libadwaita-1.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("ADW") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTimedAnimationGLibType, libs, "adw_timed_animation_get_type")

	core.PuregoSafeRegister(&xNewTimedAnimation, libs, "adw_timed_animation_new")

	core.PuregoSafeRegister(&xTimedAnimationGetAlternate, libs, "adw_timed_animation_get_alternate")
	core.PuregoSafeRegister(&xTimedAnimationGetDuration, libs, "adw_timed_animation_get_duration")
	core.PuregoSafeRegister(&xTimedAnimationGetEasing, libs, "adw_timed_animation_get_easing")
	core.PuregoSafeRegister(&xTimedAnimationGetRepeatCount, libs, "adw_timed_animation_get_repeat_count")
	core.PuregoSafeRegister(&xTimedAnimationGetReverse, libs, "adw_timed_animation_get_reverse")
	core.PuregoSafeRegister(&xTimedAnimationGetValueFrom, libs, "adw_timed_animation_get_value_from")
	core.PuregoSafeRegister(&xTimedAnimationGetValueTo, libs, "adw_timed_animation_get_value_to")
	core.PuregoSafeRegister(&xTimedAnimationSetAlternate, libs, "adw_timed_animation_set_alternate")
	core.PuregoSafeRegister(&xTimedAnimationSetDuration, libs, "adw_timed_animation_set_duration")
	core.PuregoSafeRegister(&xTimedAnimationSetEasing, libs, "adw_timed_animation_set_easing")
	core.PuregoSafeRegister(&xTimedAnimationSetRepeatCount, libs, "adw_timed_animation_set_repeat_count")
	core.PuregoSafeRegister(&xTimedAnimationSetReverse, libs, "adw_timed_animation_set_reverse")
	core.PuregoSafeRegister(&xTimedAnimationSetValueFrom, libs, "adw_timed_animation_set_value_from")
	core.PuregoSafeRegister(&xTimedAnimationSetValueTo, libs, "adw_timed_animation_set_value_to")

}
