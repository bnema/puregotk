// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type FlapClass struct {
	_ structs.HostLayout

	ParentClass gtk.WidgetClass
}

func (x *FlapClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Describes the possible folding behavior of a [class@Flap] widget.
type FlapFoldPolicy int

var xFlapFoldPolicyGLibType func() types.GType

func FlapFoldPolicyGLibType() types.GType {
	return xFlapFoldPolicyGLibType()
}

const (

	// Disable folding, the flap cannot reach narrow
	//   sizes.
	FlapFoldPolicyNeverValue FlapFoldPolicy = 0
	// Keep the flap always folded.
	FlapFoldPolicyAlwaysValue FlapFoldPolicy = 1
	// Fold and unfold the flap based on available
	//   space.
	FlapFoldPolicyAutoValue FlapFoldPolicy = 2
)

// Describes transitions types of a [class@Flap] widget.
//
// It determines the type of animation when transitioning between children in a
// [class@Flap] widget, as well as which areas can be swiped via
// [property@Flap:swipe-to-open] and [property@Flap:swipe-to-close].
type FlapTransitionType int

var xFlapTransitionTypeGLibType func() types.GType

func FlapTransitionTypeGLibType() types.GType {
	return xFlapTransitionTypeGLibType()
}

const (

	// The flap slides over the content, which is
	//   dimmed. When folded, only the flap can be swiped.
	FlapTransitionTypeOverValue FlapTransitionType = 0
	// The content slides over the flap. Only the
	//   content can be swiped.
	FlapTransitionTypeUnderValue FlapTransitionType = 1
	// The flap slides offscreen when hidden,
	//   neither the flap nor content overlap each other. Both widgets can be
	//   swiped.
	FlapTransitionTypeSlideValue FlapTransitionType = 2
)

// An adaptive container acting like a box or an overlay.
//
// &lt;picture&gt;
//
//	&lt;source srcset="flap-wide-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="flap-wide.png" alt="flap-wide"&gt;
//
// &lt;/picture&gt;
// &lt;picture&gt;
//
//	&lt;source srcset="flap-narrow-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="flap-narrow.png" alt="flap-narrow"&gt;
//
// &lt;/picture&gt;
//
// The `AdwFlap` widget can display its children like a [class@Gtk.Box] does or
// like a [class@Gtk.Overlay] does, according to the
// [property@Flap:fold-policy] value.
//
// `AdwFlap` has at most three children: [property@Flap:content],
// [property@Flap:flap] and [property@Flap:separator]. Content is the primary
// child, flap is displayed next to it when unfolded, or overlays it when
// folded. Flap can be shown or hidden by changing the
// [property@Flap:reveal-flap] value, as well as via swipe gestures if
// [property@Flap:swipe-to-open] and/or [property@Flap:swipe-to-close] are set
// to `TRUE`.
//
// Optionally, a separator can be provided, which would be displayed between
// the content and the flap when there's no shadow to separate them, depending
// on the transition type.
//
// [property@Flap:flap] is transparent by default; add the
// [`.background`](style-classes.html#background) style class to it if this is
// unwanted.
//
// If [property@Flap:modal] is set to `TRUE`, content becomes completely
// inaccessible when the flap is revealed while folded.
//
// The position of the flap and separator children relative to the content is
// determined by orientation, as well as the [property@Flap:flap-position]
// value.
//
// Folding the flap will automatically hide the flap widget, and unfolding it
// will automatically reveal it. If this behavior is not desired, the
// [property@Flap:locked] property can be used to override it.
//
// Common use cases include sidebars, header bars that need to be able to
// overlap the window content (for example, in fullscreen mode) and bottom
// sheets.
//
// ## AdwFlap as GtkBuildable
//
// The `AdwFlap` implementation of the [iface@Gtk.Buildable] interface supports
// setting the flap child by specifying “flap” as the “type” attribute of a
// `&lt;child&gt;` element, and separator by specifying “separator”. Specifying
// “content” child type or omitting it results in setting the content child.
//
// ## CSS nodes
//
// `AdwFlap` has a single CSS node with name `flap`. The node will get the style
// classes `.folded` when it is folded, and `.unfolded` when it's not.
type Flap struct {
	gtk.Widget
}

var xFlapGLibType func() types.GType

func FlapGLibType() types.GType {
	return xFlapGLibType()
}

func FlapNewFromInternalPtr(ptr uintptr) *Flap {
	cls := &Flap{}
	cls.Ptr = ptr
	return cls
}

var xNewFlap func() uintptr

// Creates a new `AdwFlap`.
func NewFlap() *Flap {
	var cls *Flap

	cret := xNewFlap()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Flap{}
	cls.Ptr = cret
	return cls
}

var xFlapGetContent func(uintptr) uintptr

// Gets the content widget for @self.
func (x *Flap) GetContent() *gtk.Widget {
	var cls *gtk.Widget

	cret := xFlapGetContent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xFlapGetFlap func(uintptr) uintptr

// Gets the flap widget for @self.
func (x *Flap) GetFlap() *gtk.Widget {
	var cls *gtk.Widget

	cret := xFlapGetFlap(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xFlapGetFlapPosition func(uintptr) gtk.PackType

// Gets the flap position for @self.
func (x *Flap) GetFlapPosition() gtk.PackType {

	cret := xFlapGetFlapPosition(x.GoPointer())
	return cret
}

var xFlapGetFoldDuration func(uintptr) uint

// Gets the fold transition animation duration for @self, in milliseconds.
func (x *Flap) GetFoldDuration() uint {

	cret := xFlapGetFoldDuration(x.GoPointer())
	return cret
}

var xFlapGetFoldPolicy func(uintptr) FlapFoldPolicy

// Gets the fold policy for @self.
func (x *Flap) GetFoldPolicy() FlapFoldPolicy {

	cret := xFlapGetFoldPolicy(x.GoPointer())
	return cret
}

var xFlapGetFoldThresholdPolicy func(uintptr) FoldThresholdPolicy

// Gets the fold threshold policy for @self.
func (x *Flap) GetFoldThresholdPolicy() FoldThresholdPolicy {

	cret := xFlapGetFoldThresholdPolicy(x.GoPointer())
	return cret
}

var xFlapGetFolded func(uintptr) bool

// Gets whether @self is currently folded.
//
// See [property@Flap:fold-policy].
func (x *Flap) GetFolded() bool {

	cret := xFlapGetFolded(x.GoPointer())
	return cret
}

var xFlapGetLocked func(uintptr) bool

// Gets whether @self is locked.
func (x *Flap) GetLocked() bool {

	cret := xFlapGetLocked(x.GoPointer())
	return cret
}

var xFlapGetModal func(uintptr) bool

// Gets whether @self is modal.
func (x *Flap) GetModal() bool {

	cret := xFlapGetModal(x.GoPointer())
	return cret
}

var xFlapGetRevealFlap func(uintptr) bool

// Gets whether the flap widget is revealed for @self.
func (x *Flap) GetRevealFlap() bool {

	cret := xFlapGetRevealFlap(x.GoPointer())
	return cret
}

var xFlapGetRevealParams func(uintptr) *SpringParams

// Gets the reveal animation spring parameters for @self.
func (x *Flap) GetRevealParams() *SpringParams {

	cret := xFlapGetRevealParams(x.GoPointer())
	return cret
}

var xFlapGetRevealProgress func(uintptr) float64

// Gets the current reveal progress for @self.
//
// 0 means fully hidden, 1 means fully revealed.
//
// See [property@Flap:reveal-flap].
func (x *Flap) GetRevealProgress() float64 {

	cret := xFlapGetRevealProgress(x.GoPointer())
	return cret
}

var xFlapGetSeparator func(uintptr) uintptr

// Gets the separator widget for @self.
func (x *Flap) GetSeparator() *gtk.Widget {
	var cls *gtk.Widget

	cret := xFlapGetSeparator(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xFlapGetSwipeToClose func(uintptr) bool

// Gets whether @self can be closed with a swipe gesture.
func (x *Flap) GetSwipeToClose() bool {

	cret := xFlapGetSwipeToClose(x.GoPointer())
	return cret
}

var xFlapGetSwipeToOpen func(uintptr) bool

// Gets whether @self can be opened with a swipe gesture.
func (x *Flap) GetSwipeToOpen() bool {

	cret := xFlapGetSwipeToOpen(x.GoPointer())
	return cret
}

var xFlapGetTransitionType func(uintptr) FlapTransitionType

// Gets the type of animation used for reveal and fold transitions in @self.
func (x *Flap) GetTransitionType() FlapTransitionType {

	cret := xFlapGetTransitionType(x.GoPointer())
	return cret
}

var xFlapSetContent func(uintptr, uintptr)

// Sets the content widget for @self.
//
// It's always displayed when unfolded, and partially visible when folded.
func (x *Flap) SetContent(ContentVar *gtk.Widget) {

	xFlapSetContent(x.GoPointer(), ContentVar.GoPointer())

}

var xFlapSetFlap func(uintptr, uintptr)

// Sets the flap widget for @self.
//
// It's only visible when [property@Flap:reveal-progress] is greater than 0.
func (x *Flap) SetFlap(FlapVar *gtk.Widget) {

	xFlapSetFlap(x.GoPointer(), FlapVar.GoPointer())

}

var xFlapSetFlapPosition func(uintptr, gtk.PackType)

// Sets the flap position for @self.
//
// If it's set to `GTK_PACK_START`, the flap is displayed before the content,
// if `GTK_PACK_END`, it's displayed after the content.
func (x *Flap) SetFlapPosition(PositionVar gtk.PackType) {

	xFlapSetFlapPosition(x.GoPointer(), PositionVar)

}

var xFlapSetFoldDuration func(uintptr, uint)

// Sets the fold transition animation duration for @self, in milliseconds.
func (x *Flap) SetFoldDuration(DurationVar uint) {

	xFlapSetFoldDuration(x.GoPointer(), DurationVar)

}

var xFlapSetFoldPolicy func(uintptr, FlapFoldPolicy)

// Sets the fold policy for @self.
func (x *Flap) SetFoldPolicy(PolicyVar FlapFoldPolicy) {

	xFlapSetFoldPolicy(x.GoPointer(), PolicyVar)

}

var xFlapSetFoldThresholdPolicy func(uintptr, FoldThresholdPolicy)

// Sets the fold threshold policy for @self.
//
// If set to `ADW_FOLD_THRESHOLD_POLICY_MINIMUM`, flap will only fold when the
// children cannot fit anymore. With `ADW_FOLD_THRESHOLD_POLICY_NATURAL`, it
// will fold as soon as children don't get their natural size.
//
// This can be useful if you have a long ellipsizing label and want to let it
// ellipsize instead of immediately folding.
func (x *Flap) SetFoldThresholdPolicy(PolicyVar FoldThresholdPolicy) {

	xFlapSetFoldThresholdPolicy(x.GoPointer(), PolicyVar)

}

var xFlapSetLocked func(uintptr, bool)

// Sets whether @self is locked.
//
// If `FALSE`, folding when the flap is revealed automatically closes it, and
// unfolding it when the flap is not revealed opens it. If `TRUE`,
// [property@Flap:reveal-flap] value never changes on its own.
func (x *Flap) SetLocked(LockedVar bool) {

	xFlapSetLocked(x.GoPointer(), LockedVar)

}

var xFlapSetModal func(uintptr, bool)

// Sets whether @self is modal.
//
// If `TRUE`, clicking the content widget while flap is revealed, as well as
// pressing the &lt;kbd&gt;Esc&lt;/kbd&gt; key, will close the flap. If `FALSE`, clicks are
// passed through to the content widget.
func (x *Flap) SetModal(ModalVar bool) {

	xFlapSetModal(x.GoPointer(), ModalVar)

}

var xFlapSetRevealFlap func(uintptr, bool)

// Sets whether the flap widget is revealed for @self.
func (x *Flap) SetRevealFlap(RevealFlapVar bool) {

	xFlapSetRevealFlap(x.GoPointer(), RevealFlapVar)

}

var xFlapSetRevealParams func(uintptr, *SpringParams)

// Sets the reveal animation spring parameters for @self.
//
// The default value is equivalent to:
//
// ```c
// adw_spring_params_new (1, 0.5, 500)
// ```
func (x *Flap) SetRevealParams(ParamsVar *SpringParams) {

	xFlapSetRevealParams(x.GoPointer(), ParamsVar)

}

var xFlapSetSeparator func(uintptr, uintptr)

// Sets the separator widget for @self.
//
// It's displayed between content and flap when there's no shadow to display.
// When exactly it's visible depends on the [property@Flap:transition-type]
// value.
func (x *Flap) SetSeparator(SeparatorVar *gtk.Widget) {

	xFlapSetSeparator(x.GoPointer(), SeparatorVar.GoPointer())

}

var xFlapSetSwipeToClose func(uintptr, bool)

// Sets whether @self can be closed with a swipe gesture.
//
// The area that can be swiped depends on the [property@Flap:transition-type]
// value.
func (x *Flap) SetSwipeToClose(SwipeToCloseVar bool) {

	xFlapSetSwipeToClose(x.GoPointer(), SwipeToCloseVar)

}

var xFlapSetSwipeToOpen func(uintptr, bool)

// Sets whether @self can be opened with a swipe gesture.
//
// The area that can be swiped depends on the [property@Flap:transition-type]
// value.
func (x *Flap) SetSwipeToOpen(SwipeToOpenVar bool) {

	xFlapSetSwipeToOpen(x.GoPointer(), SwipeToOpenVar)

}

var xFlapSetTransitionType func(uintptr, FlapTransitionType)

// Sets the type of animation used for reveal and fold transitions in @self.
//
// [property@Flap:flap] is transparent by default, which means the content will
// be seen through it with `ADW_FLAP_TRANSITION_TYPE_OVER` transitions; add the
// [`.background`](style-classes.html#background) style class to it if this is
// unwanted.
func (x *Flap) SetTransitionType(TransitionTypeVar FlapTransitionType) {

	xFlapSetTransitionType(x.GoPointer(), TransitionTypeVar)

}

func (c *Flap) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Flap) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyFoldDuration sets the "fold-duration" property.
// The fold transition animation duration, in milliseconds.
func (x *Flap) SetPropertyFoldDuration(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("fold-duration", &v)
}

// GetPropertyFoldDuration gets the "fold-duration" property.
// The fold transition animation duration, in milliseconds.
func (x *Flap) GetPropertyFoldDuration() uint {
	var v gobject.Value
	x.GetProperty("fold-duration", &v)
	return v.GetUint()
}

// GetPropertyFolded gets the "folded" property.
// Whether the flap is currently folded.
//
// See [property@Flap:fold-policy].
func (x *Flap) GetPropertyFolded() bool {
	var v gobject.Value
	x.GetProperty("folded", &v)
	return v.GetBoolean()
}

// SetPropertyLocked sets the "locked" property.
// Whether the flap is locked.
//
// If `FALSE`, folding when the flap is revealed automatically closes it, and
// unfolding it when the flap is not revealed opens it. If `TRUE`,
// [property@Flap:reveal-flap] value never changes on its own.
func (x *Flap) SetPropertyLocked(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("locked", &v)
}

// GetPropertyLocked gets the "locked" property.
// Whether the flap is locked.
//
// If `FALSE`, folding when the flap is revealed automatically closes it, and
// unfolding it when the flap is not revealed opens it. If `TRUE`,
// [property@Flap:reveal-flap] value never changes on its own.
func (x *Flap) GetPropertyLocked() bool {
	var v gobject.Value
	x.GetProperty("locked", &v)
	return v.GetBoolean()
}

// SetPropertyModal sets the "modal" property.
// Whether the flap is modal.
//
// If `TRUE`, clicking the content widget while flap is revealed, as well as
// pressing the &lt;kbd&gt;Esc&lt;/kbd&gt; key, will close the flap. If `FALSE`, clicks
// are passed through to the content widget.
func (x *Flap) SetPropertyModal(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("modal", &v)
}

// GetPropertyModal gets the "modal" property.
// Whether the flap is modal.
//
// If `TRUE`, clicking the content widget while flap is revealed, as well as
// pressing the &lt;kbd&gt;Esc&lt;/kbd&gt; key, will close the flap. If `FALSE`, clicks
// are passed through to the content widget.
func (x *Flap) GetPropertyModal() bool {
	var v gobject.Value
	x.GetProperty("modal", &v)
	return v.GetBoolean()
}

// SetPropertyRevealFlap sets the "reveal-flap" property.
// Whether the flap widget is revealed.
func (x *Flap) SetPropertyRevealFlap(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("reveal-flap", &v)
}

// GetPropertyRevealFlap gets the "reveal-flap" property.
// Whether the flap widget is revealed.
func (x *Flap) GetPropertyRevealFlap() bool {
	var v gobject.Value
	x.GetProperty("reveal-flap", &v)
	return v.GetBoolean()
}

// SetPropertyRevealParams sets the "reveal-params" property.
// The reveal animation spring parameters.
//
// The default value is equivalent to:
//
// ```c
// adw_spring_params_new (1, 0.5, 500)
// ```
func (x *Flap) SetPropertyRevealParams(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("reveal-params", &v)
}

// GetPropertyRevealParams gets the "reveal-params" property.
// The reveal animation spring parameters.
//
// The default value is equivalent to:
//
// ```c
// adw_spring_params_new (1, 0.5, 500)
// ```
func (x *Flap) GetPropertyRevealParams() uintptr {
	var v gobject.Value
	x.GetProperty("reveal-params", &v)
	return v.GetPointer()
}

// GetPropertyRevealProgress gets the "reveal-progress" property.
// The current reveal transition progress.
//
// 0 means fully hidden, 1 means fully revealed.
//
// See [property@Flap:reveal-flap].
func (x *Flap) GetPropertyRevealProgress() float64 {
	var v gobject.Value
	x.GetProperty("reveal-progress", &v)
	return v.GetDouble()
}

// SetPropertySwipeToClose sets the "swipe-to-close" property.
// Whether the flap can be closed with a swipe gesture.
//
// The area that can be swiped depends on the [property@Flap:transition-type]
// value.
func (x *Flap) SetPropertySwipeToClose(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("swipe-to-close", &v)
}

// GetPropertySwipeToClose gets the "swipe-to-close" property.
// Whether the flap can be closed with a swipe gesture.
//
// The area that can be swiped depends on the [property@Flap:transition-type]
// value.
func (x *Flap) GetPropertySwipeToClose() bool {
	var v gobject.Value
	x.GetProperty("swipe-to-close", &v)
	return v.GetBoolean()
}

// SetPropertySwipeToOpen sets the "swipe-to-open" property.
// Whether the flap can be opened with a swipe gesture.
//
// The area that can be swiped depends on the [property@Flap:transition-type]
// value.
func (x *Flap) SetPropertySwipeToOpen(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("swipe-to-open", &v)
}

// GetPropertySwipeToOpen gets the "swipe-to-open" property.
// Whether the flap can be opened with a swipe gesture.
//
// The area that can be swiped depends on the [property@Flap:transition-type]
// value.
func (x *Flap) GetPropertySwipeToOpen() bool {
	var v gobject.Value
	x.GetProperty("swipe-to-open", &v)
	return v.GetBoolean()
}

// Gets the progress @self will snap back to after the gesture is canceled.
func (x *Flap) GetCancelProgress() float64 {

	cret := XAdwSwipeableGetCancelProgress(x.GoPointer())
	return cret
}

// Gets the swipe distance of @self.
//
// This corresponds to how many pixels 1 unit represents.
func (x *Flap) GetDistance() float64 {

	cret := XAdwSwipeableGetDistance(x.GoPointer())
	return cret
}

// Gets the current progress of @self.
func (x *Flap) GetProgress() float64 {

	cret := XAdwSwipeableGetProgress(x.GoPointer())
	return cret
}

// Gets the snap points of @self.
//
// Each snap point represents a progress value that is considered acceptable to
// end the swipe on.
func (x *Flap) GetSnapPoints(NSnapPointsVar *int) uintptr {

	cret := XAdwSwipeableGetSnapPoints(x.GoPointer(), NSnapPointsVar)
	return cret
}

// Gets the area @self can start a swipe from for the given direction and
// gesture type.
//
// This can be used to restrict swipes to only be possible from a certain area,
// for example, to only allow edge swipes, or to have a draggable element and
// ignore swipes elsewhere.
//
// If not implemented, the default implementation returns the allocation of
// @self, allowing swipes from anywhere.
func (x *Flap) GetSwipeArea(NavigationDirectionVar NavigationDirection, IsDragVar bool, RectVar *gdk.Rectangle) {

	XAdwSwipeableGetSwipeArea(x.GoPointer(), NavigationDirectionVar, IsDragVar, RectVar)

}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *Flap) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *Flap) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *Flap) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *Flap) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *Flap) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *Flap) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *Flap) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *Flap) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *Flap) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *Flap) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *Flap) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *Flap) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *Flap) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *Flap) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Flap) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Flap) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Flap) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Flap) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Flap) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Flap) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *Flap) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Retrieves the orientation of the @orientable.
func (x *Flap) GetOrientation() gtk.Orientation {

	cret := gtk.XGtkOrientableGetOrientation(x.GoPointer())
	return cret
}

// Sets the orientation of the @orientable.
func (x *Flap) SetOrientation(OrientationVar gtk.Orientation) {

	gtk.XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)

}

func init() {
	core.SetPackageName("ADW", "libadwaita-1")
	core.SetSharedLibraries("ADW", []string{"libadwaita-1.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("ADW") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xFlapFoldPolicyGLibType, libs, "adw_flap_fold_policy_get_type")

	core.PuregoSafeRegister(&xFlapTransitionTypeGLibType, libs, "adw_flap_transition_type_get_type")

	core.PuregoSafeRegister(&xFlapGLibType, libs, "adw_flap_get_type")

	core.PuregoSafeRegister(&xNewFlap, libs, "adw_flap_new")

	core.PuregoSafeRegister(&xFlapGetContent, libs, "adw_flap_get_content")
	core.PuregoSafeRegister(&xFlapGetFlap, libs, "adw_flap_get_flap")
	core.PuregoSafeRegister(&xFlapGetFlapPosition, libs, "adw_flap_get_flap_position")
	core.PuregoSafeRegister(&xFlapGetFoldDuration, libs, "adw_flap_get_fold_duration")
	core.PuregoSafeRegister(&xFlapGetFoldPolicy, libs, "adw_flap_get_fold_policy")
	core.PuregoSafeRegister(&xFlapGetFoldThresholdPolicy, libs, "adw_flap_get_fold_threshold_policy")
	core.PuregoSafeRegister(&xFlapGetFolded, libs, "adw_flap_get_folded")
	core.PuregoSafeRegister(&xFlapGetLocked, libs, "adw_flap_get_locked")
	core.PuregoSafeRegister(&xFlapGetModal, libs, "adw_flap_get_modal")
	core.PuregoSafeRegister(&xFlapGetRevealFlap, libs, "adw_flap_get_reveal_flap")
	core.PuregoSafeRegister(&xFlapGetRevealParams, libs, "adw_flap_get_reveal_params")
	core.PuregoSafeRegister(&xFlapGetRevealProgress, libs, "adw_flap_get_reveal_progress")
	core.PuregoSafeRegister(&xFlapGetSeparator, libs, "adw_flap_get_separator")
	core.PuregoSafeRegister(&xFlapGetSwipeToClose, libs, "adw_flap_get_swipe_to_close")
	core.PuregoSafeRegister(&xFlapGetSwipeToOpen, libs, "adw_flap_get_swipe_to_open")
	core.PuregoSafeRegister(&xFlapGetTransitionType, libs, "adw_flap_get_transition_type")
	core.PuregoSafeRegister(&xFlapSetContent, libs, "adw_flap_set_content")
	core.PuregoSafeRegister(&xFlapSetFlap, libs, "adw_flap_set_flap")
	core.PuregoSafeRegister(&xFlapSetFlapPosition, libs, "adw_flap_set_flap_position")
	core.PuregoSafeRegister(&xFlapSetFoldDuration, libs, "adw_flap_set_fold_duration")
	core.PuregoSafeRegister(&xFlapSetFoldPolicy, libs, "adw_flap_set_fold_policy")
	core.PuregoSafeRegister(&xFlapSetFoldThresholdPolicy, libs, "adw_flap_set_fold_threshold_policy")
	core.PuregoSafeRegister(&xFlapSetLocked, libs, "adw_flap_set_locked")
	core.PuregoSafeRegister(&xFlapSetModal, libs, "adw_flap_set_modal")
	core.PuregoSafeRegister(&xFlapSetRevealFlap, libs, "adw_flap_set_reveal_flap")
	core.PuregoSafeRegister(&xFlapSetRevealParams, libs, "adw_flap_set_reveal_params")
	core.PuregoSafeRegister(&xFlapSetSeparator, libs, "adw_flap_set_separator")
	core.PuregoSafeRegister(&xFlapSetSwipeToClose, libs, "adw_flap_set_swipe_to_close")
	core.PuregoSafeRegister(&xFlapSetSwipeToOpen, libs, "adw_flap_set_swipe_to_open")
	core.PuregoSafeRegister(&xFlapSetTransitionType, libs, "adw_flap_set_transition_type")

}
