// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type WrapBoxClass struct {
	_ structs.HostLayout

	ParentClass gtk.WidgetClass
}

func (x *WrapBoxClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A box-like widget that can wrap into multiple lines.
//
// &lt;picture&gt;
//
//	&lt;source srcset="wrap-box-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="wrap-box.png" alt="wrap-box"&gt;
//
// &lt;/picture&gt;
//
// `AdwWrapBox` is similar to [class@Gtk.Box], but can wrap lines when the
// widgets cannot fit otherwise. Unlike [class@Gtk.FlowBox], the children aren't
// arranged into a grid and behave more like words in a wrapping label.
//
// Like `GtkBox`, `AdwWrapBox` is orientable and has spacing:
//
// - [property@WrapBox:child-spacing] between children in the same line;
// - [property@WrapBox:line-spacing] between lines.
//
// ::: note
//
//	Unlike `GtkBox`, `AdwWrapBox` cannot follow the CSS `border-spacing`
//	property.
//
// Use the [property@WrapBox:natural-line-length] property to determine the
// layout's natural size, e.g. when using it in a [class@Gtk.Popover].
//
// Normally, a horizontal `AdwWrapBox` wraps left to right and top to bottom
// for left-to-right languages. Both of these directions can be reversed, using
// the [property@WrapBox:pack-direction] and [property@WrapBox:wrap-reverse]
// properties. Additionally, the alignment of each line can be controlled with
// the [property@WrapBox:align] property.
//
// Lines can be justified using the [property@WrapBox:justify] property, filling
// the entire line by either increasing child size or spacing depending on the
// value. Set [property@WrapBox:justify-last-line] to justify the last line as
// well.
//
// By default, `AdwWrapBox` wraps as soon as the previous line cannot fit any
// more children without shrinking them past their natural size. Set
// [property@WrapBox:wrap-policy] to [enum@Adw.WrapPolicy.MINIMUM] to only wrap
// once all the children in the previous line have been shrunk to their minimum
// size.
//
// To make each line take the same amount of space, set
// [property@WrapBox:line-homogeneous] to `TRUE`.
//
// Spacing and natural line length can scale with the text scale factor, use the
// [property@WrapBox:child-spacing-unit], [property@WrapBox:line-spacing-unit]
// and/or [property@WrapBox:natural-line-length-unit] properties to enable that
// behavior.
//
// See [class@WrapLayout].
//
// ## CSS nodes
//
// `AdwWrapBox` uses a single CSS node with name `wrap-box`.
//
// ## Accessibility
//
// `AdwWrapBox` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
type WrapBox struct {
	gtk.Widget
}

var xWrapBoxGLibType func() types.GType

func WrapBoxGLibType() types.GType {
	return xWrapBoxGLibType()
}

func WrapBoxNewFromInternalPtr(ptr uintptr) *WrapBox {
	cls := &WrapBox{}
	cls.Ptr = ptr
	return cls
}

var xNewWrapBox func() uintptr

// Creates a new `AdwWrapBox`.
func NewWrapBox() *WrapBox {
	var cls *WrapBox

	cret := xNewWrapBox()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WrapBox{}
	cls.Ptr = cret
	return cls
}

var xWrapBoxAppend func(uintptr, uintptr)

// Adds @child as the last child to @self.
func (x *WrapBox) Append(ChildVar *gtk.Widget) {

	xWrapBoxAppend(x.GoPointer(), ChildVar.GoPointer())

}

var xWrapBoxGetAlign func(uintptr) float32

// Gets the alignment of the children within each line.
func (x *WrapBox) GetAlign() float32 {

	cret := xWrapBoxGetAlign(x.GoPointer())
	return cret
}

var xWrapBoxGetChildSpacing func(uintptr) int

// Gets spacing between widgets on the same line.
func (x *WrapBox) GetChildSpacing() int {

	cret := xWrapBoxGetChildSpacing(x.GoPointer())
	return cret
}

var xWrapBoxGetChildSpacingUnit func(uintptr) LengthUnit

// Gets the length unit for child spacing.
func (x *WrapBox) GetChildSpacingUnit() LengthUnit {

	cret := xWrapBoxGetChildSpacingUnit(x.GoPointer())
	return cret
}

var xWrapBoxGetJustify func(uintptr) JustifyMode

// Gets whether and how each complete line is stretched to fill the entire widget.
func (x *WrapBox) GetJustify() JustifyMode {

	cret := xWrapBoxGetJustify(x.GoPointer())
	return cret
}

var xWrapBoxGetJustifyLastLine func(uintptr) bool

// Gets whether the last line should be stretched to fill the entire widget.
func (x *WrapBox) GetJustifyLastLine() bool {

	cret := xWrapBoxGetJustifyLastLine(x.GoPointer())
	return cret
}

var xWrapBoxGetLineHomogeneous func(uintptr) bool

// Gets whether all lines should take the same amount of space.
func (x *WrapBox) GetLineHomogeneous() bool {

	cret := xWrapBoxGetLineHomogeneous(x.GoPointer())
	return cret
}

var xWrapBoxGetLineSpacing func(uintptr) int

// Gets the spacing between lines.
//
// See [property@WrapBox:line-spacing-unit].
func (x *WrapBox) GetLineSpacing() int {

	cret := xWrapBoxGetLineSpacing(x.GoPointer())
	return cret
}

var xWrapBoxGetLineSpacingUnit func(uintptr) LengthUnit

// Gets the length unit for line spacing.
func (x *WrapBox) GetLineSpacingUnit() LengthUnit {

	cret := xWrapBoxGetLineSpacingUnit(x.GoPointer())
	return cret
}

var xWrapBoxGetNaturalLineLength func(uintptr) int

// Gets the natural size for each line.
func (x *WrapBox) GetNaturalLineLength() int {

	cret := xWrapBoxGetNaturalLineLength(x.GoPointer())
	return cret
}

var xWrapBoxGetNaturalLineLengthUnit func(uintptr) LengthUnit

// Gets the length unit for line spacing.
func (x *WrapBox) GetNaturalLineLengthUnit() LengthUnit {

	cret := xWrapBoxGetNaturalLineLengthUnit(x.GoPointer())
	return cret
}

var xWrapBoxGetPackDirection func(uintptr) PackDirection

// Gets the direction children are packed in each line.
func (x *WrapBox) GetPackDirection() PackDirection {

	cret := xWrapBoxGetPackDirection(x.GoPointer())
	return cret
}

var xWrapBoxGetWrapPolicy func(uintptr) WrapPolicy

// Gets the policy for line wrapping.
func (x *WrapBox) GetWrapPolicy() WrapPolicy {

	cret := xWrapBoxGetWrapPolicy(x.GoPointer())
	return cret
}

var xWrapBoxGetWrapReverse func(uintptr) bool

// Gets whether wrap direction is reversed.
func (x *WrapBox) GetWrapReverse() bool {

	cret := xWrapBoxGetWrapReverse(x.GoPointer())
	return cret
}

var xWrapBoxInsertChildAfter func(uintptr, uintptr, uintptr)

// Inserts @child in the position after @sibling in the list of @self children.
//
// If @sibling is `NULL`, inserts @child at the first position.
func (x *WrapBox) InsertChildAfter(ChildVar *gtk.Widget, SiblingVar *gtk.Widget) {

	xWrapBoxInsertChildAfter(x.GoPointer(), ChildVar.GoPointer(), SiblingVar.GoPointer())

}

var xWrapBoxPrepend func(uintptr, uintptr)

// Adds @child as the first child to @self.
func (x *WrapBox) Prepend(ChildVar *gtk.Widget) {

	xWrapBoxPrepend(x.GoPointer(), ChildVar.GoPointer())

}

var xWrapBoxRemove func(uintptr, uintptr)

// Removes a child widget from @self.
//
// The child must have been added before with [method@Adw.WrapBox.append],
// [method@Adw.WrapBox.prepend], or [method@Adw.WrapBox.insert_child_after].
func (x *WrapBox) Remove(ChildVar *gtk.Widget) {

	xWrapBoxRemove(x.GoPointer(), ChildVar.GoPointer())

}

var xWrapBoxRemoveAll func(uintptr)

// Removes all children from @self.
func (x *WrapBox) RemoveAll() {

	xWrapBoxRemoveAll(x.GoPointer())

}

var xWrapBoxReorderChildAfter func(uintptr, uintptr, uintptr)

// Moves @child to the position after @sibling in the list of @self children.
//
// If @sibling is `NULL`, moves @child to the first position.
func (x *WrapBox) ReorderChildAfter(ChildVar *gtk.Widget, SiblingVar *gtk.Widget) {

	xWrapBoxReorderChildAfter(x.GoPointer(), ChildVar.GoPointer(), SiblingVar.GoPointer())

}

var xWrapBoxSetAlign func(uintptr, float32)

// Sets the alignment of the children within each line.
//
// 0 means the children are placed at the start of the line, 1 means they are
// placed at the end of the line. 0.5 means they are placed in the middle of the
// line.
//
// Alignment is only used when [property@WrapBox:justify] is set to
// `ADW_JUSTIFY_NONE`, or on the last line when the
// [property@WrapBox:justify-last-line] is `FALSE`.
func (x *WrapBox) SetAlign(AlignVar float32) {

	xWrapBoxSetAlign(x.GoPointer(), AlignVar)

}

var xWrapBoxSetChildSpacing func(uintptr, int)

// Sets the spacing between widgets on the same line.
//
// See [property@WrapBox:child-spacing-unit].
func (x *WrapBox) SetChildSpacing(ChildSpacingVar int) {

	xWrapBoxSetChildSpacing(x.GoPointer(), ChildSpacingVar)

}

var xWrapBoxSetChildSpacingUnit func(uintptr, LengthUnit)

// Sets the length unit for child spacing.
//
// Allows the spacing to vary depending on the text scale factor.
//
// See [property@WrapBox:child-spacing].
func (x *WrapBox) SetChildSpacingUnit(UnitVar LengthUnit) {

	xWrapBoxSetChildSpacingUnit(x.GoPointer(), UnitVar)

}

var xWrapBoxSetJustify func(uintptr, JustifyMode)

// Determines whether and how each complete line should be stretched to fill
// the entire widget.
//
// If set to `ADW_JUSTIFY_FILL`, each widget in the line will be stretched,
// keeping consistent spacing, so that the line fills the entire widget.
//
// If set to `ADW_JUSTIFY_SPREAD`, the spacing between widgets will be
// increased, keeping widget sizes intact. The first and last widget will be
// aligned with the beginning and end of the line. If the line only contains a
// single widget, it will be stretched regardless.
//
// If set to `ADW_JUSTIFY_NONE`, the line will not be stretched and the children
// will be placed together within the line, according to
// [property@WrapBox:align].
//
// By default this doesn't affect the last line, as it will be incomplete. Use
// [property@WrapBox:justify-last-line] to justify it as well.
func (x *WrapBox) SetJustify(JustifyVar JustifyMode) {

	xWrapBoxSetJustify(x.GoPointer(), JustifyVar)

}

var xWrapBoxSetJustifyLastLine func(uintptr, bool)

// Sets whether the last line should be stretched to fill the entire widget.
//
// See [property@WrapBox:justify].
func (x *WrapBox) SetJustifyLastLine(JustifyLastLineVar bool) {

	xWrapBoxSetJustifyLastLine(x.GoPointer(), JustifyLastLineVar)

}

var xWrapBoxSetLineHomogeneous func(uintptr, bool)

// Sets whether all lines should take the same amount of space.
func (x *WrapBox) SetLineHomogeneous(HomogeneousVar bool) {

	xWrapBoxSetLineHomogeneous(x.GoPointer(), HomogeneousVar)

}

var xWrapBoxSetLineSpacing func(uintptr, int)

// Sets the spacing between lines.
func (x *WrapBox) SetLineSpacing(LineSpacingVar int) {

	xWrapBoxSetLineSpacing(x.GoPointer(), LineSpacingVar)

}

var xWrapBoxSetLineSpacingUnit func(uintptr, LengthUnit)

// Sets the length unit for line spacing.
//
// Allows the spacing to vary depending on the text scale factor.
//
// See [property@WrapBox:line-spacing].
func (x *WrapBox) SetLineSpacingUnit(UnitVar LengthUnit) {

	xWrapBoxSetLineSpacingUnit(x.GoPointer(), UnitVar)

}

var xWrapBoxSetNaturalLineLength func(uintptr, int)

// Sets the natural size for each line.
//
// It should be used to limit the line lengths, for example when used in
// popovers.
//
// See [property@WrapBox:natural-line-length-unit].
func (x *WrapBox) SetNaturalLineLength(NaturalLineLengthVar int) {

	xWrapBoxSetNaturalLineLength(x.GoPointer(), NaturalLineLengthVar)

}

var xWrapBoxSetNaturalLineLengthUnit func(uintptr, LengthUnit)

// Sets the length unit for natural line length.
//
// Allows the length to vary depending on the text scale factor.
//
// See [property@WrapBox:natural-line-length].
func (x *WrapBox) SetNaturalLineLengthUnit(UnitVar LengthUnit) {

	xWrapBoxSetNaturalLineLengthUnit(x.GoPointer(), UnitVar)

}

var xWrapBoxSetPackDirection func(uintptr, PackDirection)

// Sets the direction children are packed in each line.
func (x *WrapBox) SetPackDirection(PackDirectionVar PackDirection) {

	xWrapBoxSetPackDirection(x.GoPointer(), PackDirectionVar)

}

var xWrapBoxSetWrapPolicy func(uintptr, WrapPolicy)

// Sets the policy for line wrapping.
//
// If set to `ADW_WRAP_NATURAL`, the box will wrap to the next line as soon as
// the previous line cannot fit any more children without shrinking them past
// their natural size.
//
// If set to `ADW_WRAP_MINIMUM`, the box will try to fit as many children into
// each line as possible, shrinking them down to their minimum size before
// wrapping to the next line.
func (x *WrapBox) SetWrapPolicy(WrapPolicyVar WrapPolicy) {

	xWrapBoxSetWrapPolicy(x.GoPointer(), WrapPolicyVar)

}

var xWrapBoxSetWrapReverse func(uintptr, bool)

// Sets whether wrap direction should be reversed.
//
// By default, lines wrap downwards in a horizontal box, and towards the end
// in a vertical box. If set to `TRUE`, they wrap upwards or towards the start
// respectively.
func (x *WrapBox) SetWrapReverse(WrapReverseVar bool) {

	xWrapBoxSetWrapReverse(x.GoPointer(), WrapReverseVar)

}

func (c *WrapBox) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WrapBox) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAlign sets the "align" property.
// The alignment of the children within each line.
//
// 0 means the children are placed at the start of the line, 1 means they are
// placed at the end of the line. 0.5 means they are placed in the middle of
// the line.
//
// Alignment is only used when [property@WrapBox:justify] is set to
// `ADW_JUSTIFY_NONE`, or on the last line when the
// [property@WrapBox:justify-last-line] is `FALSE`.
func (x *WrapBox) SetPropertyAlign(value float32) {
	var v gobject.Value
	v.Init(gobject.TypeFloatVal)
	v.SetFloat(value)
	x.SetProperty("align", &v)
}

// GetPropertyAlign gets the "align" property.
// The alignment of the children within each line.
//
// 0 means the children are placed at the start of the line, 1 means they are
// placed at the end of the line. 0.5 means they are placed in the middle of
// the line.
//
// Alignment is only used when [property@WrapBox:justify] is set to
// `ADW_JUSTIFY_NONE`, or on the last line when the
// [property@WrapBox:justify-last-line] is `FALSE`.
func (x *WrapBox) GetPropertyAlign() float32 {
	var v gobject.Value
	x.GetProperty("align", &v)
	return v.GetFloat()
}

// SetPropertyChildSpacing sets the "child-spacing" property.
// The spacing between widgets on the same line.
//
// See [property@WrapBox:child-spacing-unit].
func (x *WrapBox) SetPropertyChildSpacing(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("child-spacing", &v)
}

// GetPropertyChildSpacing gets the "child-spacing" property.
// The spacing between widgets on the same line.
//
// See [property@WrapBox:child-spacing-unit].
func (x *WrapBox) GetPropertyChildSpacing() int {
	var v gobject.Value
	x.GetProperty("child-spacing", &v)
	return v.GetInt()
}

// SetPropertyJustifyLastLine sets the "justify-last-line" property.
// Whether the last line should be stretched to fill the entire widget.
//
// See [property@WrapBox:justify].
func (x *WrapBox) SetPropertyJustifyLastLine(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("justify-last-line", &v)
}

// GetPropertyJustifyLastLine gets the "justify-last-line" property.
// Whether the last line should be stretched to fill the entire widget.
//
// See [property@WrapBox:justify].
func (x *WrapBox) GetPropertyJustifyLastLine() bool {
	var v gobject.Value
	x.GetProperty("justify-last-line", &v)
	return v.GetBoolean()
}

// SetPropertyLineHomogeneous sets the "line-homogeneous" property.
// Whether all lines should take the same amount of space.
func (x *WrapBox) SetPropertyLineHomogeneous(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("line-homogeneous", &v)
}

// GetPropertyLineHomogeneous gets the "line-homogeneous" property.
// Whether all lines should take the same amount of space.
func (x *WrapBox) GetPropertyLineHomogeneous() bool {
	var v gobject.Value
	x.GetProperty("line-homogeneous", &v)
	return v.GetBoolean()
}

// SetPropertyLineSpacing sets the "line-spacing" property.
// The spacing between lines.
//
// See [property@WrapBox:line-spacing-unit].
func (x *WrapBox) SetPropertyLineSpacing(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("line-spacing", &v)
}

// GetPropertyLineSpacing gets the "line-spacing" property.
// The spacing between lines.
//
// See [property@WrapBox:line-spacing-unit].
func (x *WrapBox) GetPropertyLineSpacing() int {
	var v gobject.Value
	x.GetProperty("line-spacing", &v)
	return v.GetInt()
}

// SetPropertyNaturalLineLength sets the "natural-line-length" property.
// Determines the natural size for each line.
//
// It should be used to limit the line lengths, for example when used in
// popovers.
//
// See [property@WrapBox:natural-line-length-unit].
func (x *WrapBox) SetPropertyNaturalLineLength(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("natural-line-length", &v)
}

// GetPropertyNaturalLineLength gets the "natural-line-length" property.
// Determines the natural size for each line.
//
// It should be used to limit the line lengths, for example when used in
// popovers.
//
// See [property@WrapBox:natural-line-length-unit].
func (x *WrapBox) GetPropertyNaturalLineLength() int {
	var v gobject.Value
	x.GetProperty("natural-line-length", &v)
	return v.GetInt()
}

// SetPropertyWrapReverse sets the "wrap-reverse" property.
// Whether wrap direction should be reversed.
//
// By default, lines wrap downwards in a horizontal box, and towards the end
// in a vertical box. If set to `TRUE`, they wrap upwards or towards the start
// respectively.
func (x *WrapBox) SetPropertyWrapReverse(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("wrap-reverse", &v)
}

// GetPropertyWrapReverse gets the "wrap-reverse" property.
// Whether wrap direction should be reversed.
//
// By default, lines wrap downwards in a horizontal box, and towards the end
// in a vertical box. If set to `TRUE`, they wrap upwards or towards the start
// respectively.
func (x *WrapBox) GetPropertyWrapReverse() bool {
	var v gobject.Value
	x.GetProperty("wrap-reverse", &v)
	return v.GetBoolean()
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *WrapBox) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *WrapBox) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *WrapBox) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *WrapBox) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *WrapBox) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *WrapBox) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *WrapBox) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *WrapBox) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *WrapBox) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *WrapBox) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *WrapBox) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *WrapBox) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *WrapBox) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *WrapBox) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *WrapBox) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *WrapBox) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *WrapBox) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *WrapBox) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *WrapBox) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *WrapBox) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *WrapBox) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Retrieves the orientation of the @orientable.
func (x *WrapBox) GetOrientation() gtk.Orientation {

	cret := gtk.XGtkOrientableGetOrientation(x.GoPointer())
	return cret
}

// Sets the orientation of the @orientable.
func (x *WrapBox) SetOrientation(OrientationVar gtk.Orientation) {

	gtk.XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)

}

func init() {
	core.SetPackageName("ADW", "libadwaita-1")
	core.SetSharedLibraries("ADW", []string{"libadwaita-1.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("ADW") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWrapBoxGLibType, libs, "adw_wrap_box_get_type")

	core.PuregoSafeRegister(&xNewWrapBox, libs, "adw_wrap_box_new")

	core.PuregoSafeRegister(&xWrapBoxAppend, libs, "adw_wrap_box_append")
	core.PuregoSafeRegister(&xWrapBoxGetAlign, libs, "adw_wrap_box_get_align")
	core.PuregoSafeRegister(&xWrapBoxGetChildSpacing, libs, "adw_wrap_box_get_child_spacing")
	core.PuregoSafeRegister(&xWrapBoxGetChildSpacingUnit, libs, "adw_wrap_box_get_child_spacing_unit")
	core.PuregoSafeRegister(&xWrapBoxGetJustify, libs, "adw_wrap_box_get_justify")
	core.PuregoSafeRegister(&xWrapBoxGetJustifyLastLine, libs, "adw_wrap_box_get_justify_last_line")
	core.PuregoSafeRegister(&xWrapBoxGetLineHomogeneous, libs, "adw_wrap_box_get_line_homogeneous")
	core.PuregoSafeRegister(&xWrapBoxGetLineSpacing, libs, "adw_wrap_box_get_line_spacing")
	core.PuregoSafeRegister(&xWrapBoxGetLineSpacingUnit, libs, "adw_wrap_box_get_line_spacing_unit")
	core.PuregoSafeRegister(&xWrapBoxGetNaturalLineLength, libs, "adw_wrap_box_get_natural_line_length")
	core.PuregoSafeRegister(&xWrapBoxGetNaturalLineLengthUnit, libs, "adw_wrap_box_get_natural_line_length_unit")
	core.PuregoSafeRegister(&xWrapBoxGetPackDirection, libs, "adw_wrap_box_get_pack_direction")
	core.PuregoSafeRegister(&xWrapBoxGetWrapPolicy, libs, "adw_wrap_box_get_wrap_policy")
	core.PuregoSafeRegister(&xWrapBoxGetWrapReverse, libs, "adw_wrap_box_get_wrap_reverse")
	core.PuregoSafeRegister(&xWrapBoxInsertChildAfter, libs, "adw_wrap_box_insert_child_after")
	core.PuregoSafeRegister(&xWrapBoxPrepend, libs, "adw_wrap_box_prepend")
	core.PuregoSafeRegister(&xWrapBoxRemove, libs, "adw_wrap_box_remove")
	core.PuregoSafeRegister(&xWrapBoxRemoveAll, libs, "adw_wrap_box_remove_all")
	core.PuregoSafeRegister(&xWrapBoxReorderChildAfter, libs, "adw_wrap_box_reorder_child_after")
	core.PuregoSafeRegister(&xWrapBoxSetAlign, libs, "adw_wrap_box_set_align")
	core.PuregoSafeRegister(&xWrapBoxSetChildSpacing, libs, "adw_wrap_box_set_child_spacing")
	core.PuregoSafeRegister(&xWrapBoxSetChildSpacingUnit, libs, "adw_wrap_box_set_child_spacing_unit")
	core.PuregoSafeRegister(&xWrapBoxSetJustify, libs, "adw_wrap_box_set_justify")
	core.PuregoSafeRegister(&xWrapBoxSetJustifyLastLine, libs, "adw_wrap_box_set_justify_last_line")
	core.PuregoSafeRegister(&xWrapBoxSetLineHomogeneous, libs, "adw_wrap_box_set_line_homogeneous")
	core.PuregoSafeRegister(&xWrapBoxSetLineSpacing, libs, "adw_wrap_box_set_line_spacing")
	core.PuregoSafeRegister(&xWrapBoxSetLineSpacingUnit, libs, "adw_wrap_box_set_line_spacing_unit")
	core.PuregoSafeRegister(&xWrapBoxSetNaturalLineLength, libs, "adw_wrap_box_set_natural_line_length")
	core.PuregoSafeRegister(&xWrapBoxSetNaturalLineLengthUnit, libs, "adw_wrap_box_set_natural_line_length_unit")
	core.PuregoSafeRegister(&xWrapBoxSetPackDirection, libs, "adw_wrap_box_set_pack_direction")
	core.PuregoSafeRegister(&xWrapBoxSetWrapPolicy, libs, "adw_wrap_box_set_wrap_policy")
	core.PuregoSafeRegister(&xWrapBoxSetWrapReverse, libs, "adw_wrap_box_set_wrap_reverse")

}
