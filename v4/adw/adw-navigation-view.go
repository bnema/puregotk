// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type NavigationPageClass struct {
	_ structs.HostLayout

	ParentClass gtk.WidgetClass

	xShowing uintptr

	xShown uintptr

	xHiding uintptr

	xHidden uintptr

	Padding [8]uintptr
}

func (x *NavigationPageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideShowing sets the "showing" callback function.
func (x *NavigationPageClass) OverrideShowing(cb func(*NavigationPage)) {
	if cb == nil {
		x.xShowing = 0
	} else {
		x.xShowing = purego.NewCallback(func(SelfVarp uintptr) {
			cb(NavigationPageNewFromInternalPtr(SelfVarp))
		})
	}
}

// GetShowing gets the "showing" callback function.
func (x *NavigationPageClass) GetShowing() func(*NavigationPage) {
	if x.xShowing == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xShowing)
	return func(SelfVar *NavigationPage) {
		rawCallback(SelfVar.GoPointer())
	}
}

// OverrideShown sets the "shown" callback function.
func (x *NavigationPageClass) OverrideShown(cb func(*NavigationPage)) {
	if cb == nil {
		x.xShown = 0
	} else {
		x.xShown = purego.NewCallback(func(SelfVarp uintptr) {
			cb(NavigationPageNewFromInternalPtr(SelfVarp))
		})
	}
}

// GetShown gets the "shown" callback function.
func (x *NavigationPageClass) GetShown() func(*NavigationPage) {
	if x.xShown == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xShown)
	return func(SelfVar *NavigationPage) {
		rawCallback(SelfVar.GoPointer())
	}
}

// OverrideHiding sets the "hiding" callback function.
func (x *NavigationPageClass) OverrideHiding(cb func(*NavigationPage)) {
	if cb == nil {
		x.xHiding = 0
	} else {
		x.xHiding = purego.NewCallback(func(SelfVarp uintptr) {
			cb(NavigationPageNewFromInternalPtr(SelfVarp))
		})
	}
}

// GetHiding gets the "hiding" callback function.
func (x *NavigationPageClass) GetHiding() func(*NavigationPage) {
	if x.xHiding == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xHiding)
	return func(SelfVar *NavigationPage) {
		rawCallback(SelfVar.GoPointer())
	}
}

// OverrideHidden sets the "hidden" callback function.
func (x *NavigationPageClass) OverrideHidden(cb func(*NavigationPage)) {
	if cb == nil {
		x.xHidden = 0
	} else {
		x.xHidden = purego.NewCallback(func(SelfVarp uintptr) {
			cb(NavigationPageNewFromInternalPtr(SelfVarp))
		})
	}
}

// GetHidden gets the "hidden" callback function.
func (x *NavigationPageClass) GetHidden() func(*NavigationPage) {
	if x.xHidden == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xHidden)
	return func(SelfVar *NavigationPage) {
		rawCallback(SelfVar.GoPointer())
	}
}

type NavigationViewClass struct {
	_ structs.HostLayout

	ParentClass gtk.WidgetClass
}

func (x *NavigationViewClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A page within [class@NavigationView] or [class@NavigationSplitView].
//
// Each page has a child widget, a title and optionally a tag.
//
// The [signal@NavigationPage::showing], [signal@NavigationPage::shown],
// [signal@NavigationPage::hiding] and [signal@NavigationPage::hidden] signals
// can be used to track the page's visibility within its `AdwNavigationView`.
//
// ## Header Bar Integration
//
// When placed inside `AdwNavigationPage`, [class@HeaderBar] will display the
// page title instead of window title.
//
// When used together with [class@NavigationView], it will also display a back
// button that can be used to go back to the previous page. Set
// [property@HeaderBar:show-back-button] to `FALSE` to disable that behavior if
// it's unwanted.
//
// ## CSS Nodes
//
// `AdwNavigationPage` has a single CSS node with name
// `navigation-view-page`.
//
// ## Accessibility
//
// `AdwNavigationPage` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
type NavigationPage struct {
	gtk.Widget
}

var xNavigationPageGLibType func() types.GType

func NavigationPageGLibType() types.GType {
	return xNavigationPageGLibType()
}

func NavigationPageNewFromInternalPtr(ptr uintptr) *NavigationPage {
	cls := &NavigationPage{}
	cls.Ptr = ptr
	return cls
}

var xNewNavigationPage func(uintptr, string) uintptr

// Creates a new `AdwNavigationPage`.
func NewNavigationPage(ChildVar *gtk.Widget, TitleVar string) *NavigationPage {
	var cls *NavigationPage

	cret := xNewNavigationPage(ChildVar.GoPointer(), TitleVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNewNavigationPageWithTag func(uintptr, string, string) uintptr

// Creates a new `AdwNavigationPage` with provided tag.
func NewNavigationPageWithTag(ChildVar *gtk.Widget, TitleVar string, TagVar string) *NavigationPage {
	var cls *NavigationPage

	cret := xNewNavigationPageWithTag(ChildVar.GoPointer(), TitleVar, TagVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNavigationPageGetCanPop func(uintptr) bool

// Gets whether @self can be popped from navigation stack.
func (x *NavigationPage) GetCanPop() bool {

	cret := xNavigationPageGetCanPop(x.GoPointer())
	return cret
}

var xNavigationPageGetChild func(uintptr) uintptr

// Gets the child widget of @self.
func (x *NavigationPage) GetChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xNavigationPageGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xNavigationPageGetTag func(uintptr) string

// Gets the tag of @self.
func (x *NavigationPage) GetTag() string {

	cret := xNavigationPageGetTag(x.GoPointer())
	return cret
}

var xNavigationPageGetTitle func(uintptr) string

// Gets the title of @self.
func (x *NavigationPage) GetTitle() string {

	cret := xNavigationPageGetTitle(x.GoPointer())
	return cret
}

var xNavigationPageSetCanPop func(uintptr, bool)

// Sets whether @self can be popped from navigation stack.
//
// Set it to `FALSE` to disable shortcuts and gestures, as well as remove the
// back button from [class@HeaderBar].
//
// Manually calling [method@NavigationView.pop] or using the `navigation.pop`
// action will still work.
//
// See [property@HeaderBar:show-back-button] for removing only the back button,
// but not shortcuts.
func (x *NavigationPage) SetCanPop(CanPopVar bool) {

	xNavigationPageSetCanPop(x.GoPointer(), CanPopVar)

}

var xNavigationPageSetChild func(uintptr, uintptr)

// Sets the child widget of @self.
func (x *NavigationPage) SetChild(ChildVar *gtk.Widget) {

	xNavigationPageSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xNavigationPageSetTag func(uintptr, string)

// Sets the tag for @self.
//
// The tag can be used to retrieve the page with
// [method@NavigationView.find_page], as well as with
// [method@NavigationView.push_by_tag], [method@NavigationView.pop_to_tag] or
// [method@NavigationView.replace_with_tags].
//
// Tags must be unique within each [class@NavigationView].
//
// The tag also must be set to use the `navigation.push` action.
func (x *NavigationPage) SetTag(TagVar string) {

	xNavigationPageSetTag(x.GoPointer(), TagVar)

}

var xNavigationPageSetTitle func(uintptr, string)

// Sets the title of @self.
//
// It's displayed in [class@HeaderBar] instead of the window title, and used as
// the tooltip on the next page's back button, as well as by screen reader.
func (x *NavigationPage) SetTitle(TitleVar string) {

	xNavigationPageSetTitle(x.GoPointer(), TitleVar)

}

func (c *NavigationPage) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *NavigationPage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyCanPop sets the "can-pop" property.
// Whether the page can be popped from navigation stack.
//
// Set it to `FALSE` to disable shortcuts and gestures, as well as remove the
// back button from [class@HeaderBar].
//
// Manually calling [method@NavigationView.pop] or using the `navigation.pop`
// action will still work.
//
// See [property@HeaderBar:show-back-button] for removing only the back
// button, but not shortcuts.
func (x *NavigationPage) SetPropertyCanPop(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("can-pop", &v)
}

// GetPropertyCanPop gets the "can-pop" property.
// Whether the page can be popped from navigation stack.
//
// Set it to `FALSE` to disable shortcuts and gestures, as well as remove the
// back button from [class@HeaderBar].
//
// Manually calling [method@NavigationView.pop] or using the `navigation.pop`
// action will still work.
//
// See [property@HeaderBar:show-back-button] for removing only the back
// button, but not shortcuts.
func (x *NavigationPage) GetPropertyCanPop() bool {
	var v gobject.Value
	x.GetProperty("can-pop", &v)
	return v.GetBoolean()
}

// SetPropertyTag sets the "tag" property.
// The page tag.
//
// The tag can be used to retrieve the page with
// [method@NavigationView.find_page], as well as with
// [method@NavigationView.push_by_tag], [method@NavigationView.pop_to_tag] or
// [method@NavigationView.replace_with_tags].
//
// Tags must be unique within each [class@NavigationView].
//
// The tag also must be set to use the `navigation.push` action.
func (x *NavigationPage) SetPropertyTag(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("tag", &v)
}

// GetPropertyTag gets the "tag" property.
// The page tag.
//
// The tag can be used to retrieve the page with
// [method@NavigationView.find_page], as well as with
// [method@NavigationView.push_by_tag], [method@NavigationView.pop_to_tag] or
// [method@NavigationView.replace_with_tags].
//
// Tags must be unique within each [class@NavigationView].
//
// The tag also must be set to use the `navigation.push` action.
func (x *NavigationPage) GetPropertyTag() string {
	var v gobject.Value
	x.GetProperty("tag", &v)
	return v.GetString()
}

// SetPropertyTitle sets the "title" property.
// The page title.
//
// It's displayed in [class@HeaderBar] instead of the window title, and used
// as the tooltip on the next page's back button, as well as by screen reader.
func (x *NavigationPage) SetPropertyTitle(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("title", &v)
}

// GetPropertyTitle gets the "title" property.
// The page title.
//
// It's displayed in [class@HeaderBar] instead of the window title, and used
// as the tooltip on the next page's back button, as well as by screen reader.
func (x *NavigationPage) GetPropertyTitle() string {
	var v gobject.Value
	x.GetProperty("title", &v)
	return v.GetString()
}

// Emitted when the navigation view transition has been completed and the page
// is fully hidden.
//
// It will always be preceded by [signal@NavigationPage::hiding] or
// [signal@NavigationPage::showing].
func (x *NavigationPage) ConnectHidden(cb *func(NavigationPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "hidden", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "hidden", cbRefPtr)
}

// Emitted when the page starts hiding at the beginning of the navigation view
// transition.
//
// It will always be followed by [signal@NavigationPage::hidden] or
// [signal@NavigationPage::shown].
func (x *NavigationPage) ConnectHiding(cb *func(NavigationPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "hiding", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "hiding", cbRefPtr)
}

// Emitted when the page shows at the beginning of the navigation view
// transition.
//
// It will always be followed by [signal@NavigationPage::shown] or
// [signal@NavigationPage::hidden].
func (x *NavigationPage) ConnectShowing(cb *func(NavigationPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "showing", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "showing", cbRefPtr)
}

// Emitted when the navigation view transition has been completed and the page
// is fully shown.
//
// It will always be preceded by [signal@NavigationPage::showing] or
// [signal@NavigationPage::hiding].
func (x *NavigationPage) ConnectShown(cb *func(NavigationPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "shown", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "shown", cbRefPtr)
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *NavigationPage) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *NavigationPage) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *NavigationPage) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *NavigationPage) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *NavigationPage) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *NavigationPage) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *NavigationPage) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *NavigationPage) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *NavigationPage) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *NavigationPage) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *NavigationPage) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *NavigationPage) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *NavigationPage) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *NavigationPage) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *NavigationPage) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationPage) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *NavigationPage) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationPage) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *NavigationPage) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationPage) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *NavigationPage) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// A page-based navigation container.
//
// &lt;picture&gt;
//
//	&lt;source srcset="navigation-view-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="navigation-view.png" alt="navigation-view"&gt;
//
// &lt;/picture&gt;
//
// `AdwNavigationView` presents one child at a time, similar to
// [class@Gtk.Stack].
//
// `AdwNavigationView` can only contain [class@NavigationPage] children.
//
// It maintains a navigation stack that can be controlled with
// [method@NavigationView.push] and [method@NavigationView.pop]. The whole
// navigation stack can also be replaced using [method@NavigationView.replace].
//
// `AdwNavigationView` allows to manage pages statically or dynamically.
//
// Static pages can be added using the [method@NavigationView.add] method. The
// `AdwNavigationView` will keep a reference to these pages, but they aren't
// accessible to the user until [method@NavigationView.push] is called (except
// for the first page, which is pushed automatically). Use the
// [method@NavigationView.remove] method to remove them. This is useful for
// applications that have a small number of unique pages and just need
// navigation between them.
//
// Dynamic pages are automatically destroyed once they are popped off the
// navigation stack. To add a page like this, push it using the
// [method@NavigationView.push] method without calling
// [method@NavigationView.add] first.
//
// ## Tags
//
// Static pages, as well as any pages in the navigation stack, can be accessed
// by their [property@NavigationPage:tag]. For example,
// [method@NavigationView.push_by_tag] can be used to push a static page that's
// not in the navigation stack without having to keep a reference to it manually.
//
// ## Header Bar Integration
//
// When used inside `AdwNavigationView`, [class@HeaderBar] will automatically
// display a back button that can be used to go back to the previous page when
// possible. The button also has a context menu, allowing to pop multiple pages
// at once, potentially across multiple navigation views.
//
// Set [property@HeaderBar:show-back-button] to `FALSE` to disable this behavior
// in rare scenarios where it's unwanted.
//
// `AdwHeaderBar` will also display the title of the `AdwNavigationPage` it's
// placed into, so most applications shouldn't need to customize it at all.
//
// ## Shortcuts and Gestures
//
// `AdwNavigationView` supports the following shortcuts for going to the
// previous page:
//
//   - &lt;kbd&gt;Escape&lt;/kbd&gt; (unless [property@NavigationView:pop-on-escape] is set to
//     `FALSE`)
//   - &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;←&lt;/kbd&gt;
//   - Back mouse button
//
// Additionally, it supports interactive gestures:
//
// - One-finger swipe towards the right on touchscreens
// - Scrolling towards the right on touchpads (usually two-finger swipe)
//
// These gestures have transitions enabled regardless of the
// [property@NavigationView:animate-transitions] value.
//
// Applications can also enable shortcuts for pushing another page onto the
// navigation stack via connecting to the [signal@NavigationView::get-next-page]
// signal, in that case the following shortcuts are supported:
//
// - &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;→&lt;/kbd&gt;
// - Forward mouse button
// - Swipe/scrolling towards the left
//
// For right-to-left locales, the gestures and shortcuts are reversed.
//
// [property@NavigationPage:can-pop] can be used to disable them, along with the
// header bar back buttons.
//
// ## Actions
//
// `AdwNavigationView` defines actions for controlling the navigation stack.
// actions for controlling the navigation stack:
//
// - `navigation.push` takes a string parameter specifying the tag of the page to
// push, and is equivalent to calling [method@NavigationView.push_by_tag].
//
// - `navigation.pop` doesn't take any parameters and pops the current page from
// the navigation stack, equivalent to calling [method@NavigationView.pop].
//
// ## `AdwNavigationView` as `GtkBuildable`
//
// `AdwNavigationView` allows to add pages as children, equivalent to using the
// [method@NavigationView.add] method.
//
// Example of an `AdwNavigationView` UI definition:
//
// ```xml
// &lt;object class="AdwNavigationView"&gt;
//
//	&lt;child&gt;
//	  &lt;object class="AdwNavigationPage"&gt;
//	    &lt;property name="title" translatable="yes"&gt;Page 1&lt;/property&gt;
//	    &lt;property name="child"&gt;
//	      &lt;object class="AdwToolbarView"&gt;
//	        &lt;child type="top"&gt;
//	          &lt;object class="AdwHeaderBar"/&gt;
//	        &lt;/child&gt;
//	        &lt;property name="content"&gt;
//	          &lt;object class="GtkButton"&gt;
//	            &lt;property name="label" translatable="yes"&gt;Open Page 2&lt;/property&gt;
//	            &lt;property name="halign"&gt;center&lt;/property&gt;
//	            &lt;property name="valign"&gt;center&lt;/property&gt;
//	            &lt;property name="action-name"&gt;navigation.push&lt;/property&gt;
//	            &lt;property name="action-target"&gt;'page-2'&lt;/property&gt;
//	            &lt;style&gt;
//	              &lt;class name="pill"/&gt;
//	             &lt;/style&gt;
//	          &lt;/object&gt;
//	        &lt;/property&gt;
//	      &lt;/object&gt;
//	    &lt;/property&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//	&lt;child&gt;
//	  &lt;object class="AdwNavigationPage"&gt;
//	    &lt;property name="title" translatable="yes"&gt;Page 2&lt;/property&gt;
//	    &lt;property name="tag"&gt;page-2&lt;/property&gt;
//	    &lt;property name="child"&gt;
//	      &lt;object class="AdwToolbarView"&gt;
//	        &lt;child type="top"&gt;
//	          &lt;object class="AdwHeaderBar"/&gt;
//	        &lt;/child&gt;
//	        &lt;property name="content"&gt;
//	          &lt;!-- ... --&gt;
//	        &lt;/property&gt;
//	      &lt;/object&gt;
//	    &lt;/property&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//
// &lt;/object&gt;
// ```
//
// &lt;picture&gt;
//
//	&lt;source srcset="navigation-view-example-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="navigation-view-example.png" alt="navigation-view-example"&gt;
//
// &lt;/picture&gt;
//
// ## CSS nodes
//
// `AdwNavigationView` has a single CSS node with the name `navigation-view`.
//
// ## Accessibility
//
// `AdwNavigationView` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
type NavigationView struct {
	gtk.Widget
}

var xNavigationViewGLibType func() types.GType

func NavigationViewGLibType() types.GType {
	return xNavigationViewGLibType()
}

func NavigationViewNewFromInternalPtr(ptr uintptr) *NavigationView {
	cls := &NavigationView{}
	cls.Ptr = ptr
	return cls
}

var xNewNavigationView func() uintptr

// Creates a new `AdwNavigationView`.
func NewNavigationView() *NavigationView {
	var cls *NavigationView

	cret := xNewNavigationView()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationView{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewAdd func(uintptr, uintptr)

// Permanently adds @page to @self.
//
// Any page that has been added will stay in @self even after being popped from
// the navigation stack.
//
// Adding a page while no page is visible will automatically push it to the
// navigation stack.
//
// See [method@NavigationView.remove].
func (x *NavigationView) Add(PageVar *NavigationPage) {

	xNavigationViewAdd(x.GoPointer(), PageVar.GoPointer())

}

var xNavigationViewFindPage func(uintptr, string) uintptr

// Finds a page in @self by its tag.
//
// See [property@NavigationPage:tag].
func (x *NavigationView) FindPage(TagVar string) *NavigationPage {
	var cls *NavigationPage

	cret := xNavigationViewFindPage(x.GoPointer(), TagVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewGetAnimateTransitions func(uintptr) bool

// Gets whether @self animates page transitions.
func (x *NavigationView) GetAnimateTransitions() bool {

	cret := xNavigationViewGetAnimateTransitions(x.GoPointer())
	return cret
}

var xNavigationViewGetHhomogeneous func(uintptr) bool

// Gets whether @self is horizontally homogeneous.
func (x *NavigationView) GetHhomogeneous() bool {

	cret := xNavigationViewGetHhomogeneous(x.GoPointer())
	return cret
}

var xNavigationViewGetNavigationStack func(uintptr) uintptr

// Returns a [iface@Gio.ListModel] that contains the pages in navigation stack.
//
// The pages are sorted from root page to visible page.
//
// This can be used to keep an up-to-date view.
func (x *NavigationView) GetNavigationStack() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xNavigationViewGetNavigationStack(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewGetPopOnEscape func(uintptr) bool

// Gets whether pressing Escape pops the current page on @self.
func (x *NavigationView) GetPopOnEscape() bool {

	cret := xNavigationViewGetPopOnEscape(x.GoPointer())
	return cret
}

var xNavigationViewGetPreviousPage func(uintptr, uintptr) uintptr

// Gets the previous page for @page.
//
// If @page is in the navigation stack, returns the page popping @page will
// reveal.
//
// If @page is the root page or is not in the navigation stack, returns `NULL`.
func (x *NavigationView) GetPreviousPage(PageVar *NavigationPage) *NavigationPage {
	var cls *NavigationPage

	cret := xNavigationViewGetPreviousPage(x.GoPointer(), PageVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewGetVhomogeneous func(uintptr) bool

// Gets whether @self is vertically homogeneous.
func (x *NavigationView) GetVhomogeneous() bool {

	cret := xNavigationViewGetVhomogeneous(x.GoPointer())
	return cret
}

var xNavigationViewGetVisiblePage func(uintptr) uintptr

// Gets the currently visible page in @self.
func (x *NavigationView) GetVisiblePage() *NavigationPage {
	var cls *NavigationPage

	cret := xNavigationViewGetVisiblePage(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewGetVisiblePageTag func(uintptr) string

// Gets the tag of the currently visible page in @self.
func (x *NavigationView) GetVisiblePageTag() string {

	cret := xNavigationViewGetVisiblePageTag(x.GoPointer())
	return cret
}

var xNavigationViewPop func(uintptr) bool

// Pops the visible page from the navigation stack.
//
// Does nothing if the navigation stack contains less than two pages.
//
// If [method@NavigationView.add] hasn't been called, the page is automatically
// removed.
//
// [signal@NavigationView::popped] will be emitted for the current visible page.
//
// See [method@NavigationView.pop_to_page] and
// [method@NavigationView.pop_to_tag].
func (x *NavigationView) Pop() bool {

	cret := xNavigationViewPop(x.GoPointer())
	return cret
}

var xNavigationViewPopToPage func(uintptr, uintptr) bool

// Pops pages from the navigation stack until @page is visible.
//
// @page must be in the navigation stack.
//
// If [method@NavigationView.add] hasn't been called for any of the popped pages,
// they are automatically removed.
//
// [signal@NavigationView::popped] will be be emitted for each of the popped
// pages.
//
// See [method@NavigationView.pop] and [method@NavigationView.pop_to_tag].
func (x *NavigationView) PopToPage(PageVar *NavigationPage) bool {

	cret := xNavigationViewPopToPage(x.GoPointer(), PageVar.GoPointer())
	return cret
}

var xNavigationViewPopToTag func(uintptr, string) bool

// Pops pages from the navigation stack until page with the tag @tag is visible.
//
// The page must be in the navigation stack.
//
// If [method@NavigationView.add] hasn't been called for any of the popped pages,
// they are automatically removed.
//
// [signal@NavigationView::popped] will be emitted for each of the popped pages.
//
// See [method@NavigationView.pop_to_page] and [property@NavigationPage:tag].
func (x *NavigationView) PopToTag(TagVar string) bool {

	cret := xNavigationViewPopToTag(x.GoPointer(), TagVar)
	return cret
}

var xNavigationViewPush func(uintptr, uintptr)

// Pushes @page onto the navigation stack.
//
// If [method@NavigationView.add] hasn't been called, the page is automatically
// removed once it's popped.
//
// [signal@NavigationView::pushed] will be emitted for @page.
//
// See [method@NavigationView.push_by_tag].
func (x *NavigationView) Push(PageVar *NavigationPage) {

	xNavigationViewPush(x.GoPointer(), PageVar.GoPointer())

}

var xNavigationViewPushByTag func(uintptr, string)

// Pushes the page with the tag @tag onto the navigation stack.
//
// If [method@NavigationView.add] hasn't been called, the page is automatically
// removed once it's popped.
//
// [signal@NavigationView::pushed] will be emitted for the page.
//
// See [method@NavigationView.push] and [property@NavigationPage:tag].
func (x *NavigationView) PushByTag(TagVar string) {

	xNavigationViewPushByTag(x.GoPointer(), TagVar)

}

var xNavigationViewRemove func(uintptr, uintptr)

// Removes @page from @self.
//
// If @page is currently in the navigation stack, it will be removed once it's
// popped. Otherwise, it's removed immediately.
//
// See [method@NavigationView.add].
func (x *NavigationView) Remove(PageVar *NavigationPage) {

	xNavigationViewRemove(x.GoPointer(), PageVar.GoPointer())

}

var xNavigationViewReplace func(uintptr, uintptr, int)

// Replaces the current navigation stack with @pages.
//
// The last page becomes the visible page.
//
// Replacing the navigation stack has no animation.
//
// If [method@NavigationView.add] hasn't been called for any pages that are no
// longer in the navigation stack, they are automatically removed.
//
// @n_pages can be 0, in that case no page will be visible after calling this
// method. This can be useful for removing all pages from @self.
//
// The [signal@NavigationView::replaced] signal will be emitted.
//
// See [method@NavigationView.replace_with_tags].
func (x *NavigationView) Replace(PagesVar uintptr, NPagesVar int) {

	xNavigationViewReplace(x.GoPointer(), PagesVar, NPagesVar)

}

var xNavigationViewReplaceWithTags func(uintptr, []string, int)

// Replaces the current navigation stack with pages with the tags @tags.
//
// The last page becomes the visible page.
//
// Replacing the navigation stack has no animation.
//
// If [method@NavigationView.add] hasn't been called for any pages that are no
// longer in the navigation stack, they are automatically removed.
//
// @n_tags can be 0, in that case no page will be visible after calling this
// method. This can be useful for removing all pages from @self.
//
// The [signal@NavigationView::replaced] signal will be emitted.
//
// See [method@NavigationView.replace] and [property@NavigationPage:tag].
func (x *NavigationView) ReplaceWithTags(TagsVar []string, NTagsVar int) {

	xNavigationViewReplaceWithTags(x.GoPointer(), TagsVar, NTagsVar)

}

var xNavigationViewSetAnimateTransitions func(uintptr, bool)

// Sets whether @self should animate page transitions.
//
// Gesture-based transitions are always animated.
func (x *NavigationView) SetAnimateTransitions(AnimateTransitionsVar bool) {

	xNavigationViewSetAnimateTransitions(x.GoPointer(), AnimateTransitionsVar)

}

var xNavigationViewSetHhomogeneous func(uintptr, bool)

// Sets @self to be horizontally homogeneous or not.
//
// If the view is horizontally homogeneous, it allocates the same width for
// all pages.
//
// If it's not, the view may change width when a different page becomes visible.
func (x *NavigationView) SetHhomogeneous(HhomogeneousVar bool) {

	xNavigationViewSetHhomogeneous(x.GoPointer(), HhomogeneousVar)

}

var xNavigationViewSetPopOnEscape func(uintptr, bool)

// Sets whether pressing Escape pops the current page on @self.
//
// Applications using `AdwNavigationView` to implement a browser may want to
// disable it.
func (x *NavigationView) SetPopOnEscape(PopOnEscapeVar bool) {

	xNavigationViewSetPopOnEscape(x.GoPointer(), PopOnEscapeVar)

}

var xNavigationViewSetVhomogeneous func(uintptr, bool)

// Sets @self to be vertically homogeneous or not.
//
// If the view is vertically homogeneous, it allocates the same height for
// all pages.
//
// If it's not, the view may change height when a different page becomes
// visible.
func (x *NavigationView) SetVhomogeneous(VhomogeneousVar bool) {

	xNavigationViewSetVhomogeneous(x.GoPointer(), VhomogeneousVar)

}

func (c *NavigationView) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *NavigationView) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAnimateTransitions sets the "animate-transitions" property.
// Whether to animate page transitions.
//
// Gesture-based transitions are always animated.
func (x *NavigationView) SetPropertyAnimateTransitions(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("animate-transitions", &v)
}

// GetPropertyAnimateTransitions gets the "animate-transitions" property.
// Whether to animate page transitions.
//
// Gesture-based transitions are always animated.
func (x *NavigationView) GetPropertyAnimateTransitions() bool {
	var v gobject.Value
	x.GetProperty("animate-transitions", &v)
	return v.GetBoolean()
}

// SetPropertyHhomogeneous sets the "hhomogeneous" property.
// Whether the view is horizontally homogeneous.
//
// If the view is horizontally homogeneous, it allocates the same width for
// all pages.
//
// If it's not, the page may change width when a different page becomes
// visible.
func (x *NavigationView) SetPropertyHhomogeneous(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("hhomogeneous", &v)
}

// GetPropertyHhomogeneous gets the "hhomogeneous" property.
// Whether the view is horizontally homogeneous.
//
// If the view is horizontally homogeneous, it allocates the same width for
// all pages.
//
// If it's not, the page may change width when a different page becomes
// visible.
func (x *NavigationView) GetPropertyHhomogeneous() bool {
	var v gobject.Value
	x.GetProperty("hhomogeneous", &v)
	return v.GetBoolean()
}

// SetPropertyPopOnEscape sets the "pop-on-escape" property.
// Whether pressing Escape pops the current page.
//
// Applications using `AdwNavigationView` to implement a browser may want to
// disable it.
func (x *NavigationView) SetPropertyPopOnEscape(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("pop-on-escape", &v)
}

// GetPropertyPopOnEscape gets the "pop-on-escape" property.
// Whether pressing Escape pops the current page.
//
// Applications using `AdwNavigationView` to implement a browser may want to
// disable it.
func (x *NavigationView) GetPropertyPopOnEscape() bool {
	var v gobject.Value
	x.GetProperty("pop-on-escape", &v)
	return v.GetBoolean()
}

// SetPropertyVhomogeneous sets the "vhomogeneous" property.
// Whether the view is vertically homogeneous.
//
// If the view is vertically homogeneous, it allocates the same height for
// all pages.
//
// If it's not, the view may change height when a different page becomes
// visible.
func (x *NavigationView) SetPropertyVhomogeneous(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("vhomogeneous", &v)
}

// GetPropertyVhomogeneous gets the "vhomogeneous" property.
// Whether the view is vertically homogeneous.
//
// If the view is vertically homogeneous, it allocates the same height for
// all pages.
//
// If it's not, the view may change height when a different page becomes
// visible.
func (x *NavigationView) GetPropertyVhomogeneous() bool {
	var v gobject.Value
	x.GetProperty("vhomogeneous", &v)
	return v.GetBoolean()
}

// GetPropertyVisiblePageTag gets the "visible-page-tag" property.
// The tag of the currently visible page.
func (x *NavigationView) GetPropertyVisiblePageTag() string {
	var v gobject.Value
	x.GetProperty("visible-page-tag", &v)
	return v.GetString()
}

// Emitted when a push shortcut or a gesture is triggered.
//
// To support the push shortcuts and gestures, the application is expected to
// return the page to push in the handler.
//
// This signal can be emitted multiple times for the gestures, for example
// when the gesture is cancelled by the user. As such, the application must
// not make any irreversible changes in the handler, such as removing the page
// from a forward stack.
//
// Instead, it should be done in the [signal@NavigationView::pushed] handler.
func (x *NavigationView) ConnectGetNextPage(cb *func(NavigationView) NavigationPage) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "get-next-page", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) uintptr {
		fa := NavigationView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		GetNextPageCls := cbFn(fa)
		return GetNextPageCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "get-next-page", cbRefPtr)
}

// Emitted after @page has been popped from the navigation stack.
//
// See [method@NavigationView.pop].
//
// When using [method@NavigationView.pop_to_page] or
// [method@NavigationView.pop_to_tag], this signal is emitted for each of the
// popped pages.
func (x *NavigationView) ConnectPopped(cb *func(NavigationView, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "popped", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr) {
		fa := NavigationView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "popped", cbRefPtr)
}

// Emitted after a page has been pushed to the navigation stack.
//
// See [method@NavigationView.push].
func (x *NavigationView) ConnectPushed(cb *func(NavigationView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "pushed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "pushed", cbRefPtr)
}

// Emitted after the navigation stack has been replaced.
//
// See [method@NavigationView.replace].
func (x *NavigationView) ConnectReplaced(cb *func(NavigationView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "replaced", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "replaced", cbRefPtr)
}

// Gets the progress @self will snap back to after the gesture is canceled.
func (x *NavigationView) GetCancelProgress() float64 {

	cret := XAdwSwipeableGetCancelProgress(x.GoPointer())
	return cret
}

// Gets the swipe distance of @self.
//
// This corresponds to how many pixels 1 unit represents.
func (x *NavigationView) GetDistance() float64 {

	cret := XAdwSwipeableGetDistance(x.GoPointer())
	return cret
}

// Gets the current progress of @self.
func (x *NavigationView) GetProgress() float64 {

	cret := XAdwSwipeableGetProgress(x.GoPointer())
	return cret
}

// Gets the snap points of @self.
//
// Each snap point represents a progress value that is considered acceptable to
// end the swipe on.
func (x *NavigationView) GetSnapPoints(NSnapPointsVar *int) uintptr {

	cret := XAdwSwipeableGetSnapPoints(x.GoPointer(), NSnapPointsVar)
	return cret
}

// Gets the area @self can start a swipe from for the given direction and
// gesture type.
//
// This can be used to restrict swipes to only be possible from a certain area,
// for example, to only allow edge swipes, or to have a draggable element and
// ignore swipes elsewhere.
//
// If not implemented, the default implementation returns the allocation of
// @self, allowing swipes from anywhere.
func (x *NavigationView) GetSwipeArea(NavigationDirectionVar NavigationDirection, IsDragVar bool, RectVar *gdk.Rectangle) {

	XAdwSwipeableGetSwipeArea(x.GoPointer(), NavigationDirectionVar, IsDragVar, RectVar)

}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *NavigationView) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *NavigationView) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *NavigationView) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *NavigationView) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *NavigationView) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *NavigationView) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *NavigationView) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *NavigationView) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *NavigationView) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *NavigationView) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *NavigationView) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *NavigationView) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *NavigationView) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *NavigationView) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *NavigationView) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *NavigationView) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationView) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *NavigationView) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationView) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *NavigationView) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	core.SetPackageName("ADW", "libadwaita-1")
	core.SetSharedLibraries("ADW", []string{"libadwaita-1.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("ADW") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xNavigationPageGLibType, libs, "adw_navigation_page_get_type")

	core.PuregoSafeRegister(&xNewNavigationPage, libs, "adw_navigation_page_new")
	core.PuregoSafeRegister(&xNewNavigationPageWithTag, libs, "adw_navigation_page_new_with_tag")

	core.PuregoSafeRegister(&xNavigationPageGetCanPop, libs, "adw_navigation_page_get_can_pop")
	core.PuregoSafeRegister(&xNavigationPageGetChild, libs, "adw_navigation_page_get_child")
	core.PuregoSafeRegister(&xNavigationPageGetTag, libs, "adw_navigation_page_get_tag")
	core.PuregoSafeRegister(&xNavigationPageGetTitle, libs, "adw_navigation_page_get_title")
	core.PuregoSafeRegister(&xNavigationPageSetCanPop, libs, "adw_navigation_page_set_can_pop")
	core.PuregoSafeRegister(&xNavigationPageSetChild, libs, "adw_navigation_page_set_child")
	core.PuregoSafeRegister(&xNavigationPageSetTag, libs, "adw_navigation_page_set_tag")
	core.PuregoSafeRegister(&xNavigationPageSetTitle, libs, "adw_navigation_page_set_title")

	core.PuregoSafeRegister(&xNavigationViewGLibType, libs, "adw_navigation_view_get_type")

	core.PuregoSafeRegister(&xNewNavigationView, libs, "adw_navigation_view_new")

	core.PuregoSafeRegister(&xNavigationViewAdd, libs, "adw_navigation_view_add")
	core.PuregoSafeRegister(&xNavigationViewFindPage, libs, "adw_navigation_view_find_page")
	core.PuregoSafeRegister(&xNavigationViewGetAnimateTransitions, libs, "adw_navigation_view_get_animate_transitions")
	core.PuregoSafeRegister(&xNavigationViewGetHhomogeneous, libs, "adw_navigation_view_get_hhomogeneous")
	core.PuregoSafeRegister(&xNavigationViewGetNavigationStack, libs, "adw_navigation_view_get_navigation_stack")
	core.PuregoSafeRegister(&xNavigationViewGetPopOnEscape, libs, "adw_navigation_view_get_pop_on_escape")
	core.PuregoSafeRegister(&xNavigationViewGetPreviousPage, libs, "adw_navigation_view_get_previous_page")
	core.PuregoSafeRegister(&xNavigationViewGetVhomogeneous, libs, "adw_navigation_view_get_vhomogeneous")
	core.PuregoSafeRegister(&xNavigationViewGetVisiblePage, libs, "adw_navigation_view_get_visible_page")
	core.PuregoSafeRegister(&xNavigationViewGetVisiblePageTag, libs, "adw_navigation_view_get_visible_page_tag")
	core.PuregoSafeRegister(&xNavigationViewPop, libs, "adw_navigation_view_pop")
	core.PuregoSafeRegister(&xNavigationViewPopToPage, libs, "adw_navigation_view_pop_to_page")
	core.PuregoSafeRegister(&xNavigationViewPopToTag, libs, "adw_navigation_view_pop_to_tag")
	core.PuregoSafeRegister(&xNavigationViewPush, libs, "adw_navigation_view_push")
	core.PuregoSafeRegister(&xNavigationViewPushByTag, libs, "adw_navigation_view_push_by_tag")
	core.PuregoSafeRegister(&xNavigationViewRemove, libs, "adw_navigation_view_remove")
	core.PuregoSafeRegister(&xNavigationViewReplace, libs, "adw_navigation_view_replace")
	core.PuregoSafeRegister(&xNavigationViewReplaceWithTags, libs, "adw_navigation_view_replace_with_tags")
	core.PuregoSafeRegister(&xNavigationViewSetAnimateTransitions, libs, "adw_navigation_view_set_animate_transitions")
	core.PuregoSafeRegister(&xNavigationViewSetHhomogeneous, libs, "adw_navigation_view_set_hhomogeneous")
	core.PuregoSafeRegister(&xNavigationViewSetPopOnEscape, libs, "adw_navigation_view_set_pop_on_escape")
	core.PuregoSafeRegister(&xNavigationViewSetVhomogeneous, libs, "adw_navigation_view_set_vhomogeneous")

}
