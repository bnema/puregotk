// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type BottomSheetClass struct {
	_ structs.HostLayout

	ParentClass gtk.WidgetClass
}

func (x *BottomSheetClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A bottom sheet with an optional bottom bar.
//
// &lt;picture&gt;
//
//	&lt;source srcset="bottom-sheet-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="bottom-sheet.png" alt="bottom-sheet"&gt;
//
// &lt;/picture&gt;
//
// `AdwBottomSheet` has three child widgets. [property@BottomSheet:content] is
// shown persistently. [property@BottomSheet:sheet] is displayed above it when
// it's open, and [property@BottomSheet:bottom-bar] is displayed when it's not.
//
// Bottom sheet and bottom bar are attached to the bottom edge of the widget.
// They take the full width by default, but can only take a portion of it if
// [property@BottomSheet:full-width] is set to `FALSE`. In this case,
// [property@BottomSheet:align] determines where along the bottom edge they are
// placed.
//
// Bottom bar can be hidden using the [property@BottomSheet:reveal-bottom-bar]
// property.
//
// `AdwBottomSheet` can be useful for applications such as music players, that
// want to have a persistent bottom bar that expands into a bottom sheet when
// clicked. It's meant for cases where a bottom sheet is tightly integrated into
// the UI. For more transient bottom sheets, see [class@Dialog].
//
// To open or close the bottom sheet, use the [property@BottomSheet:open]
// property.
//
// By default, the bottom sheet has an overlaid drag handle. It can be disabled
// by setting [property@BottomSheet:show-drag-handle] to `FALSE`. Note that the
// handle also controls whether the sheet can be dragged using a pointer.
//
// Bottom sheets are modal by default, meaning that the content is dimmed and
// cannot be accessed while the sheet is open. Set [property@BottomSheet:modal]
// to `FALSE` if this behavior is unwanted.
//
// To disable user interactions for opening or closing the bottom sheet (such as
// swipes or clicking the bottom bar or close button), set
// [property@BottomSheet:can-open] or [property@BottomSheet:can-close] to
// `FALSE`.
//
// In some cases, particularly when using a full-width bottom bar, it may be
// necessary to shift [property@BottomSheet:content] upwards. Use the
// [property@BottomSheet:bottom-bar-height] and
// [property@BottomSheet:sheet-height] for that.
//
// `AdwBottomSheet` is not adaptive, and for larger window sizes applications
// may want to replace it with another UI, such as a sidebar. This can be done
// using [class@MultiLayoutView].
//
// ## Sizing
//
// Unlike [class@Dialog] presented as a bottom sheet, `AdwBottomSheet` just
// follows the content's natural size, and it's up to the applications to make
// sure their content provides one. For example, when using
// [class@Gtk.ScrolledWindow], make sure to set
// [property@Gtk.ScrolledWindow:propagate-natural-height] to `TRUE`.
//
// ## Header Bar Integration
//
// When placed inside an `AdwBottomSheet`, [class@HeaderBar] will not show the
// title when [property@BottomSheet:show-drag-handle] is `TRUE`, regardless of
// [property@HeaderBar:show-title]. This only applies to the default title,
// titles set with [property@HeaderBar:title-widget] will still be shown.
//
// ## `AdwBottomSheet` as `GtkBuildable`:
//
// The `AdwBottomSheet` implementation of the [iface@Gtk.Buildable] interface
// supports setting the sheet widget by specifying “sheet” as the “type”
// attribute of a `&lt;child&gt;` element, and the bottom bar by specifying
// “bottom-bar”. Specifying “content” or omitting the child type results in
// setting the content child.
type BottomSheet struct {
	gtk.Widget
}

var xBottomSheetGLibType func() types.GType

func BottomSheetGLibType() types.GType {
	return xBottomSheetGLibType()
}

func BottomSheetNewFromInternalPtr(ptr uintptr) *BottomSheet {
	cls := &BottomSheet{}
	cls.Ptr = ptr
	return cls
}

var xNewBottomSheet func() uintptr

// Creates a new `AdwBottomSheet`.
func NewBottomSheet() *BottomSheet {
	var cls *BottomSheet

	cret := xNewBottomSheet()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &BottomSheet{}
	cls.Ptr = cret
	return cls
}

var xBottomSheetGetAlign func(uintptr) float32

// Gets horizontal alignment of the bottom sheet.
func (x *BottomSheet) GetAlign() float32 {

	cret := xBottomSheetGetAlign(x.GoPointer())

	return cret
}

var xBottomSheetGetBottomBar func(uintptr) uintptr

// Gets the bottom bar widget for @self.
func (x *BottomSheet) GetBottomBar() *gtk.Widget {
	var cls *gtk.Widget

	cret := xBottomSheetGetBottomBar(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xBottomSheetGetBottomBarHeight func(uintptr) int

// Gets the current bottom bar height.
//
// It can be used to shift the content upwards permanently to accommodate for
// the bottom bar.
func (x *BottomSheet) GetBottomBarHeight() int {

	cret := xBottomSheetGetBottomBarHeight(x.GoPointer())

	return cret
}

var xBottomSheetGetCanClose func(uintptr) bool

// Gets whether the bottom sheet can be closed by user.
func (x *BottomSheet) GetCanClose() bool {

	cret := xBottomSheetGetCanClose(x.GoPointer())

	return cret
}

var xBottomSheetGetCanOpen func(uintptr) bool

// Gets whether the bottom sheet can be opened by user.
func (x *BottomSheet) GetCanOpen() bool {

	cret := xBottomSheetGetCanOpen(x.GoPointer())

	return cret
}

var xBottomSheetGetContent func(uintptr) uintptr

// Gets the content widget for @self.
func (x *BottomSheet) GetContent() *gtk.Widget {
	var cls *gtk.Widget

	cret := xBottomSheetGetContent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xBottomSheetGetFullWidth func(uintptr) bool

// Gets whether the bottom sheet takes the full width.
func (x *BottomSheet) GetFullWidth() bool {

	cret := xBottomSheetGetFullWidth(x.GoPointer())

	return cret
}

var xBottomSheetGetModal func(uintptr) bool

// Gets whether the bottom sheet is modal.
func (x *BottomSheet) GetModal() bool {

	cret := xBottomSheetGetModal(x.GoPointer())

	return cret
}

var xBottomSheetGetOpen func(uintptr) bool

// Gets whether the bottom sheet is open.
func (x *BottomSheet) GetOpen() bool {

	cret := xBottomSheetGetOpen(x.GoPointer())

	return cret
}

var xBottomSheetGetRevealBottomBar func(uintptr) bool

// Gets whether the bottom bar is revealed.
func (x *BottomSheet) GetRevealBottomBar() bool {

	cret := xBottomSheetGetRevealBottomBar(x.GoPointer())

	return cret
}

var xBottomSheetGetSheet func(uintptr) uintptr

// Gets the bottom sheet widget for @self.
func (x *BottomSheet) GetSheet() *gtk.Widget {
	var cls *gtk.Widget

	cret := xBottomSheetGetSheet(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xBottomSheetGetSheetHeight func(uintptr) int

// Gets the current bottom sheet height.
//
// It can be used to shift the content upwards when the bottom sheet is open.
func (x *BottomSheet) GetSheetHeight() int {

	cret := xBottomSheetGetSheetHeight(x.GoPointer())

	return cret
}

var xBottomSheetGetShowDragHandle func(uintptr) bool

// Gets whether to show a drag handle in the bottom sheet.
func (x *BottomSheet) GetShowDragHandle() bool {

	cret := xBottomSheetGetShowDragHandle(x.GoPointer())

	return cret
}

var xBottomSheetSetAlign func(uintptr, float32)

// Sets horizontal alignment of the bottom sheet.
//
// 0 means the bottom sheet is flush with the start edge, 1 means it's flush
// with the end edge. 0.5 means it's centered.
//
// Only used when [property@BottomSheet:full-width] is set to `FALSE`.
func (x *BottomSheet) SetAlign(AlignVar float32) {

	xBottomSheetSetAlign(x.GoPointer(), AlignVar)

}

var xBottomSheetSetBottomBar func(uintptr, uintptr)

// Sets the bottom bar widget for @self.
//
// Shown when [property@BottomSheet:open] is `FALSE`. When open, morphs into
// the [property@BottomSheet:sheet].
//
// Bottom bar can be temporarily hidden using the
// [property@BottomSheet:reveal-bottom-bar] property.
func (x *BottomSheet) SetBottomBar(BottomBarVar *gtk.Widget) {

	xBottomSheetSetBottomBar(x.GoPointer(), BottomBarVar.GoPointer())

}

var xBottomSheetSetCanClose func(uintptr, bool)

// Sets whether the bottom sheet can be closed by user.
//
// It can be closed via the close button, swiping down, pressing
// &lt;kbd&gt;Escape&lt;/kbd&gt; or clicking the content dimming (when modal).
//
// Bottom sheet can still be closed using [property@BottomSheet:open].
func (x *BottomSheet) SetCanClose(CanCloseVar bool) {

	xBottomSheetSetCanClose(x.GoPointer(), CanCloseVar)

}

var xBottomSheetSetCanOpen func(uintptr, bool)

// Sets whether the bottom sheet can be opened by user.
//
// It can be opened via clicking or swiping up from the bottom bar.
//
// Does nothing if [property@BottomSheet:bottom-bar] is not set.
//
// Bottom sheet can still be opened using [property@BottomSheet:open].
func (x *BottomSheet) SetCanOpen(CanOpenVar bool) {

	xBottomSheetSetCanOpen(x.GoPointer(), CanOpenVar)

}

var xBottomSheetSetContent func(uintptr, uintptr)

// Sets the content widget for @self.
//
// It's always shown, and the bottom sheet is overlaid over it.
func (x *BottomSheet) SetContent(ContentVar *gtk.Widget) {

	xBottomSheetSetContent(x.GoPointer(), ContentVar.GoPointer())

}

var xBottomSheetSetFullWidth func(uintptr, bool)

// Sets whether the bottom sheet takes the full width.
//
// When full width, [property@BottomSheet:align] is ignored.
func (x *BottomSheet) SetFullWidth(FullWidthVar bool) {

	xBottomSheetSetFullWidth(x.GoPointer(), FullWidthVar)

}

var xBottomSheetSetModal func(uintptr, bool)

// Sets whether the bottom sheet is modal.
//
// When modal, [property@BottomSheet:content] will be dimmed when the bottom
// sheet is open, and clicking it will close the bottom sheet. It also cannot be
// focused with keyboard.
//
// Otherwise, the content is accessible even when the bottom sheet is open.
func (x *BottomSheet) SetModal(ModalVar bool) {

	xBottomSheetSetModal(x.GoPointer(), ModalVar)

}

var xBottomSheetSetOpen func(uintptr, bool)

// Sets whether the bottom sheet is open.
func (x *BottomSheet) SetOpen(OpenVar bool) {

	xBottomSheetSetOpen(x.GoPointer(), OpenVar)

}

var xBottomSheetSetRevealBottomBar func(uintptr, bool)

// Sets whether to reveal the bottom bar.
//
// The transition will be animated.
//
// See [property@BottomSheet:bottom-bar] and
// [property@BottomSheet:bottom-bar-height].
func (x *BottomSheet) SetRevealBottomBar(RevealVar bool) {

	xBottomSheetSetRevealBottomBar(x.GoPointer(), RevealVar)

}

var xBottomSheetSetSheet func(uintptr, uintptr)

// Sets the bottom sheet widget for @self.
//
// Only shown when [property@BottomSheet:open] is `TRUE`.
func (x *BottomSheet) SetSheet(SheetVar *gtk.Widget) {

	xBottomSheetSetSheet(x.GoPointer(), SheetVar.GoPointer())

}

var xBottomSheetSetShowDragHandle func(uintptr, bool)

// Sets whether to show a drag handle in the bottom sheet.
//
// The handle will be overlaid over [property@BottomSheet:sheet].
//
// When the handle is shown, [class@HeaderBar] will hide its default title, and
// [class@ToolbarView] will reserve space if there are no top bars.
//
// Showing drag handle also allows to swipe the bottom sheet down (and to swipe
// the bottom bar up) with a pointer, instead of just touchscreen.
func (x *BottomSheet) SetShowDragHandle(ShowDragHandleVar bool) {

	xBottomSheetSetShowDragHandle(x.GoPointer(), ShowDragHandleVar)

}

func (c *BottomSheet) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *BottomSheet) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAlign sets the "align" property.
// Horizontal alignment of the bottom sheet.
//
// 0 means the bottom sheet is flush with the start edge, 1 means it's flush
// with the end edge. 0.5 means it's centered.
//
// Only used when [property@BottomSheet:full-width] is set to `FALSE`.
func (x *BottomSheet) SetPropertyAlign(value float32) {
	var v gobject.Value
	v.Init(gobject.TypeFloatVal)
	v.SetFloat(value)
	x.SetProperty("align", &v)
}

// GetPropertyAlign gets the "align" property.
// Horizontal alignment of the bottom sheet.
//
// 0 means the bottom sheet is flush with the start edge, 1 means it's flush
// with the end edge. 0.5 means it's centered.
//
// Only used when [property@BottomSheet:full-width] is set to `FALSE`.
func (x *BottomSheet) GetPropertyAlign() float32 {
	var v gobject.Value
	x.GetProperty("align", &v)
	return v.GetFloat()
}

// GetPropertyBottomBarHeight gets the "bottom-bar-height" property.
// The current bottom bar height.
//
// It can be used to shift the content upwards permanently to accommodate for
// the bottom bar.
func (x *BottomSheet) GetPropertyBottomBarHeight() int {
	var v gobject.Value
	x.GetProperty("bottom-bar-height", &v)
	return v.GetInt()
}

// SetPropertyCanClose sets the "can-close" property.
// Whether the bottom sheet can be closed by user.
//
// It can be closed via the close button, swiping down, pressing
// &lt;kbd&gt;Escape&lt;/kbd&gt; or clicking the content dimming (when modal).
//
// Bottom sheet can still be closed using [property@BottomSheet:open].
func (x *BottomSheet) SetPropertyCanClose(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("can-close", &v)
}

// GetPropertyCanClose gets the "can-close" property.
// Whether the bottom sheet can be closed by user.
//
// It can be closed via the close button, swiping down, pressing
// &lt;kbd&gt;Escape&lt;/kbd&gt; or clicking the content dimming (when modal).
//
// Bottom sheet can still be closed using [property@BottomSheet:open].
func (x *BottomSheet) GetPropertyCanClose() bool {
	var v gobject.Value
	x.GetProperty("can-close", &v)
	return v.GetBoolean()
}

// SetPropertyCanOpen sets the "can-open" property.
// Whether the bottom sheet can be opened by user.
//
// It can be opened via clicking or swiping up from the bottom bar.
//
// Does nothing if [property@BottomSheet:bottom-bar] is not set.
//
// Bottom sheet can still be opened using [property@BottomSheet:open].
func (x *BottomSheet) SetPropertyCanOpen(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("can-open", &v)
}

// GetPropertyCanOpen gets the "can-open" property.
// Whether the bottom sheet can be opened by user.
//
// It can be opened via clicking or swiping up from the bottom bar.
//
// Does nothing if [property@BottomSheet:bottom-bar] is not set.
//
// Bottom sheet can still be opened using [property@BottomSheet:open].
func (x *BottomSheet) GetPropertyCanOpen() bool {
	var v gobject.Value
	x.GetProperty("can-open", &v)
	return v.GetBoolean()
}

// SetPropertyFullWidth sets the "full-width" property.
// Whether the bottom sheet takes the full width.
//
// When full width, [property@BottomSheet:align] is ignored.
func (x *BottomSheet) SetPropertyFullWidth(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("full-width", &v)
}

// GetPropertyFullWidth gets the "full-width" property.
// Whether the bottom sheet takes the full width.
//
// When full width, [property@BottomSheet:align] is ignored.
func (x *BottomSheet) GetPropertyFullWidth() bool {
	var v gobject.Value
	x.GetProperty("full-width", &v)
	return v.GetBoolean()
}

// SetPropertyModal sets the "modal" property.
// Whether the bottom sheet is modal.
//
// When modal, [property@BottomSheet:content] will be dimmed when the bottom
// sheet is open, and clicking it will close the bottom sheet. It also cannot
// be focused with keyboard.
//
// Otherwise, the content is accessible even when the bottom sheet is open.
func (x *BottomSheet) SetPropertyModal(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("modal", &v)
}

// GetPropertyModal gets the "modal" property.
// Whether the bottom sheet is modal.
//
// When modal, [property@BottomSheet:content] will be dimmed when the bottom
// sheet is open, and clicking it will close the bottom sheet. It also cannot
// be focused with keyboard.
//
// Otherwise, the content is accessible even when the bottom sheet is open.
func (x *BottomSheet) GetPropertyModal() bool {
	var v gobject.Value
	x.GetProperty("modal", &v)
	return v.GetBoolean()
}

// SetPropertyOpen sets the "open" property.
// Whether the bottom sheet is open.
func (x *BottomSheet) SetPropertyOpen(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("open", &v)
}

// GetPropertyOpen gets the "open" property.
// Whether the bottom sheet is open.
func (x *BottomSheet) GetPropertyOpen() bool {
	var v gobject.Value
	x.GetProperty("open", &v)
	return v.GetBoolean()
}

// SetPropertyRevealBottomBar sets the "reveal-bottom-bar" property.
// Whether to reveal the bottom bar.
//
// The transition will be animated.
//
// See [property@BottomSheet:bottom-bar] and
// [property@BottomSheet:bottom-bar-height].
func (x *BottomSheet) SetPropertyRevealBottomBar(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("reveal-bottom-bar", &v)
}

// GetPropertyRevealBottomBar gets the "reveal-bottom-bar" property.
// Whether to reveal the bottom bar.
//
// The transition will be animated.
//
// See [property@BottomSheet:bottom-bar] and
// [property@BottomSheet:bottom-bar-height].
func (x *BottomSheet) GetPropertyRevealBottomBar() bool {
	var v gobject.Value
	x.GetProperty("reveal-bottom-bar", &v)
	return v.GetBoolean()
}

// GetPropertySheetHeight gets the "sheet-height" property.
// The current bottom sheet height.
//
// It can be used to shift the content upwards when the bottom sheet is open.
func (x *BottomSheet) GetPropertySheetHeight() int {
	var v gobject.Value
	x.GetProperty("sheet-height", &v)
	return v.GetInt()
}

// SetPropertyShowDragHandle sets the "show-drag-handle" property.
// Whether to overlay a drag handle in the bottom sheet.
//
// The handle will be overlaid over [property@BottomSheet:sheet].
//
// When the handle is shown, [class@HeaderBar] will hide its default title,
// and [class@ToolbarView] will reserve space if there are no top bars.
//
// Showing drag handle also allows to swipe the bottom sheet down (and to
// swipe the bottom bar up) with a pointer, instead of just touchscreen.
func (x *BottomSheet) SetPropertyShowDragHandle(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("show-drag-handle", &v)
}

// GetPropertyShowDragHandle gets the "show-drag-handle" property.
// Whether to overlay a drag handle in the bottom sheet.
//
// The handle will be overlaid over [property@BottomSheet:sheet].
//
// When the handle is shown, [class@HeaderBar] will hide its default title,
// and [class@ToolbarView] will reserve space if there are no top bars.
//
// Showing drag handle also allows to swipe the bottom sheet down (and to
// swipe the bottom bar up) with a pointer, instead of just touchscreen.
func (x *BottomSheet) GetPropertyShowDragHandle() bool {
	var v gobject.Value
	x.GetProperty("show-drag-handle", &v)
	return v.GetBoolean()
}

// Emitted when the close button or shortcut is used while
// [property@Dialog:can-close] is set to `FALSE`.
func (x *BottomSheet) ConnectCloseAttempt(cb *func(BottomSheet)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "close-attempt", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := BottomSheet{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "close-attempt", cbRefPtr)
}

// Gets the progress @self will snap back to after the gesture is canceled.
func (x *BottomSheet) GetCancelProgress() float64 {

	cret := XAdwSwipeableGetCancelProgress(x.GoPointer())

	return cret
}

// Gets the swipe distance of @self.
//
// This corresponds to how many pixels 1 unit represents.
func (x *BottomSheet) GetDistance() float64 {

	cret := XAdwSwipeableGetDistance(x.GoPointer())

	return cret
}

// Gets the current progress of @self.
func (x *BottomSheet) GetProgress() float64 {

	cret := XAdwSwipeableGetProgress(x.GoPointer())

	return cret
}

// Gets the snap points of @self.
//
// Each snap point represents a progress value that is considered acceptable to
// end the swipe on.
func (x *BottomSheet) GetSnapPoints(NSnapPointsVar *int) uintptr {

	cret := XAdwSwipeableGetSnapPoints(x.GoPointer(), NSnapPointsVar)

	return cret
}

// Gets the area @self can start a swipe from for the given direction and
// gesture type.
//
// This can be used to restrict swipes to only be possible from a certain area,
// for example, to only allow edge swipes, or to have a draggable element and
// ignore swipes elsewhere.
//
// If not implemented, the default implementation returns the allocation of
// @self, allowing swipes from anywhere.
func (x *BottomSheet) GetSwipeArea(NavigationDirectionVar NavigationDirection, IsDragVar bool, RectVar *gdk.Rectangle) {

	XAdwSwipeableGetSwipeArea(x.GoPointer(), NavigationDirectionVar, IsDragVar, RectVar)

}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *BottomSheet) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *BottomSheet) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *BottomSheet) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())

	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *BottomSheet) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *BottomSheet) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)

	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *BottomSheet) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *BottomSheet) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *BottomSheet) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)

	return cret
}

// Resets the accessible property to its default value.
func (x *BottomSheet) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *BottomSheet) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *BottomSheet) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *BottomSheet) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *BottomSheet) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *BottomSheet) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *BottomSheet) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *BottomSheet) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *BottomSheet) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *BottomSheet) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *BottomSheet) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *BottomSheet) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *BottomSheet) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())

	return cret
}

func init() {
	core.SetPackageName("ADW", "libadwaita-1")
	core.SetSharedLibraries("ADW", []string{"libadwaita-1.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("ADW") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xBottomSheetGLibType, libs, "adw_bottom_sheet_get_type")

	core.PuregoSafeRegister(&xNewBottomSheet, libs, "adw_bottom_sheet_new")

	core.PuregoSafeRegister(&xBottomSheetGetAlign, libs, "adw_bottom_sheet_get_align")
	core.PuregoSafeRegister(&xBottomSheetGetBottomBar, libs, "adw_bottom_sheet_get_bottom_bar")
	core.PuregoSafeRegister(&xBottomSheetGetBottomBarHeight, libs, "adw_bottom_sheet_get_bottom_bar_height")
	core.PuregoSafeRegister(&xBottomSheetGetCanClose, libs, "adw_bottom_sheet_get_can_close")
	core.PuregoSafeRegister(&xBottomSheetGetCanOpen, libs, "adw_bottom_sheet_get_can_open")
	core.PuregoSafeRegister(&xBottomSheetGetContent, libs, "adw_bottom_sheet_get_content")
	core.PuregoSafeRegister(&xBottomSheetGetFullWidth, libs, "adw_bottom_sheet_get_full_width")
	core.PuregoSafeRegister(&xBottomSheetGetModal, libs, "adw_bottom_sheet_get_modal")
	core.PuregoSafeRegister(&xBottomSheetGetOpen, libs, "adw_bottom_sheet_get_open")
	core.PuregoSafeRegister(&xBottomSheetGetRevealBottomBar, libs, "adw_bottom_sheet_get_reveal_bottom_bar")
	core.PuregoSafeRegister(&xBottomSheetGetSheet, libs, "adw_bottom_sheet_get_sheet")
	core.PuregoSafeRegister(&xBottomSheetGetSheetHeight, libs, "adw_bottom_sheet_get_sheet_height")
	core.PuregoSafeRegister(&xBottomSheetGetShowDragHandle, libs, "adw_bottom_sheet_get_show_drag_handle")
	core.PuregoSafeRegister(&xBottomSheetSetAlign, libs, "adw_bottom_sheet_set_align")
	core.PuregoSafeRegister(&xBottomSheetSetBottomBar, libs, "adw_bottom_sheet_set_bottom_bar")
	core.PuregoSafeRegister(&xBottomSheetSetCanClose, libs, "adw_bottom_sheet_set_can_close")
	core.PuregoSafeRegister(&xBottomSheetSetCanOpen, libs, "adw_bottom_sheet_set_can_open")
	core.PuregoSafeRegister(&xBottomSheetSetContent, libs, "adw_bottom_sheet_set_content")
	core.PuregoSafeRegister(&xBottomSheetSetFullWidth, libs, "adw_bottom_sheet_set_full_width")
	core.PuregoSafeRegister(&xBottomSheetSetModal, libs, "adw_bottom_sheet_set_modal")
	core.PuregoSafeRegister(&xBottomSheetSetOpen, libs, "adw_bottom_sheet_set_open")
	core.PuregoSafeRegister(&xBottomSheetSetRevealBottomBar, libs, "adw_bottom_sheet_set_reveal_bottom_bar")
	core.PuregoSafeRegister(&xBottomSheetSetSheet, libs, "adw_bottom_sheet_set_sheet")
	core.PuregoSafeRegister(&xBottomSheetSetShowDragHandle, libs, "adw_bottom_sheet_set_show_drag_handle")

}
