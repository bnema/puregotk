// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type ToggleClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *ToggleClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type ToggleGroupClass struct {
	_ structs.HostLayout

	ParentClass gtk.WidgetClass
}

func (x *ToggleGroupClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A toggle within [class@ToggleGroup].
//
// `AdwToggle` can optionally have a name, set with [property@Toggle:name].
// If the name is set, [property@ToggleGroup:active-name] can be used to access
// toggles instead of index.
type Toggle struct {
	gobject.Object
}

var xToggleGLibType func() types.GType

func ToggleGLibType() types.GType {
	return xToggleGLibType()
}

func ToggleNewFromInternalPtr(ptr uintptr) *Toggle {
	cls := &Toggle{}
	cls.Ptr = ptr
	return cls
}

var xNewToggle func() uintptr

// Creates a new `AdwToggle`.
func NewToggle() *Toggle {
	var cls *Toggle

	cret := xNewToggle()

	if cret == 0 {
		return nil
	}
	cls = &Toggle{}
	cls.Ptr = cret
	return cls
}

var xToggleGetChild func(uintptr) uintptr

// Gets the child widget of @self.
func (x *Toggle) GetChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xToggleGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xToggleGetEnabled func(uintptr) bool

// Gets whether @self is enabled.
func (x *Toggle) GetEnabled() bool {

	cret := xToggleGetEnabled(x.GoPointer())
	return cret
}

var xToggleGetIconName func(uintptr) string

// Gets the icon name of @self.
func (x *Toggle) GetIconName() string {

	cret := xToggleGetIconName(x.GoPointer())
	return cret
}

var xToggleGetIndex func(uintptr) uint

// Gets the index of @self within its toggle group.
func (x *Toggle) GetIndex() uint {

	cret := xToggleGetIndex(x.GoPointer())
	return cret
}

var xToggleGetLabel func(uintptr) string

// Gets the label of @self.
func (x *Toggle) GetLabel() string {

	cret := xToggleGetLabel(x.GoPointer())
	return cret
}

var xToggleGetName func(uintptr) string

// Gets the name of @self.
func (x *Toggle) GetName() string {

	cret := xToggleGetName(x.GoPointer())
	return cret
}

var xToggleGetTooltip func(uintptr) string

// Gets the tooltip of @self.
func (x *Toggle) GetTooltip() string {

	cret := xToggleGetTooltip(x.GoPointer())
	return cret
}

var xToggleGetUseUnderline func(uintptr) bool

// Gets whether @self uses underlines.
func (x *Toggle) GetUseUnderline() bool {

	cret := xToggleGetUseUnderline(x.GoPointer())
	return cret
}

var xToggleSetChild func(uintptr, uintptr)

// Sets the child of @self to @child.
//
// When the child is set, icon and label are not displayed.
//
// It's recommended to still set the label, as it can still be used by the
// screen reader.
func (x *Toggle) SetChild(ChildVar *gtk.Widget) {

	xToggleSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xToggleSetEnabled func(uintptr, bool)

// Sets whether @self is enabled.
func (x *Toggle) SetEnabled(EnabledVar bool) {

	xToggleSetEnabled(x.GoPointer(), EnabledVar)

}

var xToggleSetIconName func(uintptr, uintptr)

// Sets the icon name of @self to @icon_name.
//
// The icon will be displayed alone or next to the label, unless
// [property@Toggle:child] is set.
func (x *Toggle) SetIconName(IconNameVar *string) {

	xToggleSetIconName(x.GoPointer(), core.NullableStringToPtr(IconNameVar))

}

var xToggleSetLabel func(uintptr, uintptr)

// Sets the label of @self to @label.
//
// The label will be displayed alone or next to the icon, unless
// [property@Toggle:child] is set, but will still be read out by the screen
// reader.
func (x *Toggle) SetLabel(LabelVar *string) {

	xToggleSetLabel(x.GoPointer(), core.NullableStringToPtr(LabelVar))

}

var xToggleSetName func(uintptr, uintptr)

// Sets the name of @self to @name.
//
// Allows accessing @self by its name instead of index.
//
// See [property@ToggleGroup:active-name].
func (x *Toggle) SetName(NameVar *string) {

	xToggleSetName(x.GoPointer(), core.NullableStringToPtr(NameVar))

}

var xToggleSetTooltip func(uintptr, string)

// Sets the tooltip of @self to @tooltip.
//
// @tooltip can be marked up with the Pango text markup language.
func (x *Toggle) SetTooltip(TooltipVar string) {

	xToggleSetTooltip(x.GoPointer(), TooltipVar)

}

var xToggleSetUseUnderline func(uintptr, bool)

// Sets whether an embedded underline in the label indicates a mnemonic.
//
// See [property@Toggle:label].
func (x *Toggle) SetUseUnderline(UseUnderlineVar bool) {

	xToggleSetUseUnderline(x.GoPointer(), UseUnderlineVar)

}

func (c *Toggle) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Toggle) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyEnabled sets the "enabled" property.
// Whether this toggle is enabled.
func (x *Toggle) SetPropertyEnabled(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("enabled", &v)
}

// GetPropertyEnabled gets the "enabled" property.
// Whether this toggle is enabled.
func (x *Toggle) GetPropertyEnabled() bool {
	var v gobject.Value
	x.GetProperty("enabled", &v)
	return v.GetBoolean()
}

// SetPropertyIconName sets the "icon-name" property.
// The toggle icon name.
//
// The icon will be displayed alone or next to the label, unless
// [property@Toggle:child] is set.
func (x *Toggle) SetPropertyIconName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("icon-name", &v)
}

// GetPropertyIconName gets the "icon-name" property.
// The toggle icon name.
//
// The icon will be displayed alone or next to the label, unless
// [property@Toggle:child] is set.
func (x *Toggle) GetPropertyIconName() string {
	var v gobject.Value
	x.GetProperty("icon-name", &v)
	return v.GetString()
}

// SetPropertyLabel sets the "label" property.
// The toggle label.
//
// The label will be displayed alone or next to the icon, unless
// [property@Toggle:child] is set, but will still be read out by the screen
// reader.
func (x *Toggle) SetPropertyLabel(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("label", &v)
}

// GetPropertyLabel gets the "label" property.
// The toggle label.
//
// The label will be displayed alone or next to the icon, unless
// [property@Toggle:child] is set, but will still be read out by the screen
// reader.
func (x *Toggle) GetPropertyLabel() string {
	var v gobject.Value
	x.GetProperty("label", &v)
	return v.GetString()
}

// SetPropertyName sets the "name" property.
// The toggle name.
//
// Allows accessing the toggle by its name instead of index.
//
// See [property@ToggleGroup:active-name].
func (x *Toggle) SetPropertyName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("name", &v)
}

// GetPropertyName gets the "name" property.
// The toggle name.
//
// Allows accessing the toggle by its name instead of index.
//
// See [property@ToggleGroup:active-name].
func (x *Toggle) GetPropertyName() string {
	var v gobject.Value
	x.GetProperty("name", &v)
	return v.GetString()
}

// SetPropertyTooltip sets the "tooltip" property.
// The tooltip of the toggle.
//
// The tooltip can be marked up with the Pango text markup language.
func (x *Toggle) SetPropertyTooltip(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("tooltip", &v)
}

// GetPropertyTooltip gets the "tooltip" property.
// The tooltip of the toggle.
//
// The tooltip can be marked up with the Pango text markup language.
func (x *Toggle) GetPropertyTooltip() string {
	var v gobject.Value
	x.GetProperty("tooltip", &v)
	return v.GetString()
}

// SetPropertyUseUnderline sets the "use-underline" property.
// Whether an embedded underline in the label indicates a mnemonic.
//
// See [property@Toggle:label].
func (x *Toggle) SetPropertyUseUnderline(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("use-underline", &v)
}

// GetPropertyUseUnderline gets the "use-underline" property.
// Whether an embedded underline in the label indicates a mnemonic.
//
// See [property@Toggle:label].
func (x *Toggle) GetPropertyUseUnderline() bool {
	var v gobject.Value
	x.GetProperty("use-underline", &v)
	return v.GetBoolean()
}

// A group of exclusive toggles.
//
// &lt;picture&gt;
//
//	&lt;source srcset="toggle-group-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="toggle-group.png" alt="toggle-group"&gt;
//
// &lt;/picture&gt;
//
// `AdwToggleGroup` presents a set of exclusive toggles, represented as
// [class@Toggle] objects. Each toggle can display an icon, a label, an icon
// and a label, or a custom child.
//
// Toggles are indexed by their position, with the first toggle being equivalent
// to 0, and so on. Use the [property@ToggleGroup:active] to get that position.
//
// Toggles can also have optional names, set via the [property@Toggle:name]
// property. The name of the active toggle can be accessed via the
// [property@ToggleGroup:active-name] property.
//
// `AdwToggle` objects can be retrieved via their index or name, using
// [method@ToggleGroup.get_toggle] or [method@ToggleGroup.get_toggle_by_name]
// respectively. `AdwToggleGroup` also provides a [iface@Gtk.SelectionModel] of
// its toggles via the [property@ToggleGroup:toggles] property.
//
// `AdwToggleGroup` is orientable, and the toggles can be displayed horizontally
// or vertically. This is mostly useful for icon-only toggles.
//
// Use the [property@ToggleGroup:homogeneous] property to make the toggles take
// the same size, and the [property@ToggleGroup:can-shrink] to control whether
// the toggles can ellipsize.
//
// Example of an `AdwToggleGroup` UI definition:
//
// ```xml
//
//	&lt;object class="AdwToggleGroup"&gt;
//	  &lt;property name="active-name"&gt;picture&lt;/property&gt;
//	  &lt;child&gt;
//	    &lt;object class="AdwToggle"&gt;
//	      &lt;property name="icon-name"&gt;camera-photo-symbolic&lt;/property&gt;
//	      &lt;property name="tooltip" translatable="yes"&gt;Picture Mode&lt;/property&gt;
//	      &lt;property name="name"&gt;picture&lt;/property&gt;
//	    &lt;/object&gt;
//	  &lt;/child&gt;
//	  &lt;child&gt;
//	    &lt;object class="AdwToggle"&gt;
//	      &lt;property name="icon-name"&gt;camera-video-symbolic&lt;/property&gt;
//	      &lt;property name="tooltip" translatable="yes"&gt;Recording Mode&lt;/property&gt;
//	      &lt;property name="name"&gt;recording&lt;/property&gt;
//	    &lt;/object&gt;
//	  &lt;/child&gt;
//	&lt;/object&gt;
//
// ```
//
// See also: [class@InlineViewSwitcher].
//
// ## CSS nodes
//
// `AdwToggleGroup` has a main CSS node with the name `toggle-group`.
//
// Its toggles have CSS nodes with the name `toggle`, and its separators have nodes
// with the name `separator`.
//
// Toggle nodes will have a different style classes depending on their content:
// `.text-button` for labels, `.image-button` for icons, `.image-text-button`
// for both or no style class for custom children.
//
// The hidden separators use the `.hidden` style class.
//
// ## Style classes
//
// `AdwToggleGroup` can use the [`.flat`](style-classes.html#flat_1) style class
// to remove its background and make it look like a group of buttons.
//
// &lt;picture&gt;
//
//	&lt;source srcset="toggle-group-flat-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="toggle-group-flat.png" alt="toggle-group-flat"&gt;
//
// &lt;/picture&gt;
//
// It can also use the [`.round`](style-classes.html#round) style class to make
// its toggles and the group itself rounded.
//
// &lt;picture&gt;
//
//	&lt;source srcset="toggle-group-round-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="toggle-group-round.png" alt="toggle-group-round"&gt;
//
// &lt;/picture&gt;
//
// They can also be combined with each other.
//
// &lt;picture&gt;
//
//	&lt;source srcset="toggle-group-flat-round-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="toggle-group-flat-round.png" alt="toggle-group-flat-round"&gt;
//
// &lt;/picture&gt;
//
// ## Accessibility
//
// `AdwToggleGroup` uses the `GTK_ACCESSIBLE_ROLE_RADIO_GROUP` role. Its toggles
// use the `GTK_ACCESSIBLE_ROLE_RADIO` role.
type ToggleGroup struct {
	gtk.Widget
}

var xToggleGroupGLibType func() types.GType

func ToggleGroupGLibType() types.GType {
	return xToggleGroupGLibType()
}

func ToggleGroupNewFromInternalPtr(ptr uintptr) *ToggleGroup {
	cls := &ToggleGroup{}
	cls.Ptr = ptr
	return cls
}

var xNewToggleGroup func() uintptr

// Creates a new `AdwToggleGroup`.
func NewToggleGroup() *ToggleGroup {
	var cls *ToggleGroup

	cret := xNewToggleGroup()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ToggleGroup{}
	cls.Ptr = cret
	return cls
}

var xToggleGroupAdd func(uintptr, uintptr)

// Adds a toggle to @self.
func (x *ToggleGroup) Add(ToggleVar *Toggle) {

	xToggleGroupAdd(x.GoPointer(), ToggleVar.GoPointer())

}

var xToggleGroupGetActive func(uintptr) uint

// Gets the index of the active toggle in @self.
//
// Returns `GTK_INVALID_LIST_POSITION` if no toggle is active.
func (x *ToggleGroup) GetActive() uint {

	cret := xToggleGroupGetActive(x.GoPointer())
	return cret
}

var xToggleGroupGetActiveName func(uintptr) string

// Gets the name of the active toggle in @self.
//
// Can be `NULL` if the currently active toggle doesn't have a name.
//
// See [property@Toggle:name].
func (x *ToggleGroup) GetActiveName() string {

	cret := xToggleGroupGetActiveName(x.GoPointer())
	return cret
}

var xToggleGroupGetCanShrink func(uintptr) bool

// Gets whether the toggles can be smaller than the natural size of their
// contents.
func (x *ToggleGroup) GetCanShrink() bool {

	cret := xToggleGroupGetCanShrink(x.GoPointer())
	return cret
}

var xToggleGroupGetHomogeneous func(uintptr) bool

// Gets whether all toggles take the same size.
func (x *ToggleGroup) GetHomogeneous() bool {

	cret := xToggleGroupGetHomogeneous(x.GoPointer())
	return cret
}

var xToggleGroupGetNToggles func(uintptr) uint

// Gets the number of toggles within @self.
func (x *ToggleGroup) GetNToggles() uint {

	cret := xToggleGroupGetNToggles(x.GoPointer())
	return cret
}

var xToggleGroupGetToggle func(uintptr, uint) uintptr

// Gets the toggle with @index from @self.
func (x *ToggleGroup) GetToggle(IndexVar uint) *Toggle {
	var cls *Toggle

	cret := xToggleGroupGetToggle(x.GoPointer(), IndexVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Toggle{}
	cls.Ptr = cret
	return cls
}

var xToggleGroupGetToggleByName func(uintptr, string) uintptr

// Gets the toggle with the name @name from @self.
func (x *ToggleGroup) GetToggleByName(NameVar string) *Toggle {
	var cls *Toggle

	cret := xToggleGroupGetToggleByName(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Toggle{}
	cls.Ptr = cret
	return cls
}

var xToggleGroupGetToggles func(uintptr) uintptr

// Returns a [iface@Gio.ListModel] that contains the toggles of the group.
//
// This can be used to keep an up-to-date view. The model also implements
// [iface@Gtk.SelectionModel] and can be used to track and change the active
// toggle.
func (x *ToggleGroup) GetToggles() *gtk.SelectionModelBase {
	var cls *gtk.SelectionModelBase

	cret := xToggleGroupGetToggles(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.SelectionModelBase{}
	cls.Ptr = cret
	return cls
}

var xToggleGroupRemove func(uintptr, uintptr)

// Removes @toggle from @self.
func (x *ToggleGroup) Remove(ToggleVar *Toggle) {

	xToggleGroupRemove(x.GoPointer(), ToggleVar.GoPointer())

}

var xToggleGroupRemoveAll func(uintptr)

// Removes all toggles from @self.
func (x *ToggleGroup) RemoveAll() {

	xToggleGroupRemoveAll(x.GoPointer())

}

var xToggleGroupSetActive func(uintptr, uint)

// Sets the active toggle for @self.
//
// If the index is larger than the number of toggles in @self, unsets the
// current active toggle.
func (x *ToggleGroup) SetActive(ActiveVar uint) {

	xToggleGroupSetActive(x.GoPointer(), ActiveVar)

}

var xToggleGroupSetActiveName func(uintptr, uintptr)

// Sets the active toggle for @self.
//
// The name can be set via [property@Toggle:name].
//
// If @name is `NULL`, unset the current active toggle instead.
func (x *ToggleGroup) SetActiveName(NameVar *string) {

	xToggleGroupSetActiveName(x.GoPointer(), core.NullableStringToPtr(NameVar))

}

var xToggleGroupSetCanShrink func(uintptr, bool)

// Sets whether the toggles can be smaller than the natural size of their
// contents.
//
// If @can_shrink is `TRUE`, the toggle labels will ellipsize.
//
// See [property@Gtk.Button:can-shrink].
func (x *ToggleGroup) SetCanShrink(CanShrinkVar bool) {

	xToggleGroupSetCanShrink(x.GoPointer(), CanShrinkVar)

}

var xToggleGroupSetHomogeneous func(uintptr, bool)

// Sets whether all toggles take the same size.
func (x *ToggleGroup) SetHomogeneous(HomogeneousVar bool) {

	xToggleGroupSetHomogeneous(x.GoPointer(), HomogeneousVar)

}

func (c *ToggleGroup) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *ToggleGroup) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyActive sets the "active" property.
// The index of the active toggle.
//
// Setting the index to a larger value than the number of toggles in the group
// unsets the current active toggle.
//
// If no toggle is active, the property will be set to
// [const@Gtk.INVALID_LIST_POSITION].
func (x *ToggleGroup) SetPropertyActive(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("active", &v)
}

// GetPropertyActive gets the "active" property.
// The index of the active toggle.
//
// Setting the index to a larger value than the number of toggles in the group
// unsets the current active toggle.
//
// If no toggle is active, the property will be set to
// [const@Gtk.INVALID_LIST_POSITION].
func (x *ToggleGroup) GetPropertyActive() uint {
	var v gobject.Value
	x.GetProperty("active", &v)
	return v.GetUint()
}

// SetPropertyActiveName sets the "active-name" property.
// The name of the active toggle.
//
// The name can be set via [property@Toggle:name]. If the currently active
// toggle doesn't have a name, the property will be set to `NULL`.
//
// Set it to `NULL` to unset the current active toggle.
func (x *ToggleGroup) SetPropertyActiveName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("active-name", &v)
}

// GetPropertyActiveName gets the "active-name" property.
// The name of the active toggle.
//
// The name can be set via [property@Toggle:name]. If the currently active
// toggle doesn't have a name, the property will be set to `NULL`.
//
// Set it to `NULL` to unset the current active toggle.
func (x *ToggleGroup) GetPropertyActiveName() string {
	var v gobject.Value
	x.GetProperty("active-name", &v)
	return v.GetString()
}

// SetPropertyCanShrink sets the "can-shrink" property.
// Whether the toggles can be smaller than the natural size of their contents.
//
// If set to `TRUE`, the toggle labels will ellipsize.
//
// See [property@Gtk.Button:can-shrink].
func (x *ToggleGroup) SetPropertyCanShrink(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("can-shrink", &v)
}

// GetPropertyCanShrink gets the "can-shrink" property.
// Whether the toggles can be smaller than the natural size of their contents.
//
// If set to `TRUE`, the toggle labels will ellipsize.
//
// See [property@Gtk.Button:can-shrink].
func (x *ToggleGroup) GetPropertyCanShrink() bool {
	var v gobject.Value
	x.GetProperty("can-shrink", &v)
	return v.GetBoolean()
}

// SetPropertyHomogeneous sets the "homogeneous" property.
// Whether all toggles take the same size.
func (x *ToggleGroup) SetPropertyHomogeneous(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("homogeneous", &v)
}

// GetPropertyHomogeneous gets the "homogeneous" property.
// Whether all toggles take the same size.
func (x *ToggleGroup) GetPropertyHomogeneous() bool {
	var v gobject.Value
	x.GetProperty("homogeneous", &v)
	return v.GetBoolean()
}

// GetPropertyNToggles gets the "n-toggles" property.
// The number of toggles within the group.
func (x *ToggleGroup) GetPropertyNToggles() uint {
	var v gobject.Value
	x.GetProperty("n-toggles", &v)
	return v.GetUint()
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *ToggleGroup) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *ToggleGroup) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *ToggleGroup) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *ToggleGroup) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *ToggleGroup) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *ToggleGroup) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *ToggleGroup) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *ToggleGroup) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *ToggleGroup) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *ToggleGroup) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *ToggleGroup) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *ToggleGroup) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *ToggleGroup) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *ToggleGroup) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *ToggleGroup) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ToggleGroup) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *ToggleGroup) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ToggleGroup) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *ToggleGroup) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *ToggleGroup) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *ToggleGroup) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Retrieves the orientation of the @orientable.
func (x *ToggleGroup) GetOrientation() gtk.Orientation {

	cret := gtk.XGtkOrientableGetOrientation(x.GoPointer())
	return cret
}

// Sets the orientation of the @orientable.
func (x *ToggleGroup) SetOrientation(OrientationVar gtk.Orientation) {

	gtk.XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)

}

func init() {
	core.SetPackageName("ADW", "libadwaita-1")
	core.SetSharedLibraries("ADW", []string{"libadwaita-1.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("ADW") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xToggleGLibType, libs, "adw_toggle_get_type")

	core.PuregoSafeRegister(&xNewToggle, libs, "adw_toggle_new")

	core.PuregoSafeRegister(&xToggleGetChild, libs, "adw_toggle_get_child")
	core.PuregoSafeRegister(&xToggleGetEnabled, libs, "adw_toggle_get_enabled")
	core.PuregoSafeRegister(&xToggleGetIconName, libs, "adw_toggle_get_icon_name")
	core.PuregoSafeRegister(&xToggleGetIndex, libs, "adw_toggle_get_index")
	core.PuregoSafeRegister(&xToggleGetLabel, libs, "adw_toggle_get_label")
	core.PuregoSafeRegister(&xToggleGetName, libs, "adw_toggle_get_name")
	core.PuregoSafeRegister(&xToggleGetTooltip, libs, "adw_toggle_get_tooltip")
	core.PuregoSafeRegister(&xToggleGetUseUnderline, libs, "adw_toggle_get_use_underline")
	core.PuregoSafeRegister(&xToggleSetChild, libs, "adw_toggle_set_child")
	core.PuregoSafeRegister(&xToggleSetEnabled, libs, "adw_toggle_set_enabled")
	core.PuregoSafeRegister(&xToggleSetIconName, libs, "adw_toggle_set_icon_name")
	core.PuregoSafeRegister(&xToggleSetLabel, libs, "adw_toggle_set_label")
	core.PuregoSafeRegister(&xToggleSetName, libs, "adw_toggle_set_name")
	core.PuregoSafeRegister(&xToggleSetTooltip, libs, "adw_toggle_set_tooltip")
	core.PuregoSafeRegister(&xToggleSetUseUnderline, libs, "adw_toggle_set_use_underline")

	core.PuregoSafeRegister(&xToggleGroupGLibType, libs, "adw_toggle_group_get_type")

	core.PuregoSafeRegister(&xNewToggleGroup, libs, "adw_toggle_group_new")

	core.PuregoSafeRegister(&xToggleGroupAdd, libs, "adw_toggle_group_add")
	core.PuregoSafeRegister(&xToggleGroupGetActive, libs, "adw_toggle_group_get_active")
	core.PuregoSafeRegister(&xToggleGroupGetActiveName, libs, "adw_toggle_group_get_active_name")
	core.PuregoSafeRegister(&xToggleGroupGetCanShrink, libs, "adw_toggle_group_get_can_shrink")
	core.PuregoSafeRegister(&xToggleGroupGetHomogeneous, libs, "adw_toggle_group_get_homogeneous")
	core.PuregoSafeRegister(&xToggleGroupGetNToggles, libs, "adw_toggle_group_get_n_toggles")
	core.PuregoSafeRegister(&xToggleGroupGetToggle, libs, "adw_toggle_group_get_toggle")
	core.PuregoSafeRegister(&xToggleGroupGetToggleByName, libs, "adw_toggle_group_get_toggle_by_name")
	core.PuregoSafeRegister(&xToggleGroupGetToggles, libs, "adw_toggle_group_get_toggles")
	core.PuregoSafeRegister(&xToggleGroupRemove, libs, "adw_toggle_group_remove")
	core.PuregoSafeRegister(&xToggleGroupRemoveAll, libs, "adw_toggle_group_remove_all")
	core.PuregoSafeRegister(&xToggleGroupSetActive, libs, "adw_toggle_group_set_active")
	core.PuregoSafeRegister(&xToggleGroupSetActiveName, libs, "adw_toggle_group_set_active_name")
	core.PuregoSafeRegister(&xToggleGroupSetCanShrink, libs, "adw_toggle_group_set_can_shrink")
	core.PuregoSafeRegister(&xToggleGroupSetHomogeneous, libs, "adw_toggle_group_set_homogeneous")

}
