// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type SqueezerClass struct {
	_ structs.HostLayout

	ParentClass gtk.WidgetClass
}

func (x *SqueezerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type SqueezerPageClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *SqueezerPageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Describes the possible transitions in a [class@Squeezer] widget.
type SqueezerTransitionType int

var xSqueezerTransitionTypeGLibType func() types.GType

func SqueezerTransitionTypeGLibType() types.GType {
	return xSqueezerTransitionTypeGLibType()
}

const (

	// No transition
	SqueezerTransitionTypeNoneValue SqueezerTransitionType = 0
	// A cross-fade
	SqueezerTransitionTypeCrossfadeValue SqueezerTransitionType = 1
)

// A best fit container.
//
// &lt;picture&gt;
//
//	&lt;source srcset="squeezer-wide-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="squeezer-wide.png" alt="squeezer-wide"&gt;
//
// &lt;/picture&gt;
// &lt;picture&gt;
//
//	&lt;source srcset="squeezer-narrow-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="squeezer-narrow.png" alt="squeezer-narrow"&gt;
//
// &lt;/picture&gt;
//
// The `AdwSqueezer` widget is a container which only shows the first of its
// children that fits in the available size. It is convenient to offer different
// widgets to represent the same data with different levels of detail, making
// the widget seem to squeeze itself to fit in the available space.
//
// Transitions between children can be animated as fades. This can be controlled
// with [property@Squeezer:transition-type].
//
// ## CSS nodes
//
// `AdwSqueezer` has a single CSS node with name `squeezer`.
type Squeezer struct {
	gtk.Widget
}

var xSqueezerGLibType func() types.GType

func SqueezerGLibType() types.GType {
	return xSqueezerGLibType()
}

func SqueezerNewFromInternalPtr(ptr uintptr) *Squeezer {
	cls := &Squeezer{}
	cls.Ptr = ptr
	return cls
}

var xNewSqueezer func() uintptr

// Creates a new `AdwSqueezer`.
func NewSqueezer() *Squeezer {
	var cls *Squeezer

	cret := xNewSqueezer()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Squeezer{}
	cls.Ptr = cret
	return cls
}

var xSqueezerAdd func(uintptr, uintptr) uintptr

// Adds a child to @self.
func (x *Squeezer) Add(ChildVar *gtk.Widget) *SqueezerPage {
	var cls *SqueezerPage

	cret := xSqueezerAdd(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &SqueezerPage{}
	cls.Ptr = cret
	return cls
}

var xSqueezerGetAllowNone func(uintptr) bool

// Gets whether to allow squeezing beyond the last child's minimum size.
func (x *Squeezer) GetAllowNone() bool {

	cret := xSqueezerGetAllowNone(x.GoPointer())

	return cret
}

var xSqueezerGetHomogeneous func(uintptr) bool

// Gets whether all children have the same size for the opposite orientation.
func (x *Squeezer) GetHomogeneous() bool {

	cret := xSqueezerGetHomogeneous(x.GoPointer())

	return cret
}

var xSqueezerGetInterpolateSize func(uintptr) bool

// Gets whether @self interpolates its size when changing the visible child.
func (x *Squeezer) GetInterpolateSize() bool {

	cret := xSqueezerGetInterpolateSize(x.GoPointer())

	return cret
}

var xSqueezerGetPage func(uintptr, uintptr) uintptr

// Returns the [class@SqueezerPage] object for @child.
func (x *Squeezer) GetPage(ChildVar *gtk.Widget) *SqueezerPage {
	var cls *SqueezerPage

	cret := xSqueezerGetPage(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &SqueezerPage{}
	cls.Ptr = cret
	return cls
}

var xSqueezerGetPages func(uintptr) uintptr

// Returns a [iface@Gio.ListModel] that contains the pages of @self.
//
// This can be used to keep an up-to-date view. The model also implements
// [iface@Gtk.SelectionModel] and can be used to track the visible page.
func (x *Squeezer) GetPages() *gtk.SelectionModelBase {
	var cls *gtk.SelectionModelBase

	cret := xSqueezerGetPages(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.SelectionModelBase{}
	cls.Ptr = cret
	return cls
}

var xSqueezerGetSwitchThresholdPolicy func(uintptr) FoldThresholdPolicy

// Gets the switch threshold policy for @self.
func (x *Squeezer) GetSwitchThresholdPolicy() FoldThresholdPolicy {

	cret := xSqueezerGetSwitchThresholdPolicy(x.GoPointer())

	return cret
}

var xSqueezerGetTransitionDuration func(uintptr) uint

// Gets the transition animation duration for @self.
func (x *Squeezer) GetTransitionDuration() uint {

	cret := xSqueezerGetTransitionDuration(x.GoPointer())

	return cret
}

var xSqueezerGetTransitionRunning func(uintptr) bool

// Gets whether a transition is currently running for @self.
//
// If a transition is impossible, the property value will be set to `TRUE` and
// then immediately to `FALSE`, so it's possible to rely on its notifications
// to know that a transition has happened.
func (x *Squeezer) GetTransitionRunning() bool {

	cret := xSqueezerGetTransitionRunning(x.GoPointer())

	return cret
}

var xSqueezerGetTransitionType func(uintptr) SqueezerTransitionType

// Gets the type of animation used for transitions between children in @self.
func (x *Squeezer) GetTransitionType() SqueezerTransitionType {

	cret := xSqueezerGetTransitionType(x.GoPointer())

	return cret
}

var xSqueezerGetVisibleChild func(uintptr) uintptr

// Gets the currently visible child of @self.
func (x *Squeezer) GetVisibleChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xSqueezerGetVisibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xSqueezerGetXalign func(uintptr) float32

// Gets the horizontal alignment, from 0 (start) to 1 (end).
func (x *Squeezer) GetXalign() float32 {

	cret := xSqueezerGetXalign(x.GoPointer())

	return cret
}

var xSqueezerGetYalign func(uintptr) float32

// Gets the vertical alignment, from 0 (top) to 1 (bottom).
func (x *Squeezer) GetYalign() float32 {

	cret := xSqueezerGetYalign(x.GoPointer())

	return cret
}

var xSqueezerRemove func(uintptr, uintptr)

// Removes a child widget from @self.
func (x *Squeezer) Remove(ChildVar *gtk.Widget) {

	xSqueezerRemove(x.GoPointer(), ChildVar.GoPointer())

}

var xSqueezerSetAllowNone func(uintptr, bool)

// Sets whether to allow squeezing beyond the last child's minimum size.
//
// If set to `TRUE`, the squeezer can shrink to the point where no child can be
// shown. This is functionally equivalent to appending a widget with 0×0 minimum
// size.
func (x *Squeezer) SetAllowNone(AllowNoneVar bool) {

	xSqueezerSetAllowNone(x.GoPointer(), AllowNoneVar)

}

var xSqueezerSetHomogeneous func(uintptr, bool)

// Sets whether all children have the same size for the opposite orientation.
//
// For example, if a squeezer is horizontal and is homogeneous, it will request
// the same height for all its children. If it isn't, the squeezer may change
// size when a different child becomes visible.
func (x *Squeezer) SetHomogeneous(HomogeneousVar bool) {

	xSqueezerSetHomogeneous(x.GoPointer(), HomogeneousVar)

}

var xSqueezerSetInterpolateSize func(uintptr, bool)

// Sets whether @self interpolates its size when changing the visible child.
//
// If `TRUE`, the squeezer will interpolate its size between the one of the
// previous visible child and the one of the new visible child, according to the
// set transition duration and the orientation, e.g. if the squeezer is
// horizontal, it will interpolate the its height.
func (x *Squeezer) SetInterpolateSize(InterpolateSizeVar bool) {

	xSqueezerSetInterpolateSize(x.GoPointer(), InterpolateSizeVar)

}

var xSqueezerSetSwitchThresholdPolicy func(uintptr, FoldThresholdPolicy)

// Sets the switch threshold policy for @self.
//
// Determines when the squeezer will switch children.
//
// If set to `ADW_FOLD_THRESHOLD_POLICY_MINIMUM`, it will only switch when the
// visible child cannot fit anymore. With `ADW_FOLD_THRESHOLD_POLICY_NATURAL`,
// it will switch as soon as the visible child doesn't get their natural size.
//
// This can be useful if you have a long ellipsizing label and want to let it
// ellipsize instead of immediately switching.
func (x *Squeezer) SetSwitchThresholdPolicy(PolicyVar FoldThresholdPolicy) {

	xSqueezerSetSwitchThresholdPolicy(x.GoPointer(), PolicyVar)

}

var xSqueezerSetTransitionDuration func(uintptr, uint)

// Sets the transition animation duration for @self.
func (x *Squeezer) SetTransitionDuration(DurationVar uint) {

	xSqueezerSetTransitionDuration(x.GoPointer(), DurationVar)

}

var xSqueezerSetTransitionType func(uintptr, SqueezerTransitionType)

// Sets the type of animation used for transitions between children in @self.
func (x *Squeezer) SetTransitionType(TransitionVar SqueezerTransitionType) {

	xSqueezerSetTransitionType(x.GoPointer(), TransitionVar)

}

var xSqueezerSetXalign func(uintptr, float32)

// Sets the horizontal alignment, from 0 (start) to 1 (end).
//
// This affects the children allocation during transitions, when they exceed the
// size of the squeezer.
//
// For example, 0.5 means the child will be centered, 0 means it will keep the
// start side aligned and overflow the end side, and 1 means the opposite.
func (x *Squeezer) SetXalign(XalignVar float32) {

	xSqueezerSetXalign(x.GoPointer(), XalignVar)

}

var xSqueezerSetYalign func(uintptr, float32)

// Sets the vertical alignment, from 0 (top) to 1 (bottom).
//
// This affects the children allocation during transitions, when they exceed the
// size of the squeezer.
//
// For example, 0.5 means the child will be centered, 0 means it will keep the
// top side aligned and overflow the bottom side, and 1 means the opposite.
func (x *Squeezer) SetYalign(YalignVar float32) {

	xSqueezerSetYalign(x.GoPointer(), YalignVar)

}

func (c *Squeezer) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Squeezer) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAllowNone sets the "allow-none" property.
// Whether to allow squeezing beyond the last child's minimum size.
//
// If set to `TRUE`, the squeezer can shrink to the point where no child can
// be shown. This is functionally equivalent to appending a widget with 0×0
// minimum size.
func (x *Squeezer) SetPropertyAllowNone(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("allow-none", &v)
}

// GetPropertyAllowNone gets the "allow-none" property.
// Whether to allow squeezing beyond the last child's minimum size.
//
// If set to `TRUE`, the squeezer can shrink to the point where no child can
// be shown. This is functionally equivalent to appending a widget with 0×0
// minimum size.
func (x *Squeezer) GetPropertyAllowNone() bool {
	var v gobject.Value
	x.GetProperty("allow-none", &v)
	return v.GetBoolean()
}

// SetPropertyHomogeneous sets the "homogeneous" property.
// Whether all children have the same size for the opposite orientation.
//
// For example, if a squeezer is horizontal and is homogeneous, it will
// request the same height for all its children. If it isn't, the squeezer may
// change size when a different child becomes visible.
func (x *Squeezer) SetPropertyHomogeneous(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("homogeneous", &v)
}

// GetPropertyHomogeneous gets the "homogeneous" property.
// Whether all children have the same size for the opposite orientation.
//
// For example, if a squeezer is horizontal and is homogeneous, it will
// request the same height for all its children. If it isn't, the squeezer may
// change size when a different child becomes visible.
func (x *Squeezer) GetPropertyHomogeneous() bool {
	var v gobject.Value
	x.GetProperty("homogeneous", &v)
	return v.GetBoolean()
}

// SetPropertyInterpolateSize sets the "interpolate-size" property.
// Whether the squeezer interpolates its size when changing the visible child.
//
// If `TRUE`, the squeezer will interpolate its size between the one of the
// previous visible child and the one of the new visible child, according to
// the set transition duration and the orientation, e.g. if the squeezer is
// horizontal, it will interpolate the its height.
func (x *Squeezer) SetPropertyInterpolateSize(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("interpolate-size", &v)
}

// GetPropertyInterpolateSize gets the "interpolate-size" property.
// Whether the squeezer interpolates its size when changing the visible child.
//
// If `TRUE`, the squeezer will interpolate its size between the one of the
// previous visible child and the one of the new visible child, according to
// the set transition duration and the orientation, e.g. if the squeezer is
// horizontal, it will interpolate the its height.
func (x *Squeezer) GetPropertyInterpolateSize() bool {
	var v gobject.Value
	x.GetProperty("interpolate-size", &v)
	return v.GetBoolean()
}

// SetPropertyTransitionDuration sets the "transition-duration" property.
// The transition animation duration, in milliseconds.
func (x *Squeezer) SetPropertyTransitionDuration(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("transition-duration", &v)
}

// GetPropertyTransitionDuration gets the "transition-duration" property.
// The transition animation duration, in milliseconds.
func (x *Squeezer) GetPropertyTransitionDuration() uint {
	var v gobject.Value
	x.GetProperty("transition-duration", &v)
	return v.GetUint()
}

// GetPropertyTransitionRunning gets the "transition-running" property.
// Whether a transition is currently running.
//
// If a transition is impossible, the property value will be set to `TRUE` and
// then immediately to `FALSE`, so it's possible to rely on its notifications
// to know that a transition has happened.
func (x *Squeezer) GetPropertyTransitionRunning() bool {
	var v gobject.Value
	x.GetProperty("transition-running", &v)
	return v.GetBoolean()
}

// SetPropertyXalign sets the "xalign" property.
// The horizontal alignment, from 0 (start) to 1 (end).
//
// This affects the children allocation during transitions, when they exceed
// the size of the squeezer.
//
// For example, 0.5 means the child will be centered, 0 means it will keep the
// start side aligned and overflow the end side, and 1 means the opposite.
func (x *Squeezer) SetPropertyXalign(value float32) {
	var v gobject.Value
	v.Init(gobject.TypeFloatVal)
	v.SetFloat(value)
	x.SetProperty("xalign", &v)
}

// GetPropertyXalign gets the "xalign" property.
// The horizontal alignment, from 0 (start) to 1 (end).
//
// This affects the children allocation during transitions, when they exceed
// the size of the squeezer.
//
// For example, 0.5 means the child will be centered, 0 means it will keep the
// start side aligned and overflow the end side, and 1 means the opposite.
func (x *Squeezer) GetPropertyXalign() float32 {
	var v gobject.Value
	x.GetProperty("xalign", &v)
	return v.GetFloat()
}

// SetPropertyYalign sets the "yalign" property.
// The vertical alignment, from 0 (top) to 1 (bottom).
//
// This affects the children allocation during transitions, when they exceed
// the size of the squeezer.
//
// For example, 0.5 means the child will be centered, 0 means it will keep the
// top side aligned and overflow the bottom side, and 1 means the opposite.
func (x *Squeezer) SetPropertyYalign(value float32) {
	var v gobject.Value
	v.Init(gobject.TypeFloatVal)
	v.SetFloat(value)
	x.SetProperty("yalign", &v)
}

// GetPropertyYalign gets the "yalign" property.
// The vertical alignment, from 0 (top) to 1 (bottom).
//
// This affects the children allocation during transitions, when they exceed
// the size of the squeezer.
//
// For example, 0.5 means the child will be centered, 0 means it will keep the
// top side aligned and overflow the bottom side, and 1 means the opposite.
func (x *Squeezer) GetPropertyYalign() float32 {
	var v gobject.Value
	x.GetProperty("yalign", &v)
	return v.GetFloat()
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *Squeezer) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *Squeezer) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *Squeezer) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())

	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *Squeezer) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *Squeezer) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)

	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *Squeezer) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *Squeezer) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *Squeezer) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)

	return cret
}

// Resets the accessible property to its default value.
func (x *Squeezer) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *Squeezer) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *Squeezer) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *Squeezer) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *Squeezer) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *Squeezer) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Squeezer) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Squeezer) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Squeezer) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Squeezer) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Squeezer) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Squeezer) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *Squeezer) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())

	return cret
}

// Retrieves the orientation of the @orientable.
func (x *Squeezer) GetOrientation() gtk.Orientation {

	cret := gtk.XGtkOrientableGetOrientation(x.GoPointer())

	return cret
}

// Sets the orientation of the @orientable.
func (x *Squeezer) SetOrientation(OrientationVar gtk.Orientation) {

	gtk.XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)

}

// An auxiliary class used by [class@Squeezer].
type SqueezerPage struct {
	gobject.Object
}

var xSqueezerPageGLibType func() types.GType

func SqueezerPageGLibType() types.GType {
	return xSqueezerPageGLibType()
}

func SqueezerPageNewFromInternalPtr(ptr uintptr) *SqueezerPage {
	cls := &SqueezerPage{}
	cls.Ptr = ptr
	return cls
}

var xSqueezerPageGetChild func(uintptr) uintptr

// Returns the squeezer child to which @self belongs.
func (x *SqueezerPage) GetChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xSqueezerPageGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xSqueezerPageGetEnabled func(uintptr) bool

// Gets whether @self is enabled.
func (x *SqueezerPage) GetEnabled() bool {

	cret := xSqueezerPageGetEnabled(x.GoPointer())

	return cret
}

var xSqueezerPageSetEnabled func(uintptr, bool)

// Sets whether @self is enabled.
//
// If a child is disabled, it will be ignored when looking for the child
// fitting the available size best.
//
// This allows to programmatically and prematurely hide a child even if it fits
// in the available space.
//
// This can be used e.g. to ensure a certain child is hidden below a certain
// window width, or any other constraint you find suitable.
func (x *SqueezerPage) SetEnabled(EnabledVar bool) {

	xSqueezerPageSetEnabled(x.GoPointer(), EnabledVar)

}

func (c *SqueezerPage) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *SqueezerPage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyEnabled sets the "enabled" property.
// Whether the child is enabled.
//
// If a child is disabled, it will be ignored when looking for the child
// fitting the available size best.
//
// This allows to programmatically and prematurely hide a child even if it
// fits in the available space.
//
// This can be used e.g. to ensure a certain child is hidden below a certain
// window width, or any other constraint you find suitable.
func (x *SqueezerPage) SetPropertyEnabled(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("enabled", &v)
}

// GetPropertyEnabled gets the "enabled" property.
// Whether the child is enabled.
//
// If a child is disabled, it will be ignored when looking for the child
// fitting the available size best.
//
// This allows to programmatically and prematurely hide a child even if it
// fits in the available space.
//
// This can be used e.g. to ensure a certain child is hidden below a certain
// window width, or any other constraint you find suitable.
func (x *SqueezerPage) GetPropertyEnabled() bool {
	var v gobject.Value
	x.GetProperty("enabled", &v)
	return v.GetBoolean()
}

func init() {
	core.SetPackageName("ADW", "libadwaita-1")
	core.SetSharedLibraries("ADW", []string{"libadwaita-1.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("ADW") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSqueezerTransitionTypeGLibType, libs, "adw_squeezer_transition_type_get_type")

	core.PuregoSafeRegister(&xSqueezerGLibType, libs, "adw_squeezer_get_type")

	core.PuregoSafeRegister(&xNewSqueezer, libs, "adw_squeezer_new")

	core.PuregoSafeRegister(&xSqueezerAdd, libs, "adw_squeezer_add")
	core.PuregoSafeRegister(&xSqueezerGetAllowNone, libs, "adw_squeezer_get_allow_none")
	core.PuregoSafeRegister(&xSqueezerGetHomogeneous, libs, "adw_squeezer_get_homogeneous")
	core.PuregoSafeRegister(&xSqueezerGetInterpolateSize, libs, "adw_squeezer_get_interpolate_size")
	core.PuregoSafeRegister(&xSqueezerGetPage, libs, "adw_squeezer_get_page")
	core.PuregoSafeRegister(&xSqueezerGetPages, libs, "adw_squeezer_get_pages")
	core.PuregoSafeRegister(&xSqueezerGetSwitchThresholdPolicy, libs, "adw_squeezer_get_switch_threshold_policy")
	core.PuregoSafeRegister(&xSqueezerGetTransitionDuration, libs, "adw_squeezer_get_transition_duration")
	core.PuregoSafeRegister(&xSqueezerGetTransitionRunning, libs, "adw_squeezer_get_transition_running")
	core.PuregoSafeRegister(&xSqueezerGetTransitionType, libs, "adw_squeezer_get_transition_type")
	core.PuregoSafeRegister(&xSqueezerGetVisibleChild, libs, "adw_squeezer_get_visible_child")
	core.PuregoSafeRegister(&xSqueezerGetXalign, libs, "adw_squeezer_get_xalign")
	core.PuregoSafeRegister(&xSqueezerGetYalign, libs, "adw_squeezer_get_yalign")
	core.PuregoSafeRegister(&xSqueezerRemove, libs, "adw_squeezer_remove")
	core.PuregoSafeRegister(&xSqueezerSetAllowNone, libs, "adw_squeezer_set_allow_none")
	core.PuregoSafeRegister(&xSqueezerSetHomogeneous, libs, "adw_squeezer_set_homogeneous")
	core.PuregoSafeRegister(&xSqueezerSetInterpolateSize, libs, "adw_squeezer_set_interpolate_size")
	core.PuregoSafeRegister(&xSqueezerSetSwitchThresholdPolicy, libs, "adw_squeezer_set_switch_threshold_policy")
	core.PuregoSafeRegister(&xSqueezerSetTransitionDuration, libs, "adw_squeezer_set_transition_duration")
	core.PuregoSafeRegister(&xSqueezerSetTransitionType, libs, "adw_squeezer_set_transition_type")
	core.PuregoSafeRegister(&xSqueezerSetXalign, libs, "adw_squeezer_set_xalign")
	core.PuregoSafeRegister(&xSqueezerSetYalign, libs, "adw_squeezer_set_yalign")

	core.PuregoSafeRegister(&xSqueezerPageGLibType, libs, "adw_squeezer_page_get_type")

	core.PuregoSafeRegister(&xSqueezerPageGetChild, libs, "adw_squeezer_page_get_child")
	core.PuregoSafeRegister(&xSqueezerPageGetEnabled, libs, "adw_squeezer_page_get_enabled")
	core.PuregoSafeRegister(&xSqueezerPageSetEnabled, libs, "adw_squeezer_page_set_enabled")

}
