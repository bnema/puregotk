// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Provides information to interpret colors and pixels in a variety of ways.
//
// They are also known as
// [*color spaces*](https://en.wikipedia.org/wiki/Color_space).
//
// Crucially, GTK knows how to convert colors from one color
// state to another.
//
// `GdkColorState` objects are immutable and therefore threadsafe.
type ColorState struct {
	_ structs.HostLayout
}

var xColorStateGLibType func() types.GType

func ColorStateGLibType() types.GType {
	return xColorStateGLibType()
}

func (x *ColorState) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xColorStateCreateCicpParams func(uintptr) uintptr

// Create a [class@Gdk.CicpParams] representing the colorstate.
//
// It is not guaranteed that every `GdkColorState` can be
// represented with Cicp parameters. If that is the case,
// this function returns `NULL`.
func (x *ColorState) CreateCicpParams() *CicpParams {
	var cls *CicpParams

	cret := xColorStateCreateCicpParams(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &CicpParams{}
	cls.Ptr = cret
	return cls
}

var xColorStateEqual func(uintptr, *ColorState) bool

// Compares two `GdkColorStates` for equality.
//
// Note that this function is not guaranteed to be perfect and two objects
// describing the same color state may compare not equal. However, different
// color states will never compare equal.
func (x *ColorState) Equal(OtherVar *ColorState) bool {

	cret := xColorStateEqual(x.GoPointer(), OtherVar)
	return cret
}

var xColorStateRef func(uintptr) *ColorState

// Increase the reference count of @self.
func (x *ColorState) Ref() *ColorState {

	cret := xColorStateRef(x.GoPointer())
	return cret
}

var xColorStateUnref func(uintptr)

// Decrease the reference count of @self.
//
// Unless @self is static, it will be freed
// when the reference count reaches zero.
func (x *ColorState) Unref() {

	xColorStateUnref(x.GoPointer())

}

// Used to advertise and negotiate the format of content.
//
// You will encounter `GdkContentFormats` when interacting with objects
// controlling operations that pass data between different widgets, window
// or application, like [class@Gdk.Drag], [class@Gdk.Drop],
// [class@Gdk.Clipboard] or [class@Gdk.ContentProvider].
//
// GDK supports content in 2 forms: `GType` and mime type.
// Using `GTypes` is meant only for in-process content transfers. Mime types
// are meant to be used for data passing both in-process and out-of-process.
// The details of how data is passed is described in the documentation of
// the actual implementations. To transform between the two forms,
// [class@Gdk.ContentSerializer] and [class@Gdk.ContentDeserializer] are used.
//
// A `GdkContentFormats` describes a set of possible formats content can be
// exchanged in. It is assumed that this set is ordered. `GTypes` are more
// important than mime types. Order between different `GTypes` or mime types
// is the order they were added in, most important first. Functions that
// care about order, such as [method@Gdk.ContentFormats.union], will describe
// in their documentation how they interpret that order, though in general the
// order of the first argument is considered the primary order of the result,
// followed by the order of further arguments.
//
// For debugging purposes, the function [method@Gdk.ContentFormats.to_string]
// exists. It will print a comma-separated list of formats from most important
// to least important.
//
// `GdkContentFormats` is an immutable struct. After creation, you cannot change
// the types it represents. Instead, new `GdkContentFormats` have to be created.
// The [struct@Gdk.ContentFormatsBuilder] structure is meant to help in this
// endeavor.
type ContentFormats struct {
	_ structs.HostLayout
}

var xContentFormatsGLibType func() types.GType

func ContentFormatsGLibType() types.GType {
	return xContentFormatsGLibType()
}

func (x *ContentFormats) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewContentFormats func([]string, uint) *ContentFormats

// Creates a new `GdkContentFormats` from an array of mime types.
//
// The mime types must be valid and different from each other or the
// behavior of the return value is undefined. If you cannot guarantee
// this, use [struct@Gdk.ContentFormatsBuilder] instead.
func NewContentFormats(MimeTypesVar []string, NMimeTypesVar uint) *ContentFormats {

	cret := xNewContentFormats(MimeTypesVar, NMimeTypesVar)
	return cret
}

var xNewContentFormatsForGtype func(types.GType) *ContentFormats

// Creates a new `GdkContentFormats` for a given `GType`.
func NewContentFormatsForGtype(TypeVar types.GType) *ContentFormats {

	cret := xNewContentFormatsForGtype(TypeVar)
	return cret
}

var xContentFormatsContainGtype func(uintptr, types.GType) bool

// Checks if a given `GType` is part of the given @formats.
func (x *ContentFormats) ContainGtype(TypeVar types.GType) bool {

	cret := xContentFormatsContainGtype(x.GoPointer(), TypeVar)
	return cret
}

var xContentFormatsContainMimeType func(uintptr, string) bool

// Checks if a given mime type is part of the given @formats.
func (x *ContentFormats) ContainMimeType(MimeTypeVar string) bool {

	cret := xContentFormatsContainMimeType(x.GoPointer(), MimeTypeVar)
	return cret
}

var xContentFormatsGetGtypes func(uintptr, uint) uintptr

// Gets the `GType`s included in @formats.
//
// Note that @formats may not contain any `GType`s, in particular when
// they are empty. In that case %NULL will be returned.
func (x *ContentFormats) GetGtypes(NGtypesVar uint) uintptr {

	cret := xContentFormatsGetGtypes(x.GoPointer(), NGtypesVar)
	return cret
}

var xContentFormatsGetMimeTypes func(uintptr, uint) []string

// Gets the mime types included in @formats.
//
// Note that @formats may not contain any mime types, in particular
// when they are empty. In that case %NULL will be returned.
func (x *ContentFormats) GetMimeTypes(NMimeTypesVar uint) []string {

	cret := xContentFormatsGetMimeTypes(x.GoPointer(), NMimeTypesVar)
	return cret
}

var xContentFormatsIsEmpty func(uintptr) bool

// Returns whether the content formats contain any formats.
func (x *ContentFormats) IsEmpty() bool {

	cret := xContentFormatsIsEmpty(x.GoPointer())
	return cret
}

var xContentFormatsMatch func(uintptr, *ContentFormats) bool

// Checks if @first and @second have any matching formats.
func (x *ContentFormats) Match(SecondVar *ContentFormats) bool {

	cret := xContentFormatsMatch(x.GoPointer(), SecondVar)
	return cret
}

var xContentFormatsMatchGtype func(uintptr, *ContentFormats) types.GType

// Finds the first `GType` from @first that is also contained
// in @second.
//
// If no matching `GType` is found, %G_TYPE_INVALID is returned.
func (x *ContentFormats) MatchGtype(SecondVar *ContentFormats) types.GType {

	cret := xContentFormatsMatchGtype(x.GoPointer(), SecondVar)
	return cret
}

var xContentFormatsMatchMimeType func(uintptr, *ContentFormats) string

// Finds the first mime type from @first that is also contained
// in @second.
//
// If no matching mime type is found, %NULL is returned.
func (x *ContentFormats) MatchMimeType(SecondVar *ContentFormats) string {

	cret := xContentFormatsMatchMimeType(x.GoPointer(), SecondVar)
	return cret
}

var xContentFormatsPrint func(uintptr, *glib.String)

// Prints the given @formats into a string for human consumption.
//
// The result of this function can later be parsed with
// [func@Gdk.ContentFormats.parse].
func (x *ContentFormats) Print(StringVar *glib.String) {

	xContentFormatsPrint(x.GoPointer(), StringVar)

}

var xContentFormatsRef func(uintptr) *ContentFormats

// Increases the reference count of a `GdkContentFormats` by one.
func (x *ContentFormats) Ref() *ContentFormats {

	cret := xContentFormatsRef(x.GoPointer())
	return cret
}

var xContentFormatsToString func(uintptr) string

// Prints the given @formats into a human-readable string.
//
// The resulting string can be parsed with [func@Gdk.ContentFormats.parse].
//
// This is a small wrapper around [method@Gdk.ContentFormats.print]
// to help when debugging.
func (x *ContentFormats) ToString() string {

	cret := xContentFormatsToString(x.GoPointer())
	return cret
}

var xContentFormatsUnion func(uintptr, *ContentFormats) *ContentFormats

// Append all missing types from @second to @first, in the order
// they had in @second.
func (x *ContentFormats) Union(SecondVar *ContentFormats) *ContentFormats {

	cret := xContentFormatsUnion(x.GoPointer(), SecondVar)
	return cret
}

var xContentFormatsUnionDeserializeGtypes func(uintptr) *ContentFormats

// Add GTypes for mime types in @formats for which deserializers are
// registered.
func (x *ContentFormats) UnionDeserializeGtypes() *ContentFormats {

	cret := xContentFormatsUnionDeserializeGtypes(x.GoPointer())
	return cret
}

var xContentFormatsUnionDeserializeMimeTypes func(uintptr) *ContentFormats

// Add mime types for GTypes in @formats for which deserializers are
// registered.
func (x *ContentFormats) UnionDeserializeMimeTypes() *ContentFormats {

	cret := xContentFormatsUnionDeserializeMimeTypes(x.GoPointer())
	return cret
}

var xContentFormatsUnionSerializeGtypes func(uintptr) *ContentFormats

// Add GTypes for the mime types in @formats for which serializers are
// registered.
func (x *ContentFormats) UnionSerializeGtypes() *ContentFormats {

	cret := xContentFormatsUnionSerializeGtypes(x.GoPointer())
	return cret
}

var xContentFormatsUnionSerializeMimeTypes func(uintptr) *ContentFormats

// Add mime types for GTypes in @formats for which serializers are
// registered.
func (x *ContentFormats) UnionSerializeMimeTypes() *ContentFormats {

	cret := xContentFormatsUnionSerializeMimeTypes(x.GoPointer())
	return cret
}

var xContentFormatsUnref func(uintptr)

// Decreases the reference count of a `GdkContentFormats` by one.
//
// If the resulting reference count is zero, frees the formats.
func (x *ContentFormats) Unref() {

	xContentFormatsUnref(x.GoPointer())

}

// Provides information about supported DMA buffer formats.
//
// You can query whether a given format is supported with
// [method@Gdk.DmabufFormats.contains] and you can iterate
// over the list of all supported formats with
// [method@Gdk.DmabufFormats.get_n_formats] and
// [method@Gdk.DmabufFormats.get_format].
//
// The list of supported formats is sorted by preference,
// with the best formats coming first.
//
// The list may contains (format, modifier) pairs where the modifier
// is `DMA_FORMAT_MOD_INVALID`, indicating that **_implicit modifiers_**
// may be used with this format.
//
// See [class@Gdk.DmabufTextureBuilder] for more information
// about DMA buffers.
//
// Note that DMA buffers only exist on Linux.
type DmabufFormats struct {
	_ structs.HostLayout
}

var xDmabufFormatsGLibType func() types.GType

func DmabufFormatsGLibType() types.GType {
	return xDmabufFormatsGLibType()
}

func (x *DmabufFormats) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xDmabufFormatsContains func(uintptr, uint32, uint64) bool

// Returns whether a given format is contained in @formats.
func (x *DmabufFormats) Contains(FourccVar uint32, ModifierVar uint64) bool {

	cret := xDmabufFormatsContains(x.GoPointer(), FourccVar, ModifierVar)
	return cret
}

var xDmabufFormatsEqual func(uintptr, *DmabufFormats) bool

// Returns whether @formats1 and @formats2 contain the
// same dmabuf formats, in the same order.
func (x *DmabufFormats) Equal(Formats2Var *DmabufFormats) bool {

	cret := xDmabufFormatsEqual(x.GoPointer(), Formats2Var)
	return cret
}

var xDmabufFormatsGetFormat func(uintptr, uint, uint32, uint64)

// Gets the fourcc code and modifier for a format
// that is contained in @formats.
func (x *DmabufFormats) GetFormat(IdxVar uint, FourccVar uint32, ModifierVar uint64) {

	xDmabufFormatsGetFormat(x.GoPointer(), IdxVar, FourccVar, ModifierVar)

}

var xDmabufFormatsGetNFormats func(uintptr) uint

// Returns the number of formats that the @formats object
// contains.
//
// Note that DMA buffers are a Linux concept, so on other
// platforms, [method@Gdk.DmabufFormats.get_n_formats] will
// always return zero.
func (x *DmabufFormats) GetNFormats() uint {

	cret := xDmabufFormatsGetNFormats(x.GoPointer())
	return cret
}

var xDmabufFormatsRef func(uintptr) *DmabufFormats

// Increases the reference count of @formats.
func (x *DmabufFormats) Ref() *DmabufFormats {

	cret := xDmabufFormatsRef(x.GoPointer())
	return cret
}

var xDmabufFormatsUnref func(uintptr)

// Decreases the reference count of @formats.
//
// When the reference count reaches zero,
// the object is freed.
func (x *DmabufFormats) Unref() {

	xDmabufFormatsUnref(x.GoPointer())

}

// Represents a hardware key that can be mapped to a keyval.
type KeymapKey struct {
	_ structs.HostLayout

	Keycode uint

	Group int

	Level int
}

func (x *KeymapKey) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Represents a rectangle.
//
// `GdkRectangle` is identical to `cairo_rectangle_t`. Together with Cairo’s
// `cairo_region_t` data type, these are the central types for representing
// sets of pixels.
//
// The intersection of two rectangles can be computed with
// [method@Gdk.Rectangle.intersect]; to find the union of two rectangles use
// [method@Gdk.Rectangle.union].
//
// The `cairo_region_t` type provided by Cairo is usually used for managing
// non-rectangular clipping of graphical operations.
//
// The Graphene library has a number of other data types for regions and
// volumes in 2D and 3D.
type Rectangle struct {
	_ structs.HostLayout

	X int

	Y int

	Width int

	Height int
}

var xRectangleGLibType func() types.GType

func RectangleGLibType() types.GType {
	return xRectangleGLibType()
}

func (x *Rectangle) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xRectangleContainsPoint func(uintptr, int, int) bool

// Returns %TRUE if @rect contains the point described by @x and @y.
func (x *Rectangle) ContainsPoint(XVar int, YVar int) bool {

	cret := xRectangleContainsPoint(x.GoPointer(), XVar, YVar)
	return cret
}

var xRectangleEqual func(uintptr, *Rectangle) bool

// Checks if the two given rectangles are equal.
func (x *Rectangle) Equal(Rect2Var *Rectangle) bool {

	cret := xRectangleEqual(x.GoPointer(), Rect2Var)
	return cret
}

var xRectangleIntersect func(uintptr, *Rectangle, *Rectangle) bool

// Calculates the intersection of two rectangles.
//
// It is allowed for @dest to be the same as either @src1 or @src2.
// If the rectangles do not intersect, @dest’s width and height is set
// to 0 and its x and y values are undefined. If you are only interested
// in whether the rectangles intersect, but not in the intersecting area
// itself, pass %NULL for @dest.
func (x *Rectangle) Intersect(Src2Var *Rectangle, DestVar *Rectangle) bool {

	cret := xRectangleIntersect(x.GoPointer(), Src2Var, DestVar)
	return cret
}

var xRectangleUnion func(uintptr, *Rectangle, *Rectangle)

// Calculates the union of two rectangles.
//
// The union of rectangles @src1 and @src2 is the smallest rectangle which
// includes both @src1 and @src2 within it. It is allowed for @dest to be
// the same as either @src1 or @src2.
//
// Note that this function does not ignore 'empty' rectangles (ie. with
// zero width or height).
func (x *Rectangle) Union(Src2Var *Rectangle, DestVar *Rectangle) {

	xRectangleUnion(x.GoPointer(), Src2Var, DestVar)

}

// Used to download the contents of a [class@Gdk.Texture].
//
// It is intended to be created as a short-term object for a single download,
// but can be used for multiple downloads of different textures or with different
// settings.
//
// `GdkTextureDownloader` can be used to convert data between different formats.
// Create a `GdkTexture` for the existing format and then download it in a
// different format.
type TextureDownloader struct {
	_ structs.HostLayout
}

var xTextureDownloaderGLibType func() types.GType

func TextureDownloaderGLibType() types.GType {
	return xTextureDownloaderGLibType()
}

func (x *TextureDownloader) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewTextureDownloader func(uintptr) *TextureDownloader

// Creates a new texture downloader for @texture.
//
// By default, the downloader will convert the data to
// the default memory format, and to the sRGB color state.
func NewTextureDownloader(TextureVar *Texture) *TextureDownloader {

	cret := xNewTextureDownloader(TextureVar.GoPointer())
	return cret
}

var xTextureDownloaderCopy func(uintptr) *TextureDownloader

// Creates a copy of the downloader.
//
// This function is meant for language bindings.
func (x *TextureDownloader) Copy() *TextureDownloader {

	cret := xTextureDownloaderCopy(x.GoPointer())
	return cret
}

var xTextureDownloaderDownloadBytes func(uintptr, uint) *glib.Bytes

// Downloads the given texture pixels into a `GBytes`. The rowstride will
// be stored in the stride value.
//
// This function will abort if it tries to download a large texture and
// fails to allocate memory. If you think that may happen, you should handle
// memory allocation yourself and use [method@Gdk.TextureDownloader.download_into]
// once allocation succeeded.
func (x *TextureDownloader) DownloadBytes(OutStrideVar uint) *glib.Bytes {

	cret := xTextureDownloaderDownloadBytes(x.GoPointer(), OutStrideVar)
	return cret
}

var xTextureDownloaderDownloadInto func(uintptr, []byte, uint)

// Downloads the @texture into local memory.
func (x *TextureDownloader) DownloadInto(DataVar []byte, StrideVar uint) {

	xTextureDownloaderDownloadInto(x.GoPointer(), DataVar, StrideVar)

}

var xTextureDownloaderFree func(uintptr)

// Frees the given downloader and all its associated resources.
func (x *TextureDownloader) Free() {

	xTextureDownloaderFree(x.GoPointer())

}

var xTextureDownloaderGetColorState func(uintptr) *ColorState

// Gets the color state that the data will be downloaded in.
func (x *TextureDownloader) GetColorState() *ColorState {

	cret := xTextureDownloaderGetColorState(x.GoPointer())
	return cret
}

var xTextureDownloaderGetFormat func(uintptr) MemoryFormat

// Gets the format that the data will be downloaded in.
func (x *TextureDownloader) GetFormat() MemoryFormat {

	cret := xTextureDownloaderGetFormat(x.GoPointer())
	return cret
}

var xTextureDownloaderGetTexture func(uintptr) uintptr

// Gets the texture that the downloader will download.
func (x *TextureDownloader) GetTexture() *Texture {
	var cls *Texture

	cret := xTextureDownloaderGetTexture(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Texture{}
	cls.Ptr = cret
	return cls
}

var xTextureDownloaderSetColorState func(uintptr, *ColorState)

// Sets the color state the downloader will convert the data to.
//
// By default, the sRGB colorstate returned by [func@ColorState.get_srgb]
// is used.
func (x *TextureDownloader) SetColorState(ColorStateVar *ColorState) {

	xTextureDownloaderSetColorState(x.GoPointer(), ColorStateVar)

}

var xTextureDownloaderSetFormat func(uintptr, MemoryFormat)

// Sets the format the downloader will download.
//
// By default, GDK_MEMORY_DEFAULT is set.
func (x *TextureDownloader) SetFormat(FormatVar MemoryFormat) {

	xTextureDownloaderSetFormat(x.GoPointer(), FormatVar)

}

var xTextureDownloaderSetTexture func(uintptr, uintptr)

// Changes the texture the downloader will download.
func (x *TextureDownloader) SetTexture(TextureVar *Texture) {

	xTextureDownloaderSetTexture(x.GoPointer(), TextureVar.GoPointer())

}

const (
	// Represents the current time, and can be used anywhere a time is expected.
	CURRENT_TIME int = 0
)

func init() {
	core.SetPackageName("GDK", "gtk4")
	core.SetSharedLibrary("GDK", "libgtk-4.so.1")
	lib, err := purego.Dlopen(core.GetPath("GDK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xColorStateGLibType, lib, "gdk_color_state_get_type")

	core.PuregoSafeRegister(&xColorStateCreateCicpParams, lib, "gdk_color_state_create_cicp_params")
	core.PuregoSafeRegister(&xColorStateEqual, lib, "gdk_color_state_equal")
	core.PuregoSafeRegister(&xColorStateRef, lib, "gdk_color_state_ref")
	core.PuregoSafeRegister(&xColorStateUnref, lib, "gdk_color_state_unref")

	core.PuregoSafeRegister(&xContentFormatsGLibType, lib, "gdk_content_formats_get_type")

	core.PuregoSafeRegister(&xNewContentFormats, lib, "gdk_content_formats_new")
	core.PuregoSafeRegister(&xNewContentFormatsForGtype, lib, "gdk_content_formats_new_for_gtype")

	core.PuregoSafeRegister(&xContentFormatsContainGtype, lib, "gdk_content_formats_contain_gtype")
	core.PuregoSafeRegister(&xContentFormatsContainMimeType, lib, "gdk_content_formats_contain_mime_type")
	core.PuregoSafeRegister(&xContentFormatsGetGtypes, lib, "gdk_content_formats_get_gtypes")
	core.PuregoSafeRegister(&xContentFormatsGetMimeTypes, lib, "gdk_content_formats_get_mime_types")
	core.PuregoSafeRegister(&xContentFormatsIsEmpty, lib, "gdk_content_formats_is_empty")
	core.PuregoSafeRegister(&xContentFormatsMatch, lib, "gdk_content_formats_match")
	core.PuregoSafeRegister(&xContentFormatsMatchGtype, lib, "gdk_content_formats_match_gtype")
	core.PuregoSafeRegister(&xContentFormatsMatchMimeType, lib, "gdk_content_formats_match_mime_type")
	core.PuregoSafeRegister(&xContentFormatsPrint, lib, "gdk_content_formats_print")
	core.PuregoSafeRegister(&xContentFormatsRef, lib, "gdk_content_formats_ref")
	core.PuregoSafeRegister(&xContentFormatsToString, lib, "gdk_content_formats_to_string")
	core.PuregoSafeRegister(&xContentFormatsUnion, lib, "gdk_content_formats_union")
	core.PuregoSafeRegister(&xContentFormatsUnionDeserializeGtypes, lib, "gdk_content_formats_union_deserialize_gtypes")
	core.PuregoSafeRegister(&xContentFormatsUnionDeserializeMimeTypes, lib, "gdk_content_formats_union_deserialize_mime_types")
	core.PuregoSafeRegister(&xContentFormatsUnionSerializeGtypes, lib, "gdk_content_formats_union_serialize_gtypes")
	core.PuregoSafeRegister(&xContentFormatsUnionSerializeMimeTypes, lib, "gdk_content_formats_union_serialize_mime_types")
	core.PuregoSafeRegister(&xContentFormatsUnref, lib, "gdk_content_formats_unref")

	core.PuregoSafeRegister(&xDmabufFormatsGLibType, lib, "gdk_dmabuf_formats_get_type")

	core.PuregoSafeRegister(&xDmabufFormatsContains, lib, "gdk_dmabuf_formats_contains")
	core.PuregoSafeRegister(&xDmabufFormatsEqual, lib, "gdk_dmabuf_formats_equal")
	core.PuregoSafeRegister(&xDmabufFormatsGetFormat, lib, "gdk_dmabuf_formats_get_format")
	core.PuregoSafeRegister(&xDmabufFormatsGetNFormats, lib, "gdk_dmabuf_formats_get_n_formats")
	core.PuregoSafeRegister(&xDmabufFormatsRef, lib, "gdk_dmabuf_formats_ref")
	core.PuregoSafeRegister(&xDmabufFormatsUnref, lib, "gdk_dmabuf_formats_unref")

	core.PuregoSafeRegister(&xRectangleGLibType, lib, "gdk_rectangle_get_type")

	core.PuregoSafeRegister(&xRectangleContainsPoint, lib, "gdk_rectangle_contains_point")
	core.PuregoSafeRegister(&xRectangleEqual, lib, "gdk_rectangle_equal")
	core.PuregoSafeRegister(&xRectangleIntersect, lib, "gdk_rectangle_intersect")
	core.PuregoSafeRegister(&xRectangleUnion, lib, "gdk_rectangle_union")

	core.PuregoSafeRegister(&xTextureDownloaderGLibType, lib, "gdk_texture_downloader_get_type")

	core.PuregoSafeRegister(&xNewTextureDownloader, lib, "gdk_texture_downloader_new")

	core.PuregoSafeRegister(&xTextureDownloaderCopy, lib, "gdk_texture_downloader_copy")
	core.PuregoSafeRegister(&xTextureDownloaderDownloadBytes, lib, "gdk_texture_downloader_download_bytes")
	core.PuregoSafeRegister(&xTextureDownloaderDownloadInto, lib, "gdk_texture_downloader_download_into")
	core.PuregoSafeRegister(&xTextureDownloaderFree, lib, "gdk_texture_downloader_free")
	core.PuregoSafeRegister(&xTextureDownloaderGetColorState, lib, "gdk_texture_downloader_get_color_state")
	core.PuregoSafeRegister(&xTextureDownloaderGetFormat, lib, "gdk_texture_downloader_get_format")
	core.PuregoSafeRegister(&xTextureDownloaderGetTexture, lib, "gdk_texture_downloader_get_texture")
	core.PuregoSafeRegister(&xTextureDownloaderSetColorState, lib, "gdk_texture_downloader_set_color_state")
	core.PuregoSafeRegister(&xTextureDownloaderSetFormat, lib, "gdk_texture_downloader_set_format")
	core.PuregoSafeRegister(&xTextureDownloaderSetTexture, lib, "gdk_texture_downloader_set_texture")

}
