// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import "github.com/jwijenbergh/puregotk/v4/gobject/types"

const (
	// Defines all possible DND actions.
	//
	// This can be used in [method@Gdk.Drop.status] messages when any drop
	// can be accepted or a more specific drop method is not yet known.
	ACTION_ALL int = 7
	// A mask covering all entries in `GdkModifierType`.
	MODIFIER_MASK int = 469769999
)

// Flags describing the current capabilities of a device/tool.
type AxisFlags int

var xAxisFlagsGLibType func() types.GType

func AxisFlagsGLibType() types.GType {
	return xAxisFlagsGLibType()
}

const (

	// X axis is present
	AxisFlagXValue AxisFlags = 2
	// Y axis is present
	AxisFlagYValue AxisFlags = 4
	// Scroll X delta axis is present
	AxisFlagDeltaXValue AxisFlags = 8
	// Scroll Y delta axis is present
	AxisFlagDeltaYValue AxisFlags = 16
	// Pressure axis is present
	AxisFlagPressureValue AxisFlags = 32
	// X tilt axis is present
	AxisFlagXtiltValue AxisFlags = 64
	// Y tilt axis is present
	AxisFlagYtiltValue AxisFlags = 128
	// Wheel axis is present
	AxisFlagWheelValue AxisFlags = 256
	// Distance axis is present
	AxisFlagDistanceValue AxisFlags = 512
	// Z-axis rotation is present
	AxisFlagRotationValue AxisFlags = 1024
	// Slider axis is present
	AxisFlagSliderValue AxisFlags = 2048
)

// Used in `GdkDrop` and `GdkDrag` to indicate the actions that the
// destination can and should do with the dropped data.
type DragAction int

var xDragActionGLibType func() types.GType

func DragActionGLibType() types.GType {
	return xDragActionGLibType()
}

const (

	// No action.
	ActionNoneValue DragAction = 0
	// Copy the data.
	ActionCopyValue DragAction = 1
	// Move the data, i.e. first copy it, then delete
	//   it from the source using the DELETE target of the X selection protocol.
	ActionMoveValue DragAction = 2
	// Add a link to the data. Note that this is only
	//   useful if source and destination agree on what it means, and is not
	//   supported on all platforms.
	ActionLinkValue DragAction = 4
	// Ask the user what to do with the data.
	ActionAskValue DragAction = 8
)

// The list of the different APIs that GdkGLContext can potentially support.
type GLAPI int

var xGLAPIGLibType func() types.GType

func GLAPIGLibType() types.GType {
	return xGLAPIGLibType()
}

const (

	// The OpenGL API
	GlApiGlValue GLAPI = 1
	// The OpenGL ES API
	GlApiGlesValue GLAPI = 2
)

// Flags to indicate the state of modifier keys and mouse buttons
// in events.
//
// Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose,
// Apple, CapsLock or ShiftLock.
//
// Note that GDK may add internal values to events which include values outside
// of this enumeration. Your code should preserve and ignore them. You can use
// %GDK_MODIFIER_MASK to remove all private values.
type ModifierType int

var xModifierTypeGLibType func() types.GType

func ModifierTypeGLibType() types.GType {
	return xModifierTypeGLibType()
}

const (

	// No modifier.
	NoModifierMaskValue ModifierType = 0
	// the Shift key.
	ShiftMaskValue ModifierType = 1
	// a Lock key (depending on the Windowing System configuration,
	//    this may either be &lt;kbd&gt;CapsLock&lt;/kbd&gt; or &lt;kbd&gt;ShiftLock&lt;/kbd&gt;).
	LockMaskValue ModifierType = 2
	// the Control key.
	ControlMaskValue ModifierType = 4
	// the fourth modifier key (it depends on the Windowing System
	//    configuration which key is interpreted as this modifier, but normally it
	//    is the &lt;kbd&gt;Alt&lt;/kbd&gt; key).
	AltMaskValue ModifierType = 8
	// the first mouse button.
	Button1MaskValue ModifierType = 256
	// the second mouse button.
	Button2MaskValue ModifierType = 512
	// the third mouse button.
	Button3MaskValue ModifierType = 1024
	// the fourth mouse button.
	Button4MaskValue ModifierType = 2048
	// the fifth mouse button.
	Button5MaskValue ModifierType = 4096
	// the Super modifier.
	SuperMaskValue ModifierType = 67108864
	// the Hyper modifier.
	HyperMaskValue ModifierType = 134217728
	// the Meta modifier. Maps to Command on macOS.
	MetaMaskValue ModifierType = 268435456
)

// Defines how device axes are interpreted by GTK.
//
// Note that the X and Y axes are not really needed; pointer devices
// report their location via the x/y members of events regardless. Whether
// X and Y are present as axes depends on the GDK backend.
type AxisUse int

var xAxisUseGLibType func() types.GType

func AxisUseGLibType() types.GType {
	return xAxisUseGLibType()
}

const (

	// the axis is ignored.
	AxisIgnoreValue AxisUse = 0
	// the axis is used as the x axis.
	AxisXValue AxisUse = 1
	// the axis is used as the y axis.
	AxisYValue AxisUse = 2
	// the axis is used as the scroll x delta
	AxisDeltaXValue AxisUse = 3
	// the axis is used as the scroll y delta
	AxisDeltaYValue AxisUse = 4
	// the axis is used for pressure information.
	AxisPressureValue AxisUse = 5
	// the axis is used for x tilt information.
	AxisXtiltValue AxisUse = 6
	// the axis is used for y tilt information.
	AxisYtiltValue AxisUse = 7
	// the axis is used for wheel information.
	AxisWheelValue AxisUse = 8
	// the axis is used for pen/tablet distance information
	AxisDistanceValue AxisUse = 9
	// the axis is used for pen rotation information
	AxisRotationValue AxisUse = 10
	// the axis is used for pen slider information
	AxisSliderValue AxisUse = 11
	// a constant equal to the numerically highest axis value.
	AxisLastValue AxisUse = 12
)

// Error enumeration for `GdkDmabufTexture`.
type DmabufError int

var xDmabufErrorGLibType func() types.GType

func DmabufErrorGLibType() types.GType {
	return xDmabufErrorGLibType()
}

const (

	// Dmabuf support is not available, because the OS
	//   is not Linux, or it was explicitly disabled at compile- or runtime
	DmabufErrorNotAvailableValue DmabufError = 0
	// The requested format is not supported
	DmabufErrorUnsupportedFormatValue DmabufError = 1
	// GTK failed to create the resource for other
	//   reasons
	DmabufErrorCreationFailedValue DmabufError = 2
)

// Error enumeration for `GdkGLContext`.
type GLError int

var xGLErrorGLibType func() types.GType

func GLErrorGLibType() types.GType {
	return xGLErrorGLibType()
}

const (

	// OpenGL support is not available
	GlErrorNotAvailableValue GLError = 0
	// The requested visual format is not supported
	GlErrorUnsupportedFormatValue GLError = 1
	// The requested profile is not supported
	GlErrorUnsupportedProfileValue GLError = 2
	// The shader compilation failed
	GlErrorCompilationFailedValue GLError = 3
	// The shader linking failed
	GlErrorLinkFailedValue GLError = 4
)

// Defines the reference point of a surface and is used in `GdkPopupLayout`.
type Gravity int

var xGravityGLibType func() types.GType

func GravityGLibType() types.GType {
	return xGravityGLibType()
}

const (

	// the reference point is at the top left corner.
	GravityNorthWestValue Gravity = 1
	// the reference point is in the middle of the top edge.
	GravityNorthValue Gravity = 2
	// the reference point is at the top right corner.
	GravityNorthEastValue Gravity = 3
	// the reference point is at the middle of the left edge.
	GravityWestValue Gravity = 4
	// the reference point is at the center of the surface.
	GravityCenterValue Gravity = 5
	// the reference point is at the middle of the right edge.
	GravityEastValue Gravity = 6
	// the reference point is at the lower left corner.
	GravitySouthWestValue Gravity = 7
	// the reference point is at the middle of the lower edge.
	GravitySouthValue Gravity = 8
	// the reference point is at the lower right corner.
	GravitySouthEastValue Gravity = 9
	// the reference point is at the top left corner of the
	//  surface itself, ignoring window manager decorations.
	GravityStaticValue Gravity = 10
)

// Describes formats that image data can have in memory.
//
// It describes formats by listing the contents of the memory passed to it.
// So `GDK_MEMORY_A8R8G8B8` will be 1 byte (8 bits) of alpha, followed by a
// byte each of red, green and blue. It is not endian-dependent, so
// `CAIRO_FORMAT_ARGB32` is represented by different `GdkMemoryFormats`
// on architectures with different endiannesses.
//
// Its naming is modelled after
// [VkFormat](https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormat)
// for details).
type MemoryFormat int

var xMemoryFormatGLibType func() types.GType

func MemoryFormatGLibType() types.GType {
	return xMemoryFormatGLibType()
}

const (

	// 4 bytes; for blue, green, red, alpha.
	//   The color values are premultiplied with the alpha value.
	MemoryB8g8r8a8PremultipliedValue MemoryFormat = 0
	// 4 bytes; for alpha, red, green, blue.
	//   The color values are premultiplied with the alpha value.
	MemoryA8r8g8b8PremultipliedValue MemoryFormat = 1
	// 4 bytes; for red, green, blue, alpha
	//   The color values are premultiplied with the alpha value.
	MemoryR8g8b8a8PremultipliedValue MemoryFormat = 2
	// 4 bytes; for blue, green, red, alpha.
	MemoryB8g8r8a8Value MemoryFormat = 3
	// 4 bytes; for alpha, red, green, blue.
	MemoryA8r8g8b8Value MemoryFormat = 4
	// 4 bytes; for red, green, blue, alpha.
	MemoryR8g8b8a8Value MemoryFormat = 5
	// 4 bytes; for alpha, blue, green, red.
	MemoryA8b8g8r8Value MemoryFormat = 6
	// 3 bytes; for red, green, blue. The data is opaque.
	MemoryR8g8b8Value MemoryFormat = 7
	// 3 bytes; for blue, green, red. The data is opaque.
	MemoryB8g8r8Value MemoryFormat = 8
	// 3 guint16 values; for red, green, blue.
	MemoryR16g16b16Value MemoryFormat = 9
	// 4 guint16 values; for red, green, blue, alpha. The color values are
	// premultiplied with the alpha value.
	MemoryR16g16b16a16PremultipliedValue MemoryFormat = 10
	// 4 guint16 values; for red, green, blue, alpha.
	MemoryR16g16b16a16Value MemoryFormat = 11
	// 3 half-float values; for red, green, blue. The data is opaque.
	MemoryR16g16b16FloatValue MemoryFormat = 12
	// 4 half-float values; for red, green, blue and alpha. The color values are
	// premultiplied with the alpha value.
	MemoryR16g16b16a16FloatPremultipliedValue MemoryFormat = 13
	// 4 half-float values; for red, green, blue and alpha.
	MemoryR16g16b16a16FloatValue MemoryFormat = 14
	// 3 float values; for red, green, blue.
	MemoryR32g32b32FloatValue MemoryFormat = 15
	// 4 float values; for red, green, blue and alpha. The color values are
	// premultiplied with the alpha value.
	MemoryR32g32b32a32FloatPremultipliedValue MemoryFormat = 16
	// 4 float values; for red, green, blue and alpha.
	MemoryR32g32b32a32FloatValue MemoryFormat = 17
	// 2 bytes; for grayscale, alpha. The color values are premultiplied with the
	// alpha value.
	MemoryG8a8PremultipliedValue MemoryFormat = 18
	// 2 bytes; for grayscale, alpha.
	MemoryG8a8Value MemoryFormat = 19
	// One byte; for grayscale. The data is opaque.
	MemoryG8Value MemoryFormat = 20
	// 2 guint16 values; for grayscale, alpha. The color values are premultiplied
	// with the alpha value.
	MemoryG16a16PremultipliedValue MemoryFormat = 21
	// 2 guint16 values; for grayscale, alpha.
	MemoryG16a16Value MemoryFormat = 22
	// One guint16 value; for grayscale. The data is opaque.
	MemoryG16Value MemoryFormat = 23
	// One byte; for alpha.
	MemoryA8Value MemoryFormat = 24
	// One guint16 value; for alpha.
	MemoryA16Value MemoryFormat = 25
	// One half-float value; for alpha.
	MemoryA16FloatValue MemoryFormat = 26
	// One float value; for alpha.
	MemoryA32FloatValue MemoryFormat = 27
	// 4 bytes; for alpha, blue, green, red, The color values are premultiplied with
	// the alpha value.
	MemoryA8b8g8r8PremultipliedValue MemoryFormat = 28
	// 4 bytes; for blue, green, red, unused.
	MemoryB8g8r8x8Value MemoryFormat = 29
	// 4 bytes; for unused, red, green, blue.
	MemoryX8r8g8b8Value MemoryFormat = 30
	// 4 bytes; for red, green, blue, unused.
	MemoryR8g8b8x8Value MemoryFormat = 31
	// 4 bytes; for unused, blue, green, red.
	MemoryX8b8g8r8Value MemoryFormat = 32
	// Multiplane format with 2 planes.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cb followed by Cr.
	// Subsampled in both the X and Y direction.
	//
	// Commonly known by the fourcc "NV12".
	MemoryG8B8r8420Value MemoryFormat = 33
	// Multiplane format with 2 planes.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cr followed by Cb.
	// Subsampled in both the X and Y direction.
	//
	// Commonly known by the fourcc "NV21".
	MemoryG8R8b8420Value MemoryFormat = 34
	// Multiplane format with 2 planes.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cb followed by Cr.
	// Subsampled in the X direction.
	//
	// Commonly known by the fourcc "NV16".
	MemoryG8B8r8422Value MemoryFormat = 35
	// Multiplane format with 2 planes.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cr followed by Cb.
	// Subsampled in the X direction.
	//
	// Commonly known by the fourcc "NV61".
	MemoryG8R8b8422Value MemoryFormat = 36
	// Multiplane format with 2 planes.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cb followed by Cr.
	// This format is not subsampled.
	//
	// Commonly known by the fourcc "NV24".
	MemoryG8B8r8444Value MemoryFormat = 37
	// Multiplane format with 2 planes.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cr followed by Cb.
	// This format is not subsampled.
	//
	// Commonly known by the fourcc "NV42".
	MemoryG8R8b8444Value MemoryFormat = 38
	// Multiplane format with 2 planes.
	//
	// Each channel is a 16 bit integer, but only the highest 10 bits are used.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cr followed by Cb.
	// This format is not subsampled.
	//
	// Commonly known by the fourcc "P010".
	MemoryG10x6B10x6r10x6420Value MemoryFormat = 39
	// Multiplane format with 2 planes.
	//
	// Each channel is a 16 bit integer, but only the highest 10 bits are used.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cr followed by Cb.
	// This format is not subsampled.
	//
	// Commonly known by the fourcc "P012".
	MemoryG12x4B12x4r12x4420Value MemoryFormat = 40
	// Multiplane format with 2 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// The first plane contains the first channel, usually containing
	// luma values.
	// The second plane with interleaved chroma values, Cr followed by Cb.
	// This format is not subsampled.
	//
	// Commonly known by the fourcc "P016".
	MemoryG16B16r16420Value MemoryFormat = 41
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in both the X and Y direction with 4:1 ratio. It is
	// mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in both the X and Y direction with 4:1 ratio. It is
	// mapped into the 1st channel.
	//
	// Commonly known by the fourcc "YUV410".
	MemoryG8B8R8410Value MemoryFormat = 42
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the second chroma chanel.
	// Subsampled in both the X and Y direction with 4:1 ratio. It is
	// mapped into the 1st channel.
	//
	// The third plane usually contains the first chroma channel.
	// Subsampled in both the X and Y direction with 4:1 ratio. It is
	// mapped into the 3rd channel.
	//
	// Commonly known by the fourcc "YVU410".
	MemoryG8R8B8410Value MemoryFormat = 43
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in the X direction with 4:1 ratio. It is
	// mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in the X direction with 4:1 ratio. It is
	// mapped into the 1st channel.
	//
	// Commonly known by the fourcc "YUV411".
	MemoryG8B8R8411Value MemoryFormat = 44
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the second chroma chanel.
	// Subsampled in the X direction with 4:1 ratio. It is
	// mapped into the 1st channel.
	//
	// The third plane usually contains the first chroma channel.
	// Subsampled in the X direction with 4:1 ratio. It is
	// mapped into the 3rd channel.
	//
	// Commonly known by the fourcc "YVU411".
	MemoryG8R8B8411Value MemoryFormat = 45
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 1st channel.
	//
	// Commonly known by the fourcc "YUV420".
	MemoryG8B8R8420Value MemoryFormat = 46
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the second chroma chanel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 1st channel.
	//
	// The third plane usually contains the first chroma channel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 3rd channel.
	//
	// Commonly known by the fourcc "YVU420".
	MemoryG8R8B8420Value MemoryFormat = 47
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in the X direction. It is mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in the X direction. It is mapped into the 1st channel.
	//
	// Commonly known by the fourcc "YUV422".
	MemoryG8B8R8422Value MemoryFormat = 48
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the second chroma chanel.
	// Subsampled in the X direction. It is mapped into the 1st channel.
	//
	// The third plane usually contains the first chroma channel.
	// Subsampled in the X direction. It is mapped into the 3rd channel.
	//
	// Commonly known by the fourcc "YVU422".
	MemoryG8R8B8422Value MemoryFormat = 49
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel. It is
	// mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel. It is
	// mapped into the 1st channel.
	//
	// Commonly known by the fourcc "YUV444".
	MemoryG8B8R8444Value MemoryFormat = 50
	// Multiplane format with 3 planes.
	//
	// Each channel is a 8 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the second chroma chanel.
	// Subsampled in the X direction. It is mapped into the 1st channel.
	//
	// The third plane usually contains the first chroma channel.
	// Subsampled in the X direction. It is mapped into the 3rd channel.
	//
	// Commonly known by the fourcc "YVU444".
	MemoryG8R8B8444Value MemoryFormat = 51
	// Packed format with subsampled channels.
	//
	// Each channel is a 8 bit integer. The red and blue/chroma channels
	// are subsampled and interleaved with the green/luma channel.
	//
	// Each block contains 2 pixels, so the width must be a multiple of
	// 2.
	//
	// Commonly known by the fourcc "YUYV".
	MemoryG8b8g8r8422Value MemoryFormat = 52
	// Packed format with subsampled channels.
	//
	// Each channel is a 8 bit integer. The red and blue/chroma channels
	// are subsampled and interleaved with the green/luma channel.
	//
	// Each block contains 2 pixels, so the width must be a multiple of
	// 2.
	//
	// Commonly known by the fourcc "YVYU".
	MemoryG8r8g8b8422Value MemoryFormat = 53
	// Packed format with subsampled channels.
	//
	// Each channel is a 8 bit integer. The red and blue/chroma channels
	// are subsampled and interleaved with the green/luma channel.
	//
	// Each block contains 2 pixels, so the width must be a multiple of
	// 2.
	//
	// Commonly known by the fourcc "VYUY".
	MemoryR8g8b8g8422Value MemoryFormat = 54
	// Packed format with subsampled channels.
	//
	// Each channel is a 8 bit integer. The red and blue/chroma channels
	// are subsampled and interleaved with the green/luma channel.
	//
	// Each block contains 2 pixels, so the width must be a multiple of
	// 2.
	//
	// Commonly known by the fourcc "UYVY".
	MemoryB8g8r8g8422Value MemoryFormat = 55
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// Only the 10 lower bits are used. The remaining ones must be set to 0 by the
	// producer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 1st channel.
	//
	// Commonly known by the fourcc "S010".
	MemoryX6g10X6b10X6r10420Value MemoryFormat = 56
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// Only the 10 lower bits are used. The remaining ones must be set to 0 by the
	// producer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in the X direction. It is mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in the X direction. It is mapped into the 1st channel.
	//
	// Commonly known by the fourcc "S210".
	MemoryX6g10X6b10X6r10422Value MemoryFormat = 57
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// Only the 10 lower bits are used. The remaining ones must be set to 0 by the
	// producer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel. It is
	// mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel. It is
	// mapped into the 1st channel.
	//
	// Commonly known by the fourcc "S410".
	MemoryX6g10X6b10X6r10444Value MemoryFormat = 58
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// Only the 12 lower bits are used. The remaining ones must be set to 0 by the
	// producer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 1st channel.
	//
	// Commonly known by the fourcc "S012".
	MemoryX4g12X4b12X4r12420Value MemoryFormat = 59
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// Only the 12 lower bits are used. The remaining ones must be set to 0 by the
	// producer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in the X direction. It is mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in the X direction. It is mapped into the 1st channel.
	//
	// Commonly known by the fourcc "S212".
	MemoryX4g12X4b12X4r12422Value MemoryFormat = 60
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// Only the 12 lower bits are used. The remaining ones must be set to 0 by the
	// producer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel. It is
	// mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel. It is
	// mapped into the 1st channel.
	//
	// Commonly known by the fourcc "S412".
	MemoryX4g12X4b12X4r12444Value MemoryFormat = 61
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in both the X and Y direction. It is mapped into the
	// 1st channel.
	//
	// Commonly known by the fourcc "S016".
	MemoryG16B16R16420Value MemoryFormat = 62
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel.
	// Subsampled in the X direction. It is mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel.
	// Subsampled in the X direction. It is mapped into the 1st channel.
	//
	// Commonly known by the fourcc "S216".
	MemoryG16B16R16422Value MemoryFormat = 63
	// Multiplane format with 3 planes.
	//
	// Each channel is a 16 bit integer.
	//
	// The first plane usually contains the luma channel. It is mapped
	// into the 2nd channel.
	//
	// The second plane usually contains the first chroma chanel. It is
	// mapped into the 3rd channel.
	//
	// The third plane usually contains the second chroma channel. It is
	// mapped into the 1st channel.
	//
	// Commonly known by the fourcc "S416".
	MemoryG16B16R16444Value MemoryFormat = 64
	// The number of formats. This value will change as
	//   more formats get added, so do not rely on its concrete integer.
	MemoryNFormatsValue MemoryFormat = 65
)

// Used in scroll events, to announce the direction relative
// to physical motion.
type ScrollRelativeDirection int

var xScrollRelativeDirectionGLibType func() types.GType

func ScrollRelativeDirectionGLibType() types.GType {
	return xScrollRelativeDirectionGLibType()
}

const (

	// Physical motion and event motion are the same
	ScrollRelativeDirectionIdenticalValue ScrollRelativeDirection = 0
	// Physical motion is inverted relative to event motion
	ScrollRelativeDirectionInvertedValue ScrollRelativeDirection = 1
	// Relative motion is unknown on this device or backend
	ScrollRelativeDirectionUnknownValue ScrollRelativeDirection = 2
)

// Error enumeration for `GdkVulkanContext`.
type VulkanError int

var xVulkanErrorGLibType func() types.GType

func VulkanErrorGLibType() types.GType {
	return xVulkanErrorGLibType()
}

const (

	// Vulkan is not supported on this backend or has not been
	//   compiled in.
	VulkanErrorUnsupportedValue VulkanError = 0
	// Vulkan support is not available on this Surface
	VulkanErrorNotAvailableValue VulkanError = 1
)
