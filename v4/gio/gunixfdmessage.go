// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type UnixFDMessageClass struct {
	_ structs.HostLayout

	ParentClass SocketControlMessageClass

	xGReserved1 uintptr

	xGReserved2 uintptr
}

func (x *UnixFDMessageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGReserved1 sets the callback function.
func (x *UnixFDMessageClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the callback function.
func (x *UnixFDMessageClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the callback function.
func (x *UnixFDMessageClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the callback function.
func (x *UnixFDMessageClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

type UnixFDMessagePrivate struct {
	_ structs.HostLayout
}

func (x *UnixFDMessagePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// This [class@Gio.SocketControlMessage] contains a [class@Gio.UnixFDList].
// It may be sent using [method@Gio.Socket.send_message] and received using
// [method@Gio.Socket.receive_message] over UNIX sockets (ie: sockets in the
// `G_SOCKET_FAMILY_UNIX` family). The file descriptors are copied
// between processes by the kernel.
//
// For an easier way to send and receive file descriptors over
// stream-oriented UNIX sockets, see [method@Gio.UnixConnection.send_fd] and
// [method@Gio.UnixConnection.receive_fd].
//
// Note that `&lt;gio/gunixfdmessage.h&gt;` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
// file or the `GioUnix-2.0` GIR namespace when using it.
type UnixFDMessage struct {
	SocketControlMessage
}

var xUnixFDMessageGLibType func() types.GType

func UnixFDMessageGLibType() types.GType {
	return xUnixFDMessageGLibType()
}

func UnixFDMessageNewFromInternalPtr(ptr uintptr) *UnixFDMessage {
	cls := &UnixFDMessage{}
	cls.Ptr = ptr
	return cls
}

var xNewUnixFDMessage func() uintptr

// Creates a new #GUnixFDMessage containing an empty file descriptor
// list.
func NewUnixFDMessage() *UnixFDMessage {
	var cls *UnixFDMessage

	cret := xNewUnixFDMessage()

	if cret == 0 {
		return nil
	}
	cls = &UnixFDMessage{}
	cls.Ptr = cret
	return cls
}

var xNewUnixFDMessageWithFdList func(uintptr) uintptr

// Creates a new #GUnixFDMessage containing @list.
func NewUnixFDMessageWithFdList(FdListVar *UnixFDList) *UnixFDMessage {
	var cls *UnixFDMessage

	cret := xNewUnixFDMessageWithFdList(FdListVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &UnixFDMessage{}
	cls.Ptr = cret
	return cls
}

var xUnixFDMessageAppendFd func(uintptr, int, **glib.Error) bool

// Adds a file descriptor to @message.
//
// The file descriptor is duplicated using dup(). You keep your copy
// of the descriptor and the copy contained in @message will be closed
// when @message is finalized.
//
// A possible cause of failure is exceeding the per-process or
// system-wide file descriptor limit.
func (x *UnixFDMessage) AppendFd(FdVar int) (bool, error) {
	var cerr *glib.Error

	cret := xUnixFDMessageAppendFd(x.GoPointer(), FdVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixFDMessageGetFdList func(uintptr) uintptr

// Gets the #GUnixFDList contained in @message.  This function does not
// return a reference to the caller, but the returned list is valid for
// the lifetime of @message.
func (x *UnixFDMessage) GetFdList() *UnixFDList {
	var cls *UnixFDList

	cret := xUnixFDMessageGetFdList(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &UnixFDList{}
	cls.Ptr = cret
	return cls
}

var xUnixFDMessageStealFds func(uintptr, int) uintptr

// Returns the array of file descriptors that is contained in this
// object.
//
// After this call, the descriptors are no longer contained in
// @message. Further calls will return an empty list (unless more
// descriptors have been added).
//
// The return result of this function must be freed with g_free().
// The caller is also responsible for closing all of the file
// descriptors.
//
// If @length is non-%NULL then it is set to the number of file
// descriptors in the returned array. The returned array is also
// terminated with -1.
//
// This function never returns %NULL. In case there are no file
// descriptors contained in @message, an empty array is returned.
func (x *UnixFDMessage) StealFds(LengthVar int) uintptr {

	cret := xUnixFDMessageStealFds(x.GoPointer(), LengthVar)
	return cret
}

func (c *UnixFDMessage) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *UnixFDMessage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibrary("GIO", "libgio-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xUnixFDMessageGLibType, lib, "g_unix_fd_message_get_type")

	core.PuregoSafeRegister(&xNewUnixFDMessage, lib, "g_unix_fd_message_new")
	core.PuregoSafeRegister(&xNewUnixFDMessageWithFdList, lib, "g_unix_fd_message_new_with_fd_list")

	core.PuregoSafeRegister(&xUnixFDMessageAppendFd, lib, "g_unix_fd_message_append_fd")
	core.PuregoSafeRegister(&xUnixFDMessageGetFdList, lib, "g_unix_fd_message_get_fd_list")
	core.PuregoSafeRegister(&xUnixFDMessageStealFds, lib, "g_unix_fd_message_steal_fds")

}
