// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Invoked when a connection to a message bus has been obtained.
type BusAcquiredCallback func(uintptr, string, uintptr)

// Invoked when the name is acquired.
type BusNameAcquiredCallback func(uintptr, string, uintptr)

// Invoked when the name is lost or @connection has been closed.
type BusNameLostCallback func(uintptr, string, uintptr)

var xBusOwnName func(BusType, string, BusNameOwnerFlags, uintptr, uintptr, uintptr, uintptr, uintptr) uint

// Requests ownership of @name on the bus specified by @bus_type.
//
// It asynchronously calls @name_acquired_handler and @name_lost_handler when
// the name is acquired and lost, respectively.
//
// Callbacks will be invoked in the thread-default
// main context (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this function from.
//
// You are guaranteed that one of the @name_acquired_handler and @name_lost_handler
// callbacks will be invoked after calling this function — there are three
// possible cases:
//
//   - @name_lost_handler with a `NULL` connection (if a connection to the bus
//     can’t be made).
//   - @bus_acquired_handler then @name_lost_handler (if the name can’t be
//     obtained).
//   - @bus_acquired_handler then @name_acquired_handler (if the name was
//     obtained).
//
// When you are done owning the name, call [func@Gio.bus_unown_name] with the
// owner ID this function returns.
//
// If the name is acquired or lost (for example another application
// could acquire the name if you allow replacement or the application
// currently owning the name exits), the handlers are also invoked.
// If the [class@Gio.DBusConnection] that is used for attempting to own the name
// closes, then @name_lost_handler is invoked since it is no longer
// possible for other processes to access the process.
//
// You cannot use [func@Gio.bus_own_name] several times for the same name (unless
// interleaved with calls to [func@Gio.bus_unown_name]) — only the first call
// will work.
//
// Another guarantee is that invocations of @name_acquired_handler
// and @name_lost_handler are guaranteed to alternate; that
// is, if @name_acquired_handler is invoked then you are
// guaranteed that the next time one of the handlers is invoked, it
// will be @name_lost_handler. The reverse is also true.
//
// If you plan on exporting objects (using, for example,
// [method@Gio.DBusConnection.register_object]), note that it is generally too late
// to export the objects in @name_acquired_handler. Instead, you can do this
// in @bus_acquired_handler since you are guaranteed that this will run
// before @name is requested from the bus.
//
// This behavior makes it very simple to write applications that want
// to [own names](dbus-name-owning.html#d-bus-name-owning) and export objects.
// Simply register objects to be exported in @bus_acquired_handler and
// unregister the objects (if any) in @name_lost_handler.
func BusOwnName(BusTypeVar BusType, NameVar string, FlagsVar BusNameOwnerFlags, BusAcquiredHandlerVar *BusAcquiredCallback, NameAcquiredHandlerVar *BusNameAcquiredCallback, NameLostHandlerVar *BusNameLostCallback, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) uint {

	var BusAcquiredHandlerVarRef uintptr
	if BusAcquiredHandlerVar != nil {
		BusAcquiredHandlerVarPtr := uintptr(unsafe.Pointer(BusAcquiredHandlerVar))
		if cbRefPtr, ok := glib.GetCallback(BusAcquiredHandlerVarPtr); ok {
			BusAcquiredHandlerVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *BusAcquiredHandlerVar
				cbFn(arg0, core.GoString(arg1), arg2)
			}
			BusAcquiredHandlerVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(BusAcquiredHandlerVarPtr, BusAcquiredHandlerVarRef, BusAcquiredHandlerVar)
		}
	}

	var NameAcquiredHandlerVarRef uintptr
	if NameAcquiredHandlerVar != nil {
		NameAcquiredHandlerVarPtr := uintptr(unsafe.Pointer(NameAcquiredHandlerVar))
		if cbRefPtr, ok := glib.GetCallback(NameAcquiredHandlerVarPtr); ok {
			NameAcquiredHandlerVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *NameAcquiredHandlerVar
				cbFn(arg0, core.GoString(arg1), arg2)
			}
			NameAcquiredHandlerVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(NameAcquiredHandlerVarPtr, NameAcquiredHandlerVarRef, NameAcquiredHandlerVar)
		}
	}

	var NameLostHandlerVarRef uintptr
	if NameLostHandlerVar != nil {
		NameLostHandlerVarPtr := uintptr(unsafe.Pointer(NameLostHandlerVar))
		if cbRefPtr, ok := glib.GetCallback(NameLostHandlerVarPtr); ok {
			NameLostHandlerVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *NameLostHandlerVar
				cbFn(arg0, core.GoString(arg1), arg2)
			}
			NameLostHandlerVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(NameLostHandlerVarPtr, NameLostHandlerVarRef, NameLostHandlerVar)
		}
	}

	var UserDataFreeFuncVarRef uintptr
	if UserDataFreeFuncVar != nil {
		UserDataFreeFuncVarPtr := uintptr(unsafe.Pointer(UserDataFreeFuncVar))
		if cbRefPtr, ok := glib.GetCallback(UserDataFreeFuncVarPtr); ok {
			UserDataFreeFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *UserDataFreeFuncVar
				cbFn(arg0)
			}
			UserDataFreeFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(UserDataFreeFuncVarPtr, UserDataFreeFuncVarRef, UserDataFreeFuncVar)
		}
	}

	cret := xBusOwnName(BusTypeVar, NameVar, FlagsVar, BusAcquiredHandlerVarRef, NameAcquiredHandlerVarRef, NameLostHandlerVarRef, UserDataVar, UserDataFreeFuncVarRef)
	return cret
}

var xBusOwnNameOnConnection func(uintptr, string, BusNameOwnerFlags, uintptr, uintptr, uintptr, uintptr) uint

// Like [func@Gio.bus_own_name] but takes a [class@Gio.DBusConnection] instead
// of a [enum@Gio.BusType].
func BusOwnNameOnConnection(ConnectionVar *DBusConnection, NameVar string, FlagsVar BusNameOwnerFlags, NameAcquiredHandlerVar *BusNameAcquiredCallback, NameLostHandlerVar *BusNameLostCallback, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) uint {

	var NameAcquiredHandlerVarRef uintptr
	if NameAcquiredHandlerVar != nil {
		NameAcquiredHandlerVarPtr := uintptr(unsafe.Pointer(NameAcquiredHandlerVar))
		if cbRefPtr, ok := glib.GetCallback(NameAcquiredHandlerVarPtr); ok {
			NameAcquiredHandlerVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *NameAcquiredHandlerVar
				cbFn(arg0, core.GoString(arg1), arg2)
			}
			NameAcquiredHandlerVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(NameAcquiredHandlerVarPtr, NameAcquiredHandlerVarRef, NameAcquiredHandlerVar)
		}
	}

	var NameLostHandlerVarRef uintptr
	if NameLostHandlerVar != nil {
		NameLostHandlerVarPtr := uintptr(unsafe.Pointer(NameLostHandlerVar))
		if cbRefPtr, ok := glib.GetCallback(NameLostHandlerVarPtr); ok {
			NameLostHandlerVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *NameLostHandlerVar
				cbFn(arg0, core.GoString(arg1), arg2)
			}
			NameLostHandlerVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(NameLostHandlerVarPtr, NameLostHandlerVarRef, NameLostHandlerVar)
		}
	}

	var UserDataFreeFuncVarRef uintptr
	if UserDataFreeFuncVar != nil {
		UserDataFreeFuncVarPtr := uintptr(unsafe.Pointer(UserDataFreeFuncVar))
		if cbRefPtr, ok := glib.GetCallback(UserDataFreeFuncVarPtr); ok {
			UserDataFreeFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *UserDataFreeFuncVar
				cbFn(arg0)
			}
			UserDataFreeFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(UserDataFreeFuncVarPtr, UserDataFreeFuncVarRef, UserDataFreeFuncVar)
		}
	}

	cret := xBusOwnNameOnConnection(ConnectionVar.GoPointer(), NameVar, FlagsVar, NameAcquiredHandlerVarRef, NameLostHandlerVarRef, UserDataVar, UserDataFreeFuncVarRef)
	return cret
}

var xBusOwnNameOnConnectionWithClosures func(uintptr, string, BusNameOwnerFlags, *gobject.Closure, *gobject.Closure) uint

// Version of [func@Gio.bus_own_name_on_connection] using closures instead of
// callbacks for easier binding in other languages.
func BusOwnNameOnConnectionWithClosures(ConnectionVar *DBusConnection, NameVar string, FlagsVar BusNameOwnerFlags, NameAcquiredClosureVar *gobject.Closure, NameLostClosureVar *gobject.Closure) uint {

	cret := xBusOwnNameOnConnectionWithClosures(ConnectionVar.GoPointer(), NameVar, FlagsVar, NameAcquiredClosureVar, NameLostClosureVar)
	return cret
}

var xBusOwnNameWithClosures func(BusType, string, BusNameOwnerFlags, *gobject.Closure, *gobject.Closure, *gobject.Closure) uint

// Version of [func@Gio.bus_own_name using closures instead of callbacks for
// easier binding in other languages.
func BusOwnNameWithClosures(BusTypeVar BusType, NameVar string, FlagsVar BusNameOwnerFlags, BusAcquiredClosureVar *gobject.Closure, NameAcquiredClosureVar *gobject.Closure, NameLostClosureVar *gobject.Closure) uint {

	cret := xBusOwnNameWithClosures(BusTypeVar, NameVar, FlagsVar, BusAcquiredClosureVar, NameAcquiredClosureVar, NameLostClosureVar)
	return cret
}

var xBusUnownName func(uint)

// Stops owning a name.
//
// Note that there may still be D-Bus traffic to process (relating to owning
// and unowning the name) in the current thread-default
// [struct@GLib.MainContext] after this function has returned. You should
// continue to iterate the [struct@GLib.MainContext] until the
// [callback@GLib.DestroyNotify] function passed to [func@Gio.bus_own_name] is
// called, in order to avoid memory leaks through callbacks queued on the
// [struct@GLib.MainContext] after it’s stopped being iterated.
func BusUnownName(OwnerIdVar uint) {

	xBusUnownName(OwnerIdVar)

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xBusOwnName, libs, "g_bus_own_name")
	core.PuregoSafeRegister(&xBusOwnNameOnConnection, libs, "g_bus_own_name_on_connection")
	core.PuregoSafeRegister(&xBusOwnNameOnConnectionWithClosures, libs, "g_bus_own_name_on_connection_with_closures")
	core.PuregoSafeRegister(&xBusOwnNameWithClosures, libs, "g_bus_own_name_with_closures")
	core.PuregoSafeRegister(&xBusUnownName, libs, "g_bus_unown_name")

}
