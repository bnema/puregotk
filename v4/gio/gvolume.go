// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Interface for implementing operations for mountable volumes.
type VolumeIface struct {
	_ structs.HostLayout

	GIface uintptr

	xChanged uintptr

	xRemoved uintptr

	xGetName uintptr

	xGetIcon uintptr

	xGetUuid uintptr

	xGetDrive uintptr

	xGetMount uintptr

	xCanMount uintptr

	xCanEject uintptr

	xMountFn uintptr

	xMountFinish uintptr

	xEject uintptr

	xEjectFinish uintptr

	xGetIdentifier uintptr

	xEnumerateIdentifiers uintptr

	xShouldAutomount uintptr

	xGetActivationRoot uintptr

	xEjectWithOperation uintptr

	xEjectWithOperationFinish uintptr

	xGetSortKey uintptr

	xGetSymbolicIcon uintptr
}

func (x *VolumeIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideChanged sets the callback function.
// Changed signal that is emitted when the volume's state has changed.
func (x *VolumeIface) OverrideChanged(cb func(Volume)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(VolumeVarp uintptr) {
			cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetChanged gets the callback function.
// Changed signal that is emitted when the volume's state has changed.
func (x *VolumeIface) GetChanged() func(Volume) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(VolumeVar Volume) {
		rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideRemoved sets the callback function.
// The removed signal that is emitted when the #GVolume have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.
func (x *VolumeIface) OverrideRemoved(cb func(Volume)) {
	if cb == nil {
		x.xRemoved = 0
	} else {
		x.xRemoved = purego.NewCallback(func(VolumeVarp uintptr) {
			cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetRemoved gets the callback function.
// The removed signal that is emitted when the #GVolume have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.
func (x *VolumeIface) GetRemoved() func(Volume) {
	if x.xRemoved == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRemoved)
	return func(VolumeVar Volume) {
		rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideGetName sets the callback function.
// Gets a string containing the name of the #GVolume.
func (x *VolumeIface) OverrideGetName(cb func(Volume) string) {
	if cb == nil {
		x.xGetName = 0
	} else {
		x.xGetName = purego.NewCallback(func(VolumeVarp uintptr) string {
			return cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetGetName gets the callback function.
// Gets a string containing the name of the #GVolume.
func (x *VolumeIface) GetGetName() func(Volume) string {
	if x.xGetName == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetName)
	return func(VolumeVar Volume) string {
		return rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideGetIcon sets the callback function.
// Gets a #GIcon for the #GVolume.
func (x *VolumeIface) OverrideGetIcon(cb func(Volume) *IconBase) {
	if cb == nil {
		x.xGetIcon = 0
	} else {
		x.xGetIcon = purego.NewCallback(func(VolumeVarp uintptr) uintptr {
			ret := cb(&VolumeBase{Ptr: VolumeVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetIcon gets the callback function.
// Gets a #GIcon for the #GVolume.
func (x *VolumeIface) GetGetIcon() func(Volume) *IconBase {
	if x.xGetIcon == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetIcon)
	return func(VolumeVar Volume) *IconBase {
		rawRet := rawCallback(VolumeVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetUuid sets the callback function.
// Gets the UUID for the #GVolume. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.
func (x *VolumeIface) OverrideGetUuid(cb func(Volume) string) {
	if cb == nil {
		x.xGetUuid = 0
	} else {
		x.xGetUuid = purego.NewCallback(func(VolumeVarp uintptr) string {
			return cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetGetUuid gets the callback function.
// Gets the UUID for the #GVolume. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.
func (x *VolumeIface) GetGetUuid() func(Volume) string {
	if x.xGetUuid == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetUuid)
	return func(VolumeVar Volume) string {
		return rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideGetDrive sets the callback function.
// Gets a #GDrive the volume is located on. Returns %NULL if the #GVolume is not associated with a #GDrive.
func (x *VolumeIface) OverrideGetDrive(cb func(Volume) *DriveBase) {
	if cb == nil {
		x.xGetDrive = 0
	} else {
		x.xGetDrive = purego.NewCallback(func(VolumeVarp uintptr) uintptr {
			ret := cb(&VolumeBase{Ptr: VolumeVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetDrive gets the callback function.
// Gets a #GDrive the volume is located on. Returns %NULL if the #GVolume is not associated with a #GDrive.
func (x *VolumeIface) GetGetDrive() func(Volume) *DriveBase {
	if x.xGetDrive == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetDrive)
	return func(VolumeVar Volume) *DriveBase {
		rawRet := rawCallback(VolumeVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &DriveBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetMount sets the callback function.
// Gets a #GMount representing the mounted volume. Returns %NULL if the #GVolume is not mounted.
func (x *VolumeIface) OverrideGetMount(cb func(Volume) *MountBase) {
	if cb == nil {
		x.xGetMount = 0
	} else {
		x.xGetMount = purego.NewCallback(func(VolumeVarp uintptr) uintptr {
			ret := cb(&VolumeBase{Ptr: VolumeVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetMount gets the callback function.
// Gets a #GMount representing the mounted volume. Returns %NULL if the #GVolume is not mounted.
func (x *VolumeIface) GetGetMount() func(Volume) *MountBase {
	if x.xGetMount == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetMount)
	return func(VolumeVar Volume) *MountBase {
		rawRet := rawCallback(VolumeVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &MountBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCanMount sets the callback function.
// Returns %TRUE if the #GVolume can be mounted.
func (x *VolumeIface) OverrideCanMount(cb func(Volume) bool) {
	if cb == nil {
		x.xCanMount = 0
	} else {
		x.xCanMount = purego.NewCallback(func(VolumeVarp uintptr) bool {
			return cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetCanMount gets the callback function.
// Returns %TRUE if the #GVolume can be mounted.
func (x *VolumeIface) GetCanMount() func(Volume) bool {
	if x.xCanMount == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanMount)
	return func(VolumeVar Volume) bool {
		return rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideCanEject sets the callback function.
// Checks if a #GVolume can be ejected.
func (x *VolumeIface) OverrideCanEject(cb func(Volume) bool) {
	if cb == nil {
		x.xCanEject = 0
	} else {
		x.xCanEject = purego.NewCallback(func(VolumeVarp uintptr) bool {
			return cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetCanEject gets the callback function.
// Checks if a #GVolume can be ejected.
func (x *VolumeIface) GetCanEject() func(Volume) bool {
	if x.xCanEject == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanEject)
	return func(VolumeVar Volume) bool {
		return rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideMountFn sets the callback function.
// Mounts a given #GVolume.
//
//	#GVolume implementations must emit the #GMountOperation::aborted
//	signal before completing a mount operation that is aborted while
//	awaiting input from the user through a #GMountOperation instance.
func (x *VolumeIface) OverrideMountFn(cb func(Volume, MountMountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xMountFn = 0
	} else {
		x.xMountFn = purego.NewCallback(func(VolumeVarp uintptr, FlagsVarp MountMountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&VolumeBase{Ptr: VolumeVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetMountFn gets the callback function.
// Mounts a given #GVolume.
//
//	#GVolume implementations must emit the #GMountOperation::aborted
//	signal before completing a mount operation that is aborted while
//	awaiting input from the user through a #GMountOperation instance.
func (x *VolumeIface) GetMountFn() func(Volume, MountMountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xMountFn == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr, FlagsVarp MountMountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMountFn)
	return func(VolumeVar Volume, FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(VolumeVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideMountFinish sets the callback function.
// Finishes a mount operation.
func (x *VolumeIface) OverrideMountFinish(cb func(Volume, AsyncResult) bool) {
	if cb == nil {
		x.xMountFinish = 0
	} else {
		x.xMountFinish = purego.NewCallback(func(VolumeVarp uintptr, ResultVarp uintptr) bool {
			return cb(&VolumeBase{Ptr: VolumeVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetMountFinish gets the callback function.
// Finishes a mount operation.
func (x *VolumeIface) GetMountFinish() func(Volume, AsyncResult) bool {
	if x.xMountFinish == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xMountFinish)
	return func(VolumeVar Volume, ResultVar AsyncResult) bool {
		return rawCallback(VolumeVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideEject sets the callback function.
// Ejects a given #GVolume.
func (x *VolumeIface) OverrideEject(cb func(Volume, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEject = 0
	} else {
		x.xEject = purego.NewCallback(func(VolumeVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&VolumeBase{Ptr: VolumeVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEject gets the callback function.
// Ejects a given #GVolume.
func (x *VolumeIface) GetEject() func(Volume, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEject == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEject)
	return func(VolumeVar Volume, FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(VolumeVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEjectFinish sets the callback function.
// Finishes an eject operation.
func (x *VolumeIface) OverrideEjectFinish(cb func(Volume, AsyncResult) bool) {
	if cb == nil {
		x.xEjectFinish = 0
	} else {
		x.xEjectFinish = purego.NewCallback(func(VolumeVarp uintptr, ResultVarp uintptr) bool {
			return cb(&VolumeBase{Ptr: VolumeVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetEjectFinish gets the callback function.
// Finishes an eject operation.
func (x *VolumeIface) GetEjectFinish() func(Volume, AsyncResult) bool {
	if x.xEjectFinish == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEjectFinish)
	return func(VolumeVar Volume, ResultVar AsyncResult) bool {
		return rawCallback(VolumeVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGetIdentifier sets the callback function.
// Returns the [identifier](#volume-identifiers) of the given kind, or %NULL if
//
//	the #GVolume doesn't have one.
func (x *VolumeIface) OverrideGetIdentifier(cb func(Volume, string) string) {
	if cb == nil {
		x.xGetIdentifier = 0
	} else {
		x.xGetIdentifier = purego.NewCallback(func(VolumeVarp uintptr, KindVarp string) string {
			return cb(&VolumeBase{Ptr: VolumeVarp}, KindVarp)
		})
	}
}

// GetGetIdentifier gets the callback function.
// Returns the [identifier](#volume-identifiers) of the given kind, or %NULL if
//
//	the #GVolume doesn't have one.
func (x *VolumeIface) GetGetIdentifier() func(Volume, string) string {
	if x.xGetIdentifier == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr, KindVarp string) string
	purego.RegisterFunc(&rawCallback, x.xGetIdentifier)
	return func(VolumeVar Volume, KindVar string) string {
		return rawCallback(VolumeVar.GoPointer(), KindVar)
	}
}

// OverrideEnumerateIdentifiers sets the callback function.
// Returns an array strings listing the kinds
//
//	of [identifiers](#volume-identifiers) which the #GVolume has.
func (x *VolumeIface) OverrideEnumerateIdentifiers(cb func(Volume) []string) {
	if cb == nil {
		x.xEnumerateIdentifiers = 0
	} else {
		x.xEnumerateIdentifiers = purego.NewCallback(func(VolumeVarp uintptr) []string {
			return cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetEnumerateIdentifiers gets the callback function.
// Returns an array strings listing the kinds
//
//	of [identifiers](#volume-identifiers) which the #GVolume has.
func (x *VolumeIface) GetEnumerateIdentifiers() func(Volume) []string {
	if x.xEnumerateIdentifiers == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) []string
	purego.RegisterFunc(&rawCallback, x.xEnumerateIdentifiers)
	return func(VolumeVar Volume) []string {
		return rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideShouldAutomount sets the callback function.
// Returns %TRUE if the #GVolume should be automatically mounted.
func (x *VolumeIface) OverrideShouldAutomount(cb func(Volume) bool) {
	if cb == nil {
		x.xShouldAutomount = 0
	} else {
		x.xShouldAutomount = purego.NewCallback(func(VolumeVarp uintptr) bool {
			return cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetShouldAutomount gets the callback function.
// Returns %TRUE if the #GVolume should be automatically mounted.
func (x *VolumeIface) GetShouldAutomount() func(Volume) bool {
	if x.xShouldAutomount == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xShouldAutomount)
	return func(VolumeVar Volume) bool {
		return rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideGetActivationRoot sets the callback function.
// Returns the activation root for the #GVolume if it is known in advance or %NULL if
//
//	it is not known.
func (x *VolumeIface) OverrideGetActivationRoot(cb func(Volume) *FileBase) {
	if cb == nil {
		x.xGetActivationRoot = 0
	} else {
		x.xGetActivationRoot = purego.NewCallback(func(VolumeVarp uintptr) uintptr {
			ret := cb(&VolumeBase{Ptr: VolumeVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetActivationRoot gets the callback function.
// Returns the activation root for the #GVolume if it is known in advance or %NULL if
//
//	it is not known.
func (x *VolumeIface) GetGetActivationRoot() func(Volume) *FileBase {
	if x.xGetActivationRoot == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetActivationRoot)
	return func(VolumeVar Volume) *FileBase {
		rawRet := rawCallback(VolumeVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideEjectWithOperation sets the callback function.
// Starts ejecting a #GVolume using a #GMountOperation. Since 2.22.
func (x *VolumeIface) OverrideEjectWithOperation(cb func(Volume, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEjectWithOperation = 0
	} else {
		x.xEjectWithOperation = purego.NewCallback(func(VolumeVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&VolumeBase{Ptr: VolumeVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEjectWithOperation gets the callback function.
// Starts ejecting a #GVolume using a #GMountOperation. Since 2.22.
func (x *VolumeIface) GetEjectWithOperation() func(Volume, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEjectWithOperation == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEjectWithOperation)
	return func(VolumeVar Volume, FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(VolumeVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEjectWithOperationFinish sets the callback function.
// Finishes an eject operation using a #GMountOperation. Since 2.22.
func (x *VolumeIface) OverrideEjectWithOperationFinish(cb func(Volume, AsyncResult) bool) {
	if cb == nil {
		x.xEjectWithOperationFinish = 0
	} else {
		x.xEjectWithOperationFinish = purego.NewCallback(func(VolumeVarp uintptr, ResultVarp uintptr) bool {
			return cb(&VolumeBase{Ptr: VolumeVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetEjectWithOperationFinish gets the callback function.
// Finishes an eject operation using a #GMountOperation. Since 2.22.
func (x *VolumeIface) GetEjectWithOperationFinish() func(Volume, AsyncResult) bool {
	if x.xEjectWithOperationFinish == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEjectWithOperationFinish)
	return func(VolumeVar Volume, ResultVar AsyncResult) bool {
		return rawCallback(VolumeVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGetSortKey sets the callback function.
// Gets a key used for sorting #GVolume instance or %NULL if no such key exists. Since 2.32.
func (x *VolumeIface) OverrideGetSortKey(cb func(Volume) string) {
	if cb == nil {
		x.xGetSortKey = 0
	} else {
		x.xGetSortKey = purego.NewCallback(func(VolumeVarp uintptr) string {
			return cb(&VolumeBase{Ptr: VolumeVarp})
		})
	}
}

// GetGetSortKey gets the callback function.
// Gets a key used for sorting #GVolume instance or %NULL if no such key exists. Since 2.32.
func (x *VolumeIface) GetGetSortKey() func(Volume) string {
	if x.xGetSortKey == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetSortKey)
	return func(VolumeVar Volume) string {
		return rawCallback(VolumeVar.GoPointer())
	}
}

// OverrideGetSymbolicIcon sets the callback function.
// Gets a symbolic #GIcon for the #GVolume. Since 2.34.
func (x *VolumeIface) OverrideGetSymbolicIcon(cb func(Volume) *IconBase) {
	if cb == nil {
		x.xGetSymbolicIcon = 0
	} else {
		x.xGetSymbolicIcon = purego.NewCallback(func(VolumeVarp uintptr) uintptr {
			ret := cb(&VolumeBase{Ptr: VolumeVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetSymbolicIcon gets the callback function.
// Gets a symbolic #GIcon for the #GVolume. Since 2.34.
func (x *VolumeIface) GetGetSymbolicIcon() func(Volume) *IconBase {
	if x.xGetSymbolicIcon == 0 {
		return nil
	}
	var rawCallback func(VolumeVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetSymbolicIcon)
	return func(VolumeVar Volume) *IconBase {
		rawRet := rawCallback(VolumeVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// The `GVolume` interface represents user-visible objects that can be
// mounted. For example, a file system partition on a USB flash drive, or an
// optical disc inserted into a disc drive.
//
// If a `GVolume` is currently mounted, the corresponding [iface@Gio.Mount] can
// be retrieved using [method@Gio.Volume.get_mount].
//
// Mounting a `GVolume` instance is an asynchronous operation. For more
// information about asynchronous operations, see [iface@Gio.AsyncResult] and
// [class@Gio.Task]. To mount a `GVolume`, first call [method@Gio.Volume.mount]
// with (at least) the `GVolume` instance, optionally a
// [class@Gio.MountOperation] object and a [type@Gio.AsyncReadyCallback].
//
// Typically, one will only want to pass `NULL` for the
// [class@Gio.MountOperation] if automounting all volumes when a desktop session
// starts since it’s not desirable to put up a lot of dialogs asking
// for credentials.
//
// The callback will be fired when the operation has resolved (either
// with success or failure), and a [iface@Gio.AsyncResult] instance will be
// passed to the callback.  That callback should then call
// [method@Gio.Volume.mount_finish] with the `GVolume` instance and the
// [iface@Gio.AsyncResult] data to see if the operation was completed
// successfully.  If a [type@GLib.Error] is present when
// [method@Gio.Volume.mount_finish] is called, then it will be filled with any
// error information.
//
// Note, when [porting from GnomeVFS](migrating-gnome-vfs.html),
// `GVolume` is the moral equivalent of `GnomeVFSDrive`.
//
// ## Volume Identifiers
//
// It is sometimes necessary to directly access the underlying
// operating system object behind a volume (e.g. for passing a volume
// to an application via the command line). For this purpose, GIO
// allows to obtain an ‘identifier’ for the volume. There can be
// different kinds of identifiers, such as Hal UDIs, filesystem labels,
// traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
// strings as names for the different kinds of identifiers:
// `G_VOLUME_IDENTIFIER_KIND_UUID`, `G_VOLUME_IDENTIFIER_KIND_LABEL`, etc.
// Use [method@Gio.Volume.get_identifier] to obtain an identifier for a volume.
//
// Note that `G_VOLUME_IDENTIFIER_KIND_HAL_UDI` will only be available
// when the GVFS hal volume monitor is in use. Other volume monitors
// will generally be able to provide the `G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE`
// identifier, which can be used to obtain a hal device by means of
// `libhal_manager_find_device_string_match()`.
type Volume interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	CanEject() bool
	CanMount() bool
	Eject(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectFinish(ResultVar AsyncResult) (bool, error)
	EjectWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectWithOperationFinish(ResultVar AsyncResult) (bool, error)
	EnumerateIdentifiers() []string
	GetActivationRoot() *FileBase
	GetDrive() *DriveBase
	GetIcon() *IconBase
	GetIdentifier(KindVar string) string
	GetMount() *MountBase
	GetName() string
	GetSortKey() string
	GetSymbolicIcon() *IconBase
	GetUuid() string
	Mount(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MountFinish(ResultVar AsyncResult) (bool, error)
	ShouldAutomount() bool
}

var xVolumeGLibType func() types.GType

func VolumeGLibType() types.GType {
	return xVolumeGLibType()
}

type VolumeBase struct {
	Ptr uintptr
}

func (x *VolumeBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *VolumeBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Checks if a volume can be ejected.
func (x *VolumeBase) CanEject() bool {

	cret := XGVolumeCanEject(x.GoPointer())
	return cret
}

// Checks if a volume can be mounted.
func (x *VolumeBase) CanMount() bool {

	cret := XGVolumeCanMount(x.GoPointer())
	return cret
}

// Ejects a volume. This is an asynchronous operation, and is
// finished by calling g_volume_eject_finish() with the @volume
// and #GAsyncResult returned in the @callback.
func (x *VolumeBase) Eject(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGVolumeEject(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes ejecting a volume. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *VolumeBase) EjectFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGVolumeEjectFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Ejects a volume. This is an asynchronous operation, and is
// finished by calling g_volume_eject_with_operation_finish() with the @volume
// and #GAsyncResult data returned in the @callback.
func (x *VolumeBase) EjectWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGVolumeEjectWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes ejecting a volume. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *VolumeBase) EjectWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGVolumeEjectWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the kinds of [identifiers](#volume-identifiers) that @volume has.
// Use g_volume_get_identifier() to obtain the identifiers themselves.
func (x *VolumeBase) EnumerateIdentifiers() []string {

	cret := XGVolumeEnumerateIdentifiers(x.GoPointer())
	return cret
}

// Gets the activation root for a #GVolume if it is known ahead of
// mount time. Returns %NULL otherwise. If not %NULL and if @volume
// is mounted, then the result of g_mount_get_root() on the
// #GMount object obtained from g_volume_get_mount() will always
// either be equal or a prefix of what this function returns. In
// other words, in code
//
// |[&lt;!-- language="C" --&gt;
//
//	GMount *mount;
//	GFile *mount_root
//	GFile *volume_activation_root;
//
//	mount = g_volume_get_mount (volume); // mounted, so never NULL
//	mount_root = g_mount_get_root (mount);
//	volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
//
// ]|
// then the expression
// |[&lt;!-- language="C" --&gt;
//
//	(g_file_has_prefix (volume_activation_root, mount_root) ||
//	 g_file_equal (volume_activation_root, mount_root))
//
// ]|
// will always be %TRUE.
//
// Activation roots are typically used in #GVolumeMonitor
// implementations to find the underlying mount to shadow, see
// g_mount_is_shadowed() for more details.
func (x *VolumeBase) GetActivationRoot() *FileBase {
	var cls *FileBase

	cret := XGVolumeGetActivationRoot(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the drive for the @volume.
func (x *VolumeBase) GetDrive() *DriveBase {
	var cls *DriveBase

	cret := XGVolumeGetDrive(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &DriveBase{}
	cls.Ptr = cret
	return cls
}

// Gets the icon for @volume.
func (x *VolumeBase) GetIcon() *IconBase {
	var cls *IconBase

	cret := XGVolumeGetIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Gets the identifier of the given kind for @volume.
// See the [introduction](#volume-identifiers) for more
// information about volume identifiers.
func (x *VolumeBase) GetIdentifier(KindVar string) string {

	cret := XGVolumeGetIdentifier(x.GoPointer(), KindVar)
	return cret
}

// Gets the mount for the @volume.
func (x *VolumeBase) GetMount() *MountBase {
	var cls *MountBase

	cret := XGVolumeGetMount(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &MountBase{}
	cls.Ptr = cret
	return cls
}

// Gets the name of @volume.
func (x *VolumeBase) GetName() string {

	cret := XGVolumeGetName(x.GoPointer())
	return cret
}

// Gets the sort key for @volume, if any.
func (x *VolumeBase) GetSortKey() string {

	cret := XGVolumeGetSortKey(x.GoPointer())
	return cret
}

// Gets the symbolic icon for @volume.
func (x *VolumeBase) GetSymbolicIcon() *IconBase {
	var cls *IconBase

	cret := XGVolumeGetSymbolicIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Gets the UUID for the @volume. The reference is typically based on
// the file system UUID for the volume in question and should be
// considered an opaque string. Returns %NULL if there is no UUID
// available.
func (x *VolumeBase) GetUuid() string {

	cret := XGVolumeGetUuid(x.GoPointer())
	return cret
}

// Mounts a volume. This is an asynchronous operation, and is
// finished by calling g_volume_mount_finish() with the @volume
// and #GAsyncResult returned in the @callback.
func (x *VolumeBase) Mount(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGVolumeMount(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes mounting a volume. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
//
// If the mount operation succeeded, g_volume_get_mount() on @volume
// is guaranteed to return the mount right after calling this
// function; there's no need to listen for the 'mount-added' signal on
// #GVolumeMonitor.
func (x *VolumeBase) MountFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGVolumeMountFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Returns whether the volume should be automatically mounted.
func (x *VolumeBase) ShouldAutomount() bool {

	cret := XGVolumeShouldAutomount(x.GoPointer())
	return cret
}

var XGVolumeCanEject func(uintptr) bool
var XGVolumeCanMount func(uintptr) bool
var XGVolumeEject func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGVolumeEjectFinish func(uintptr, uintptr, **glib.Error) bool
var XGVolumeEjectWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGVolumeEjectWithOperationFinish func(uintptr, uintptr, **glib.Error) bool
var XGVolumeEnumerateIdentifiers func(uintptr) []string
var XGVolumeGetActivationRoot func(uintptr) uintptr
var XGVolumeGetDrive func(uintptr) uintptr
var XGVolumeGetIcon func(uintptr) uintptr
var XGVolumeGetIdentifier func(uintptr, string) string
var XGVolumeGetMount func(uintptr) uintptr
var XGVolumeGetName func(uintptr) string
var XGVolumeGetSortKey func(uintptr) string
var XGVolumeGetSymbolicIcon func(uintptr) uintptr
var XGVolumeGetUuid func(uintptr) string
var XGVolumeMount func(uintptr, MountMountFlags, uintptr, uintptr, uintptr, uintptr)
var XGVolumeMountFinish func(uintptr, uintptr, **glib.Error) bool
var XGVolumeShouldAutomount func(uintptr) bool

const (
	// The string used to obtain the volume class with g_volume_get_identifier().
	//
	// Known volume classes include `device`, `network`, and `loop`. Other
	// classes may be added in the future.
	//
	// This is intended to be used by applications to classify #GVolume
	// instances into different sections - for example a file manager or
	// file chooser can use this information to show `network` volumes under
	// a "Network" heading and `device` volumes under a "Devices" heading.
	VOLUME_IDENTIFIER_KIND_CLASS string = "class"
	// The string used to obtain a Hal UDI with g_volume_get_identifier().
	VOLUME_IDENTIFIER_KIND_HAL_UDI string = "hal-udi"
	// The string used to obtain a filesystem label with g_volume_get_identifier().
	VOLUME_IDENTIFIER_KIND_LABEL string = "label"
	// The string used to obtain a NFS mount with g_volume_get_identifier().
	VOLUME_IDENTIFIER_KIND_NFS_MOUNT string = "nfs-mount"
	// The string used to obtain a Unix device path with g_volume_get_identifier().
	VOLUME_IDENTIFIER_KIND_UNIX_DEVICE string = "unix-device"
	// The string used to obtain a UUID with g_volume_get_identifier().
	VOLUME_IDENTIFIER_KIND_UUID string = "uuid"
)

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xVolumeGLibType, libs, "g_volume_get_type")

	core.PuregoSafeRegister(&XGVolumeCanEject, libs, "g_volume_can_eject")
	core.PuregoSafeRegister(&XGVolumeCanMount, libs, "g_volume_can_mount")
	core.PuregoSafeRegister(&XGVolumeEject, libs, "g_volume_eject")
	core.PuregoSafeRegister(&XGVolumeEjectFinish, libs, "g_volume_eject_finish")
	core.PuregoSafeRegister(&XGVolumeEjectWithOperation, libs, "g_volume_eject_with_operation")
	core.PuregoSafeRegister(&XGVolumeEjectWithOperationFinish, libs, "g_volume_eject_with_operation_finish")
	core.PuregoSafeRegister(&XGVolumeEnumerateIdentifiers, libs, "g_volume_enumerate_identifiers")
	core.PuregoSafeRegister(&XGVolumeGetActivationRoot, libs, "g_volume_get_activation_root")
	core.PuregoSafeRegister(&XGVolumeGetDrive, libs, "g_volume_get_drive")
	core.PuregoSafeRegister(&XGVolumeGetIcon, libs, "g_volume_get_icon")
	core.PuregoSafeRegister(&XGVolumeGetIdentifier, libs, "g_volume_get_identifier")
	core.PuregoSafeRegister(&XGVolumeGetMount, libs, "g_volume_get_mount")
	core.PuregoSafeRegister(&XGVolumeGetName, libs, "g_volume_get_name")
	core.PuregoSafeRegister(&XGVolumeGetSortKey, libs, "g_volume_get_sort_key")
	core.PuregoSafeRegister(&XGVolumeGetSymbolicIcon, libs, "g_volume_get_symbolic_icon")
	core.PuregoSafeRegister(&XGVolumeGetUuid, libs, "g_volume_get_uuid")
	core.PuregoSafeRegister(&XGVolumeMount, libs, "g_volume_mount")
	core.PuregoSafeRegister(&XGVolumeMountFinish, libs, "g_volume_mount_finish")
	core.PuregoSafeRegister(&XGVolumeShouldAutomount, libs, "g_volume_should_automount")

}
