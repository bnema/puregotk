// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Provides an interface for implementing seekable functionality on I/O Streams.
type SeekableIface struct {
	_ structs.HostLayout

	GIface uintptr

	xTell uintptr

	xCanSeek uintptr

	xSeek uintptr

	xCanTruncate uintptr

	xTruncateFn uintptr
}

func (x *SeekableIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideTell sets the callback function.
// Tells the current location within a stream.
func (x *SeekableIface) OverrideTell(cb func(Seekable) int64) {
	if cb == nil {
		x.xTell = 0
	} else {
		x.xTell = purego.NewCallback(func(SeekableVarp uintptr) int64 {
			return cb(&SeekableBase{Ptr: SeekableVarp})
		})
	}
}

// GetTell gets the callback function.
// Tells the current location within a stream.
func (x *SeekableIface) GetTell() func(Seekable) int64 {
	if x.xTell == 0 {
		return nil
	}
	var rawCallback func(SeekableVarp uintptr) int64
	purego.RegisterFunc(&rawCallback, x.xTell)
	return func(SeekableVar Seekable) int64 {
		return rawCallback(SeekableVar.GoPointer())
	}
}

// OverrideCanSeek sets the callback function.
// Checks if seeking is supported by the stream.
func (x *SeekableIface) OverrideCanSeek(cb func(Seekable) bool) {
	if cb == nil {
		x.xCanSeek = 0
	} else {
		x.xCanSeek = purego.NewCallback(func(SeekableVarp uintptr) bool {
			return cb(&SeekableBase{Ptr: SeekableVarp})
		})
	}
}

// GetCanSeek gets the callback function.
// Checks if seeking is supported by the stream.
func (x *SeekableIface) GetCanSeek() func(Seekable) bool {
	if x.xCanSeek == 0 {
		return nil
	}
	var rawCallback func(SeekableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanSeek)
	return func(SeekableVar Seekable) bool {
		return rawCallback(SeekableVar.GoPointer())
	}
}

// OverrideSeek sets the callback function.
// Seeks to a location within a stream.
func (x *SeekableIface) OverrideSeek(cb func(Seekable, int64, glib.SeekType, *Cancellable) bool) {
	if cb == nil {
		x.xSeek = 0
	} else {
		x.xSeek = purego.NewCallback(func(SeekableVarp uintptr, OffsetVarp int64, TypeVarp glib.SeekType, CancellableVarp uintptr) bool {
			return cb(&SeekableBase{Ptr: SeekableVarp}, OffsetVarp, TypeVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetSeek gets the callback function.
// Seeks to a location within a stream.
func (x *SeekableIface) GetSeek() func(Seekable, int64, glib.SeekType, *Cancellable) bool {
	if x.xSeek == 0 {
		return nil
	}
	var rawCallback func(SeekableVarp uintptr, OffsetVarp int64, TypeVarp glib.SeekType, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSeek)
	return func(SeekableVar Seekable, OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) bool {
		return rawCallback(SeekableVar.GoPointer(), OffsetVar, TypeVar, CancellableVar.GoPointer())
	}
}

// OverrideCanTruncate sets the callback function.
// Checks if truncation is supported by the stream.
func (x *SeekableIface) OverrideCanTruncate(cb func(Seekable) bool) {
	if cb == nil {
		x.xCanTruncate = 0
	} else {
		x.xCanTruncate = purego.NewCallback(func(SeekableVarp uintptr) bool {
			return cb(&SeekableBase{Ptr: SeekableVarp})
		})
	}
}

// GetCanTruncate gets the callback function.
// Checks if truncation is supported by the stream.
func (x *SeekableIface) GetCanTruncate() func(Seekable) bool {
	if x.xCanTruncate == 0 {
		return nil
	}
	var rawCallback func(SeekableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanTruncate)
	return func(SeekableVar Seekable) bool {
		return rawCallback(SeekableVar.GoPointer())
	}
}

// OverrideTruncateFn sets the callback function.
// Truncates a stream.
func (x *SeekableIface) OverrideTruncateFn(cb func(Seekable, int64, *Cancellable) bool) {
	if cb == nil {
		x.xTruncateFn = 0
	} else {
		x.xTruncateFn = purego.NewCallback(func(SeekableVarp uintptr, OffsetVarp int64, CancellableVarp uintptr) bool {
			return cb(&SeekableBase{Ptr: SeekableVarp}, OffsetVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetTruncateFn gets the callback function.
// Truncates a stream.
func (x *SeekableIface) GetTruncateFn() func(Seekable, int64, *Cancellable) bool {
	if x.xTruncateFn == 0 {
		return nil
	}
	var rawCallback func(SeekableVarp uintptr, OffsetVarp int64, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xTruncateFn)
	return func(SeekableVar Seekable, OffsetVar int64, CancellableVar *Cancellable) bool {
		return rawCallback(SeekableVar.GoPointer(), OffsetVar, CancellableVar.GoPointer())
	}
}

// `GSeekable` is implemented by streams (implementations of
// [class@Gio.InputStream] or [class@Gio.OutputStream]) that support seeking.
//
// Seekable streams largely fall into two categories: resizable and
// fixed-size.
//
// `GSeekable` on fixed-sized streams is approximately the same as POSIX
// [`lseek()`](man:lseek(2)) on a block device (for example: attempting to seek
// past the end of the device is an error).  Fixed streams typically cannot be
// truncated.
//
// `GSeekable` on resizable streams is approximately the same as POSIX
// [`lseek()`](man:lseek(2)) on a normal file.  Seeking past the end and writing
// data will usually cause the stream to resize by introducing zero bytes.
type Seekable interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	CanSeek() bool
	CanTruncate() bool
	Seek(OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) (bool, error)
	Tell() int64
	Truncate(OffsetVar int64, CancellableVar *Cancellable) (bool, error)
}

var xSeekableGLibType func() types.GType

func SeekableGLibType() types.GType {
	return xSeekableGLibType()
}

type SeekableBase struct {
	Ptr uintptr
}

func (x *SeekableBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *SeekableBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Tests if the stream supports the #GSeekableIface.
func (x *SeekableBase) CanSeek() bool {

	cret := XGSeekableCanSeek(x.GoPointer())
	return cret
}

// Tests if the length of the stream can be adjusted with
// g_seekable_truncate().
func (x *SeekableBase) CanTruncate() bool {

	cret := XGSeekableCanTruncate(x.GoPointer())
	return cret
}

// Seeks in the stream by the given @offset, modified by @type.
//
// Attempting to seek past the end of the stream will have different
// results depending on if the stream is fixed-sized or resizable.  If
// the stream is resizable then seeking past the end and then writing
// will result in zeros filling the empty space.  Seeking past the end
// of a resizable stream and reading will result in EOF.  Seeking past
// the end of a fixed-sized stream will fail.
//
// Any operation that would result in a negative offset will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *SeekableBase) Seek(OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableSeek(x.GoPointer(), OffsetVar, TypeVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tells the current position within the stream.
func (x *SeekableBase) Tell() int64 {

	cret := XGSeekableTell(x.GoPointer())
	return cret
}

// Sets the length of the stream to @offset. If the stream was previously
// larger than @offset, the extra data is discarded. If the stream was
// previously shorter than @offset, it is extended with NUL ('\0') bytes.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (x *SeekableBase) Truncate(OffsetVar int64, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableTruncate(x.GoPointer(), OffsetVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var XGSeekableCanSeek func(uintptr) bool
var XGSeekableCanTruncate func(uintptr) bool
var XGSeekableSeek func(uintptr, int64, glib.SeekType, uintptr, **glib.Error) bool
var XGSeekableTell func(uintptr) int64
var XGSeekableTruncate func(uintptr, int64, uintptr, **glib.Error) bool

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSeekableGLibType, libs, "g_seekable_get_type")

	core.PuregoSafeRegister(&XGSeekableCanSeek, libs, "g_seekable_can_seek")
	core.PuregoSafeRegister(&XGSeekableCanTruncate, libs, "g_seekable_can_truncate")
	core.PuregoSafeRegister(&XGSeekableSeek, libs, "g_seekable_seek")
	core.PuregoSafeRegister(&XGSeekableTell, libs, "g_seekable_tell")
	core.PuregoSafeRegister(&XGSeekableTruncate, libs, "g_seekable_truncate")

}
