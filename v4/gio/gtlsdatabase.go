// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The class for #GTlsDatabase. Derived classes should implement the various
// virtual methods. _async and _finish methods have a default
// implementation that runs the corresponding sync method in a thread.
type TlsDatabaseClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xVerifyChain uintptr

	xVerifyChainAsync uintptr

	xVerifyChainFinish uintptr

	xCreateCertificateHandle uintptr

	xLookupCertificateForHandle uintptr

	xLookupCertificateForHandleAsync uintptr

	xLookupCertificateForHandleFinish uintptr

	xLookupCertificateIssuer uintptr

	xLookupCertificateIssuerAsync uintptr

	xLookupCertificateIssuerFinish uintptr

	xLookupCertificatesIssuedBy uintptr

	xLookupCertificatesIssuedByAsync uintptr

	xLookupCertificatesIssuedByFinish uintptr

	Padding [16]uintptr
}

func (x *TlsDatabaseClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideVerifyChain sets the "verify_chain" callback function.
// Virtual method implementing
//
//	g_tls_database_verify_chain().
func (x *TlsDatabaseClass) OverrideVerifyChain(cb func(*TlsDatabase, *TlsCertificate, string, SocketConnectable, *TlsInteraction, TlsDatabaseVerifyFlags, *Cancellable) TlsCertificateFlags) {
	if cb == nil {
		x.xVerifyChain = 0
	} else {
		x.xVerifyChain = purego.NewCallback(func(SelfVarp uintptr, ChainVarp uintptr, PurposeVarp string, IdentityVarp uintptr, InteractionVarp uintptr, FlagsVarp TlsDatabaseVerifyFlags, CancellableVarp uintptr) TlsCertificateFlags {
			return cb(TlsDatabaseNewFromInternalPtr(SelfVarp), TlsCertificateNewFromInternalPtr(ChainVarp), PurposeVarp, &SocketConnectableBase{Ptr: IdentityVarp}, TlsInteractionNewFromInternalPtr(InteractionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetVerifyChain gets the "verify_chain" callback function.
// Virtual method implementing
//
//	g_tls_database_verify_chain().
func (x *TlsDatabaseClass) GetVerifyChain() func(*TlsDatabase, *TlsCertificate, string, SocketConnectable, *TlsInteraction, TlsDatabaseVerifyFlags, *Cancellable) TlsCertificateFlags {
	if x.xVerifyChain == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, ChainVarp uintptr, PurposeVarp string, IdentityVarp uintptr, InteractionVarp uintptr, FlagsVarp TlsDatabaseVerifyFlags, CancellableVarp uintptr) TlsCertificateFlags
	purego.RegisterFunc(&rawCallback, x.xVerifyChain)
	return func(SelfVar *TlsDatabase, ChainVar *TlsCertificate, PurposeVar string, IdentityVar SocketConnectable, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseVerifyFlags, CancellableVar *Cancellable) TlsCertificateFlags {
		return rawCallback(SelfVar.GoPointer(), ChainVar.GoPointer(), PurposeVar, IdentityVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
	}
}

// OverrideVerifyChainAsync sets the "verify_chain_async" callback function.
// Virtual method implementing
//
//	g_tls_database_verify_chain_async().
func (x *TlsDatabaseClass) OverrideVerifyChainAsync(cb func(*TlsDatabase, *TlsCertificate, string, SocketConnectable, *TlsInteraction, TlsDatabaseVerifyFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xVerifyChainAsync = 0
	} else {
		x.xVerifyChainAsync = purego.NewCallback(func(SelfVarp uintptr, ChainVarp uintptr, PurposeVarp string, IdentityVarp uintptr, InteractionVarp uintptr, FlagsVarp TlsDatabaseVerifyFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(TlsDatabaseNewFromInternalPtr(SelfVarp), TlsCertificateNewFromInternalPtr(ChainVarp), PurposeVarp, &SocketConnectableBase{Ptr: IdentityVarp}, TlsInteractionNewFromInternalPtr(InteractionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetVerifyChainAsync gets the "verify_chain_async" callback function.
// Virtual method implementing
//
//	g_tls_database_verify_chain_async().
func (x *TlsDatabaseClass) GetVerifyChainAsync() func(*TlsDatabase, *TlsCertificate, string, SocketConnectable, *TlsInteraction, TlsDatabaseVerifyFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xVerifyChainAsync == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, ChainVarp uintptr, PurposeVarp string, IdentityVarp uintptr, InteractionVarp uintptr, FlagsVarp TlsDatabaseVerifyFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xVerifyChainAsync)
	return func(SelfVar *TlsDatabase, ChainVar *TlsCertificate, PurposeVar string, IdentityVar SocketConnectable, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseVerifyFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(SelfVar.GoPointer(), ChainVar.GoPointer(), PurposeVar, IdentityVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideVerifyChainFinish sets the "verify_chain_finish" callback function.
// Virtual method implementing
//
//	g_tls_database_verify_chain_finish().
func (x *TlsDatabaseClass) OverrideVerifyChainFinish(cb func(*TlsDatabase, AsyncResult) TlsCertificateFlags) {
	if cb == nil {
		x.xVerifyChainFinish = 0
	} else {
		x.xVerifyChainFinish = purego.NewCallback(func(SelfVarp uintptr, ResultVarp uintptr) TlsCertificateFlags {
			return cb(TlsDatabaseNewFromInternalPtr(SelfVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetVerifyChainFinish gets the "verify_chain_finish" callback function.
// Virtual method implementing
//
//	g_tls_database_verify_chain_finish().
func (x *TlsDatabaseClass) GetVerifyChainFinish() func(*TlsDatabase, AsyncResult) TlsCertificateFlags {
	if x.xVerifyChainFinish == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, ResultVarp uintptr) TlsCertificateFlags
	purego.RegisterFunc(&rawCallback, x.xVerifyChainFinish)
	return func(SelfVar *TlsDatabase, ResultVar AsyncResult) TlsCertificateFlags {
		return rawCallback(SelfVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideCreateCertificateHandle sets the "create_certificate_handle" callback function.
// Virtual method implementing
//
//	g_tls_database_create_certificate_handle().
func (x *TlsDatabaseClass) OverrideCreateCertificateHandle(cb func(*TlsDatabase, *TlsCertificate) string) {
	if cb == nil {
		x.xCreateCertificateHandle = 0
	} else {
		x.xCreateCertificateHandle = purego.NewCallback(func(SelfVarp uintptr, CertificateVarp uintptr) string {
			return cb(TlsDatabaseNewFromInternalPtr(SelfVarp), TlsCertificateNewFromInternalPtr(CertificateVarp))
		})
	}
}

// GetCreateCertificateHandle gets the "create_certificate_handle" callback function.
// Virtual method implementing
//
//	g_tls_database_create_certificate_handle().
func (x *TlsDatabaseClass) GetCreateCertificateHandle() func(*TlsDatabase, *TlsCertificate) string {
	if x.xCreateCertificateHandle == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, CertificateVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xCreateCertificateHandle)
	return func(SelfVar *TlsDatabase, CertificateVar *TlsCertificate) string {
		return rawCallback(SelfVar.GoPointer(), CertificateVar.GoPointer())
	}
}

// OverrideLookupCertificateForHandle sets the "lookup_certificate_for_handle" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_for_handle().
func (x *TlsDatabaseClass) OverrideLookupCertificateForHandle(cb func(*TlsDatabase, string, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable) *TlsCertificate) {
	if cb == nil {
		x.xLookupCertificateForHandle = 0
	} else {
		x.xLookupCertificateForHandle = purego.NewCallback(func(SelfVarp uintptr, HandleVarp string, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr) uintptr {
			ret := cb(TlsDatabaseNewFromInternalPtr(SelfVarp), HandleVarp, TlsInteractionNewFromInternalPtr(InteractionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLookupCertificateForHandle gets the "lookup_certificate_for_handle" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_for_handle().
func (x *TlsDatabaseClass) GetLookupCertificateForHandle() func(*TlsDatabase, string, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable) *TlsCertificate {
	if x.xLookupCertificateForHandle == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, HandleVarp string, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xLookupCertificateForHandle)
	return func(SelfVar *TlsDatabase, HandleVar string, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) *TlsCertificate {
		rawRet := rawCallback(SelfVar.GoPointer(), HandleVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &TlsCertificate{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideLookupCertificateForHandleAsync sets the "lookup_certificate_for_handle_async" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_for_handle_async().
func (x *TlsDatabaseClass) OverrideLookupCertificateForHandleAsync(cb func(*TlsDatabase, string, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLookupCertificateForHandleAsync = 0
	} else {
		x.xLookupCertificateForHandleAsync = purego.NewCallback(func(SelfVarp uintptr, HandleVarp string, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(TlsDatabaseNewFromInternalPtr(SelfVarp), HandleVarp, TlsInteractionNewFromInternalPtr(InteractionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLookupCertificateForHandleAsync gets the "lookup_certificate_for_handle_async" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_for_handle_async().
func (x *TlsDatabaseClass) GetLookupCertificateForHandleAsync() func(*TlsDatabase, string, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLookupCertificateForHandleAsync == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, HandleVarp string, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLookupCertificateForHandleAsync)
	return func(SelfVar *TlsDatabase, HandleVar string, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(SelfVar.GoPointer(), HandleVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLookupCertificateForHandleFinish sets the "lookup_certificate_for_handle_finish" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_for_handle_finish().
func (x *TlsDatabaseClass) OverrideLookupCertificateForHandleFinish(cb func(*TlsDatabase, AsyncResult) *TlsCertificate) {
	if cb == nil {
		x.xLookupCertificateForHandleFinish = 0
	} else {
		x.xLookupCertificateForHandleFinish = purego.NewCallback(func(SelfVarp uintptr, ResultVarp uintptr) uintptr {
			ret := cb(TlsDatabaseNewFromInternalPtr(SelfVarp), &AsyncResultBase{Ptr: ResultVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLookupCertificateForHandleFinish gets the "lookup_certificate_for_handle_finish" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_for_handle_finish().
func (x *TlsDatabaseClass) GetLookupCertificateForHandleFinish() func(*TlsDatabase, AsyncResult) *TlsCertificate {
	if x.xLookupCertificateForHandleFinish == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, ResultVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xLookupCertificateForHandleFinish)
	return func(SelfVar *TlsDatabase, ResultVar AsyncResult) *TlsCertificate {
		rawRet := rawCallback(SelfVar.GoPointer(), ResultVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &TlsCertificate{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideLookupCertificateIssuer sets the "lookup_certificate_issuer" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_issuer().
func (x *TlsDatabaseClass) OverrideLookupCertificateIssuer(cb func(*TlsDatabase, *TlsCertificate, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable) *TlsCertificate) {
	if cb == nil {
		x.xLookupCertificateIssuer = 0
	} else {
		x.xLookupCertificateIssuer = purego.NewCallback(func(SelfVarp uintptr, CertificateVarp uintptr, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr) uintptr {
			ret := cb(TlsDatabaseNewFromInternalPtr(SelfVarp), TlsCertificateNewFromInternalPtr(CertificateVarp), TlsInteractionNewFromInternalPtr(InteractionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLookupCertificateIssuer gets the "lookup_certificate_issuer" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_issuer().
func (x *TlsDatabaseClass) GetLookupCertificateIssuer() func(*TlsDatabase, *TlsCertificate, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable) *TlsCertificate {
	if x.xLookupCertificateIssuer == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, CertificateVarp uintptr, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xLookupCertificateIssuer)
	return func(SelfVar *TlsDatabase, CertificateVar *TlsCertificate, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) *TlsCertificate {
		rawRet := rawCallback(SelfVar.GoPointer(), CertificateVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &TlsCertificate{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideLookupCertificateIssuerAsync sets the "lookup_certificate_issuer_async" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_issuer_async().
func (x *TlsDatabaseClass) OverrideLookupCertificateIssuerAsync(cb func(*TlsDatabase, *TlsCertificate, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLookupCertificateIssuerAsync = 0
	} else {
		x.xLookupCertificateIssuerAsync = purego.NewCallback(func(SelfVarp uintptr, CertificateVarp uintptr, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(TlsDatabaseNewFromInternalPtr(SelfVarp), TlsCertificateNewFromInternalPtr(CertificateVarp), TlsInteractionNewFromInternalPtr(InteractionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLookupCertificateIssuerAsync gets the "lookup_certificate_issuer_async" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_issuer_async().
func (x *TlsDatabaseClass) GetLookupCertificateIssuerAsync() func(*TlsDatabase, *TlsCertificate, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLookupCertificateIssuerAsync == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, CertificateVarp uintptr, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLookupCertificateIssuerAsync)
	return func(SelfVar *TlsDatabase, CertificateVar *TlsCertificate, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(SelfVar.GoPointer(), CertificateVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLookupCertificateIssuerFinish sets the "lookup_certificate_issuer_finish" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_issuer_finish().
func (x *TlsDatabaseClass) OverrideLookupCertificateIssuerFinish(cb func(*TlsDatabase, AsyncResult) *TlsCertificate) {
	if cb == nil {
		x.xLookupCertificateIssuerFinish = 0
	} else {
		x.xLookupCertificateIssuerFinish = purego.NewCallback(func(SelfVarp uintptr, ResultVarp uintptr) uintptr {
			ret := cb(TlsDatabaseNewFromInternalPtr(SelfVarp), &AsyncResultBase{Ptr: ResultVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLookupCertificateIssuerFinish gets the "lookup_certificate_issuer_finish" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificate_issuer_finish().
func (x *TlsDatabaseClass) GetLookupCertificateIssuerFinish() func(*TlsDatabase, AsyncResult) *TlsCertificate {
	if x.xLookupCertificateIssuerFinish == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, ResultVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xLookupCertificateIssuerFinish)
	return func(SelfVar *TlsDatabase, ResultVar AsyncResult) *TlsCertificate {
		rawRet := rawCallback(SelfVar.GoPointer(), ResultVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &TlsCertificate{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideLookupCertificatesIssuedBy sets the "lookup_certificates_issued_by" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificates_issued_by().
func (x *TlsDatabaseClass) OverrideLookupCertificatesIssuedBy(cb func(*TlsDatabase, []byte, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable) *glib.List) {
	if cb == nil {
		x.xLookupCertificatesIssuedBy = 0
	} else {
		x.xLookupCertificatesIssuedBy = purego.NewCallback(func(SelfVarp uintptr, IssuerRawDnVarp []byte, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr) *glib.List {
			return cb(TlsDatabaseNewFromInternalPtr(SelfVarp), IssuerRawDnVarp, TlsInteractionNewFromInternalPtr(InteractionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetLookupCertificatesIssuedBy gets the "lookup_certificates_issued_by" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificates_issued_by().
func (x *TlsDatabaseClass) GetLookupCertificatesIssuedBy() func(*TlsDatabase, []byte, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable) *glib.List {
	if x.xLookupCertificatesIssuedBy == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, IssuerRawDnVarp []byte, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupCertificatesIssuedBy)
	return func(SelfVar *TlsDatabase, IssuerRawDnVar []byte, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) *glib.List {
		return rawCallback(SelfVar.GoPointer(), IssuerRawDnVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
	}
}

// OverrideLookupCertificatesIssuedByAsync sets the "lookup_certificates_issued_by_async" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificates_issued_by_async().
func (x *TlsDatabaseClass) OverrideLookupCertificatesIssuedByAsync(cb func(*TlsDatabase, []byte, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLookupCertificatesIssuedByAsync = 0
	} else {
		x.xLookupCertificatesIssuedByAsync = purego.NewCallback(func(SelfVarp uintptr, IssuerRawDnVarp []byte, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(TlsDatabaseNewFromInternalPtr(SelfVarp), IssuerRawDnVarp, TlsInteractionNewFromInternalPtr(InteractionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLookupCertificatesIssuedByAsync gets the "lookup_certificates_issued_by_async" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificates_issued_by_async().
func (x *TlsDatabaseClass) GetLookupCertificatesIssuedByAsync() func(*TlsDatabase, []byte, *TlsInteraction, TlsDatabaseLookupFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLookupCertificatesIssuedByAsync == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, IssuerRawDnVarp []byte, InteractionVarp uintptr, FlagsVarp TlsDatabaseLookupFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLookupCertificatesIssuedByAsync)
	return func(SelfVar *TlsDatabase, IssuerRawDnVar []byte, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(SelfVar.GoPointer(), IssuerRawDnVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLookupCertificatesIssuedByFinish sets the "lookup_certificates_issued_by_finish" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificates_issued_by_finish().
func (x *TlsDatabaseClass) OverrideLookupCertificatesIssuedByFinish(cb func(*TlsDatabase, AsyncResult) *glib.List) {
	if cb == nil {
		x.xLookupCertificatesIssuedByFinish = 0
	} else {
		x.xLookupCertificatesIssuedByFinish = purego.NewCallback(func(SelfVarp uintptr, ResultVarp uintptr) *glib.List {
			return cb(TlsDatabaseNewFromInternalPtr(SelfVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetLookupCertificatesIssuedByFinish gets the "lookup_certificates_issued_by_finish" callback function.
// Virtual method implementing
//
//	g_tls_database_lookup_certificates_issued_by_finish().
func (x *TlsDatabaseClass) GetLookupCertificatesIssuedByFinish() func(*TlsDatabase, AsyncResult) *glib.List {
	if x.xLookupCertificatesIssuedByFinish == 0 {
		return nil
	}
	var rawCallback func(SelfVarp uintptr, ResultVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupCertificatesIssuedByFinish)
	return func(SelfVar *TlsDatabase, ResultVar AsyncResult) *glib.List {
		return rawCallback(SelfVar.GoPointer(), ResultVar.GoPointer())
	}
}

type TlsDatabasePrivate struct {
	_ structs.HostLayout
}

func (x *TlsDatabasePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

const (
	// The purpose used to verify the client certificate in a TLS connection.
	// Used by TLS servers.
	TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT string = "1.3.6.1.5.5.7.3.2"
	// The purpose used to verify the server certificate in a TLS connection. This
	// is the most common purpose in use. Used by TLS clients.
	TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER string = "1.3.6.1.5.5.7.3.1"
)

// `GTlsDatabase` is used to look up certificates and other information
// from a certificate or key store. It is an abstract base class which
// TLS library specific subtypes override.
//
// A `GTlsDatabase` may be accessed from multiple threads by the TLS backend.
// All implementations are required to be fully thread-safe.
//
// Most common client applications will not directly interact with
// `GTlsDatabase`. It is used internally by [class@Gio.TlsConnection].
type TlsDatabase struct {
	gobject.Object
}

var xTlsDatabaseGLibType func() types.GType

func TlsDatabaseGLibType() types.GType {
	return xTlsDatabaseGLibType()
}

func TlsDatabaseNewFromInternalPtr(ptr uintptr) *TlsDatabase {
	cls := &TlsDatabase{}
	cls.Ptr = ptr
	return cls
}

var xTlsDatabaseCreateCertificateHandle func(uintptr, uintptr) string

// Create a handle string for the certificate. The database will only be able
// to create a handle for certificates that originate from the database. In
// cases where the database cannot create a handle for a certificate, %NULL
// will be returned.
//
// This handle should be stable across various instances of the application,
// and between applications. If a certificate is modified in the database,
// then it is not guaranteed that this handle will continue to point to it.
func (x *TlsDatabase) CreateCertificateHandle(CertificateVar *TlsCertificate) string {

	cret := xTlsDatabaseCreateCertificateHandle(x.GoPointer(), CertificateVar.GoPointer())

	return cret
}

var xTlsDatabaseLookupCertificateForHandle func(uintptr, string, uintptr, TlsDatabaseLookupFlags, uintptr, **glib.Error) uintptr

// Look up a certificate by its handle.
//
// The handle should have been created by calling
// g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
// the same TLS backend. The handle is designed to remain valid across
// instantiations of the database.
//
// If the handle is no longer valid, or does not point to a certificate in
// this database, then %NULL will be returned.
//
// This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
// the lookup operation asynchronously.
func (x *TlsDatabase) LookupCertificateForHandle(HandleVar string, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificateForHandle(x.GoPointer(), HandleVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsDatabaseLookupCertificateForHandleAsync func(uintptr, string, uintptr, TlsDatabaseLookupFlags, uintptr, uintptr, uintptr)

// Asynchronously look up a certificate by its handle in the database. See
// g_tls_database_lookup_certificate_for_handle() for more information.
func (x *TlsDatabase) LookupCertificateForHandleAsync(HandleVar string, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xTlsDatabaseLookupCertificateForHandleAsync(x.GoPointer(), HandleVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xTlsDatabaseLookupCertificateForHandleFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous lookup of a certificate by its handle. See
// g_tls_database_lookup_certificate_for_handle() for more information.
//
// If the handle is no longer valid, or does not point to a certificate in
// this database, then %NULL will be returned.
func (x *TlsDatabase) LookupCertificateForHandleFinish(ResultVar AsyncResult) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificateForHandleFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsDatabaseLookupCertificateIssuer func(uintptr, uintptr, uintptr, TlsDatabaseLookupFlags, uintptr, **glib.Error) uintptr

// Look up the issuer of @certificate in the database. The
// #GTlsCertificate:issuer property of @certificate is not modified, and
// the two certificates are not hooked into a chain.
//
// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
// to perform the lookup operation asynchronously.
//
// Beware this function cannot be used to build certification paths. The
// issuer certificate returned by this function may not be the same as
// the certificate that would actually be used to construct a valid
// certification path during certificate verification.
// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
// why an issuer certificate cannot be naively assumed to be part of the
// the certification path (though GLib's TLS backends may not follow the
// path building strategies outlined in this RFC). Due to the complexity
// of certification path building, GLib does not provide any way to know
// which certification path will actually be used when verifying a TLS
// certificate. Accordingly, this function cannot be used to make
// security-related decisions. Only GLib itself should make security
// decisions about TLS certificates.
func (x *TlsDatabase) LookupCertificateIssuer(CertificateVar *TlsCertificate, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificateIssuer(x.GoPointer(), CertificateVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsDatabaseLookupCertificateIssuerAsync func(uintptr, uintptr, uintptr, TlsDatabaseLookupFlags, uintptr, uintptr, uintptr)

// Asynchronously look up the issuer of @certificate in the database. See
// g_tls_database_lookup_certificate_issuer() for more information.
func (x *TlsDatabase) LookupCertificateIssuerAsync(CertificateVar *TlsCertificate, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xTlsDatabaseLookupCertificateIssuerAsync(x.GoPointer(), CertificateVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xTlsDatabaseLookupCertificateIssuerFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous lookup issuer operation. See
// g_tls_database_lookup_certificate_issuer() for more information.
func (x *TlsDatabase) LookupCertificateIssuerFinish(ResultVar AsyncResult) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificateIssuerFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsDatabaseLookupCertificatesIssuedBy func(uintptr, []byte, uintptr, TlsDatabaseLookupFlags, uintptr, **glib.Error) *glib.List

// Look up certificates issued by this issuer in the database.
//
// This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
// the lookup operation asynchronously.
func (x *TlsDatabase) LookupCertificatesIssuedBy(IssuerRawDnVar []byte, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificatesIssuedBy(x.GoPointer(), IssuerRawDnVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsDatabaseLookupCertificatesIssuedByAsync func(uintptr, []byte, uintptr, TlsDatabaseLookupFlags, uintptr, uintptr, uintptr)

// Asynchronously look up certificates issued by this issuer in the database. See
// g_tls_database_lookup_certificates_issued_by() for more information.
//
// The database may choose to hold a reference to the issuer byte array for the duration
// of this asynchronous operation. The byte array should not be modified during
// this time.
func (x *TlsDatabase) LookupCertificatesIssuedByAsync(IssuerRawDnVar []byte, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xTlsDatabaseLookupCertificatesIssuedByAsync(x.GoPointer(), IssuerRawDnVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xTlsDatabaseLookupCertificatesIssuedByFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finish an asynchronous lookup of certificates. See
// g_tls_database_lookup_certificates_issued_by() for more information.
func (x *TlsDatabase) LookupCertificatesIssuedByFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificatesIssuedByFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsDatabaseVerifyChain func(uintptr, uintptr, string, uintptr, uintptr, TlsDatabaseVerifyFlags, uintptr, **glib.Error) TlsCertificateFlags

// Determines the validity of a certificate chain, outside the context
// of a TLS session.
//
// @chain is a chain of #GTlsCertificate objects each pointing to the next
// certificate in the chain by its #GTlsCertificate:issuer property.
//
// @purpose describes the purpose (or usage) for which the certificate
// is being used. Typically @purpose will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
// which means that the certificate is being used to authenticate a server
// (and we are acting as the client).
//
// The @identity is used to ensure the server certificate is valid for
// the expected peer identity. If the identity does not match the
// certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
// return value. If @identity is %NULL, that bit will never be set in
// the return value. The peer identity may also be used to check for
// pinned certificates (trust exceptions) in the database. These may
// override the normal verification process on a host-by-host basis.
//
// Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
// used.
//
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate at
// least one problem found. If the function is unable to determine
// whether @chain is valid (for example, because @cancellable is
// triggered before it completes) then the return value will be
// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
// @error is not set when @chain is successfully analyzed but found to
// be invalid.
//
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
//
// Prior to GLib 2.48, GLib's default TLS backend modified @chain to
// represent the certification path built by #GTlsDatabase during
// certificate verification by adjusting the #GTlsCertificate:issuer
// property of each certificate in @chain. Since GLib 2.48, this no
// longer occurs, so you cannot rely on #GTlsCertificate:issuer to
// represent the actual certification path used during certificate
// verification.
//
// Because TLS session context is not used, #GTlsDatabase may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
//
// The TLS backend may attempt to look up and add missing certificates
// to the chain. This may involve HTTP requests to download missing
// certificates.
//
// This function can block. Use g_tls_database_verify_chain_async() to
// perform the verification operation asynchronously.
func (x *TlsDatabase) VerifyChain(ChainVar *TlsCertificate, PurposeVar string, IdentityVar SocketConnectable, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseVerifyFlags, CancellableVar *Cancellable) (TlsCertificateFlags, error) {
	var cerr *glib.Error

	cret := xTlsDatabaseVerifyChain(x.GoPointer(), ChainVar.GoPointer(), PurposeVar, IdentityVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsDatabaseVerifyChainAsync func(uintptr, uintptr, string, uintptr, uintptr, TlsDatabaseVerifyFlags, uintptr, uintptr, uintptr)

// Asynchronously determines the validity of a certificate chain after
// looking up and adding any missing certificates to the chain. See
// g_tls_database_verify_chain() for more information.
func (x *TlsDatabase) VerifyChainAsync(ChainVar *TlsCertificate, PurposeVar string, IdentityVar SocketConnectable, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseVerifyFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xTlsDatabaseVerifyChainAsync(x.GoPointer(), ChainVar.GoPointer(), PurposeVar, IdentityVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xTlsDatabaseVerifyChainFinish func(uintptr, uintptr, **glib.Error) TlsCertificateFlags

// Finish an asynchronous verify chain operation. See
// g_tls_database_verify_chain() for more information.
//
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate
// the problems found. If the function is unable to determine whether
// @chain is valid or not (eg, because @cancellable is triggered
// before it completes) then the return value will be
// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
// accordingly. @error is not set when @chain is successfully analyzed
// but found to be invalid.
func (x *TlsDatabase) VerifyChainFinish(ResultVar AsyncResult) (TlsCertificateFlags, error) {
	var cerr *glib.Error

	cret := xTlsDatabaseVerifyChainFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *TlsDatabase) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *TlsDatabase) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTlsDatabaseGLibType, libs, "g_tls_database_get_type")

	core.PuregoSafeRegister(&xTlsDatabaseCreateCertificateHandle, libs, "g_tls_database_create_certificate_handle")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateForHandle, libs, "g_tls_database_lookup_certificate_for_handle")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateForHandleAsync, libs, "g_tls_database_lookup_certificate_for_handle_async")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateForHandleFinish, libs, "g_tls_database_lookup_certificate_for_handle_finish")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateIssuer, libs, "g_tls_database_lookup_certificate_issuer")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateIssuerAsync, libs, "g_tls_database_lookup_certificate_issuer_async")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateIssuerFinish, libs, "g_tls_database_lookup_certificate_issuer_finish")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificatesIssuedBy, libs, "g_tls_database_lookup_certificates_issued_by")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificatesIssuedByAsync, libs, "g_tls_database_lookup_certificates_issued_by_async")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificatesIssuedByFinish, libs, "g_tls_database_lookup_certificates_issued_by_finish")
	core.PuregoSafeRegister(&xTlsDatabaseVerifyChain, libs, "g_tls_database_verify_chain")
	core.PuregoSafeRegister(&xTlsDatabaseVerifyChainAsync, libs, "g_tls_database_verify_chain_async")
	core.PuregoSafeRegister(&xTlsDatabaseVerifyChainFinish, libs, "g_tls_database_verify_chain_finish")

}
