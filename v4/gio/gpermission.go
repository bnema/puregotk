// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type PermissionClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xAcquire uintptr

	xAcquireAsync uintptr

	xAcquireFinish uintptr

	xRelease uintptr

	xReleaseAsync uintptr

	xReleaseFinish uintptr

	Reserved [16]uintptr
}

func (x *PermissionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideAcquire sets the "acquire" callback function.
func (x *PermissionClass) OverrideAcquire(cb func(*Permission, *Cancellable) bool) {
	if cb == nil {
		x.xAcquire = 0
	} else {
		x.xAcquire = purego.NewCallback(func(PermissionVarp uintptr, CancellableVarp uintptr) bool {
			return cb(PermissionNewFromInternalPtr(PermissionVarp), CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetAcquire gets the "acquire" callback function.
func (x *PermissionClass) GetAcquire() func(*Permission, *Cancellable) bool {
	if x.xAcquire == 0 {
		return nil
	}
	var rawCallback func(PermissionVarp uintptr, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xAcquire)
	return func(PermissionVar *Permission, CancellableVar *Cancellable) bool {
		return rawCallback(PermissionVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideAcquireAsync sets the "acquire_async" callback function.
func (x *PermissionClass) OverrideAcquireAsync(cb func(*Permission, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xAcquireAsync = 0
	} else {
		x.xAcquireAsync = purego.NewCallback(func(PermissionVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(PermissionNewFromInternalPtr(PermissionVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetAcquireAsync gets the "acquire_async" callback function.
func (x *PermissionClass) GetAcquireAsync() func(*Permission, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xAcquireAsync == 0 {
		return nil
	}
	var rawCallback func(PermissionVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xAcquireAsync)
	return func(PermissionVar *Permission, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(PermissionVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideAcquireFinish sets the "acquire_finish" callback function.
func (x *PermissionClass) OverrideAcquireFinish(cb func(*Permission, AsyncResult) bool) {
	if cb == nil {
		x.xAcquireFinish = 0
	} else {
		x.xAcquireFinish = purego.NewCallback(func(PermissionVarp uintptr, ResultVarp uintptr) bool {
			return cb(PermissionNewFromInternalPtr(PermissionVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetAcquireFinish gets the "acquire_finish" callback function.
func (x *PermissionClass) GetAcquireFinish() func(*Permission, AsyncResult) bool {
	if x.xAcquireFinish == 0 {
		return nil
	}
	var rawCallback func(PermissionVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xAcquireFinish)
	return func(PermissionVar *Permission, ResultVar AsyncResult) bool {
		return rawCallback(PermissionVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideRelease sets the "release" callback function.
func (x *PermissionClass) OverrideRelease(cb func(*Permission, *Cancellable) bool) {
	if cb == nil {
		x.xRelease = 0
	} else {
		x.xRelease = purego.NewCallback(func(PermissionVarp uintptr, CancellableVarp uintptr) bool {
			return cb(PermissionNewFromInternalPtr(PermissionVarp), CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetRelease gets the "release" callback function.
func (x *PermissionClass) GetRelease() func(*Permission, *Cancellable) bool {
	if x.xRelease == 0 {
		return nil
	}
	var rawCallback func(PermissionVarp uintptr, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xRelease)
	return func(PermissionVar *Permission, CancellableVar *Cancellable) bool {
		return rawCallback(PermissionVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideReleaseAsync sets the "release_async" callback function.
func (x *PermissionClass) OverrideReleaseAsync(cb func(*Permission, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xReleaseAsync = 0
	} else {
		x.xReleaseAsync = purego.NewCallback(func(PermissionVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(PermissionNewFromInternalPtr(PermissionVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetReleaseAsync gets the "release_async" callback function.
func (x *PermissionClass) GetReleaseAsync() func(*Permission, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xReleaseAsync == 0 {
		return nil
	}
	var rawCallback func(PermissionVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xReleaseAsync)
	return func(PermissionVar *Permission, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(PermissionVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideReleaseFinish sets the "release_finish" callback function.
func (x *PermissionClass) OverrideReleaseFinish(cb func(*Permission, AsyncResult) bool) {
	if cb == nil {
		x.xReleaseFinish = 0
	} else {
		x.xReleaseFinish = purego.NewCallback(func(PermissionVarp uintptr, ResultVarp uintptr) bool {
			return cb(PermissionNewFromInternalPtr(PermissionVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetReleaseFinish gets the "release_finish" callback function.
func (x *PermissionClass) GetReleaseFinish() func(*Permission, AsyncResult) bool {
	if x.xReleaseFinish == 0 {
		return nil
	}
	var rawCallback func(PermissionVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xReleaseFinish)
	return func(PermissionVar *Permission, ResultVar AsyncResult) bool {
		return rawCallback(PermissionVar.GoPointer(), ResultVar.GoPointer())
	}
}

type PermissionPrivate struct {
	_ structs.HostLayout
}

func (x *PermissionPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `GPermission` represents the status of the caller’s permission to
// perform a certain action.
//
// You can query if the action is currently allowed and if it is
// possible to acquire the permission so that the action will be allowed
// in the future.
//
// There is also an API to actually acquire the permission and one to
// release it.
//
// As an example, a `GPermission` might represent the ability for the
// user to write to a [class@Gio.Settings] object.  This `GPermission` object
// could then be used to decide if it is appropriate to show a “Click here to
// unlock” button in a dialog and to provide the mechanism to invoke
// when that button is clicked.
type Permission struct {
	gobject.Object
}

var xPermissionGLibType func() types.GType

func PermissionGLibType() types.GType {
	return xPermissionGLibType()
}

func PermissionNewFromInternalPtr(ptr uintptr) *Permission {
	cls := &Permission{}
	cls.Ptr = ptr
	return cls
}

var xPermissionAcquire func(uintptr, uintptr, **glib.Error) bool

// Attempts to acquire the permission represented by @permission.
//
// The precise method by which this happens depends on the permission
// and the underlying authentication mechanism.  A simple example is
// that a dialog may appear asking the user to enter their password.
//
// You should check with g_permission_get_can_acquire() before calling
// this function.
//
// If the permission is acquired then %TRUE is returned.  Otherwise,
// %FALSE is returned and @error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that
// user interaction is required).  See g_permission_acquire_async() for
// the non-blocking version.
func (x *Permission) Acquire(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xPermissionAcquire(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPermissionAcquireAsync func(uintptr, uintptr, uintptr, uintptr)

// Attempts to acquire the permission represented by @permission.
//
// This is the first half of the asynchronous version of
// g_permission_acquire().
func (x *Permission) AcquireAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xPermissionAcquireAsync(x.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xPermissionAcquireFinish func(uintptr, uintptr, **glib.Error) bool

// Collects the result of attempting to acquire the permission
// represented by @permission.
//
// This is the second half of the asynchronous version of
// g_permission_acquire().
func (x *Permission) AcquireFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xPermissionAcquireFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPermissionGetAllowed func(uintptr) bool

// Gets the value of the 'allowed' property.  This property is %TRUE if
// the caller currently has permission to perform the action that
// @permission represents the permission to perform.
func (x *Permission) GetAllowed() bool {

	cret := xPermissionGetAllowed(x.GoPointer())

	return cret
}

var xPermissionGetCanAcquire func(uintptr) bool

// Gets the value of the 'can-acquire' property.  This property is %TRUE
// if it is generally possible to acquire the permission by calling
// g_permission_acquire().
func (x *Permission) GetCanAcquire() bool {

	cret := xPermissionGetCanAcquire(x.GoPointer())

	return cret
}

var xPermissionGetCanRelease func(uintptr) bool

// Gets the value of the 'can-release' property.  This property is %TRUE
// if it is generally possible to release the permission by calling
// g_permission_release().
func (x *Permission) GetCanRelease() bool {

	cret := xPermissionGetCanRelease(x.GoPointer())

	return cret
}

var xPermissionImplUpdate func(uintptr, bool, bool, bool)

// This function is called by the #GPermission implementation to update
// the properties of the permission.  You should never call this
// function except from a #GPermission implementation.
//
// GObject notify signals are generated, as appropriate.
func (x *Permission) ImplUpdate(AllowedVar bool, CanAcquireVar bool, CanReleaseVar bool) {

	xPermissionImplUpdate(x.GoPointer(), AllowedVar, CanAcquireVar, CanReleaseVar)

}

var xPermissionRelease func(uintptr, uintptr, **glib.Error) bool

// Attempts to release the permission represented by @permission.
//
// The precise method by which this happens depends on the permission
// and the underlying authentication mechanism.  In most cases the
// permission will be dropped immediately without further action.
//
// You should check with g_permission_get_can_release() before calling
// this function.
//
// If the permission is released then %TRUE is returned.  Otherwise,
// %FALSE is returned and @error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that
// user interaction is required).  See g_permission_release_async() for
// the non-blocking version.
func (x *Permission) Release(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xPermissionRelease(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPermissionReleaseAsync func(uintptr, uintptr, uintptr, uintptr)

// Attempts to release the permission represented by @permission.
//
// This is the first half of the asynchronous version of
// g_permission_release().
func (x *Permission) ReleaseAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xPermissionReleaseAsync(x.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xPermissionReleaseFinish func(uintptr, uintptr, **glib.Error) bool

// Collects the result of attempting to release the permission
// represented by @permission.
//
// This is the second half of the asynchronous version of
// g_permission_release().
func (x *Permission) ReleaseFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xPermissionReleaseFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *Permission) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Permission) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// GetPropertyAllowed gets the "allowed" property.
// %TRUE if the caller currently has permission to perform the action that
// @permission represents the permission to perform.
func (x *Permission) GetPropertyAllowed() bool {
	var v gobject.Value
	x.GetProperty("allowed", &v)
	return v.GetBoolean()
}

// GetPropertyCanAcquire gets the "can-acquire" property.
// %TRUE if it is generally possible to acquire the permission by calling
// g_permission_acquire().
func (x *Permission) GetPropertyCanAcquire() bool {
	var v gobject.Value
	x.GetProperty("can-acquire", &v)
	return v.GetBoolean()
}

// GetPropertyCanRelease gets the "can-release" property.
// %TRUE if it is generally possible to release the permission by calling
// g_permission_release().
func (x *Permission) GetPropertyCanRelease() bool {
	var v gobject.Value
	x.GetProperty("can-release", &v)
	return v.GetBoolean()
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPermissionGLibType, libs, "g_permission_get_type")

	core.PuregoSafeRegister(&xPermissionAcquire, libs, "g_permission_acquire")
	core.PuregoSafeRegister(&xPermissionAcquireAsync, libs, "g_permission_acquire_async")
	core.PuregoSafeRegister(&xPermissionAcquireFinish, libs, "g_permission_acquire_finish")
	core.PuregoSafeRegister(&xPermissionGetAllowed, libs, "g_permission_get_allowed")
	core.PuregoSafeRegister(&xPermissionGetCanAcquire, libs, "g_permission_get_can_acquire")
	core.PuregoSafeRegister(&xPermissionGetCanRelease, libs, "g_permission_get_can_release")
	core.PuregoSafeRegister(&xPermissionImplUpdate, libs, "g_permission_impl_update")
	core.PuregoSafeRegister(&xPermissionRelease, libs, "g_permission_release")
	core.PuregoSafeRegister(&xPermissionReleaseAsync, libs, "g_permission_release_async")
	core.PuregoSafeRegister(&xPermissionReleaseFinish, libs, "g_permission_release_finish")

}
