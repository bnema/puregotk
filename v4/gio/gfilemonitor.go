// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type FileMonitorClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xChanged uintptr

	xCancel uintptr

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr
}

func (x *FileMonitorClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideChanged sets the callback function.
func (x *FileMonitorClass) OverrideChanged(cb func(*FileMonitor, File, File, FileMonitorEvent)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(MonitorVarp uintptr, FileVarp uintptr, OtherFileVarp uintptr, EventTypeVarp FileMonitorEvent) {
			cb(FileMonitorNewFromInternalPtr(MonitorVarp), &FileBase{Ptr: FileVarp}, &FileBase{Ptr: OtherFileVarp}, EventTypeVarp)
		})
	}
}

// GetChanged gets the callback function.
func (x *FileMonitorClass) GetChanged() func(*FileMonitor, File, File, FileMonitorEvent) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(MonitorVarp uintptr, FileVarp uintptr, OtherFileVarp uintptr, EventTypeVarp FileMonitorEvent)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(MonitorVar *FileMonitor, FileVar File, OtherFileVar File, EventTypeVar FileMonitorEvent) {
		rawCallback(MonitorVar.GoPointer(), FileVar.GoPointer(), OtherFileVar.GoPointer(), EventTypeVar)
	}
}

// OverrideCancel sets the callback function.
func (x *FileMonitorClass) OverrideCancel(cb func(*FileMonitor) bool) {
	if cb == nil {
		x.xCancel = 0
	} else {
		x.xCancel = purego.NewCallback(func(MonitorVarp uintptr) bool {
			return cb(FileMonitorNewFromInternalPtr(MonitorVarp))
		})
	}
}

// GetCancel gets the callback function.
func (x *FileMonitorClass) GetCancel() func(*FileMonitor) bool {
	if x.xCancel == 0 {
		return nil
	}
	var rawCallback func(MonitorVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCancel)
	return func(MonitorVar *FileMonitor) bool {
		return rawCallback(MonitorVar.GoPointer())
	}
}

// OverrideGReserved1 sets the callback function.
func (x *FileMonitorClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the callback function.
func (x *FileMonitorClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the callback function.
func (x *FileMonitorClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the callback function.
func (x *FileMonitorClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the callback function.
func (x *FileMonitorClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the callback function.
func (x *FileMonitorClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the callback function.
func (x *FileMonitorClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the callback function.
func (x *FileMonitorClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the callback function.
func (x *FileMonitorClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the callback function.
func (x *FileMonitorClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

type FileMonitorPrivate struct {
	_ structs.HostLayout
}

func (x *FileMonitorPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Monitors a file or directory for changes.
//
// To obtain a `GFileMonitor` for a file or directory, use
// [method@Gio.File.monitor], [method@Gio.File.monitor_file], or
// [method@Gio.File.monitor_directory].
//
// To get informed about changes to the file or directory you are
// monitoring, connect to the [signal@Gio.FileMonitor::changed] signal. The
// signal will be emitted in the thread-default main context (see
// [method@GLib.MainContext.push_thread_default]) of the thread that the monitor
// was created in (though if the global default main context is blocked, this
// may cause notifications to be blocked even if the thread-default
// context is still running).
type FileMonitor struct {
	gobject.Object
}

var xFileMonitorGLibType func() types.GType

func FileMonitorGLibType() types.GType {
	return xFileMonitorGLibType()
}

func FileMonitorNewFromInternalPtr(ptr uintptr) *FileMonitor {
	cls := &FileMonitor{}
	cls.Ptr = ptr
	return cls
}

var xFileMonitorCancel func(uintptr) bool

// Cancels a file monitor.
func (x *FileMonitor) Cancel() bool {

	cret := xFileMonitorCancel(x.GoPointer())
	return cret
}

var xFileMonitorEmitEvent func(uintptr, uintptr, uintptr, FileMonitorEvent)

// Emits the #GFileMonitor::changed signal if a change
// has taken place. Should be called from file monitor
// implementations only.
//
// Implementations are responsible to call this method from the
// thread-default main context (see [method@GLib.MainContext.push_thread_default])
// of the thread that the monitor was created in.
func (x *FileMonitor) EmitEvent(ChildVar File, OtherFileVar File, EventTypeVar FileMonitorEvent) {

	xFileMonitorEmitEvent(x.GoPointer(), ChildVar.GoPointer(), OtherFileVar.GoPointer(), EventTypeVar)

}

var xFileMonitorIsCancelled func(uintptr) bool

// Returns whether the monitor is canceled.
func (x *FileMonitor) IsCancelled() bool {

	cret := xFileMonitorIsCancelled(x.GoPointer())
	return cret
}

var xFileMonitorSetRateLimit func(uintptr, int)

// Sets the rate limit to which the @monitor will report
// consecutive change events to the same file.
func (x *FileMonitor) SetRateLimit(LimitMsecsVar int) {

	xFileMonitorSetRateLimit(x.GoPointer(), LimitMsecsVar)

}

func (c *FileMonitor) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *FileMonitor) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when @file has been changed.
//
// If using %G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and
// the information is available (and if supported by the backend),
// @event_type may be %G_FILE_MONITOR_EVENT_RENAMED,
// %G_FILE_MONITOR_EVENT_MOVED_IN or %G_FILE_MONITOR_EVENT_MOVED_OUT.
//
// In all cases @file will be a child of the monitored directory.  For
// renames, @file will be the old name and @other_file is the new
// name.  For "moved in" events, @file is the name of the file that
// appeared and @other_file is the old name that it was moved from (in
// another directory).  For "moved out" events, @file is the name of
// the file that used to be in this directory and @other_file is the
// name of the file at its new location.
//
// It makes sense to treat %G_FILE_MONITOR_EVENT_MOVED_IN as
// equivalent to %G_FILE_MONITOR_EVENT_CREATED and
// %G_FILE_MONITOR_EVENT_MOVED_OUT as equivalent to
// %G_FILE_MONITOR_EVENT_DELETED, with extra information.
// %G_FILE_MONITOR_EVENT_RENAMED is equivalent to a delete/create
// pair.  This is exactly how the events will be reported in the case
// that the %G_FILE_MONITOR_WATCH_MOVES flag is not in use.
//
// If using the deprecated flag %G_FILE_MONITOR_SEND_MOVED flag and @event_type is
// %G_FILE_MONITOR_EVENT_MOVED, @file will be set to a #GFile containing the
// old path, and @other_file will be set to a #GFile containing the new path.
//
// In all the other cases, @other_file will be set to #NULL.
func (x *FileMonitor) ConnectChanged(cb *func(FileMonitor, uintptr, uintptr, FileMonitorEvent)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, FileVarp uintptr, OtherFileVarp uintptr, EventTypeVarp FileMonitorEvent) {
		fa := FileMonitor{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, FileVarp, OtherFileVarp, EventTypeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibrary("GIO", "libgio-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFileMonitorGLibType, lib, "g_file_monitor_get_type")

	core.PuregoSafeRegister(&xFileMonitorCancel, lib, "g_file_monitor_cancel")
	core.PuregoSafeRegister(&xFileMonitorEmitEvent, lib, "g_file_monitor_emit_event")
	core.PuregoSafeRegister(&xFileMonitorIsCancelled, lib, "g_file_monitor_is_cancelled")
	core.PuregoSafeRegister(&xFileMonitorSetRateLimit, lib, "g_file_monitor_set_rate_limit")

}
