// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The type of the @get_property function in #GDBusInterfaceVTable.
type DBusInterfaceGetPropertyFunc func(uintptr, string, string, string, string, **glib.Error, uintptr) *glib.Variant

// The type of the @method_call function in #GDBusInterfaceVTable.
//
// @interface_name may be `NULL` if not specified by the sender, although it’s
// encouraged for the sender to set it. If unset, and the object has only one
// method (across all interfaces) matching @method_name, that method is invoked.
// Otherwise, behaviour is implementation defined. See the
// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-types-method).
// It is recommended to return [error@Gio.DBusError.UNKNOWN_METHOD].
type DBusInterfaceMethodCallFunc func(uintptr, string, string, string, string, *glib.Variant, uintptr, uintptr)

// The type of the @set_property function in #GDBusInterfaceVTable.
type DBusInterfaceSetPropertyFunc func(uintptr, string, string, string, string, *glib.Variant, **glib.Error, uintptr) bool

// Signature for function used in g_dbus_connection_add_filter().
//
// A filter function is passed a #GDBusMessage and expected to return
// a #GDBusMessage too. Passive filter functions that don't modify the
// message can simply return the @message object:
// |[
// static GDBusMessage *
// passive_filter (GDBusConnection *connection
//
//	GDBusMessage    *message,
//	gboolean         incoming,
//	gpointer         user_data)
//
//	{
//	  // inspect @message
//	  return message;
//	}
//
// ]|
// Filter functions that wants to drop a message can simply return %NULL:
// |[
// static GDBusMessage *
// drop_filter (GDBusConnection *connection
//
//	GDBusMessage    *message,
//	gboolean         incoming,
//	gpointer         user_data)
//
//	{
//	  if (should_drop_message)
//	    {
//	      g_object_unref (message);
//	      message = NULL;
//	    }
//	  return message;
//	}
//
// ]|
// Finally, a filter function may modify a message by copying it:
// |[
// static GDBusMessage *
// modifying_filter (GDBusConnection *connection
//
//	GDBusMessage    *message,
//	gboolean         incoming,
//	gpointer         user_data)
//
//	{
//	  GDBusMessage *copy;
//	  GError *error;
//
//	  error = NULL;
//	  copy = g_dbus_message_copy (message, &amp;error);
//	  // handle @error being set
//	  g_object_unref (message);
//
//	  // modify @copy
//
//	  return copy;
//	}
//
// ]|
// If the returned #GDBusMessage is different from @message and cannot
// be sent on @connection (it could use features, such as file
// descriptors, not compatible with @connection), then a warning is
// logged to standard error. Applications can
// check this ahead of time using g_dbus_message_to_blob() passing a
// #GDBusCapabilityFlags value obtained from @connection.
type DBusMessageFilterFunction func(uintptr, uintptr, bool, uintptr) uintptr

// Signature for callback function used in g_dbus_connection_signal_subscribe().
type DBusSignalCallback func(uintptr, string, string, string, string, *glib.Variant, uintptr)

// The type of the @dispatch function in #GDBusSubtreeVTable.
//
// Subtrees are flat.  @node, if non-%NULL, is always exactly one
// segment of the object path (ie: it never contains a slash).
type DBusSubtreeDispatchFunc func(uintptr, string, string, string, string, uintptr, uintptr) *DBusInterfaceVTable

// The type of the @enumerate function in #GDBusSubtreeVTable.
//
// This function is called when generating introspection data and also
// when preparing to dispatch incoming messages in the event that the
// %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
// specified (ie: to verify that the object path is valid).
//
// Hierarchies are not supported; the items that you return should not
// contain the `/` character.
//
// The return value will be freed with g_strfreev().
type DBusSubtreeEnumerateFunc func(uintptr, string, string, uintptr) []string

// The type of the @introspect function in #GDBusSubtreeVTable.
//
// Subtrees are flat.  @node, if non-%NULL, is always exactly one
// segment of the object path (ie: it never contains a slash).
//
// This function should return %NULL to indicate that there is no object
// at this node.
//
// If this function returns non-%NULL, the return value is expected to
// be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
// structures describing the interfaces implemented by @node.  This
// array will have g_dbus_interface_info_unref() called on each item
// before being freed with g_free().
//
// The difference between returning %NULL and an array containing zero
// items is that the standard DBus interfaces will returned to the
// remote introspector in the empty array case, but not in the %NULL
// case.
type DBusSubtreeIntrospectFunc func(uintptr, string, string, string, uintptr) uintptr

// Virtual table for handling properties and method calls for a D-Bus
// interface.
//
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give %NULL as your get_property() or set_property()
// function. The D-Bus call will be directed to your @method_call function,
// with the provided @interface_name set to "org.freedesktop.DBus.Properties".
//
// Ownership of the #GDBusMethodInvocation object passed to the
// method_call() function is transferred to your handler; you must
// call one of the methods of #GDBusMethodInvocation to return a reply
// (possibly empty), or an error. These functions also take ownership
// of the passed-in invocation object, so unless the invocation
// object has otherwise been referenced, it will be then be freed.
// Calling one of these functions may be done within your
// method_call() implementation but it also can be done at a later
// point to handle the method asynchronously.
//
// The usual checks on the validity of the calls is performed. For
// `Get` calls, an error is automatically returned if the property does
// not exist or the permissions do not allow access. The same checks are
// performed for `Set` calls, and the provided value is also checked for
// being the correct type.
//
// For both `Get` and `Set` calls, the #GDBusMethodInvocation
// passed to the @method_call handler can be queried with
// g_dbus_method_invocation_get_property_info() to get a pointer
// to the #GDBusPropertyInfo of the property.
//
// If you have readable properties specified in your interface info,
// you must ensure that you either provide a non-%NULL @get_property()
// function or provide implementations of both the `Get` and `GetAll`
// methods on org.freedesktop.DBus.Properties interface in your @method_call
// function. Note that the required return type of the `Get` call is
// `(v)`, not the type of the property. `GetAll` expects a return value
// of type `a{sv}`.
//
// If you have writable properties specified in your interface info,
// you must ensure that you either provide a non-%NULL @set_property()
// function or provide an implementation of the `Set` call. If implementing
// the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
type DBusInterfaceVTable struct {
	_ structs.HostLayout

	MethodCall DBusInterfaceMethodCallFunc

	GetProperty DBusInterfaceGetPropertyFunc

	SetProperty DBusInterfaceSetPropertyFunc

	Padding [8]uintptr
}

func (x *DBusInterfaceVTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().
type DBusSubtreeVTable struct {
	_ structs.HostLayout

	Enumerate DBusSubtreeEnumerateFunc

	Introspect DBusSubtreeIntrospectFunc

	Dispatch DBusSubtreeDispatchFunc

	Padding [8]uintptr
}

func (x *DBusSubtreeVTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xBusGet func(BusType, uintptr, uintptr, uintptr)

// Asynchronously connects to the message bus specified by @bus_type.
//
// When the operation is finished, @callback will be invoked. You can
// then call g_bus_get_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See g_bus_get_sync() for
// the synchronous version.
func BusGet(BusTypeVar BusType, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xBusGet(BusTypeVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xBusGetFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_bus_get().
//
// The returned object is a singleton, that is, shared with other
// callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
// event that you need a private message bus connection, use
// g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address() with
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
// G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
//
// Note that the returned #GDBusConnection object will (usually) have
// the #GDBusConnection:exit-on-close property set to %TRUE.
func BusGetFinish(ResVar AsyncResult) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xBusGetFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xBusGetSync func(BusType, uintptr, **glib.Error) uintptr

// Synchronously connects to the message bus specified by @bus_type.
// Note that the returned object may shared with other callers,
// e.g. if two separate parts of a process calls this function with
// the same @bus_type, they will share the same object.
//
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
//
// The returned object is a singleton, that is, shared with other
// callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
// event that you need a private message bus connection, use
// g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address() with
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
// G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
//
// Note that the returned #GDBusConnection object will (usually) have
// the #GDBusConnection:exit-on-close property set to %TRUE.
func BusGetSync(BusTypeVar BusType, CancellableVar *Cancellable) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xBusGetSync(BusTypeVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// The `GDBusConnection` type is used for D-Bus connections to remote
// peers such as a message buses.
//
// It is a low-level API that offers a lot of flexibility. For instance,
// it lets you establish a connection over any transport that can by represented
// as a [class@Gio.IOStream].
//
// This class is rarely used directly in D-Bus clients. If you are writing
// a D-Bus client, it is often easier to use the [func@Gio.bus_own_name],
// [func@Gio.bus_watch_name] or [func@Gio.DBusProxy.new_for_bus] APIs.
//
// As an exception to the usual GLib rule that a particular object must not
// be used by two threads at the same time, `GDBusConnection`s methods may be
// called from any thread. This is so that [func@Gio.bus_get] and
// [func@Gio.bus_get_sync] can safely return the same `GDBusConnection` when
// called from any thread.
//
// Most of the ways to obtain a `GDBusConnection` automatically initialize it
// (i.e. connect to D-Bus): for instance, [func@Gio.DBusConnection.new] and
// [func@Gio.bus_get], and the synchronous versions of those methods, give you
// an initialized connection. Language bindings for GIO should use
// [func@Gio.Initable.new] or [func@Gio.AsyncInitable.new_async], which also
// initialize the connection.
//
// If you construct an uninitialized `GDBusConnection`, such as via
// [ctor@GObject.Object.new], you must initialize it via [method@Gio.Initable.init] or
// [method@Gio.AsyncInitable.init_async] before using its methods or properties.
// Calling methods or accessing properties on a `GDBusConnection` that has not
// completed initialization successfully is considered to be invalid, and leads
// to undefined behaviour. In particular, if initialization fails with a
// `GError`, the only valid thing you can do with that `GDBusConnection` is to
// free it with [method@GObject.Object.unref].
//
// ## An example D-Bus server
//
// Here is an example for a D-Bus server:
// [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
//
// ## An example for exporting a subtree
//
// Here is an example for exporting a subtree:
// [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
//
// ## An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors:
// [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
//
// ## An example for exporting a GObject
//
// Here is an example for exporting a #GObject:
// [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
type DBusConnection struct {
	gobject.Object
}

var xDBusConnectionGLibType func() types.GType

func DBusConnectionGLibType() types.GType {
	return xDBusConnectionGLibType()
}

func DBusConnectionNewFromInternalPtr(ptr uintptr) *DBusConnection {
	cls := &DBusConnection{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusConnectionFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_connection_new().
func NewDBusConnectionFinish(ResVar AsyncResult) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xNewDBusConnectionFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusConnectionForAddressFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_connection_new_for_address().
func NewDBusConnectionForAddressFinish(ResVar AsyncResult) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xNewDBusConnectionForAddressFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusConnectionForAddressSync func(string, DBusConnectionFlags, uintptr, uintptr, **glib.Error) uintptr

// Synchronously connects and sets up a D-Bus client connection for
// exchanging D-Bus messages with an endpoint specified by @address
// which must be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side
// connections - use g_dbus_connection_new_sync() if you need to act
// as the server. In particular, @flags cannot contain the
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// This is a synchronous failable constructor. See
// g_dbus_connection_new_for_address() for the asynchronous version.
//
// If @observer is not %NULL it may be used to control the
// authentication process.
func NewDBusConnectionForAddressSync(AddressVar string, FlagsVar DBusConnectionFlags, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xNewDBusConnectionForAddressSync(AddressVar, FlagsVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusConnectionSync func(uintptr, string, DBusConnectionFlags, uintptr, uintptr, **glib.Error) uintptr

// Synchronously sets up a D-Bus connection for exchanging D-Bus messages
// with the end represented by @stream.
//
// If @stream is a #GSocketConnection, then the corresponding #GSocket
// will be put into non-blocking mode.
//
// The D-Bus connection will interact with @stream from a worker thread.
// As a result, the caller should not interact with @stream after this
// method has been called, except by calling g_object_unref() on it.
//
// If @observer is not %NULL it may be used to control the
// authentication process.
//
// This is a synchronous failable constructor. See
// g_dbus_connection_new() for the asynchronous version.
func NewDBusConnectionSync(StreamVar *IOStream, GuidVar string, FlagsVar DBusConnectionFlags, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xNewDBusConnectionSync(StreamVar.GoPointer(), GuidVar, FlagsVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusConnectionAddFilter func(uintptr, uintptr, uintptr, uintptr) uint

// Adds a message filter. Filters are handlers that are run on all
// incoming and outgoing messages, prior to standard dispatch. Filters
// are run in the order that they were added.  The same handler can be
// added as a filter more than once, in which case it will be run more
// than once.  Filters added during a filter callback won't be run on
// the message being processed. Filter functions are allowed to modify
// and even drop messages.
//
// Note that filters are run in a dedicated message handling thread so
// they can't block and, generally, can't do anything but signal a
// worker thread. Also note that filters are rarely needed - use API
// such as g_dbus_connection_send_message_with_reply(),
// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
//
// If a filter consumes an incoming message the message is not
// dispatched anywhere else - not even the standard dispatch machinery
// (that API such as g_dbus_connection_signal_subscribe() and
// g_dbus_connection_send_message_with_reply() relies on) will see the
// message. Similarly, if a filter consumes an outgoing message, the
// message will not be sent to the other peer.
//
// If @user_data_free_func is non-%NULL, it will be called (in the
// thread-default main context of the thread you are calling this
// method from) at some point after @user_data is no longer
// needed. (It is not guaranteed to be called synchronously when the
// filter is removed, and may be called after @connection has been
// destroyed.)
func (x *DBusConnection) AddFilter(FilterFunctionVar *DBusMessageFilterFunction, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) uint {

	cret := xDBusConnectionAddFilter(x.GoPointer(), glib.NewCallback(FilterFunctionVar), UserDataVar, glib.NewCallback(UserDataFreeFuncVar))
	return cret
}

var xDBusConnectionCall func(uintptr, string, string, string, string, *glib.Variant, *glib.VariantType, DBusCallFlags, int, uintptr, uintptr, uintptr)

// Asynchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at
// @object_path owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
// fail with %G_IO_ERROR_CANCELLED. If @parameters contains a value
// not compatible with the D-Bus protocol, the operation fails with
// %G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-%NULL then the reply will be checked for having this type and an
// error will be raised if it does not match.  Said another way, if you give a @reply_type
// then any non-%NULL return value will be of this type. Unless it’s
// %G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple containing one or more
// values.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
// |[&lt;!-- language="C" --&gt;
//
//	g_dbus_connection_call (connection,
//	                        "org.freedesktop.StringThings",
//	                        "/org/freedesktop/StringThings",
//	                        "org.freedesktop.StringThings",
//	                        "TwoStrings",
//	                        g_variant_new ("(ss)",
//	                                       "Thing One",
//	                                       "Thing Two"),
//	                        NULL,
//	                        G_DBUS_CALL_FLAGS_NONE,
//	                        -1,
//	                        NULL,
//	                        (GAsyncReadyCallback) two_strings_done,
//	                        NULL);
//
// ]|
//
// This is an asynchronous method. When the operation is finished,
// @callback will be invoked in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from. You can then call
// g_dbus_connection_call_finish() to get the result of the operation.
// See g_dbus_connection_call_sync() for the synchronous version of this
// function.
//
// If @callback is %NULL then the D-Bus method call message will be sent with
// the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
func (x *DBusConnection) Call(BusNameVar string, ObjectPathVar string, InterfaceNameVar string, MethodNameVar string, ParametersVar *glib.Variant, ReplyTypeVar *glib.VariantType, FlagsVar DBusCallFlags, TimeoutMsecVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionCall(x.GoPointer(), BusNameVar, ObjectPathVar, InterfaceNameVar, MethodNameVar, ParametersVar, ReplyTypeVar, FlagsVar, TimeoutMsecVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xDBusConnectionCallFinish func(uintptr, uintptr, **glib.Error) *glib.Variant

// Finishes an operation started with g_dbus_connection_call().
func (x *DBusConnection) CallFinish(ResVar AsyncResult) (*glib.Variant, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCallFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionCallSync func(uintptr, string, string, string, string, *glib.Variant, *glib.VariantType, DBusCallFlags, int, uintptr, **glib.Error) *glib.Variant

// Synchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at
// @object_path owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @cancellable is canceled, the
// operation will fail with %G_IO_ERROR_CANCELLED. If @parameters
// contains a value not compatible with the D-Bus protocol, the operation
// fails with %G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-%NULL then the reply will be checked for having
// this type and an error will be raised if it does not match.  Said
// another way, if you give a @reply_type then any non-%NULL return
// value will be of this type.
//
// If the @parameters #GVariant is floating, it is consumed.
// This allows convenient 'inline' use of g_variant_new(), e.g.:
// |[&lt;!-- language="C" --&gt;
//
//	g_dbus_connection_call_sync (connection,
//	                             "org.freedesktop.StringThings",
//	                             "/org/freedesktop/StringThings",
//	                             "org.freedesktop.StringThings",
//	                             "TwoStrings",
//	                             g_variant_new ("(ss)",
//	                                            "Thing One",
//	                                            "Thing Two"),
//	                             NULL,
//	                             G_DBUS_CALL_FLAGS_NONE,
//	                             -1,
//	                             NULL,
//	                             &amp;error);
//
// ]|
//
// The calling thread is blocked until a reply is received. See
// g_dbus_connection_call() for the asynchronous version of
// this method.
func (x *DBusConnection) CallSync(BusNameVar string, ObjectPathVar string, InterfaceNameVar string, MethodNameVar string, ParametersVar *glib.Variant, ReplyTypeVar *glib.VariantType, FlagsVar DBusCallFlags, TimeoutMsecVar int, CancellableVar *Cancellable) (*glib.Variant, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCallSync(x.GoPointer(), BusNameVar, ObjectPathVar, InterfaceNameVar, MethodNameVar, ParametersVar, ReplyTypeVar, FlagsVar, TimeoutMsecVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionCallWithUnixFdList func(uintptr, string, string, string, string, *glib.Variant, *glib.VariantType, DBusCallFlags, int, uintptr, uintptr, uintptr, uintptr)

// Like g_dbus_connection_call() but also takes a #GUnixFDList object.
//
// The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
// values in the body of the message. For example, if a message contains
// two file descriptors, @fd_list would have length 2, and
// `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
// somewhere in the body of the message (not necessarily in that order!)
// to represent the file descriptors at indexes 0 and 1 respectively.
//
// When designing D-Bus APIs that are intended to be interoperable,
// please note that non-GDBus implementations of D-Bus can usually only
// access file descriptors if they are referenced in this way by a
// value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
//
// This method is only available on UNIX.
func (x *DBusConnection) CallWithUnixFdList(BusNameVar string, ObjectPathVar string, InterfaceNameVar string, MethodNameVar string, ParametersVar *glib.Variant, ReplyTypeVar *glib.VariantType, FlagsVar DBusCallFlags, TimeoutMsecVar int, FdListVar *UnixFDList, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionCallWithUnixFdList(x.GoPointer(), BusNameVar, ObjectPathVar, InterfaceNameVar, MethodNameVar, ParametersVar, ReplyTypeVar, FlagsVar, TimeoutMsecVar, FdListVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xDBusConnectionCallWithUnixFdListFinish func(uintptr, **UnixFDList, uintptr, **glib.Error) *glib.Variant

// Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().
//
// The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
// values in the body of the message. For example,
// if g_variant_get_handle() returns 5, that is intended to be a reference
// to the file descriptor that can be accessed by
// `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
//
// When designing D-Bus APIs that are intended to be interoperable,
// please note that non-GDBus implementations of D-Bus can usually only
// access file descriptors if they are referenced in this way by a
// value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
func (x *DBusConnection) CallWithUnixFdListFinish(OutFdListVar **UnixFDList, ResVar AsyncResult) (*glib.Variant, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCallWithUnixFdListFinish(x.GoPointer(), OutFdListVar, ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionCallWithUnixFdListSync func(uintptr, string, string, string, string, *glib.Variant, *glib.VariantType, DBusCallFlags, int, uintptr, **UnixFDList, uintptr, **glib.Error) *glib.Variant

// Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.
// See g_dbus_connection_call_with_unix_fd_list() and
// g_dbus_connection_call_with_unix_fd_list_finish() for more details.
//
// This method is only available on UNIX.
func (x *DBusConnection) CallWithUnixFdListSync(BusNameVar string, ObjectPathVar string, InterfaceNameVar string, MethodNameVar string, ParametersVar *glib.Variant, ReplyTypeVar *glib.VariantType, FlagsVar DBusCallFlags, TimeoutMsecVar int, FdListVar *UnixFDList, OutFdListVar **UnixFDList, CancellableVar *Cancellable) (*glib.Variant, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCallWithUnixFdListSync(x.GoPointer(), BusNameVar, ObjectPathVar, InterfaceNameVar, MethodNameVar, ParametersVar, ReplyTypeVar, FlagsVar, TimeoutMsecVar, FdListVar.GoPointer(), OutFdListVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionClose func(uintptr, uintptr, uintptr, uintptr)

// Closes @connection. Note that this never causes the process to
// exit (this might only happen if the other end of a shared message
// bus connection disconnects, see #GDBusConnection:exit-on-close).
//
// Once the connection is closed, operations such as sending a message
// will return with the error %G_IO_ERROR_CLOSED. Closing a connection
// will not automatically flush the connection so queued messages may
// be lost. Use g_dbus_connection_flush() if you need such guarantees.
//
// If @connection is already closed, this method fails with
// %G_IO_ERROR_CLOSED.
//
// When @connection has been closed, the #GDBusConnection::closed
// signal is emitted in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// of the thread that @connection was constructed in.
//
// This is an asynchronous method. When the operation is finished,
// @callback will be invoked in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from. You can
// then call g_dbus_connection_close_finish() to get the result of the
// operation. See g_dbus_connection_close_sync() for the synchronous
// version.
func (x *DBusConnection) Close(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionClose(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xDBusConnectionCloseFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes an operation started with g_dbus_connection_close().
func (x *DBusConnection) CloseFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCloseFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionCloseSync func(uintptr, uintptr, **glib.Error) bool

// Synchronously closes @connection. The calling thread is blocked
// until this is done. See g_dbus_connection_close() for the
// asynchronous version of this method and more details about what it
// does.
func (x *DBusConnection) CloseSync(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCloseSync(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionEmitSignal func(uintptr, string, string, string, string, *glib.Variant, **glib.Error) bool

// Emits a signal.
//
// If the parameters GVariant is floating, it is consumed.
//
// This can only fail if @parameters is not compatible with the D-Bus protocol
// (%G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
// (%G_IO_ERROR_CLOSED).
func (x *DBusConnection) EmitSignal(DestinationBusNameVar string, ObjectPathVar string, InterfaceNameVar string, SignalNameVar string, ParametersVar *glib.Variant) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionEmitSignal(x.GoPointer(), DestinationBusNameVar, ObjectPathVar, InterfaceNameVar, SignalNameVar, ParametersVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionExportActionGroup func(uintptr, string, uintptr, **glib.Error) uint

// Exports @action_group on @connection at @object_path.
//
// The implemented D-Bus API should be considered private.  It is
// subject to change in the future.
//
// A given object path can only have one action group exported on it.
// If this constraint is violated, the export will fail and 0 will be
// returned (with @error set accordingly).
//
// You can unexport the action group using
// [method@Gio.DBusConnection.unexport_action_group] with the return value of
// this function.
//
// The thread default main context is taken at the time of this call.
// All incoming action activations and state change requests are
// reported from this context.  Any changes on the action group that
// cause it to emit signals must also come from this same context.
// Since incoming action activations and state change requests are
// rather likely to cause changes on the action group, this effectively
// limits a given action group to being exported from only one main
// context.
func (x *DBusConnection) ExportActionGroup(ObjectPathVar string, ActionGroupVar ActionGroup) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionExportActionGroup(x.GoPointer(), ObjectPathVar, ActionGroupVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionExportMenuModel func(uintptr, string, uintptr, **glib.Error) uint

// Exports @menu on @connection at @object_path.
//
// The implemented D-Bus API should be considered private.
// It is subject to change in the future.
//
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be
// returned (with @error set accordingly).
//
// Exporting menus with sections containing more than
// %G_MENU_EXPORTER_MAX_SECTION_SIZE items is not supported and results in
// undefined behavior.
//
// You can unexport the menu model using
// g_dbus_connection_unexport_menu_model() with the return value of
// this function.
func (x *DBusConnection) ExportMenuModel(ObjectPathVar string, MenuVar *MenuModel) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionExportMenuModel(x.GoPointer(), ObjectPathVar, MenuVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionFlush func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously flushes @connection, that is, writes all queued
// outgoing messages to the transport and then flushes the transport
// (using g_output_stream_flush_async()). This is useful in programs
// that want to emit a D-Bus signal and then exit immediately. Without
// flushing the connection, there is no guarantee that the message has
// been sent to the networking buffers in the OS kernel.
//
// This is an asynchronous method. When the operation is finished,
// @callback will be invoked in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from. You can
// then call g_dbus_connection_flush_finish() to get the result of the
// operation. See g_dbus_connection_flush_sync() for the synchronous
// version.
func (x *DBusConnection) Flush(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionFlush(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xDBusConnectionFlushFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes an operation started with g_dbus_connection_flush().
func (x *DBusConnection) FlushFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionFlushFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionFlushSync func(uintptr, uintptr, **glib.Error) bool

// Synchronously flushes @connection. The calling thread is blocked
// until this is done. See g_dbus_connection_flush() for the
// asynchronous version of this method and more details about what it
// does.
func (x *DBusConnection) FlushSync(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionFlushSync(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionGetCapabilities func(uintptr) DBusCapabilityFlags

// Gets the capabilities negotiated with the remote peer
func (x *DBusConnection) GetCapabilities() DBusCapabilityFlags {

	cret := xDBusConnectionGetCapabilities(x.GoPointer())
	return cret
}

var xDBusConnectionGetExitOnClose func(uintptr) bool

// Gets whether the process is terminated when @connection is
// closed by the remote peer. See
// #GDBusConnection:exit-on-close for more details.
func (x *DBusConnection) GetExitOnClose() bool {

	cret := xDBusConnectionGetExitOnClose(x.GoPointer())
	return cret
}

var xDBusConnectionGetFlags func(uintptr) DBusConnectionFlags

// Gets the flags used to construct this connection
func (x *DBusConnection) GetFlags() DBusConnectionFlags {

	cret := xDBusConnectionGetFlags(x.GoPointer())
	return cret
}

var xDBusConnectionGetGuid func(uintptr) string

// The GUID of the peer performing the role of server when
// authenticating. See #GDBusConnection:guid for more details.
func (x *DBusConnection) GetGuid() string {

	cret := xDBusConnectionGetGuid(x.GoPointer())
	return cret
}

var xDBusConnectionGetLastSerial func(uintptr) uint32

// Retrieves the last serial number assigned to a #GDBusMessage on
// the current thread. This includes messages sent via both low-level
// API such as g_dbus_connection_send_message() as well as
// high-level API such as g_dbus_connection_emit_signal(),
// g_dbus_connection_call() or g_dbus_proxy_call().
func (x *DBusConnection) GetLastSerial() uint32 {

	cret := xDBusConnectionGetLastSerial(x.GoPointer())
	return cret
}

var xDBusConnectionGetPeerCredentials func(uintptr) uintptr

// Gets the credentials of the authenticated peer. This will always
// return %NULL unless @connection acted as a server
// (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
// when set up and the client passed credentials as part of the
// authentication process.
//
// In a message bus setup, the message bus is always the server and
// each application is a client. So this method will always return
// %NULL for message bus clients.
func (x *DBusConnection) GetPeerCredentials() *Credentials {
	var cls *Credentials

	cret := xDBusConnectionGetPeerCredentials(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Credentials{}
	cls.Ptr = cret
	return cls
}

var xDBusConnectionGetStream func(uintptr) uintptr

// Gets the underlying stream used for IO.
//
// While the #GDBusConnection is active, it will interact with this
// stream from a worker thread, so it is not safe to interact with
// the stream directly.
func (x *DBusConnection) GetStream() *IOStream {
	var cls *IOStream

	cret := xDBusConnectionGetStream(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &IOStream{}
	cls.Ptr = cret
	return cls
}

var xDBusConnectionGetUniqueName func(uintptr) string

// Gets the unique name of @connection as assigned by the message
// bus. This can also be used to figure out if @connection is a
// message bus connection.
func (x *DBusConnection) GetUniqueName() string {

	cret := xDBusConnectionGetUniqueName(x.GoPointer())
	return cret
}

var xDBusConnectionIsClosed func(uintptr) bool

// Gets whether @connection is closed.
func (x *DBusConnection) IsClosed() bool {

	cret := xDBusConnectionIsClosed(x.GoPointer())
	return cret
}

var xDBusConnectionRegisterObject func(uintptr, string, *DBusInterfaceInfo, *DBusInterfaceVTable, uintptr, uintptr, **glib.Error) uint

// Registers callbacks for exported objects at @object_path with the
// D-Bus interface that is described in @interface_info.
//
// Calls to functions in @vtable (and @user_data_free_func) will happen
// in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from.
//
// Note that all #GVariant values passed to functions in @vtable will match
// the signature given in @interface_info - if a remote caller passes
// incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
// is returned to the remote caller.
//
// Additionally, if the remote caller attempts to invoke methods or
// access properties not mentioned in @interface_info the
// `org.freedesktop.DBus.Error.UnknownMethod` resp.
// `org.freedesktop.DBus.Error.InvalidArgs` errors
// are returned to the caller.
//
// It is considered a programming error if the
// #GDBusInterfaceGetPropertyFunc function in @vtable returns a
// #GVariant of incorrect type.
//
// If an existing callback is already registered at @object_path and
// @interface_name, then @error is set to %G_IO_ERROR_EXISTS.
//
// GDBus automatically implements the standard D-Bus interfaces
// org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
// and org.freedesktop.Peer, so you don't have to implement those for the
// objects you export. You can implement org.freedesktop.DBus.Properties
// yourself, e.g. to handle getting and setting of properties asynchronously.
//
// Note that the reference count on @interface_info will be
// incremented by 1 (unless allocated statically, e.g. if the
// reference count is -1, see g_dbus_interface_info_ref()) for as long
// as the object is exported. Also note that @vtable will be copied.
//
// See this [server][class@Gio.DBusConnection#an-example-d-bus-server]
// for an example of how to use this method.
func (x *DBusConnection) RegisterObject(ObjectPathVar string, InterfaceInfoVar *DBusInterfaceInfo, VtableVar *DBusInterfaceVTable, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionRegisterObject(x.GoPointer(), ObjectPathVar, InterfaceInfoVar, VtableVar, UserDataVar, glib.NewCallback(UserDataFreeFuncVar), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionRegisterObjectWithClosures func(uintptr, string, *DBusInterfaceInfo, *gobject.Closure, *gobject.Closure, *gobject.Closure, **glib.Error) uint

// Version of g_dbus_connection_register_object() using closures instead of a
// #GDBusInterfaceVTable for easier binding in other languages.
//
// Note that the reference counting semantics of the function wrapped by
// @method_call_closure are the same as those of
// [callback@Gio.DBusInterfaceMethodCallFunc]: ownership of a reference to the
// [class@Gio.DBusMethodInvocation] is transferred to the function.
func (x *DBusConnection) RegisterObjectWithClosures(ObjectPathVar string, InterfaceInfoVar *DBusInterfaceInfo, MethodCallClosureVar *gobject.Closure, GetPropertyClosureVar *gobject.Closure, SetPropertyClosureVar *gobject.Closure) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionRegisterObjectWithClosures(x.GoPointer(), ObjectPathVar, InterfaceInfoVar, MethodCallClosureVar, GetPropertyClosureVar, SetPropertyClosureVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionRegisterObjectWithClosures2 func(uintptr, string, *DBusInterfaceInfo, *gobject.Closure, *gobject.Closure, *gobject.Closure, **glib.Error) uint

// Version of [method@Gio.DBusConnection.register_object] using closures instead
// of a [type@Gio.DBusInterfaceVTable] for easier binding in other languages.
//
// In contrast to [method@Gio.DBusConnection.register_object] and
// [method@Gio.DBusConnection.register_object_with_closures], the reference
// counting semantics of the function wrapped by @method_call_closure are *not*
// the same as those of [callback@Gio.DBusInterfaceMethodCallFunc]. Ownership of
// a reference to the [class@Gio.DBusMethodInvocation] is *not* transferred to
// the function. Bindings must ensure that they add a reference to the
// [class@Gio.DBusMethodInvocation] before calling any
// `g_dbus_method_invocation_return_*()` methods on it. This should be automatic
// as a result of the introspection annotations on those methods.
func (x *DBusConnection) RegisterObjectWithClosures2(ObjectPathVar string, InterfaceInfoVar *DBusInterfaceInfo, MethodCallClosureVar *gobject.Closure, GetPropertyClosureVar *gobject.Closure, SetPropertyClosureVar *gobject.Closure) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionRegisterObjectWithClosures2(x.GoPointer(), ObjectPathVar, InterfaceInfoVar, MethodCallClosureVar, GetPropertyClosureVar, SetPropertyClosureVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionRegisterSubtree func(uintptr, string, *DBusSubtreeVTable, DBusSubtreeFlags, uintptr, uintptr, **glib.Error) uint

// Registers a whole subtree of dynamic objects.
//
// The @enumerate and @introspection functions in @vtable are used to
// convey, to remote callers, what nodes exist in the subtree rooted
// by @object_path.
//
// When handling remote calls into any node in the subtree, first the
// @enumerate function is used to check if the node exists. If the node exists
// or the %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
// the @introspection function is used to check if the node supports the
// requested method. If so, the @dispatch function is used to determine
// where to dispatch the call. The collected #GDBusInterfaceVTable and
// #gpointer will be used to call into the interface vtable for processing
// the request.
//
// All calls into user-provided code will be invoked in the thread-default
// main context (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from.
//
// If an existing subtree is already registered at @object_path or
// then @error is set to %G_IO_ERROR_EXISTS.
//
// Note that it is valid to register regular objects (using
// g_dbus_connection_register_object()) in a subtree registered with
// g_dbus_connection_register_subtree() - if so, the subtree handler
// is tried as the last resort. One way to think about a subtree
// handler is to consider it a fallback handler for object paths not
// registered via g_dbus_connection_register_object() or other bindings.
//
// Note that @vtable will be copied so you cannot change it after
// registration.
//
// See this [server][class@Gio.DBusConnection#an-example-for-exporting-a-subtree]
// for an example of how to use this method.
func (x *DBusConnection) RegisterSubtree(ObjectPathVar string, VtableVar *DBusSubtreeVTable, FlagsVar DBusSubtreeFlags, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionRegisterSubtree(x.GoPointer(), ObjectPathVar, VtableVar, FlagsVar, UserDataVar, glib.NewCallback(UserDataFreeFuncVar), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionRemoveFilter func(uintptr, uint)

// Removes a filter.
//
// Note that since filters run in a different thread, there is a race
// condition where it is possible that the filter will be running even
// after calling g_dbus_connection_remove_filter(), so you cannot just
// free data that the filter might be using. Instead, you should pass
// a #GDestroyNotify to g_dbus_connection_add_filter(), which will be
// called when it is guaranteed that the data is no longer needed.
func (x *DBusConnection) RemoveFilter(FilterIdVar uint) {

	xDBusConnectionRemoveFilter(x.GoPointer(), FilterIdVar)

}

var xDBusConnectionSendMessage func(uintptr, uintptr, DBusSendMessageFlags, *uint32, **glib.Error) bool

// Asynchronously sends @message to the peer represented by @connection.
//
// Unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
// will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
// serial number used will be written to this location prior to
// submitting the message to the underlying transport. While it has a `volatile`
// qualifier, this is a historical artifact and the argument passed to it should
// not be `volatile`.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @message is not well-formed,
// the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
//
// See this [server][class@Gio.DBusConnection#an-example-d-bus-server]
// and [client][class@Gio.DBusConnection#an-example-for-file-descriptor-passing]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (x *DBusConnection) SendMessage(MessageVar *DBusMessage, FlagsVar DBusSendMessageFlags, OutSerialVar *uint32) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionSendMessage(x.GoPointer(), MessageVar.GoPointer(), FlagsVar, OutSerialVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionSendMessageWithReply func(uintptr, uintptr, DBusSendMessageFlags, int, *uint32, uintptr, uintptr, uintptr)

// Asynchronously sends @message to the peer represented by @connection.
//
// Unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
// will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
// serial number used will be written to this location prior to
// submitting the message to the underlying transport. While it has a `volatile`
// qualifier, this is a historical artifact and the argument passed to it should
// not be `volatile`.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
// fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,
// the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from. You can then call
// g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
// See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
//
// Note that @message must be unlocked, unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
//
// See this [server][class@Gio.DBusConnection#an-example-d-bus-server]
// and [client][class@Gio.DBusConnection#an-example-for-file-descriptor-passing]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
func (x *DBusConnection) SendMessageWithReply(MessageVar *DBusMessage, FlagsVar DBusSendMessageFlags, TimeoutMsecVar int, OutSerialVar *uint32, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionSendMessageWithReply(x.GoPointer(), MessageVar.GoPointer(), FlagsVar, TimeoutMsecVar, OutSerialVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xDBusConnectionSendMessageWithReplyFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_connection_send_message_with_reply().
//
// Note that @error is only set if a local in-process error
// occurred. That is to say that the returned #GDBusMessage object may
// be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
// g_dbus_message_to_gerror() to transcode this to a #GError.
//
// See this [server][class@Gio.DBusConnection#an-example-d-bus-server]
// and [client][class@Gio.DBusConnection#an-example-for-file-descriptor-passing]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
func (x *DBusConnection) SendMessageWithReplyFinish(ResVar AsyncResult) (*DBusMessage, error) {
	var cls *DBusMessage
	var cerr *glib.Error

	cret := xDBusConnectionSendMessageWithReplyFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusConnectionSendMessageWithReplySync func(uintptr, uintptr, DBusSendMessageFlags, int, *uint32, uintptr, **glib.Error) uintptr

// Synchronously sends @message to the peer represented by @connection
// and blocks the calling thread until a reply is received or the
// timeout is reached. See g_dbus_connection_send_message_with_reply()
// for the asynchronous version of this method.
//
// Unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
// will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
// serial number used will be written to this location prior to
// submitting the message to the underlying transport. While it has a `volatile`
// qualifier, this is a historical artifact and the argument passed to it should
// not be `volatile`.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
// fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,
// the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
//
// Note that @error is only set if a local in-process error
// occurred. That is to say that the returned #GDBusMessage object may
// be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
// g_dbus_message_to_gerror() to transcode this to a #GError.
//
// See this [server][class@Gio.DBusConnection#an-example-d-bus-server]
// and [client][class@Gio.DBusConnection#an-example-for-file-descriptor-passing]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (x *DBusConnection) SendMessageWithReplySync(MessageVar *DBusMessage, FlagsVar DBusSendMessageFlags, TimeoutMsecVar int, OutSerialVar *uint32, CancellableVar *Cancellable) (*DBusMessage, error) {
	var cls *DBusMessage
	var cerr *glib.Error

	cret := xDBusConnectionSendMessageWithReplySync(x.GoPointer(), MessageVar.GoPointer(), FlagsVar, TimeoutMsecVar, OutSerialVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusConnectionSetExitOnClose func(uintptr, bool)

// Sets whether the process should be terminated when @connection is
// closed by the remote peer. See #GDBusConnection:exit-on-close for
// more details.
//
// Note that this function should be used with care. Most modern UNIX
// desktops tie the notion of a user session with the session bus, and expect
// all of a user's applications to quit when their bus connection goes away.
// If you are setting @exit_on_close to %FALSE for the shared session
// bus connection, you should make sure that your application exits
// when the user session ends.
func (x *DBusConnection) SetExitOnClose(ExitOnCloseVar bool) {

	xDBusConnectionSetExitOnClose(x.GoPointer(), ExitOnCloseVar)

}

var xDBusConnectionSignalSubscribe func(uintptr, string, string, string, string, string, DBusSignalFlags, uintptr, uintptr, uintptr) uint

// Subscribes to signals on @connection and invokes @callback whenever
// the signal is received. Note that @callback will be invoked in the
// thread-default main context (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from.
//
// If @connection is not a message bus connection, @sender must be
// %NULL.
//
// If @sender is a well-known name note that @callback is invoked with
// the unique name for the owner of @sender, not the well-known name
// as one would expect. This is because the message bus rewrites the
// name. As such, to avoid certain race conditions, users should be
// tracking the name owner of the well-known name and use that when
// processing the received signal.
//
// If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
// %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is
// interpreted as part of a namespace or path.  The first argument
// of a signal is matched against that part as specified by D-Bus.
//
// If @user_data_free_func is non-%NULL, it will be called (in the
// thread-default main context of the thread you are calling this
// method from) at some point after @user_data is no longer
// needed. (It is not guaranteed to be called synchronously when the
// signal is unsubscribed from, and may be called after @connection
// has been destroyed.)
//
// As @callback is potentially invoked in a different thread from where it’s
// emitted, it’s possible for this to happen after
// g_dbus_connection_signal_unsubscribe() has been called in another thread.
// Due to this, @user_data should have a strong reference which is freed with
// @user_data_free_func, rather than pointing to data whose lifecycle is tied
// to the signal subscription. For example, if a #GObject is used to store the
// subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
// to that #GObject must be passed to @user_data, and g_object_unref() passed to
// @user_data_free_func. You are responsible for breaking the resulting
// reference count cycle by explicitly unsubscribing from the signal when
// dropping the last external reference to the #GObject. Alternatively, a weak
// reference may be used.
//
// It is guaranteed that if you unsubscribe from a signal using
// g_dbus_connection_signal_unsubscribe() from the same thread which made the
// corresponding g_dbus_connection_signal_subscribe() call, @callback will not
// be invoked after g_dbus_connection_signal_unsubscribe() returns.
//
// The returned subscription identifier is an opaque value which is guaranteed
// to never be zero.
//
// This function can never fail.
func (x *DBusConnection) SignalSubscribe(SenderVar string, InterfaceNameVar string, MemberVar string, ObjectPathVar string, Arg0Var string, FlagsVar DBusSignalFlags, CallbackVar *DBusSignalCallback, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) uint {

	cret := xDBusConnectionSignalSubscribe(x.GoPointer(), SenderVar, InterfaceNameVar, MemberVar, ObjectPathVar, Arg0Var, FlagsVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(UserDataFreeFuncVar))
	return cret
}

var xDBusConnectionSignalUnsubscribe func(uintptr, uint)

// Unsubscribes from signals.
//
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default #GMainContext after this
// function has returned. You should continue to iterate the #GMainContext
// until the #GDestroyNotify function passed to
// g_dbus_connection_signal_subscribe() is called, in order to avoid memory
// leaks through callbacks queued on the #GMainContext after it’s stopped being
// iterated.
// Alternatively, any idle source with a priority lower than %G_PRIORITY_DEFAULT
// that was scheduled after unsubscription, also indicates that all resources
// of this subscription are released.
func (x *DBusConnection) SignalUnsubscribe(SubscriptionIdVar uint) {

	xDBusConnectionSignalUnsubscribe(x.GoPointer(), SubscriptionIdVar)

}

var xDBusConnectionStartMessageProcessing func(uintptr)

// If @connection was created with
// %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
// starts processing messages. Does nothing on if @connection wasn't
// created with this flag or if the method has already been called.
func (x *DBusConnection) StartMessageProcessing() {

	xDBusConnectionStartMessageProcessing(x.GoPointer())

}

var xDBusConnectionUnexportActionGroup func(uintptr, uint)

// Reverses the effect of a previous call to
// [method@Gio.DBusConnection.export_action_group].
//
// It is an error to call this function with an ID that wasn’t returned from
// [method@Gio.DBusConnection.export_action_group] or to call it with the same
// ID more than once.
func (x *DBusConnection) UnexportActionGroup(ExportIdVar uint) {

	xDBusConnectionUnexportActionGroup(x.GoPointer(), ExportIdVar)

}

var xDBusConnectionUnexportMenuModel func(uintptr, uint)

// Reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
//
// It is an error to call this function with an ID that wasn't returned
// from g_dbus_connection_export_menu_model() or to call it with the
// same ID more than once.
func (x *DBusConnection) UnexportMenuModel(ExportIdVar uint) {

	xDBusConnectionUnexportMenuModel(x.GoPointer(), ExportIdVar)

}

var xDBusConnectionUnregisterObject func(uintptr, uint) bool

// Unregisters an object.
func (x *DBusConnection) UnregisterObject(RegistrationIdVar uint) bool {

	cret := xDBusConnectionUnregisterObject(x.GoPointer(), RegistrationIdVar)
	return cret
}

var xDBusConnectionUnregisterSubtree func(uintptr, uint) bool

// Unregisters a subtree.
func (x *DBusConnection) UnregisterSubtree(RegistrationIdVar uint) bool {

	cret := xDBusConnectionUnregisterSubtree(x.GoPointer(), RegistrationIdVar)
	return cret
}

func (c *DBusConnection) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *DBusConnection) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAddress sets the "address" property.
// A D-Bus address specifying potential endpoints that can be used
// when establishing the connection.
func (x *DBusConnection) SetPropertyAddress(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("address", &v)
}

// GetPropertyClosed gets the "closed" property.
// A boolean specifying whether the connection has been closed.
func (x *DBusConnection) GetPropertyClosed() bool {
	var v gobject.Value
	x.GetProperty("closed", &v)
	return v.GetBoolean()
}

// SetPropertyExitOnClose sets the "exit-on-close" property.
// A boolean specifying whether the process will be terminated (by
// calling `raise(SIGTERM)`) if the connection is closed by the
// remote peer.
//
// Note that #GDBusConnection objects returned by g_bus_get_finish()
// and g_bus_get_sync() will (usually) have this property set to %TRUE.
func (x *DBusConnection) SetPropertyExitOnClose(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("exit-on-close", &v)
}

// GetPropertyExitOnClose gets the "exit-on-close" property.
// A boolean specifying whether the process will be terminated (by
// calling `raise(SIGTERM)`) if the connection is closed by the
// remote peer.
//
// Note that #GDBusConnection objects returned by g_bus_get_finish()
// and g_bus_get_sync() will (usually) have this property set to %TRUE.
func (x *DBusConnection) GetPropertyExitOnClose() bool {
	var v gobject.Value
	x.GetProperty("exit-on-close", &v)
	return v.GetBoolean()
}

// SetPropertyGuid sets the "guid" property.
// The GUID of the peer performing the role of server when
// authenticating.
//
// If you are constructing a #GDBusConnection and pass
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
// #GDBusConnection:flags property then you **must** also set this
// property to a valid guid.
//
// If you are constructing a #GDBusConnection and pass
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
// #GDBusConnection:flags property you will be able to read the GUID
// of the other peer here after the connection has been successfully
// initialized.
//
// Note that the
// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
// uses the term ‘UUID’ to refer to this, whereas GLib consistently uses the
// term ‘GUID’ for historical reasons.
//
// Despite its name, the format of #GDBusConnection:guid does not follow
// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
// GUID format.
func (x *DBusConnection) SetPropertyGuid(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("guid", &v)
}

// GetPropertyGuid gets the "guid" property.
// The GUID of the peer performing the role of server when
// authenticating.
//
// If you are constructing a #GDBusConnection and pass
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
// #GDBusConnection:flags property then you **must** also set this
// property to a valid guid.
//
// If you are constructing a #GDBusConnection and pass
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
// #GDBusConnection:flags property you will be able to read the GUID
// of the other peer here after the connection has been successfully
// initialized.
//
// Note that the
// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
// uses the term ‘UUID’ to refer to this, whereas GLib consistently uses the
// term ‘GUID’ for historical reasons.
//
// Despite its name, the format of #GDBusConnection:guid does not follow
// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
// GUID format.
func (x *DBusConnection) GetPropertyGuid() string {
	var v gobject.Value
	x.GetProperty("guid", &v)
	return v.GetString()
}

// GetPropertyUniqueName gets the "unique-name" property.
// The unique name as assigned by the message bus or %NULL if the
// connection is not open or not a message bus connection.
func (x *DBusConnection) GetPropertyUniqueName() string {
	var v gobject.Value
	x.GetProperty("unique-name", &v)
	return v.GetString()
}

// Emitted when the connection is closed.
//
// # The cause of this event can be
//
//   - If g_dbus_connection_close() is called. In this case
//     @remote_peer_vanished is set to %FALSE and @error is %NULL.
//
//   - If the remote peer closes the connection. In this case
//     @remote_peer_vanished is set to %TRUE and @error is set.
//
//   - If the remote peer sends invalid or malformed data. In this
//     case @remote_peer_vanished is set to %FALSE and @error is set.
//
// Upon receiving this signal, you should give up your reference to
// @connection. You are guaranteed that this signal is emitted only
// once.
func (x *DBusConnection) ConnectClosed(cb *func(DBusConnection, bool, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, RemotePeerVanishedVarp bool, ErrorVarp uintptr) {
		fa := DBusConnection{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, RemotePeerVanishedVarp, ErrorVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
}

// Starts asynchronous initialization of the object implementing the
// interface. This must be done before any real use of the object after
// initial construction. If the object also implements #GInitable you can
// optionally call g_initable_init() instead.
//
// This method is intended for language bindings. If writing in C,
// g_async_initable_new_async() should typically be used instead.
//
// When the initialization is finished, @callback will be called. You can
// then call g_async_initable_init_finish() to get the result of the
// initialization.
//
// Implementations may also support cancellation. If @cancellable is not
// %NULL, then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
// the object doesn't support cancellable initialization, the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// As with #GInitable, if the object is not initialized, or initialization
// returns with an error, then all operations on the object except
// g_object_ref() and g_object_unref() are considered to be invalid, and
// have undefined behaviour. They will often fail with g_critical() or
// g_warning(), but this must not be relied on.
//
// Callers should not assume that a class which implements #GAsyncInitable can
// be initialized multiple times; for more information, see g_initable_init().
// If a class explicitly supports being initialized multiple times,
// implementation requires yielding all subsequent calls to init_async() on the
// results of the first call.
//
// For classes that also support the #GInitable interface, the default
// implementation of this method will run the g_initable_init() function
// in a thread, so if you want to support asynchronous initialization via
// threads, just implement the #GAsyncInitable interface without overriding
// any interface methods.
func (x *DBusConnection) InitAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGAsyncInitableInitAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes asynchronous initialization and returns the result.
// See g_async_initable_init_async().
func (x *DBusConnection) InitFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGAsyncInitableInitFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Finishes the async construction for the various g_async_initable_new
// calls, returning the created object or %NULL on error.
func (x *DBusConnection) NewFinish(ResVar AsyncResult) (*gobject.Object, error) {
	var cls *gobject.Object
	var cerr *glib.Error

	cret := XGAsyncInitableNewFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [description][iface@Gio.Initable#description] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class’ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *DBusConnection) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionNew func(uintptr, string, DBusConnectionFlags, uintptr, uintptr, uintptr, uintptr)

// Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
// with the end represented by @stream.
//
// If @stream is a #GSocketConnection, then the corresponding #GSocket
// will be put into non-blocking mode.
//
// The D-Bus connection will interact with @stream from a worker thread.
// As a result, the caller should not interact with @stream after this
// method has been called, except by calling g_object_unref() on it.
//
// If @observer is not %NULL it may be used to control the
// authentication process.
//
// When the operation is finished, @callback will be invoked. You can
// then call g_dbus_connection_new_finish() to get the result of the
// operation.
//
// This is an asynchronous failable constructor. See
// g_dbus_connection_new_sync() for the synchronous
// version.
func DBusConnectionNew(StreamVar *IOStream, GuidVar string, FlagsVar DBusConnectionFlags, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionNew(StreamVar.GoPointer(), GuidVar, FlagsVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xDBusConnectionNewForAddress func(string, DBusConnectionFlags, uintptr, uintptr, uintptr, uintptr)

// Asynchronously connects and sets up a D-Bus client connection for
// exchanging D-Bus messages with an endpoint specified by @address
// which must be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side
// connections - use g_dbus_connection_new() if you need to act as the
// server. In particular, @flags cannot contain the
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// When the operation is finished, @callback will be invoked. You can
// then call g_dbus_connection_new_for_address_finish() to get the result of
// the operation.
//
// If @observer is not %NULL it may be used to control the
// authentication process.
//
// This is an asynchronous failable constructor. See
// g_dbus_connection_new_for_address_sync() for the synchronous
// version.
func DBusConnectionNewForAddress(AddressVar string, FlagsVar DBusConnectionFlags, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionNewForAddress(AddressVar, FlagsVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xBusGet, libs, "g_bus_get")
	core.PuregoSafeRegister(&xBusGetFinish, libs, "g_bus_get_finish")
	core.PuregoSafeRegister(&xBusGetSync, libs, "g_bus_get_sync")

	core.PuregoSafeRegister(&xDBusConnectionGLibType, libs, "g_dbus_connection_get_type")

	core.PuregoSafeRegister(&xNewDBusConnectionFinish, libs, "g_dbus_connection_new_finish")
	core.PuregoSafeRegister(&xNewDBusConnectionForAddressFinish, libs, "g_dbus_connection_new_for_address_finish")
	core.PuregoSafeRegister(&xNewDBusConnectionForAddressSync, libs, "g_dbus_connection_new_for_address_sync")
	core.PuregoSafeRegister(&xNewDBusConnectionSync, libs, "g_dbus_connection_new_sync")

	core.PuregoSafeRegister(&xDBusConnectionAddFilter, libs, "g_dbus_connection_add_filter")
	core.PuregoSafeRegister(&xDBusConnectionCall, libs, "g_dbus_connection_call")
	core.PuregoSafeRegister(&xDBusConnectionCallFinish, libs, "g_dbus_connection_call_finish")
	core.PuregoSafeRegister(&xDBusConnectionCallSync, libs, "g_dbus_connection_call_sync")
	core.PuregoSafeRegister(&xDBusConnectionCallWithUnixFdList, libs, "g_dbus_connection_call_with_unix_fd_list")
	core.PuregoSafeRegister(&xDBusConnectionCallWithUnixFdListFinish, libs, "g_dbus_connection_call_with_unix_fd_list_finish")
	core.PuregoSafeRegister(&xDBusConnectionCallWithUnixFdListSync, libs, "g_dbus_connection_call_with_unix_fd_list_sync")
	core.PuregoSafeRegister(&xDBusConnectionClose, libs, "g_dbus_connection_close")
	core.PuregoSafeRegister(&xDBusConnectionCloseFinish, libs, "g_dbus_connection_close_finish")
	core.PuregoSafeRegister(&xDBusConnectionCloseSync, libs, "g_dbus_connection_close_sync")
	core.PuregoSafeRegister(&xDBusConnectionEmitSignal, libs, "g_dbus_connection_emit_signal")
	core.PuregoSafeRegister(&xDBusConnectionExportActionGroup, libs, "g_dbus_connection_export_action_group")
	core.PuregoSafeRegister(&xDBusConnectionExportMenuModel, libs, "g_dbus_connection_export_menu_model")
	core.PuregoSafeRegister(&xDBusConnectionFlush, libs, "g_dbus_connection_flush")
	core.PuregoSafeRegister(&xDBusConnectionFlushFinish, libs, "g_dbus_connection_flush_finish")
	core.PuregoSafeRegister(&xDBusConnectionFlushSync, libs, "g_dbus_connection_flush_sync")
	core.PuregoSafeRegister(&xDBusConnectionGetCapabilities, libs, "g_dbus_connection_get_capabilities")
	core.PuregoSafeRegister(&xDBusConnectionGetExitOnClose, libs, "g_dbus_connection_get_exit_on_close")
	core.PuregoSafeRegister(&xDBusConnectionGetFlags, libs, "g_dbus_connection_get_flags")
	core.PuregoSafeRegister(&xDBusConnectionGetGuid, libs, "g_dbus_connection_get_guid")
	core.PuregoSafeRegister(&xDBusConnectionGetLastSerial, libs, "g_dbus_connection_get_last_serial")
	core.PuregoSafeRegister(&xDBusConnectionGetPeerCredentials, libs, "g_dbus_connection_get_peer_credentials")
	core.PuregoSafeRegister(&xDBusConnectionGetStream, libs, "g_dbus_connection_get_stream")
	core.PuregoSafeRegister(&xDBusConnectionGetUniqueName, libs, "g_dbus_connection_get_unique_name")
	core.PuregoSafeRegister(&xDBusConnectionIsClosed, libs, "g_dbus_connection_is_closed")
	core.PuregoSafeRegister(&xDBusConnectionRegisterObject, libs, "g_dbus_connection_register_object")
	core.PuregoSafeRegister(&xDBusConnectionRegisterObjectWithClosures, libs, "g_dbus_connection_register_object_with_closures")
	core.PuregoSafeRegister(&xDBusConnectionRegisterObjectWithClosures2, libs, "g_dbus_connection_register_object_with_closures2")
	core.PuregoSafeRegister(&xDBusConnectionRegisterSubtree, libs, "g_dbus_connection_register_subtree")
	core.PuregoSafeRegister(&xDBusConnectionRemoveFilter, libs, "g_dbus_connection_remove_filter")
	core.PuregoSafeRegister(&xDBusConnectionSendMessage, libs, "g_dbus_connection_send_message")
	core.PuregoSafeRegister(&xDBusConnectionSendMessageWithReply, libs, "g_dbus_connection_send_message_with_reply")
	core.PuregoSafeRegister(&xDBusConnectionSendMessageWithReplyFinish, libs, "g_dbus_connection_send_message_with_reply_finish")
	core.PuregoSafeRegister(&xDBusConnectionSendMessageWithReplySync, libs, "g_dbus_connection_send_message_with_reply_sync")
	core.PuregoSafeRegister(&xDBusConnectionSetExitOnClose, libs, "g_dbus_connection_set_exit_on_close")
	core.PuregoSafeRegister(&xDBusConnectionSignalSubscribe, libs, "g_dbus_connection_signal_subscribe")
	core.PuregoSafeRegister(&xDBusConnectionSignalUnsubscribe, libs, "g_dbus_connection_signal_unsubscribe")
	core.PuregoSafeRegister(&xDBusConnectionStartMessageProcessing, libs, "g_dbus_connection_start_message_processing")
	core.PuregoSafeRegister(&xDBusConnectionUnexportActionGroup, libs, "g_dbus_connection_unexport_action_group")
	core.PuregoSafeRegister(&xDBusConnectionUnexportMenuModel, libs, "g_dbus_connection_unexport_menu_model")
	core.PuregoSafeRegister(&xDBusConnectionUnregisterObject, libs, "g_dbus_connection_unregister_object")
	core.PuregoSafeRegister(&xDBusConnectionUnregisterSubtree, libs, "g_dbus_connection_unregister_subtree")

	core.PuregoSafeRegister(&xDBusConnectionNew, libs, "g_dbus_connection_new")
	core.PuregoSafeRegister(&xDBusConnectionNewForAddress, libs, "g_dbus_connection_new_for_address")

}
