// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// This struct defines a single action.  It is for use with
// [method@Gio.ActionMap.add_action_entries].
//
// The order of the items in the structure are intended to reflect
// frequency of use.  It is permissible to use an incomplete initialiser
// in order to leave some of the later values as `NULL`.  All values
// after @name are optional.  Additional optional fields may be added in
// the future.
//
// See [method@Gio.ActionMap.add_action_entries] for an example.
type ActionEntry struct {
	_ structs.HostLayout

	Name uintptr

	xActivate uintptr

	ParameterType uintptr

	State uintptr

	xChangeState uintptr

	Padding [3]uint
}

func (x *ActionEntry) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideActivate sets the callback function.
// the callback to connect to the "activate" signal of the action.
//
//	Since GLib 2.40, this can be `NULL` for stateful actions, in which case
//	the default handler is used. For boolean-stated actions with no
//	parameter, this is a toggle. For other state types (and parameter type
//	equal to the state type) this will be a function that just calls
//	@change_state (which you should provide).
func (x *ActionEntry) OverrideActivate(cb func(*SimpleAction, *glib.Variant, uintptr)) {
	if cb == nil {
		x.xActivate = 0
	} else {
		x.xActivate = purego.NewCallback(func(ActionVarp uintptr, ParameterVarp *glib.Variant, UserDataVarp uintptr) {
			cb(SimpleActionNewFromInternalPtr(ActionVarp), ParameterVarp, UserDataVarp)
		})
	}
}

// GetActivate gets the callback function.
// the callback to connect to the "activate" signal of the action.
//
//	Since GLib 2.40, this can be `NULL` for stateful actions, in which case
//	the default handler is used. For boolean-stated actions with no
//	parameter, this is a toggle. For other state types (and parameter type
//	equal to the state type) this will be a function that just calls
//	@change_state (which you should provide).
func (x *ActionEntry) GetActivate() func(*SimpleAction, *glib.Variant, uintptr) {
	if x.xActivate == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr, ParameterVarp *glib.Variant, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xActivate)
	return func(ActionVar *SimpleAction, ParameterVar *glib.Variant, UserDataVar uintptr) {
		rawCallback(ActionVar.GoPointer(), ParameterVar, UserDataVar)
	}
}

// OverrideChangeState sets the callback function.
// the callback to connect to the "change-state" signal of the
//
//	action.  All stateful actions should provide a handler here; stateless
//	actions should not.
func (x *ActionEntry) OverrideChangeState(cb func(*SimpleAction, *glib.Variant, uintptr)) {
	if cb == nil {
		x.xChangeState = 0
	} else {
		x.xChangeState = purego.NewCallback(func(ActionVarp uintptr, ValueVarp *glib.Variant, UserDataVarp uintptr) {
			cb(SimpleActionNewFromInternalPtr(ActionVarp), ValueVarp, UserDataVarp)
		})
	}
}

// GetChangeState gets the callback function.
// the callback to connect to the "change-state" signal of the
//
//	action.  All stateful actions should provide a handler here; stateless
//	actions should not.
func (x *ActionEntry) GetChangeState() func(*SimpleAction, *glib.Variant, uintptr) {
	if x.xChangeState == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr, ValueVarp *glib.Variant, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChangeState)
	return func(ActionVar *SimpleAction, ValueVar *glib.Variant, UserDataVar uintptr) {
		rawCallback(ActionVar.GoPointer(), ValueVar, UserDataVar)
	}
}

// The virtual function table for [iface@Gio.ActionMap].
type ActionMapInterface struct {
	_ structs.HostLayout

	GIface uintptr

	xLookupAction uintptr

	xAddAction uintptr

	xRemoveAction uintptr
}

func (x *ActionMapInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideLookupAction sets the callback function.
// the virtual function pointer for
//
//	[method@Gio.ActionMap.lookup_action]
func (x *ActionMapInterface) OverrideLookupAction(cb func(ActionMap, string) *ActionBase) {
	if cb == nil {
		x.xLookupAction = 0
	} else {
		x.xLookupAction = purego.NewCallback(func(ActionMapVarp uintptr, ActionNameVarp string) uintptr {
			ret := cb(&ActionMapBase{Ptr: ActionMapVarp}, ActionNameVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetLookupAction gets the callback function.
// the virtual function pointer for
//
//	[method@Gio.ActionMap.lookup_action]
func (x *ActionMapInterface) GetLookupAction() func(ActionMap, string) *ActionBase {
	if x.xLookupAction == 0 {
		return nil
	}
	var rawCallback func(ActionMapVarp uintptr, ActionNameVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xLookupAction)
	return func(ActionMapVar ActionMap, ActionNameVar string) *ActionBase {
		rawRet := rawCallback(ActionMapVar.GoPointer(), ActionNameVar)
		if rawRet == 0 {
			return nil
		}
		ret := &ActionBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideAddAction sets the callback function.
// the virtual function pointer for
//
//	[method@Gio.ActionMap.add_action]
func (x *ActionMapInterface) OverrideAddAction(cb func(ActionMap, Action)) {
	if cb == nil {
		x.xAddAction = 0
	} else {
		x.xAddAction = purego.NewCallback(func(ActionMapVarp uintptr, ActionVarp uintptr) {
			cb(&ActionMapBase{Ptr: ActionMapVarp}, &ActionBase{Ptr: ActionVarp})
		})
	}
}

// GetAddAction gets the callback function.
// the virtual function pointer for
//
//	[method@Gio.ActionMap.add_action]
func (x *ActionMapInterface) GetAddAction() func(ActionMap, Action) {
	if x.xAddAction == 0 {
		return nil
	}
	var rawCallback func(ActionMapVarp uintptr, ActionVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xAddAction)
	return func(ActionMapVar ActionMap, ActionVar Action) {
		rawCallback(ActionMapVar.GoPointer(), ActionVar.GoPointer())
	}
}

// OverrideRemoveAction sets the callback function.
// the virtual function pointer for
//
//	[method@Gio.ActionMap.remove_action]
func (x *ActionMapInterface) OverrideRemoveAction(cb func(ActionMap, string)) {
	if cb == nil {
		x.xRemoveAction = 0
	} else {
		x.xRemoveAction = purego.NewCallback(func(ActionMapVarp uintptr, ActionNameVarp string) {
			cb(&ActionMapBase{Ptr: ActionMapVarp}, ActionNameVarp)
		})
	}
}

// GetRemoveAction gets the callback function.
// the virtual function pointer for
//
//	[method@Gio.ActionMap.remove_action]
func (x *ActionMapInterface) GetRemoveAction() func(ActionMap, string) {
	if x.xRemoveAction == 0 {
		return nil
	}
	var rawCallback func(ActionMapVarp uintptr, ActionNameVarp string)
	purego.RegisterFunc(&rawCallback, x.xRemoveAction)
	return func(ActionMapVar ActionMap, ActionNameVar string) {
		rawCallback(ActionMapVar.GoPointer(), ActionNameVar)
	}
}

// `GActionMap` is an interface for action containers.
//
// The `GActionMap` interface is implemented by [iface@Gio.ActionGroup]
// implementations that operate by containing a number of named
// [iface@Gio.Action] instances, such as [class@Gio.SimpleActionGroup].
//
// One useful application of this interface is to map the
// names of actions from various action groups to unique,
// prefixed names (e.g. by prepending "app." or "win.").
// This is the motivation for the ‘Map’ part of the interface
// name.
type ActionMap interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	AddAction(ActionVar Action)
	AddActionEntries(EntriesVar []ActionEntry, NEntriesVar int, UserDataVar uintptr)
	LookupAction(ActionNameVar string) *ActionBase
	RemoveAction(ActionNameVar string)
	RemoveActionEntries(EntriesVar []ActionEntry, NEntriesVar int)
}

var xActionMapGLibType func() types.GType

func ActionMapGLibType() types.GType {
	return xActionMapGLibType()
}

type ActionMapBase struct {
	Ptr uintptr
}

func (x *ActionMapBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *ActionMapBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Adds an action to the @action_map.
//
// If the action map already contains an action with the same name
// as @action then the old action is dropped from the action map.
//
// The action map takes its own reference on @action.
func (x *ActionMapBase) AddAction(ActionVar Action) {

	XGActionMapAddAction(x.GoPointer(), ActionVar.GoPointer())

}

// A convenience function for creating multiple [class@Gio.SimpleAction]
// instances and adding them to a [iface@Gio.ActionMap].
//
// Each action is constructed as per one [struct@Gio.ActionEntry].
//
// ```c
// static void
// activate_quit (GSimpleAction *simple,
//
//	GVariant      *parameter,
//	gpointer       user_data)
//
//	{
//	  exit (0);
//	}
//
// static void
// activate_print_string (GSimpleAction *simple,
//
//	GVariant      *parameter,
//	gpointer       user_data)
//
//	{
//	  g_print ("%s\n", g_variant_get_string (parameter, NULL));
//	}
//
// static GActionGroup *
// create_action_group (void)
//
//	{
//	  const GActionEntry entries[] = {
//	    { "quit",         activate_quit              },
//	    { "print-string", activate_print_string, "s" }
//	  };
//	  GSimpleActionGroup *group;
//
//	  group = g_simple_action_group_new ();
//	  g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
//
//	  return G_ACTION_GROUP (group);
//	}
//
// ```
func (x *ActionMapBase) AddActionEntries(EntriesVar []ActionEntry, NEntriesVar int, UserDataVar uintptr) {

	XGActionMapAddActionEntries(x.GoPointer(), EntriesVar, NEntriesVar, UserDataVar)

}

// Looks up the action with the name @action_name in @action_map.
//
// If no such action exists, returns `NULL`.
func (x *ActionMapBase) LookupAction(ActionNameVar string) *ActionBase {
	var cls *ActionBase

	cret := XGActionMapLookupAction(x.GoPointer(), ActionNameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ActionBase{}
	cls.Ptr = cret
	return cls
}

// Removes the named action from the action map.
//
// If no action of this name is in the map then nothing happens.
func (x *ActionMapBase) RemoveAction(ActionNameVar string) {

	XGActionMapRemoveAction(x.GoPointer(), ActionNameVar)

}

// Remove actions from a [iface@Gio.ActionMap]. This is meant as the reverse of
// [method@Gio.ActionMap.add_action_entries].
//
// ```c
//
//	static const GActionEntry entries[] = {
//	    { "quit",         activate_quit              },
//	    { "print-string", activate_print_string, "s" }
//	};
//
// void
// add_actions (GActionMap *map)
//
//	{
//	  g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
//	}
//
// void
// remove_actions (GActionMap *map)
//
//	{
//	  g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
//	}
//
// ```
func (x *ActionMapBase) RemoveActionEntries(EntriesVar []ActionEntry, NEntriesVar int) {

	XGActionMapRemoveActionEntries(x.GoPointer(), EntriesVar, NEntriesVar)

}

var XGActionMapAddAction func(uintptr, uintptr)
var XGActionMapAddActionEntries func(uintptr, []ActionEntry, int, uintptr)
var XGActionMapLookupAction func(uintptr, string) uintptr
var XGActionMapRemoveAction func(uintptr, string)
var XGActionMapRemoveActionEntries func(uintptr, []ActionEntry, int)

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibrary("GIO", "libgio-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xActionMapGLibType, lib, "g_action_map_get_type")

	core.PuregoSafeRegister(&XGActionMapAddAction, lib, "g_action_map_add_action")
	core.PuregoSafeRegister(&XGActionMapAddActionEntries, lib, "g_action_map_add_action_entries")
	core.PuregoSafeRegister(&XGActionMapLookupAction, lib, "g_action_map_lookup_action")
	core.PuregoSafeRegister(&XGActionMapRemoveAction, lib, "g_action_map_remove_action")
	core.PuregoSafeRegister(&XGActionMapRemoveActionEntries, lib, "g_action_map_remove_action_entries")

}
