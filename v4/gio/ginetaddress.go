// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type InetAddressClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xToString uintptr

	xToBytes uintptr
}

func (x *InetAddressClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideToString sets the callback function.
func (x *InetAddressClass) OverrideToString(cb func(*InetAddress) string) {
	if cb == nil {
		x.xToString = 0
	} else {
		x.xToString = purego.NewCallback(func(AddressVarp uintptr) string {
			return cb(InetAddressNewFromInternalPtr(AddressVarp))
		})
	}
}

// GetToString gets the callback function.
func (x *InetAddressClass) GetToString() func(*InetAddress) string {
	if x.xToString == 0 {
		return nil
	}
	var rawCallback func(AddressVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xToString)
	return func(AddressVar *InetAddress) string {
		return rawCallback(AddressVar.GoPointer())
	}
}

// OverrideToBytes sets the callback function.
func (x *InetAddressClass) OverrideToBytes(cb func(*InetAddress) byte) {
	if cb == nil {
		x.xToBytes = 0
	} else {
		x.xToBytes = purego.NewCallback(func(AddressVarp uintptr) byte {
			return cb(InetAddressNewFromInternalPtr(AddressVarp))
		})
	}
}

// GetToBytes gets the callback function.
func (x *InetAddressClass) GetToBytes() func(*InetAddress) byte {
	if x.xToBytes == 0 {
		return nil
	}
	var rawCallback func(AddressVarp uintptr) byte
	purego.RegisterFunc(&rawCallback, x.xToBytes)
	return func(AddressVar *InetAddress) byte {
		return rawCallback(AddressVar.GoPointer())
	}
}

type InetAddressPrivate struct {
	_ structs.HostLayout
}

func (x *InetAddressPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GInetAddress` represents an IPv4 or IPv6 internet address. Use
// [method@Gio.Resolver.lookup_by_name] or
// [method@Gio.Resolver.lookup_by_name_async] to look up the `GInetAddress` for
// a hostname. Use [method@Gio.Resolver.lookup_by_address] or
// [method@Gio.Resolver.lookup_by_address_async] to look up the hostname for a
// `GInetAddress`.
//
// To actually connect to a remote host, you will need a
// [class@Gio.InetSocketAddress] (which includes a `GInetAddress` as well as a
// port number).
type InetAddress struct {
	gobject.Object
}

var xInetAddressGLibType func() types.GType

func InetAddressGLibType() types.GType {
	return xInetAddressGLibType()
}

func InetAddressNewFromInternalPtr(ptr uintptr) *InetAddress {
	cls := &InetAddress{}
	cls.Ptr = ptr
	return cls
}

var xNewInetAddressAny func(SocketFamily) uintptr

// Creates a #GInetAddress for the "any" address (unassigned/"don't
// care") for @family.
func NewInetAddressAny(FamilyVar SocketFamily) *InetAddress {
	var cls *InetAddress

	cret := xNewInetAddressAny(FamilyVar)

	if cret == 0 {
		return nil
	}
	cls = &InetAddress{}
	cls.Ptr = cret
	return cls
}

var xNewInetAddressFromBytes func([]byte, SocketFamily) uintptr

// Creates a new #GInetAddress from the given @family and @bytes.
// @bytes should be 4 bytes for %G_SOCKET_FAMILY_IPV4 and 16 bytes for
// %G_SOCKET_FAMILY_IPV6.
func NewInetAddressFromBytes(BytesVar []byte, FamilyVar SocketFamily) *InetAddress {
	var cls *InetAddress

	cret := xNewInetAddressFromBytes(BytesVar, FamilyVar)

	if cret == 0 {
		return nil
	}
	cls = &InetAddress{}
	cls.Ptr = cret
	return cls
}

var xNewInetAddressFromString func(string) uintptr

// Parses @string as an IP address and creates a new #GInetAddress.
func NewInetAddressFromString(StringVar string) *InetAddress {
	var cls *InetAddress

	cret := xNewInetAddressFromString(StringVar)

	if cret == 0 {
		return nil
	}
	cls = &InetAddress{}
	cls.Ptr = cret
	return cls
}

var xNewInetAddressLoopback func(SocketFamily) uintptr

// Creates a #GInetAddress for the loopback address for @family.
func NewInetAddressLoopback(FamilyVar SocketFamily) *InetAddress {
	var cls *InetAddress

	cret := xNewInetAddressLoopback(FamilyVar)

	if cret == 0 {
		return nil
	}
	cls = &InetAddress{}
	cls.Ptr = cret
	return cls
}

var xInetAddressEqual func(uintptr, uintptr) bool

// Checks if two #GInetAddress instances are equal, e.g. the same address.
func (x *InetAddress) Equal(OtherAddressVar *InetAddress) bool {

	cret := xInetAddressEqual(x.GoPointer(), OtherAddressVar.GoPointer())
	return cret
}

var xInetAddressGetFamily func(uintptr) SocketFamily

// Gets @address's family
func (x *InetAddress) GetFamily() SocketFamily {

	cret := xInetAddressGetFamily(x.GoPointer())
	return cret
}

var xInetAddressGetIsAny func(uintptr) bool

// Tests whether @address is the "any" address for its family.
func (x *InetAddress) GetIsAny() bool {

	cret := xInetAddressGetIsAny(x.GoPointer())
	return cret
}

var xInetAddressGetIsLinkLocal func(uintptr) bool

// Tests whether @address is a link-local address (that is, if it
// identifies a host on a local network that is not connected to the
// Internet).
func (x *InetAddress) GetIsLinkLocal() bool {

	cret := xInetAddressGetIsLinkLocal(x.GoPointer())
	return cret
}

var xInetAddressGetIsLoopback func(uintptr) bool

// Tests whether @address is the loopback address for its family.
func (x *InetAddress) GetIsLoopback() bool {

	cret := xInetAddressGetIsLoopback(x.GoPointer())
	return cret
}

var xInetAddressGetIsMcGlobal func(uintptr) bool

// Tests whether @address is a global multicast address.
func (x *InetAddress) GetIsMcGlobal() bool {

	cret := xInetAddressGetIsMcGlobal(x.GoPointer())
	return cret
}

var xInetAddressGetIsMcLinkLocal func(uintptr) bool

// Tests whether @address is a link-local multicast address.
func (x *InetAddress) GetIsMcLinkLocal() bool {

	cret := xInetAddressGetIsMcLinkLocal(x.GoPointer())
	return cret
}

var xInetAddressGetIsMcNodeLocal func(uintptr) bool

// Tests whether @address is a node-local multicast address.
func (x *InetAddress) GetIsMcNodeLocal() bool {

	cret := xInetAddressGetIsMcNodeLocal(x.GoPointer())
	return cret
}

var xInetAddressGetIsMcOrgLocal func(uintptr) bool

// Tests whether @address is an organization-local multicast address.
func (x *InetAddress) GetIsMcOrgLocal() bool {

	cret := xInetAddressGetIsMcOrgLocal(x.GoPointer())
	return cret
}

var xInetAddressGetIsMcSiteLocal func(uintptr) bool

// Tests whether @address is a site-local multicast address.
func (x *InetAddress) GetIsMcSiteLocal() bool {

	cret := xInetAddressGetIsMcSiteLocal(x.GoPointer())
	return cret
}

var xInetAddressGetIsMulticast func(uintptr) bool

// Tests whether @address is a multicast address.
func (x *InetAddress) GetIsMulticast() bool {

	cret := xInetAddressGetIsMulticast(x.GoPointer())
	return cret
}

var xInetAddressGetIsSiteLocal func(uintptr) bool

// Tests whether @address is a site-local address such as 10.0.0.1
// (that is, the address identifies a host on a local network that can
// not be reached directly from the Internet, but which may have
// outgoing Internet connectivity via a NAT or firewall).
func (x *InetAddress) GetIsSiteLocal() bool {

	cret := xInetAddressGetIsSiteLocal(x.GoPointer())
	return cret
}

var xInetAddressGetNativeSize func(uintptr) uint

// Gets the size of the native raw binary address for @address. This
// is the size of the data that you get from g_inet_address_to_bytes().
func (x *InetAddress) GetNativeSize() uint {

	cret := xInetAddressGetNativeSize(x.GoPointer())
	return cret
}

var xInetAddressToBytes func(uintptr) byte

// Gets the raw binary address data from @address.
func (x *InetAddress) ToBytes() byte {

	cret := xInetAddressToBytes(x.GoPointer())
	return cret
}

var xInetAddressToString func(uintptr) string

// Converts @address to string form.
func (x *InetAddress) ToString() string {

	cret := xInetAddressToString(x.GoPointer())
	return cret
}

func (c *InetAddress) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *InetAddress) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xInetAddressGLibType, libs, "g_inet_address_get_type")

	core.PuregoSafeRegister(&xNewInetAddressAny, libs, "g_inet_address_new_any")
	core.PuregoSafeRegister(&xNewInetAddressFromBytes, libs, "g_inet_address_new_from_bytes")
	core.PuregoSafeRegister(&xNewInetAddressFromString, libs, "g_inet_address_new_from_string")
	core.PuregoSafeRegister(&xNewInetAddressLoopback, libs, "g_inet_address_new_loopback")

	core.PuregoSafeRegister(&xInetAddressEqual, libs, "g_inet_address_equal")
	core.PuregoSafeRegister(&xInetAddressGetFamily, libs, "g_inet_address_get_family")
	core.PuregoSafeRegister(&xInetAddressGetIsAny, libs, "g_inet_address_get_is_any")
	core.PuregoSafeRegister(&xInetAddressGetIsLinkLocal, libs, "g_inet_address_get_is_link_local")
	core.PuregoSafeRegister(&xInetAddressGetIsLoopback, libs, "g_inet_address_get_is_loopback")
	core.PuregoSafeRegister(&xInetAddressGetIsMcGlobal, libs, "g_inet_address_get_is_mc_global")
	core.PuregoSafeRegister(&xInetAddressGetIsMcLinkLocal, libs, "g_inet_address_get_is_mc_link_local")
	core.PuregoSafeRegister(&xInetAddressGetIsMcNodeLocal, libs, "g_inet_address_get_is_mc_node_local")
	core.PuregoSafeRegister(&xInetAddressGetIsMcOrgLocal, libs, "g_inet_address_get_is_mc_org_local")
	core.PuregoSafeRegister(&xInetAddressGetIsMcSiteLocal, libs, "g_inet_address_get_is_mc_site_local")
	core.PuregoSafeRegister(&xInetAddressGetIsMulticast, libs, "g_inet_address_get_is_multicast")
	core.PuregoSafeRegister(&xInetAddressGetIsSiteLocal, libs, "g_inet_address_get_is_site_local")
	core.PuregoSafeRegister(&xInetAddressGetNativeSize, libs, "g_inet_address_get_native_size")
	core.PuregoSafeRegister(&xInetAddressToBytes, libs, "g_inet_address_to_bytes")
	core.PuregoSafeRegister(&xInetAddressToString, libs, "g_inet_address_to_string")

}
