// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A `GSimpleAction` is the obvious simple implementation of the
// [iface@Gio.Action] interface. This is the easiest way to create an action for
// purposes of adding it to a [class@Gio.SimpleActionGroup].
type SimpleAction struct {
	gobject.Object
}

var xSimpleActionGLibType func() types.GType

func SimpleActionGLibType() types.GType {
	return xSimpleActionGLibType()
}

func SimpleActionNewFromInternalPtr(ptr uintptr) *SimpleAction {
	cls := &SimpleAction{}
	cls.Ptr = ptr
	return cls
}

var xNewSimpleAction func(string, *glib.VariantType) uintptr

// Creates a new action.
//
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
func NewSimpleAction(NameVar string, ParameterTypeVar *glib.VariantType) *SimpleAction {
	var cls *SimpleAction

	cret := xNewSimpleAction(NameVar, ParameterTypeVar)

	if cret == 0 {
		return nil
	}
	cls = &SimpleAction{}
	cls.Ptr = cret
	return cls
}

var xNewSimpleActionStateful func(string, *glib.VariantType, *glib.Variant) uintptr

// Creates a new stateful action.
//
// All future state values must have the same #GVariantType as the initial
// @state.
//
// If the @state #GVariant is floating, it is consumed.
func NewSimpleActionStateful(NameVar string, ParameterTypeVar *glib.VariantType, StateVar *glib.Variant) *SimpleAction {
	var cls *SimpleAction

	cret := xNewSimpleActionStateful(NameVar, ParameterTypeVar, StateVar)

	if cret == 0 {
		return nil
	}
	cls = &SimpleAction{}
	cls.Ptr = cret
	return cls
}

var xSimpleActionSetEnabled func(uintptr, bool)

// Sets the action as enabled or not.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
//
// This should only be called by the implementor of the action.  Users
// of the action should not attempt to modify its enabled flag.
func (x *SimpleAction) SetEnabled(EnabledVar bool) {

	xSimpleActionSetEnabled(x.GoPointer(), EnabledVar)

}

var xSimpleActionSetState func(uintptr, *glib.Variant)

// Sets the state of the action.
//
// This directly updates the 'state' property to the given value.
//
// This should only be called by the implementor of the action.  Users
// of the action should not attempt to directly modify the 'state'
// property.  Instead, they should call g_action_change_state() to
// request the change.
//
// If the @value GVariant is floating, it is consumed.
func (x *SimpleAction) SetState(ValueVar *glib.Variant) {

	xSimpleActionSetState(x.GoPointer(), ValueVar)

}

var xSimpleActionSetStateHint func(uintptr, *glib.Variant)

// Sets the state hint for the action.
//
// See g_action_get_state_hint() for more information about
// action state hints.
func (x *SimpleAction) SetStateHint(StateHintVar *glib.Variant) {

	xSimpleActionSetStateHint(x.GoPointer(), StateHintVar)

}

func (c *SimpleAction) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *SimpleAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyEnabled sets the "enabled" property.
// If @action is currently enabled.
//
// If the action is disabled then calls to g_action_activate() and
// g_action_change_state() have no effect.
func (x *SimpleAction) SetPropertyEnabled(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("enabled", &v)
}

// GetPropertyEnabled gets the "enabled" property.
// If @action is currently enabled.
//
// If the action is disabled then calls to g_action_activate() and
// g_action_change_state() have no effect.
func (x *SimpleAction) GetPropertyEnabled() bool {
	var v gobject.Value
	x.GetProperty("enabled", &v)
	return v.GetBoolean()
}

// SetPropertyName sets the "name" property.
// The name of the action. This is mostly meaningful for identifying
// the action once it has been added to a #GSimpleActionGroup.
func (x *SimpleAction) SetPropertyName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("name", &v)
}

// GetPropertyName gets the "name" property.
// The name of the action. This is mostly meaningful for identifying
// the action once it has been added to a #GSimpleActionGroup.
func (x *SimpleAction) GetPropertyName() string {
	var v gobject.Value
	x.GetProperty("name", &v)
	return v.GetString()
}

// SetPropertyParameterType sets the "parameter-type" property.
// The type of the parameter that must be given when activating the
// action.
func (x *SimpleAction) SetPropertyParameterType(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("parameter-type", &v)
}

// GetPropertyParameterType gets the "parameter-type" property.
// The type of the parameter that must be given when activating the
// action.
func (x *SimpleAction) GetPropertyParameterType() uintptr {
	var v gobject.Value
	x.GetProperty("parameter-type", &v)
	return v.GetPointer()
}

// SetPropertyState sets the "state" property.
// The state of the action, or %NULL if the action is stateless.
func (x *SimpleAction) SetPropertyState(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("state", &v)
}

// GetPropertyState gets the "state" property.
// The state of the action, or %NULL if the action is stateless.
func (x *SimpleAction) GetPropertyState() uintptr {
	var v gobject.Value
	x.GetProperty("state", &v)
	return v.GetPointer()
}

// GetPropertyStateType gets the "state-type" property.
// The #GVariantType of the state that the action has, or %NULL if the
// action is stateless.
func (x *SimpleAction) GetPropertyStateType() uintptr {
	var v gobject.Value
	x.GetProperty("state-type", &v)
	return v.GetPointer()
}

// Indicates that the action was just activated.
//
// @parameter will always be of the expected type, i.e. the parameter type
// specified when the action was created. If an incorrect type is given when
// activating the action, this signal is not emitted.
//
// Since GLib 2.40, if no handler is connected to this signal then the
// default behaviour for boolean-stated actions with a %NULL parameter
// type is to toggle them via the #GSimpleAction::change-state signal.
// For stateful actions where the state type is equal to the parameter
// type, the default is to forward them directly to
// #GSimpleAction::change-state.  This should allow almost all users
// of #GSimpleAction to connect only one handler or the other.
func (x *SimpleAction) ConnectActivate(cb *func(SimpleAction, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ParameterVarp uintptr) {
		fa := SimpleAction{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ParameterVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// Indicates that the action just received a request to change its
// state.
//
// @value will always be of the correct state type, i.e. the type of the
// initial state passed to g_simple_action_new_stateful(). If an incorrect
// type is given when requesting to change the state, this signal is not
// emitted.
//
// If no handler is connected to this signal then the default
// behaviour is to call g_simple_action_set_state() to set the state
// to the requested value. If you connect a signal handler then no
// default action is taken. If the state should change then you must
// call g_simple_action_set_state() from the handler.
//
// An example of a 'change-state' handler:
// |[&lt;!-- language="C" --&gt;
// static void
// change_volume_state (GSimpleAction *action,
//
//	GVariant      *value,
//	gpointer       user_data)
//
//	{
//	  gint requested;
//
//	  requested = g_variant_get_int32 (value);
//
//	  // Volume only goes from 0 to 10
//	  if (0 &lt;= requested &amp;&amp; requested &lt;= 10)
//	    g_simple_action_set_state (action, value);
//	}
//
// ]|
//
// The handler need not set the state to the requested value.
// It could set it to any value at all, or take some other action.
func (x *SimpleAction) ConnectChangeState(cb *func(SimpleAction, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "change-state", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ValueVarp uintptr) {
		fa := SimpleAction{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ValueVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "change-state", cbRefPtr)
}

// Activates the action.
//
// @parameter must be the correct type of parameter for the action (ie:
// the parameter type given at construction time).  If the parameter
// type was `NULL` then @parameter must also be `NULL`.
//
// If the @parameter [type@GLib.Variant] is floating, it is consumed.
func (x *SimpleAction) Activate(ParameterVar *glib.Variant) {

	XGActionActivate(x.GoPointer(), ParameterVar)

}

// Request for the state of @action to be changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See [method@Gio.Action.get_state_type].
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See [method@Gio.Action.get_state_hint].
//
// If the @value [type@GLib.Variant] is floating, it is consumed.
func (x *SimpleAction) ChangeState(ValueVar *glib.Variant) {

	XGActionChangeState(x.GoPointer(), ValueVar)

}

// Checks if @action is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *SimpleAction) GetEnabled() bool {

	cret := XGActionGetEnabled(x.GoPointer())

	return cret
}

// Queries the name of @action.
func (x *SimpleAction) GetName() string {

	cret := XGActionGetName(x.GoPointer())

	return cret
}

// Queries the type of the parameter that must be given when activating
// @action.
//
// When activating the action using [method@Gio.Action.activate], the
// [type@GLib.Variant] given to that function must be of the type returned by
// this function.
//
// In the case that this function returns `NULL`, you must not give any
// [type@GLib.Variant], but `NULL` instead.
func (x *SimpleAction) GetParameterType() *glib.VariantType {

	cret := XGActionGetParameterType(x.GoPointer())

	return cret
}

// Queries the current state of @action.
//
// If the action is not stateful then `NULL` will be returned.  If the
// action is stateful then the type of the return value is the type
// given by [method@Gio.Action.get_state_type].
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *SimpleAction) GetState() *glib.Variant {

	cret := XGActionGetState(x.GoPointer())

	return cret
}

// Requests a hint about the valid range of values for the state of
// @action.
//
// If `NULL` is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a [type@GLib.Variant] array is returned then each item in the array is a
// possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *SimpleAction) GetStateHint() *glib.Variant {

	cret := XGActionGetStateHint(x.GoPointer())

	return cret
}

// Queries the type of the state of @action.
//
// If the action is stateful (e.g. created with
// [ctor@Gio.SimpleAction.new_stateful]) then this function returns the
// [type@GLib.VariantType] of the state.  This is the type of the initial value
// given as the state. All calls to [method@Gio.Action.change_state] must give a
// [type@GLib.Variant] of this type and [method@Gio.Action.get_state] will return a
// [type@GLib.Variant] of the same type.
//
// If the action is not stateful (e.g. created with [ctor@Gio.SimpleAction.new])
// then this function will return `NULL`. In that case, [method@Gio.Action.get_state]
// will return `NULL` and you must not call [method@Gio.Action.change_state].
func (x *SimpleAction) GetStateType() *glib.VariantType {

	cret := XGActionGetStateType(x.GoPointer())

	return cret
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSimpleActionGLibType, libs, "g_simple_action_get_type")

	core.PuregoSafeRegister(&xNewSimpleAction, libs, "g_simple_action_new")
	core.PuregoSafeRegister(&xNewSimpleActionStateful, libs, "g_simple_action_new_stateful")

	core.PuregoSafeRegister(&xSimpleActionSetEnabled, libs, "g_simple_action_set_enabled")
	core.PuregoSafeRegister(&xSimpleActionSetState, libs, "g_simple_action_set_state")
	core.PuregoSafeRegister(&xSimpleActionSetStateHint, libs, "g_simple_action_set_state_hint")

}
