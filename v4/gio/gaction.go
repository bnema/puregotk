// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The virtual function table for [type@Gio.Action].
type ActionInterface struct {
	_ structs.HostLayout

	GIface uintptr

	xGetName uintptr

	xGetParameterType uintptr

	xGetStateType uintptr

	xGetStateHint uintptr

	xGetEnabled uintptr

	xGetState uintptr

	xChangeState uintptr

	xActivate uintptr
}

func (x *ActionInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetName sets the callback function.
// the virtual function pointer for [method@Gio.Action.get_name]
func (x *ActionInterface) OverrideGetName(cb func(Action) string) {
	if cb == nil {
		x.xGetName = 0
	} else {
		x.xGetName = purego.NewCallback(func(ActionVarp uintptr) string {
			return cb(&ActionBase{Ptr: ActionVarp})
		})
	}
}

// GetGetName gets the callback function.
// the virtual function pointer for [method@Gio.Action.get_name]
func (x *ActionInterface) GetGetName() func(Action) string {
	if x.xGetName == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetName)
	return func(ActionVar Action) string {
		return rawCallback(ActionVar.GoPointer())
	}
}

// OverrideGetParameterType sets the callback function.
// the virtual function pointer for [method@Gio.Action.get_parameter_type]
func (x *ActionInterface) OverrideGetParameterType(cb func(Action) *glib.VariantType) {
	if cb == nil {
		x.xGetParameterType = 0
	} else {
		x.xGetParameterType = purego.NewCallback(func(ActionVarp uintptr) *glib.VariantType {
			return cb(&ActionBase{Ptr: ActionVarp})
		})
	}
}

// GetGetParameterType gets the callback function.
// the virtual function pointer for [method@Gio.Action.get_parameter_type]
func (x *ActionInterface) GetGetParameterType() func(Action) *glib.VariantType {
	if x.xGetParameterType == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr) *glib.VariantType
	purego.RegisterFunc(&rawCallback, x.xGetParameterType)
	return func(ActionVar Action) *glib.VariantType {
		return rawCallback(ActionVar.GoPointer())
	}
}

// OverrideGetStateType sets the callback function.
// the virtual function pointer for [method@Gio.Action.get_state_type]
func (x *ActionInterface) OverrideGetStateType(cb func(Action) *glib.VariantType) {
	if cb == nil {
		x.xGetStateType = 0
	} else {
		x.xGetStateType = purego.NewCallback(func(ActionVarp uintptr) *glib.VariantType {
			return cb(&ActionBase{Ptr: ActionVarp})
		})
	}
}

// GetGetStateType gets the callback function.
// the virtual function pointer for [method@Gio.Action.get_state_type]
func (x *ActionInterface) GetGetStateType() func(Action) *glib.VariantType {
	if x.xGetStateType == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr) *glib.VariantType
	purego.RegisterFunc(&rawCallback, x.xGetStateType)
	return func(ActionVar Action) *glib.VariantType {
		return rawCallback(ActionVar.GoPointer())
	}
}

// OverrideGetStateHint sets the callback function.
// the virtual function pointer for [method@Gio.Action.get_state_hint]
func (x *ActionInterface) OverrideGetStateHint(cb func(Action) *glib.Variant) {
	if cb == nil {
		x.xGetStateHint = 0
	} else {
		x.xGetStateHint = purego.NewCallback(func(ActionVarp uintptr) *glib.Variant {
			return cb(&ActionBase{Ptr: ActionVarp})
		})
	}
}

// GetGetStateHint gets the callback function.
// the virtual function pointer for [method@Gio.Action.get_state_hint]
func (x *ActionInterface) GetGetStateHint() func(Action) *glib.Variant {
	if x.xGetStateHint == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr) *glib.Variant
	purego.RegisterFunc(&rawCallback, x.xGetStateHint)
	return func(ActionVar Action) *glib.Variant {
		return rawCallback(ActionVar.GoPointer())
	}
}

// OverrideGetEnabled sets the callback function.
// the virtual function pointer for [method@Gio.Action.get_enabled]
func (x *ActionInterface) OverrideGetEnabled(cb func(Action) bool) {
	if cb == nil {
		x.xGetEnabled = 0
	} else {
		x.xGetEnabled = purego.NewCallback(func(ActionVarp uintptr) bool {
			return cb(&ActionBase{Ptr: ActionVarp})
		})
	}
}

// GetGetEnabled gets the callback function.
// the virtual function pointer for [method@Gio.Action.get_enabled]
func (x *ActionInterface) GetGetEnabled() func(Action) bool {
	if x.xGetEnabled == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xGetEnabled)
	return func(ActionVar Action) bool {
		return rawCallback(ActionVar.GoPointer())
	}
}

// OverrideGetState sets the callback function.
// the virtual function pointer for [method@Gio.Action.get_state]
func (x *ActionInterface) OverrideGetState(cb func(Action) *glib.Variant) {
	if cb == nil {
		x.xGetState = 0
	} else {
		x.xGetState = purego.NewCallback(func(ActionVarp uintptr) *glib.Variant {
			return cb(&ActionBase{Ptr: ActionVarp})
		})
	}
}

// GetGetState gets the callback function.
// the virtual function pointer for [method@Gio.Action.get_state]
func (x *ActionInterface) GetGetState() func(Action) *glib.Variant {
	if x.xGetState == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr) *glib.Variant
	purego.RegisterFunc(&rawCallback, x.xGetState)
	return func(ActionVar Action) *glib.Variant {
		return rawCallback(ActionVar.GoPointer())
	}
}

// OverrideChangeState sets the callback function.
// the virtual function pointer for [method@Gio.Action.change_state]
func (x *ActionInterface) OverrideChangeState(cb func(Action, *glib.Variant)) {
	if cb == nil {
		x.xChangeState = 0
	} else {
		x.xChangeState = purego.NewCallback(func(ActionVarp uintptr, ValueVarp *glib.Variant) {
			cb(&ActionBase{Ptr: ActionVarp}, ValueVarp)
		})
	}
}

// GetChangeState gets the callback function.
// the virtual function pointer for [method@Gio.Action.change_state]
func (x *ActionInterface) GetChangeState() func(Action, *glib.Variant) {
	if x.xChangeState == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr, ValueVarp *glib.Variant)
	purego.RegisterFunc(&rawCallback, x.xChangeState)
	return func(ActionVar Action, ValueVar *glib.Variant) {
		rawCallback(ActionVar.GoPointer(), ValueVar)
	}
}

// OverrideActivate sets the callback function.
// the virtual function pointer for [method@Gio.Action.activate].  Note that [type@Gio.Action] does not have an
//
//	'activate' signal but that implementations of it may have one.
func (x *ActionInterface) OverrideActivate(cb func(Action, *glib.Variant)) {
	if cb == nil {
		x.xActivate = 0
	} else {
		x.xActivate = purego.NewCallback(func(ActionVarp uintptr, ParameterVarp *glib.Variant) {
			cb(&ActionBase{Ptr: ActionVarp}, ParameterVarp)
		})
	}
}

// GetActivate gets the callback function.
// the virtual function pointer for [method@Gio.Action.activate].  Note that [type@Gio.Action] does not have an
//
//	'activate' signal but that implementations of it may have one.
func (x *ActionInterface) GetActivate() func(Action, *glib.Variant) {
	if x.xActivate == 0 {
		return nil
	}
	var rawCallback func(ActionVarp uintptr, ParameterVarp *glib.Variant)
	purego.RegisterFunc(&rawCallback, x.xActivate)
	return func(ActionVar Action, ParameterVar *glib.Variant) {
		rawCallback(ActionVar.GoPointer(), ParameterVar)
	}
}

// `GAction` represents a single named action.
//
// The main interface to an action is that it can be activated with
// [method@Gio.Action.activate]. This results in the 'activate' signal being
// emitted. An activation has a `GVariant` parameter (which may be
// `NULL`). The correct type for the parameter is determined by a static
// parameter type (which is given at construction time).
//
// An action may optionally have a state, in which case the state may be
// set with [method@Gio.Action.change_state]. This call takes a [type@GLib.Variant]. The
// correct type for the state is determined by a static state type
// (which is given at construction time).
//
// The state may have a hint associated with it, specifying its valid
// range.
//
// `GAction` is merely the interface to the concept of an action, as
// described above.  Various implementations of actions exist, including
// [class@Gio.SimpleAction].
//
// In all cases, the implementing class is responsible for storing the
// name of the action, the parameter type, the enabled state, the optional
// state type and the state and emitting the appropriate signals when these
// change. The implementor is responsible for filtering calls to
// [method@Gio.Action.activate] and [method@Gio.Action.change_state]
// for type safety and for the state being enabled.
//
// Probably the only useful thing to do with a `GAction` is to put it
// inside of a [class@Gio.SimpleActionGroup].
type Action interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	Activate(ParameterVar *glib.Variant)
	ChangeState(ValueVar *glib.Variant)
	GetEnabled() bool
	GetName() string
	GetParameterType() *glib.VariantType
	GetState() *glib.Variant
	GetStateHint() *glib.Variant
	GetStateType() *glib.VariantType
}

var xActionGLibType func() types.GType

func ActionGLibType() types.GType {
	return xActionGLibType()
}

type ActionBase struct {
	Ptr uintptr
}

func (x *ActionBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *ActionBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Activates the action.
//
// @parameter must be the correct type of parameter for the action (ie:
// the parameter type given at construction time).  If the parameter
// type was `NULL` then @parameter must also be `NULL`.
//
// If the @parameter [type@GLib.Variant] is floating, it is consumed.
func (x *ActionBase) Activate(ParameterVar *glib.Variant) {

	XGActionActivate(x.GoPointer(), ParameterVar)

}

// Request for the state of @action to be changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See [method@Gio.Action.get_state_type].
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See [method@Gio.Action.get_state_hint].
//
// If the @value [type@GLib.Variant] is floating, it is consumed.
func (x *ActionBase) ChangeState(ValueVar *glib.Variant) {

	XGActionChangeState(x.GoPointer(), ValueVar)

}

// Checks if @action is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *ActionBase) GetEnabled() bool {

	cret := XGActionGetEnabled(x.GoPointer())
	return cret
}

// Queries the name of @action.
func (x *ActionBase) GetName() string {

	cret := XGActionGetName(x.GoPointer())
	return cret
}

// Queries the type of the parameter that must be given when activating
// @action.
//
// When activating the action using [method@Gio.Action.activate], the
// [type@GLib.Variant] given to that function must be of the type returned by
// this function.
//
// In the case that this function returns `NULL`, you must not give any
// [type@GLib.Variant], but `NULL` instead.
func (x *ActionBase) GetParameterType() *glib.VariantType {

	cret := XGActionGetParameterType(x.GoPointer())
	return cret
}

// Queries the current state of @action.
//
// If the action is not stateful then `NULL` will be returned.  If the
// action is stateful then the type of the return value is the type
// given by [method@Gio.Action.get_state_type].
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *ActionBase) GetState() *glib.Variant {

	cret := XGActionGetState(x.GoPointer())
	return cret
}

// Requests a hint about the valid range of values for the state of
// @action.
//
// If `NULL` is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a [type@GLib.Variant] array is returned then each item in the array is a
// possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *ActionBase) GetStateHint() *glib.Variant {

	cret := XGActionGetStateHint(x.GoPointer())
	return cret
}

// Queries the type of the state of @action.
//
// If the action is stateful (e.g. created with
// [ctor@Gio.SimpleAction.new_stateful]) then this function returns the
// [type@GLib.VariantType] of the state.  This is the type of the initial value
// given as the state. All calls to [method@Gio.Action.change_state] must give a
// [type@GLib.Variant] of this type and [method@Gio.Action.get_state] will return a
// [type@GLib.Variant] of the same type.
//
// If the action is not stateful (e.g. created with [ctor@Gio.SimpleAction.new])
// then this function will return `NULL`. In that case, [method@Gio.Action.get_state]
// will return `NULL` and you must not call [method@Gio.Action.change_state].
func (x *ActionBase) GetStateType() *glib.VariantType {

	cret := XGActionGetStateType(x.GoPointer())
	return cret
}

var XGActionActivate func(uintptr, *glib.Variant)
var XGActionChangeState func(uintptr, *glib.Variant)
var XGActionGetEnabled func(uintptr) bool
var XGActionGetName func(uintptr) string
var XGActionGetParameterType func(uintptr) *glib.VariantType
var XGActionGetState func(uintptr) *glib.Variant
var XGActionGetStateHint func(uintptr) *glib.Variant
var XGActionGetStateType func(uintptr) *glib.VariantType

var xActionNameIsValid func(string) bool

// Checks if @action_name is valid.
//
// @action_name is valid if it consists only of alphanumeric characters,
// plus `-` and `.`.  The empty string is not a valid action name.
//
// It is an error to call this function with a non-UTF-8 @action_name.
// @action_name must not be `NULL`.
func ActionNameIsValid(ActionNameVar string) bool {

	cret := xActionNameIsValid(ActionNameVar)
	return cret
}

var xActionParseDetailedName func(string, string, **glib.Variant, **glib.Error) bool

// Parses a detailed action name into its separate name and target
// components.
//
// Detailed action names can have three formats.
//
// The first format is used to represent an action name with no target
// value and consists of just an action name containing no whitespace
// nor the characters `:`, `(` or `)`.  For example: `app.action`.
//
// The second format is used to represent an action with a target value
// that is a non-empty string consisting only of alphanumerics, plus `-`
// and `.`.  In that case, the action name and target value are
// separated by a double colon (`::`).  For example:
// `app.action::target`.
//
// The third format is used to represent an action with any type of
// target value, including strings.  The target value follows the action
// name, surrounded in parens.  For example: `app.action(42)`.  The
// target value is parsed using [func@GLib.Variant.parse].  If a tuple-typed
// value is desired, it must be specified in the same way, resulting in
// two sets of parens, for example: `app.action((1,2,3))`.  A string
// target can be specified this way as well: `app.action('target')`.
// For strings, this third format must be used if target value is
// empty or contains characters other than alphanumerics, `-` and `.`.
//
// If this function returns `TRUE`, a non-`NULL` value is guaranteed to be returned
// in @action_name (if a pointer is passed in). A `NULL` value may still be
// returned in @target_value, as the @detailed_name may not contain a target.
//
// If returned, the [type@GLib.Variant] in @target_value is guaranteed to not be floating.
func ActionParseDetailedName(DetailedNameVar string, ActionNameVar string, TargetValueVar **glib.Variant) (bool, error) {
	var cerr *glib.Error

	cret := xActionParseDetailedName(DetailedNameVar, ActionNameVar, TargetValueVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xActionPrintDetailedName func(string, *glib.Variant) string

// Formats a detailed action name from @action_name and @target_value.
//
// It is an error to call this function with an invalid action name.
//
// This function is the opposite of [func@Gio.Action.parse_detailed_name].
// It will produce a string that can be parsed back to the @action_name
// and @target_value by that function.
//
// See that function for the types of strings that will be printed by
// this function.
func ActionPrintDetailedName(ActionNameVar string, TargetValueVar *glib.Variant) string {

	cret := xActionPrintDetailedName(ActionNameVar, TargetValueVar)
	return cret
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xActionNameIsValid, libs, "g_action_name_is_valid")
	core.PuregoSafeRegister(&xActionParseDetailedName, libs, "g_action_parse_detailed_name")
	core.PuregoSafeRegister(&xActionPrintDetailedName, libs, "g_action_print_detailed_name")

	core.PuregoSafeRegister(&xActionGLibType, libs, "g_action_get_type")

	core.PuregoSafeRegister(&XGActionActivate, libs, "g_action_activate")
	core.PuregoSafeRegister(&XGActionChangeState, libs, "g_action_change_state")
	core.PuregoSafeRegister(&XGActionGetEnabled, libs, "g_action_get_enabled")
	core.PuregoSafeRegister(&XGActionGetName, libs, "g_action_get_name")
	core.PuregoSafeRegister(&XGActionGetParameterType, libs, "g_action_get_parameter_type")
	core.PuregoSafeRegister(&XGActionGetState, libs, "g_action_get_state")
	core.PuregoSafeRegister(&XGActionGetStateHint, libs, "g_action_get_state_hint")
	core.PuregoSafeRegister(&XGActionGetStateType, libs, "g_action_get_state_type")

}
