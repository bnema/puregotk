// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"fmt"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The type for the function that is used to convert from [class@Gio.Settings]
// to an object property.
//
// The @value is already initialized to hold values of the appropriate type.
type SettingsBindGetMapping func(*gobject.Value, *glib.Variant, uintptr) bool

// The type for the function that is used to convert an object property
// value to a [struct@GLib.Variant] for storing it in [class@Gio.Settings].
type SettingsBindSetMapping func(*gobject.Value, *glib.VariantType, uintptr) *glib.Variant

// The type of the function that is used to convert from a value stored
// in a [class@Gio.Settings] to a value that is useful to the application.
//
// If the value is successfully mapped, the result should be stored at
// @result and true returned.  If mapping fails (for example, if @value
// is not in the right format) then false should be returned.
//
// If @value is `NULL` then it means that the mapping function is being
// given a ‘last chance’ to successfully return a valid value.  True
// must be returned in this case.
type SettingsGetMapping func(*glib.Variant, *uintptr, uintptr) bool

type SettingsClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xWritableChanged uintptr

	xChanged uintptr

	xWritableChangeEvent uintptr

	xChangeEvent uintptr

	Padding [20]uintptr
}

func (x *SettingsClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideWritableChanged sets the "writable_changed" callback function.
func (x *SettingsClass) OverrideWritableChanged(cb func(*Settings, string)) {
	if cb == nil {
		x.xWritableChanged = 0
	} else {
		x.xWritableChanged = purego.NewCallback(func(SettingsVarp uintptr, KeyVarp string) {
			cb(SettingsNewFromInternalPtr(SettingsVarp), KeyVarp)
		})
	}
}

// GetWritableChanged gets the "writable_changed" callback function.
func (x *SettingsClass) GetWritableChanged() func(*Settings, string) {
	if x.xWritableChanged == 0 {
		return nil
	}
	var rawCallback func(SettingsVarp uintptr, KeyVarp string)
	purego.RegisterFunc(&rawCallback, x.xWritableChanged)
	return func(SettingsVar *Settings, KeyVar string) {
		rawCallback(SettingsVar.GoPointer(), KeyVar)
	}
}

// OverrideChanged sets the "changed" callback function.
func (x *SettingsClass) OverrideChanged(cb func(*Settings, string)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(SettingsVarp uintptr, KeyVarp string) {
			cb(SettingsNewFromInternalPtr(SettingsVarp), KeyVarp)
		})
	}
}

// GetChanged gets the "changed" callback function.
func (x *SettingsClass) GetChanged() func(*Settings, string) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(SettingsVarp uintptr, KeyVarp string)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(SettingsVar *Settings, KeyVar string) {
		rawCallback(SettingsVar.GoPointer(), KeyVar)
	}
}

// OverrideWritableChangeEvent sets the "writable_change_event" callback function.
func (x *SettingsClass) OverrideWritableChangeEvent(cb func(*Settings, glib.Quark) bool) {
	if cb == nil {
		x.xWritableChangeEvent = 0
	} else {
		x.xWritableChangeEvent = purego.NewCallback(func(SettingsVarp uintptr, KeyVarp glib.Quark) bool {
			return cb(SettingsNewFromInternalPtr(SettingsVarp), KeyVarp)
		})
	}
}

// GetWritableChangeEvent gets the "writable_change_event" callback function.
func (x *SettingsClass) GetWritableChangeEvent() func(*Settings, glib.Quark) bool {
	if x.xWritableChangeEvent == 0 {
		return nil
	}
	var rawCallback func(SettingsVarp uintptr, KeyVarp glib.Quark) bool
	purego.RegisterFunc(&rawCallback, x.xWritableChangeEvent)
	return func(SettingsVar *Settings, KeyVar glib.Quark) bool {
		return rawCallback(SettingsVar.GoPointer(), KeyVar)
	}
}

// OverrideChangeEvent sets the "change_event" callback function.
func (x *SettingsClass) OverrideChangeEvent(cb func(*Settings, *glib.Quark, int) bool) {
	if cb == nil {
		x.xChangeEvent = 0
	} else {
		x.xChangeEvent = purego.NewCallback(func(SettingsVarp uintptr, KeysVarp *glib.Quark, NKeysVarp int) bool {
			return cb(SettingsNewFromInternalPtr(SettingsVarp), KeysVarp, NKeysVarp)
		})
	}
}

// GetChangeEvent gets the "change_event" callback function.
func (x *SettingsClass) GetChangeEvent() func(*Settings, *glib.Quark, int) bool {
	if x.xChangeEvent == 0 {
		return nil
	}
	var rawCallback func(SettingsVarp uintptr, KeysVarp *glib.Quark, NKeysVarp int) bool
	purego.RegisterFunc(&rawCallback, x.xChangeEvent)
	return func(SettingsVar *Settings, KeysVar *glib.Quark, NKeysVar int) bool {
		return rawCallback(SettingsVar.GoPointer(), KeysVar, NKeysVar)
	}
}

type SettingsPrivate struct {
	_ structs.HostLayout
}

func (x *SettingsPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Flags used when creating a binding.
//
// These flags determine in which direction the binding works. The default is to
// synchronize in both directions.
type SettingsBindFlags int

var xSettingsBindFlagsGLibType func() types.GType

func SettingsBindFlagsGLibType() types.GType {
	return xSettingsBindFlagsGLibType()
}

const (

	// Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	GSettingsBindDefaultValue SettingsBindFlags = 0
	// Update the [class@GObject.Object] property when the setting changes.
	//   It is an error to use this flag if the property is not writable.
	GSettingsBindGetValue SettingsBindFlags = 1
	// Update the setting when the [class@GObject.Object] property changes.
	//   It is an error to use this flag if the property is not readable.
	GSettingsBindSetValue SettingsBindFlags = 2
	// Do not try to bind a ‘sensitivity’ property to the writability of the setting
	GSettingsBindNoSensitivityValue SettingsBindFlags = 4
	// When set in addition to [flags@Gio.SettingsBindFlags.GET],
	//   set the [class@GObject.Object] property
	//   value initially from the setting, but do not listen for changes of the setting
	GSettingsBindGetNoChangesValue SettingsBindFlags = 8
	// When passed to [method@Gio.Settings.bind],
	//   uses a pair of mapping functions that invert
	//   the boolean value when mapping between the setting and the property.  The setting and property must both
	//   be booleans.  You cannot pass this flag to [method@Gio.Settings.bind_with_mapping].
	GSettingsBindInvertBooleanValue SettingsBindFlags = 16
)

// The `GSettings` class provides a convenient API for storing and retrieving
// application settings.
//
// Reads and writes can be considered to be non-blocking.  Reading
// settings with `GSettings` is typically extremely fast: on
// approximately the same order of magnitude (but slower than) a
// [struct@GLib.HashTable] lookup.  Writing settings is also extremely fast in
// terms of time to return to your application, but can be extremely expensive
// for other threads and other processes.  Many settings backends
// (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings
// a lot of work can be avoided.  For dconf, the D-Bus service doesn’t
// even need to be started in this case.  For this reason, you should
// only ever modify `GSettings` keys in response to explicit user action.
// Particular care should be paid to ensure that modifications are not
// made during startup — for example, when setting the initial value
// of preferences widgets.  The built-in [method@Gio.Settings.bind]
// functionality is careful not to write settings in response to notify signals
// as a result of modifications that it makes to widgets.
//
// When creating a `GSettings` instance, you have to specify a schema
// that describes the keys in your settings and their types and default
// values, as well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings
// are stored in the conceptual global tree of settings. However, schemas
// can also be ‘[relocatable](#relocatable-schemas)’, i.e. not equipped with
// a fixed path. This is
// useful e.g. when the schema describes an ‘account’, and you want to be
// able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character (`/`)
// and must not contain two sequential slash characters.  Paths should
// be chosen based on a domain name associated with the program or
// library to which the settings belong.  Examples of paths are
// `/org/gtk/settings/file-chooser/` and `/ca/desrt/dconf-editor/`.
// Paths should not start with `/apps/`, `/desktop/` or `/system/` as
// they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not
// restrict keys to basic types like strings and numbers. GSettings stores
// values as [struct@GLib.Variant], and allows any [type@GLib.VariantType] for
// keys. Key names are restricted to lowercase characters, numbers and `-`.
// Furthermore, the names must begin with a lowercase character, must not end
// with a `-`, and must not contain consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be
// localized, but the localized values are stored in gettext catalogs
// and looked up with the domain that is specified in the
// `gettext-domain` attribute of the `&lt;schemalist&gt;` or `&lt;schema&gt;`
// elements and the category that is specified in the `l10n` attribute of
// the `&lt;default&gt;` element. The string which is translated includes all text in
// the `&lt;default&gt;` element, including any surrounding quotation marks.
//
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the `&lt;default&gt;` element — it is recommended to
// add these comments to aid translators understand the meaning and
// implications of the default value. An optional translation `context`
// attribute can be set on the `&lt;default&gt;` element to disambiguate multiple
// defaults which use the same string.
//
// For example:
// ```xml
//
//	&lt;!-- Translators: A list of words which are not allowed to be typed, in
//	     GVariant serialization syntax.
//	     See: https://developer.gnome.org/glib/stable/gvariant-text.html --&gt;
//	&lt;default l10n='messages' context='Banned words'&gt;['bad', 'words']&lt;/default&gt;
//
// ```
//
// Translations of default values must remain syntactically valid serialized
// [struct@GLib.Variant]s (e.g. retaining any surrounding quotation marks) or
// runtime errors will occur.
//
// GSettings uses schemas in a compact binary form that is created
// by the [`glib-compile-schemas`](glib-compile-schemas.html)
// utility. The input is a schema description in an XML format.
//
// A DTD for the gschema XML format can be found here:
// [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
//
// The [`glib-compile-schemas`](glib-compile-schemas.html) tool expects schema
// files to have the extension `.gschema.xml`.
//
// At runtime, schemas are identified by their ID (as specified in the
// `id` attribute of the `&lt;schema&gt;` element). The convention for schema
// IDs is to use a dotted name, similar in style to a D-Bus bus name,
// e.g. `org.gnome.SessionManager`. In particular, if the settings are
// for a specific service that owns a D-Bus bus name, the D-Bus bus name
// and schema ID should match. For schemas which deal with settings not
// associated with one named application, the ID should not use
// StudlyCaps, e.g. `org.gnome.font-rendering`.
//
// In addition to [struct@GLib.Variant] types, keys can have types that have
// enumerated types. These can be described by a `&lt;choice&gt;`,
// `&lt;enum&gt;` or `&lt;flags&gt;` element, as seen in the
// second example below. The underlying type of such a key
// is string, but you can use [method@Gio.Settings.get_enum],
// [method@Gio.Settings.set_enum], [method@Gio.Settings.get_flags],
// [method@Gio.Settings.set_flags] access the numeric values corresponding to
// the string value of enum and flags keys.
//
// An example for default value:
// ```xml
// &lt;schemalist&gt;
//
//	&lt;schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test"&gt;
//
//	  &lt;key name="greeting" type="s"&gt;
//	    &lt;default l10n="messages"&gt;"Hello, earthlings"&lt;/default&gt;
//	    &lt;summary&gt;A greeting&lt;/summary&gt;
//	    &lt;description&gt;
//	      Greeting of the invading martians
//	    &lt;/description&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name="box" type="(ii)"&gt;
//	    &lt;default&gt;(20,30)&lt;/default&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name="empty-string" type="s"&gt;
//	    &lt;default&gt;""&lt;/default&gt;
//	    &lt;summary&gt;Empty strings have to be provided in GVariant form&lt;/summary&gt;
//	  &lt;/key&gt;
//
//	&lt;/schema&gt;
//
// &lt;/schemalist&gt;
// ```
//
// An example for ranges, choices and enumerated types:
// ```xml
// &lt;schemalist&gt;
//
//	&lt;enum id="org.gtk.Test.myenum"&gt;
//	  &lt;value nick="first" value="1"/&gt;
//	  &lt;value nick="second" value="2"/&gt;
//	&lt;/enum&gt;
//
//	&lt;flags id="org.gtk.Test.myflags"&gt;
//	  &lt;value nick="flag1" value="1"/&gt;
//	  &lt;value nick="flag2" value="2"/&gt;
//	  &lt;value nick="flag3" value="4"/&gt;
//	&lt;/flags&gt;
//
//	&lt;schema id="org.gtk.Test"&gt;
//
//	  &lt;key name="key-with-range" type="i"&gt;
//	    &lt;range min="1" max="100"/&gt;
//	    &lt;default&gt;10&lt;/default&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name="key-with-choices" type="s"&gt;
//	    &lt;choices&gt;
//	      &lt;choice value='Elisabeth'/&gt;
//	      &lt;choice value='Annabeth'/&gt;
//	      &lt;choice value='Joe'/&gt;
//	    &lt;/choices&gt;
//	    &lt;aliases&gt;
//	      &lt;alias value='Anna' target='Annabeth'/&gt;
//	      &lt;alias value='Beth' target='Elisabeth'/&gt;
//	    &lt;/aliases&gt;
//	    &lt;default&gt;'Joe'&lt;/default&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name='enumerated-key' enum='org.gtk.Test.myenum'&gt;
//	    &lt;default&gt;'first'&lt;/default&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name='flags-key' flags='org.gtk.Test.myflags'&gt;
//	    &lt;default&gt;["flag1","flag2"]&lt;/default&gt;
//	  &lt;/key&gt;
//	&lt;/schema&gt;
//
// &lt;/schemalist&gt;
// ```
//
// ## Vendor overrides
//
// Default values are defined in the schemas that get installed by
// an application. Sometimes, it is necessary for a vendor or distributor
// to adjust these defaults. Since patching the XML source for the schema
// is inconvenient and error-prone,
// [`glib-compile-schemas`](glib-compile-schemas.html) reads so-called ‘vendor
// override’ files. These are keyfiles in the same directory as the XML
// schema sources which can override default values. The schema ID serves
// as the group name in the key file, and the values are expected in
// serialized [struct@GLib.Variant] form, as in the following example:
// ```
// [org.gtk.Example]
// key1='string'
// key2=1.5
// ```
//
// `glib-compile-schemas` expects schema files to have the extension
// `.gschema.override`.
//
// ## Delay-apply mode
//
// By default, values set on a [class@Gio.Settings] instance immediately start
// to be written to the backend (although these writes may not complete by the
// time that [method@Gio.Settings.set]) returns; see [func@Gio.Settings.sync]).
//
// In order to allow groups of settings to be changed simultaneously and
// atomically, GSettings also supports a ‘delay-apply’ mode. In this mode,
// updated values are kept locally in the [class@Gio.Settings] instance until
// they are explicitly applied by calling [method@Gio.Settings.apply].
//
// For example, this could be useful for a preferences dialog where the
// preferences all need to be applied simultaneously when the user clicks ‘Save’.
//
// Switching a [class@Gio.Settings] instance to ‘delay-apply’ mode is a one-time
// irreversible operation: from that point onwards, *all* changes made to that
// [class@Gio.Settings] have to be explicitly applied by calling
// [method@Gio.Settings.apply]. The ‘delay-apply’ mode is also propagated to any
// child settings objects subsequently created using
// [method@Gio.Settings.get_child].
//
// At any point, the set of unapplied changes can be queried using
// [property@Gio.Settings:has-unapplied], and discarded by calling
// [method@Gio.Settings.revert].
//
// ## Binding
//
// A very convenient feature of GSettings lets you bind [class@GObject.Object]
// properties directly to settings, using [method@Gio.Settings.bind]. Once a
// [class@GObject.Object] property has been bound to a setting, changes on
// either side are automatically propagated to the other side. GSettings handles
// details like mapping between [class@GObject.Object] and [struct@GLib.Variant]
// types, and preventing infinite cycles.
//
// This makes it very easy to hook up a preferences dialog to the
// underlying settings. To make this even more convenient, GSettings
// looks for a boolean property with the name `sensitivity` and
// automatically binds it to the writability of the bound setting.
// If this ‘magic’ gets in the way, it can be suppressed with the
// `G_SETTINGS_BIND_NO_SENSITIVITY` flag.
//
// ## Relocatable schemas
//
// A relocatable schema is one with no `path` attribute specified on its
// `&lt;schema&gt;` element. By using [ctor@Gio.Settings.new_with_path], a `GSettings`
// object can be instantiated for a relocatable schema, assigning a path to the
// instance. Paths passed to [ctor@Gio.Settings.new_with_path] will typically be
// constructed dynamically from a constant prefix plus some form of instance
// identifier; but they must still be valid GSettings paths. Paths could also
// be constant and used with a globally installed schema originating from a
// dependency library.
//
// For example, a relocatable schema could be used to store geometry information
// for different windows in an application. If the schema ID was
// `org.foo.MyApp.Window`, it could be instantiated for paths
// `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
// `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
// they can be specified as `&lt;child&gt;` elements in the parent schema, e.g.:
// ```xml
// &lt;schema id="org.foo.MyApp" path="/org/foo/MyApp/"&gt;
//
//	&lt;child name="main" schema="org.foo.MyApp.Window"/&gt;
//
// &lt;/schema&gt;
// ```
//
// ## Build system integration
//
// ### Meson
//
// GSettings is natively supported by Meson’s [GNOME module](https://mesonbuild.com/Gnome-module.html).
//
// You can install the schemas as any other data file:
//
// ```
// install_data(
//
//	'org.foo.MyApp.gschema.xml',
//	install_dir: get_option('datadir') / 'glib-2.0/schemas',
//
// )
// ```
//
// You can use `gnome.post_install()` function to compile the schemas on
// installation:
//
// ```
// gnome = import('gnome')
// gnome.post_install(
//
//	glib_compile_schemas: true,
//
// )
// ```
//
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an `&lt;enum&gt;` element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, you will need to use the `gnome.mkenums()` function
// with the following templates:
//
// ```
// schemas_enums = gnome.mkenums('org.foo.MyApp.enums.xml',
//
//	comments: '&lt;!-- @comment@ --&gt;',
//	fhead: '&lt;schemalist&gt;',
//	vhead: '  &lt;@type@ id="org.foo.MyApp.@EnumName@"&gt;',
//	vprod: '    &lt;value nick="@valuenick@" value="@valuenum@"/&gt;',
//	vtail: '  &lt;/@type@&gt;',
//	ftail: '&lt;/schemalist&gt;',
//	sources: enum_sources,
//	install_header: true,
//	install_dir: get_option('datadir') / 'glib-2.0/schemas',
//
// )
// ```
//
// It is recommended to validate your schemas as part of the test suite for
// your application:
//
// ```
// test('validate-schema',
//
//	find_program('glib-compile-schemas'),
//	args: ['--strict', '--dry-run', meson.current_source_dir()],
//
// )
// ```
//
// If your application allows running uninstalled, you should also use the
// `gnome.compile_schemas()` function to compile the schemas in the current
// build directory:
//
// ```
// gnome.compile_schemas()
// ```
//
// ### Autotools
//
// GSettings comes with autotools integration to simplify compiling and
// installing schemas. To add GSettings support to an application, add the
// following to your `configure.ac`:
// ```
// GLIB_GSETTINGS
// ```
//
// In the appropriate `Makefile.am`, use the following snippet to compile and
// install the named schema:
// ```
// gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
// EXTRA_DIST = $(gsettings_SCHEMAS)
//
// @GSETTINGS_RULES@
// ```
//
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an `&lt;enum&gt;` element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, add the following to the relevant `Makefile.am`:
// ```
// gsettings_ENUM_NAMESPACE = org.foo.MyApp
// gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
// ```
//
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
//
// ## Localization
//
// No changes are needed to the build system to mark a schema XML file for
// translation. Assuming it sets the `gettext-domain` attribute, a schema may
// be marked for translation by adding it to `POTFILES.in`, assuming gettext
// 0.19 or newer is in use (the preferred method for translation):
// ```
// data/org.foo.MyApp.gschema.xml
// ```
//
// Alternatively, if intltool 0.50.1 is in use:
// ```
// [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
// ```
//
// GSettings will use gettext to look up translations for the `&lt;summary&gt;` and
// `&lt;description&gt;` elements, and also any `&lt;default&gt;` elements which have a
// `l10n` attribute set.
//
// Translations **must not** be included in the `.gschema.xml` file by the build
// system, for example by using a rule to generate the XML file from a template.
type Settings struct {
	gobject.Object
}

var xSettingsGLibType func() types.GType

func SettingsGLibType() types.GType {
	return xSettingsGLibType()
}

func SettingsNewFromInternalPtr(ptr uintptr) *Settings {
	cls := &Settings{}
	cls.Ptr = ptr
	return cls
}

var xNewSettings func(string) uintptr

// Creates a new [class@Gio.Settings] object with the schema specified by
// @schema_id.
//
// It is an error for the schema to not exist: schemas are an
// essential part of a program, as they provide type information.
// If schemas need to be dynamically loaded (for example, from an
// optional runtime dependency), [method@Gio.SettingsSchemaSource.lookup]
// can be used to test for their existence before loading them.
//
// Signals on the newly created [class@Gio.Settings] object will be dispatched
// via the thread-default [struct@GLib.MainContext] in effect at the time of the
// call to [ctor@Gio.Settings.new].  The new [class@Gio.Settings] will hold a reference
// on the context.  See [method@GLib.MainContext.push_thread_default].
func NewSettings(SchemaIdVar string) *Settings {
	var cls *Settings

	cret := xNewSettings(SchemaIdVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xNewSettingsFull func(*SettingsSchema, uintptr, uintptr) uintptr

// Creates a new [class@Gio.Settings] object with a given schema, backend and
// path.
//
// It should be extremely rare that you ever want to use this function.
// It is made available for advanced use-cases (such as plugin systems
// that want to provide access to schemas loaded from custom locations,
// etc).
//
// At the most basic level, a [class@Gio.Settings] object is a pure composition of
// four things: a [struct@Gio.SettingsSchema], a [class@Gio.SettingsBackend], a path within that
// backend, and a [struct@GLib.MainContext] to which signals are dispatched.
//
// This constructor therefore gives you full control over constructing
// [class@Gio.Settings] instances.  The first 3 parameters are given directly as
// @schema, @backend and @path, and the main context is taken from the
// thread-default (as per [ctor@Gio.Settings.new]).
//
// If @backend is `NULL` then the default backend is used.
//
// If @path is `NULL` then the path from the schema is used.  It is an
// error if @path is `NULL` and the schema has no path of its own or if
// @path is non-`NULL` and not equal to the path that the schema does
// have.
func NewSettingsFull(SchemaVar *SettingsSchema, BackendVar *SettingsBackend, PathVar *string) *Settings {
	var cls *Settings

	cret := xNewSettingsFull(SchemaVar, BackendVar.GoPointer(), core.NullableStringToPtr(PathVar))

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xNewSettingsWithBackend func(string, uintptr) uintptr

// Creates a new [class@Gio.Settings] object with the schema specified by
// @schema_id and a given [class@Gio.SettingsBackend].
//
// Creating a [class@Gio.Settings] object with a different backend allows accessing
// settings from a database other than the usual one. For example, it may make
// sense to pass a backend corresponding to the ‘defaults’ settings database on
// the system to get a settings object that modifies the system default
// settings instead of the settings for this user.
func NewSettingsWithBackend(SchemaIdVar string, BackendVar *SettingsBackend) *Settings {
	var cls *Settings

	cret := xNewSettingsWithBackend(SchemaIdVar, BackendVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xNewSettingsWithBackendAndPath func(string, uintptr, string) uintptr

// Creates a new [class@Gio.Settings] object with the schema specified by
// @schema_id and a given [class@Gio.SettingsBackend] and path.
//
// This is a mix of [ctor@Gio.Settings.new_with_backend] and
// [ctor@Gio.Settings.new_with_path].
func NewSettingsWithBackendAndPath(SchemaIdVar string, BackendVar *SettingsBackend, PathVar string) *Settings {
	var cls *Settings

	cret := xNewSettingsWithBackendAndPath(SchemaIdVar, BackendVar.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xNewSettingsWithPath func(string, string) uintptr

// Creates a new [class@Gio.Settings] object with the relocatable schema specified
// by @schema_id and a given path.
//
// You only need to do this if you want to directly create a settings
// object with a schema that doesn’t have a specified path of its own.
// That’s quite rare.
//
// It is a programmer error to call this function for a schema that
// has an explicitly specified path.
//
// It is a programmer error if @path is not a valid path.  A valid path
// begins and ends with `/` and does not contain two consecutive `/`
// characters.
func NewSettingsWithPath(SchemaIdVar string, PathVar string) *Settings {
	var cls *Settings

	cret := xNewSettingsWithPath(SchemaIdVar, PathVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xSettingsApply func(uintptr)

// Applies any changes that have been made to the settings.
//
// This function does nothing unless @settings is in
// [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).  In the normal
// case settings are always applied immediately.
func (x *Settings) Apply() {

	xSettingsApply(x.GoPointer())

}

var xSettingsBind func(uintptr, string, uintptr, string, SettingsBindFlags)

// Create a binding between the @key in the @settings object
// and the property @property of @object.
//
// The binding uses the default GIO mapping functions to map
// between the settings and property values. These functions
// handle booleans, numeric types and string types in a
// straightforward way. Use [method@Gio.Settings.bind_with_mapping] if
// you need a custom mapping, or map between types that are not
// supported by the default mapping functions.
//
// Unless the @flags include [flags@Gio.SettingsBindFlags.NO_SENSITIVITY], this
// function also establishes a binding between the writability of
// @key and the `sensitive` property of @object (if @object has
// a boolean property by that name). See [method@Gio.Settings.bind_writable]
// for more details about writable bindings.
//
// Note that the lifecycle of the binding is tied to @object,
// and that you can have only one binding per object property.
// If you bind the same property twice on the same object, the second
// binding overrides the first one.
func (x *Settings) Bind(KeyVar string, ObjectVar *gobject.Object, PropertyVar string, FlagsVar SettingsBindFlags) {

	xSettingsBind(x.GoPointer(), KeyVar, ObjectVar.GoPointer(), PropertyVar, FlagsVar)

}

var xSettingsBindWithMapping func(uintptr, string, uintptr, string, SettingsBindFlags, uintptr, uintptr, uintptr, uintptr)

// Create a binding between the @key in the @settings object
// and the property @property of @object.
//
// The binding uses the provided mapping functions to map between
// settings and property values.
//
// Note that the lifecycle of the binding is tied to @object,
// and that you can have only one binding per object property.
// If you bind the same property twice on the same object, the second
// binding overrides the first one.
func (x *Settings) BindWithMapping(KeyVar string, ObjectVar *gobject.Object, PropertyVar string, FlagsVar SettingsBindFlags, GetMappingVar *SettingsBindGetMapping, SetMappingVar *SettingsBindSetMapping, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var GetMappingVarRef uintptr
	if GetMappingVar != nil {
		GetMappingVarPtr := uintptr(unsafe.Pointer(GetMappingVar))
		if cbRefPtr, ok := glib.GetCallback(GetMappingVarPtr); ok {
			GetMappingVarRef = cbRefPtr
		} else {
			fcb := func(arg0 *gobject.Value, arg1 *glib.Variant, arg2 uintptr) bool {
				cbFn := *GetMappingVar
				return cbFn(arg0, arg1, arg2)
			}
			GetMappingVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(GetMappingVarPtr, GetMappingVarRef)
		}
	}

	var SetMappingVarRef uintptr
	if SetMappingVar != nil {
		SetMappingVarPtr := uintptr(unsafe.Pointer(SetMappingVar))
		if cbRefPtr, ok := glib.GetCallback(SetMappingVarPtr); ok {
			SetMappingVarRef = cbRefPtr
		} else {
			fcb := func(arg0 *gobject.Value, arg1 *glib.VariantType, arg2 uintptr) *glib.Variant {
				cbFn := *SetMappingVar
				return cbFn(arg0, arg1, arg2)
			}
			SetMappingVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(SetMappingVarPtr, SetMappingVarRef)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyVarPtr, DestroyVarRef)
		}
	}

	xSettingsBindWithMapping(x.GoPointer(), KeyVar, ObjectVar.GoPointer(), PropertyVar, FlagsVar, GetMappingVarRef, SetMappingVarRef, UserDataVar, DestroyVarRef)

}

var xSettingsBindWithMappingClosures func(uintptr, string, uintptr, string, SettingsBindFlags, *gobject.Closure, *gobject.Closure)

// Version of [method@Gio.Settings.bind_with_mapping] using closures instead of
// callbacks for easier binding in other languages.
func (x *Settings) BindWithMappingClosures(KeyVar string, ObjectVar *gobject.Object, PropertyVar string, FlagsVar SettingsBindFlags, GetMappingVar *gobject.Closure, SetMappingVar *gobject.Closure) {

	xSettingsBindWithMappingClosures(x.GoPointer(), KeyVar, ObjectVar.GoPointer(), PropertyVar, FlagsVar, GetMappingVar, SetMappingVar)

}

var xSettingsBindWritable func(uintptr, string, uintptr, string, bool)

// Create a binding between the writability of @key in the
// @settings object and the property @property of @object.
//
// The property must be boolean; `sensitive` or `visible`
// properties of widgets are the most likely candidates.
//
// Writable bindings are always uni-directional; changes of the
// writability of the setting will be propagated to the object
// property, not the other way.
//
// When the @inverted argument is true, the binding inverts the
// value as it passes from the setting to the object, i.e. @property
// will be set to true if the key is not writable.
//
// Note that the lifecycle of the binding is tied to @object,
// and that you can have only one binding per object property.
// If you bind the same property twice on the same object, the second
// binding overrides the first one.
func (x *Settings) BindWritable(KeyVar string, ObjectVar *gobject.Object, PropertyVar string, InvertedVar bool) {

	xSettingsBindWritable(x.GoPointer(), KeyVar, ObjectVar.GoPointer(), PropertyVar, InvertedVar)

}

var xSettingsCreateAction func(uintptr, string) uintptr

// Creates a [iface@Gio.Action] corresponding to a given [class@Gio.Settings] key.
//
// The action has the same name as the key.
//
// The value of the key becomes the state of the action and the action
// is enabled when the key is writable.  Changing the state of the
// action results in the key being written to.  Changes to the value or
// writability of the key cause appropriate change notifications to be
// emitted for the action.
//
// For boolean-valued keys, action activations take no parameter and
// result in the toggling of the value.  For all other types,
// activations take the new value for the key (which must have the
// correct type).
func (x *Settings) CreateAction(KeyVar string) *ActionBase {
	var cls *ActionBase

	cret := xSettingsCreateAction(x.GoPointer(), KeyVar)

	if cret == 0 {
		return nil
	}
	cls = &ActionBase{}
	cls.Ptr = cret
	return cls
}

var xSettingsDelay func(uintptr)

// Changes the [class@Gio.Settings] object into
// [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).
//
// In this
// mode, changes to @settings are not immediately propagated to the
// backend, but kept locally until [method@Gio.Settings.apply] is called.
func (x *Settings) Delay() {

	xSettingsDelay(x.GoPointer())

}

var xSettingsGet func(uintptr, string, string, ...interface{})

// Gets the value that is stored at @key in @settings.
//
// A convenience function that combines [method@Gio.Settings.get_value] with
// [method@GLib.Variant.get].
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings or for the [struct@GLib.VariantType] of @format to mismatch
// the type given in the schema.
func (x *Settings) Get(KeyVar string, FormatVar string, varArgs ...interface{}) {

	xSettingsGet(x.GoPointer(), KeyVar, FormatVar, varArgs...)

}

var xSettingsGetBoolean func(uintptr, string) bool

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of [method@Gio.Settings.get] for booleans.
//
// It is a programmer error to give a @key that isn’t specified as
// having a `b` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) GetBoolean(KeyVar string) bool {

	cret := xSettingsGetBoolean(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetChild func(uintptr, string) uintptr

// Creates a child settings object which has a base path of
// `base-path/name`, where `base-path` is the base path of
// @settings and `name` is as specified by the caller.
//
// The schema for the child settings object must have been declared
// in the schema of @settings using a `&lt;child&gt;` element.
//
// The created child settings object will inherit the
// [property@Gio.Settings:delay-apply] mode from @settings.
func (x *Settings) GetChild(NameVar string) *Settings {
	var cls *Settings

	cret := xSettingsGetChild(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xSettingsGetDefaultValue func(uintptr, string) *glib.Variant

// Gets the ‘default value’ of a key.
//
// This is the value that would be read if [method@Gio.Settings.reset] were to be
// called on the key.
//
// Note that this may be a different value than returned by
// [method@Gio.SettingsSchemaKey.get_default_value] if the system administrator
// has provided a default value.
//
// Comparing the return values of [method@Gio.Settings.get_default_value] and
// [method@Gio.Settings.get_value] is not sufficient for determining if a value
// has been set because the user may have explicitly set the value to
// something that happens to be equal to the default.  The difference
// here is that if the default changes in the future, the user’s key
// will still be set.
//
// This function may be useful for adding an indication to a UI of what
// the default value was before the user set it.
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings.
func (x *Settings) GetDefaultValue(KeyVar string) *glib.Variant {

	cret := xSettingsGetDefaultValue(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetDouble func(uintptr, string) float64

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of [method@Gio.Settings.get] for doubles.
//
// It is a programmer error to give a @key that isn’t specified as
// having a `d` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) GetDouble(KeyVar string) float64 {

	cret := xSettingsGetDouble(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetEnum func(uintptr, string) int

// Gets the value that is stored in @settings for @key and converts it
// to the enum value that it represents.
//
// In order to use this function the type of the value must be a string
// and it must be marked in the schema file as an enumerated type.
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings or is not marked as an enumerated type.
//
// If the value stored in the configuration database is not a valid
// value for the enumerated type then this function will return the
// default value.
func (x *Settings) GetEnum(KeyVar string) int {

	cret := xSettingsGetEnum(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetFlags func(uintptr, string) uint

// Gets the value that is stored in @settings for @key and converts it
// to the flags value that it represents.
//
// In order to use this function the type of the value must be an array
// of strings and it must be marked in the schema file as a flags type.
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings or is not marked as a flags type.
//
// If the value stored in the configuration database is not a valid
// value for the flags type then this function will return the default
// value.
func (x *Settings) GetFlags(KeyVar string) uint {

	cret := xSettingsGetFlags(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetHasUnapplied func(uintptr) bool

// Returns whether the [class@Gio.Settings] object has any unapplied
// changes.
//
// This can only be the case if it is in
// [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).
func (x *Settings) GetHasUnapplied() bool {

	cret := xSettingsGetHasUnapplied(x.GoPointer())
	return cret
}

var xSettingsGetInt func(uintptr, string) int

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of [method@Gio.Settings.get] for 32-bit integers.
//
// It is a programmer error to give a @key that isn’t specified as
// having an `i` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) GetInt(KeyVar string) int {

	cret := xSettingsGetInt(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetInt64 func(uintptr, string) int64

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of [method@Gio.Settings.get] for 64-bit integers.
//
// It is a programmer error to give a @key that isn’t specified as
// having an `x` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) GetInt64(KeyVar string) int64 {

	cret := xSettingsGetInt64(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetMapped func(uintptr, string, uintptr, uintptr) uintptr

// Gets the value that is stored at @key in @settings, subject to
// application-level validation/mapping.
//
// You should use this function when the application needs to perform
// some processing on the value of the key (for example, parsing).  The
// @mapping function performs that processing.  If the function
// indicates that the processing was unsuccessful (due to a parse error,
// for example) then the mapping is tried again with another value.
//
// This allows a robust ‘fall back to defaults’ behaviour to be
// implemented somewhat automatically.
//
// The first value that is tried is the user’s setting for the key.  If
// the mapping function fails to map this value, other values may be
// tried in an unspecified order (system or site defaults, translated
// schema default values, untranslated schema default values, etc).
//
// If the mapping function fails for all possible values, one additional
// attempt is made: the mapping function is called with a `NULL` value.
// If the mapping function still indicates failure at this point then
// the application will be aborted.
//
// The result parameter for the @mapping function is pointed to a
// `gpointer` which is initially set to `NULL`.  The same pointer is given
// to each invocation of @mapping.  The final value of that `gpointer` is
// what is returned by this function.  `NULL` is valid; it is returned
// just as any other value would be.
func (x *Settings) GetMapped(KeyVar string, MappingVar *SettingsGetMapping, UserDataVar uintptr) uintptr {

	var MappingVarRef uintptr
	if MappingVar != nil {
		MappingVarPtr := uintptr(unsafe.Pointer(MappingVar))
		if cbRefPtr, ok := glib.GetCallback(MappingVarPtr); ok {
			MappingVarRef = cbRefPtr
		} else {
			fcb := func(arg0 *glib.Variant, arg1 *uintptr, arg2 uintptr) bool {
				cbFn := *MappingVar
				return cbFn(arg0, arg1, arg2)
			}
			MappingVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(MappingVarPtr, MappingVarRef)
		}
	}

	cret := xSettingsGetMapped(x.GoPointer(), KeyVar, MappingVarRef, UserDataVar)
	return cret
}

var xSettingsGetRange func(uintptr, string) *glib.Variant

// Queries the range of a key.
func (x *Settings) GetRange(KeyVar string) *glib.Variant {

	cret := xSettingsGetRange(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetString func(uintptr, string) string

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of [method@Gio.Settings.get] for strings.
//
// It is a programmer error to give a @key that isn’t specified as
// having an `s` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) GetString(KeyVar string) string {

	cret := xSettingsGetString(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetStrv func(uintptr, string) []string

// A convenience variant of [method@Gio.Settings.get] for string arrays.
//
// It is a programmer error to give a @key that isn’t specified as
// having an `as` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) GetStrv(KeyVar string) []string {

	cret := xSettingsGetStrv(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetUint func(uintptr, string) uint

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of [method@Gio.Settings.get] for 32-bit unsigned
// integers.
//
// It is a programmer error to give a @key that isn’t specified as
// having a `u` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) GetUint(KeyVar string) uint {

	cret := xSettingsGetUint(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetUint64 func(uintptr, string) uint64

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of [method@Gio.Settings.get] for 64-bit unsigned
// integers.
//
// It is a programmer error to give a @key that isn’t specified as
// having a `t` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) GetUint64(KeyVar string) uint64 {

	cret := xSettingsGetUint64(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetUserValue func(uintptr, string) *glib.Variant

// Checks the ‘user value’ of a key, if there is one.
//
// The user value of a key is the last value that was set by the user.
//
// After calling [method@Gio.Settings.reset] this function should always return
// `NULL` (assuming something is not wrong with the system
// configuration).
//
// It is possible that [method@Gio.Settings.get_value] will return a different
// value than this function.  This can happen in the case that the user
// set a value for a key that was subsequently locked down by the system
// administrator — this function will return the user’s old value.
//
// This function may be useful for adding a ‘reset’ option to a UI or
// for providing indication that a particular value has been changed.
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings.
func (x *Settings) GetUserValue(KeyVar string) *glib.Variant {

	cret := xSettingsGetUserValue(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetValue func(uintptr, string) *glib.Variant

// Gets the value that is stored in @settings for @key.
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings.
func (x *Settings) GetValue(KeyVar string) *glib.Variant {

	cret := xSettingsGetValue(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsIsWritable func(uintptr, string) bool

// Finds out if a key can be written.
func (x *Settings) IsWritable(NameVar string) bool {

	cret := xSettingsIsWritable(x.GoPointer(), NameVar)
	return cret
}

var xSettingsListChildren func(uintptr) []string

// Gets the list of children on @settings.
//
// The list is exactly the list of strings for which it is not an error
// to call [method@Gio.Settings.get_child].
//
// There is little reason to call this function from ‘normal’ code, since
// you should already know what children are in your schema. This function
// may still be useful there for introspection reasons, however.
//
// You should free the return value with [func@GLib.strfreev] when you are done
// with it.
func (x *Settings) ListChildren() []string {

	cret := xSettingsListChildren(x.GoPointer())
	return cret
}

var xSettingsListKeys func(uintptr) []string

// Introspects the list of keys on @settings.
//
// You should probably not be calling this function from ‘normal’ code
// (since you should already know what keys are in your schema).  This
// function is intended for introspection reasons.
//
// You should free the return value with [func@GLib.strfreev] when you are done
// with it.
func (x *Settings) ListKeys() []string {

	cret := xSettingsListKeys(x.GoPointer())
	return cret
}

var xSettingsRangeCheck func(uintptr, string, *glib.Variant) bool

// Checks if the given @value is of the correct type and within the
// permitted range for @key.
func (x *Settings) RangeCheck(KeyVar string, ValueVar *glib.Variant) bool {

	cret := xSettingsRangeCheck(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsReset func(uintptr, string)

// Resets @key to its default value.
//
// This call resets the key, as much as possible, to its default value.
// That might be the value specified in the schema or the one set by the
// administrator.
func (x *Settings) Reset(KeyVar string) {

	xSettingsReset(x.GoPointer(), KeyVar)

}

var xSettingsRevert func(uintptr)

// Reverts all unapplied changes to the settings.
//
// This function does nothing unless @settings is in
// [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).  In the normal
// case settings are always applied immediately.
//
// Change notifications will be emitted for affected keys.
func (x *Settings) Revert() {

	xSettingsRevert(x.GoPointer())

}

var xSettingsSet func(uintptr, string, string, ...interface{}) bool

// Sets @key in @settings to @value.
//
// A convenience function that combines [method@Gio.Settings.set_value] with
// [ctor@GLib.Variant.new].
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings or for the [struct@GLib.VariantType] of @format to mismatch
// the type given in the schema.
func (x *Settings) Set(KeyVar string, FormatVar string, varArgs ...interface{}) bool {

	cret := xSettingsSet(x.GoPointer(), KeyVar, FormatVar, varArgs...)
	return cret
}

var xSettingsSetBoolean func(uintptr, string, bool) bool

// Sets @key in @settings to @value.
//
// A convenience variant of [method@Gio.Settings.set] for booleans.
//
// It is a programmer error to give a @key that isn’t specified as
// having a `b` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) SetBoolean(KeyVar string, ValueVar bool) bool {

	cret := xSettingsSetBoolean(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetDouble func(uintptr, string, float64) bool

// Sets @key in @settings to @value.
//
// A convenience variant of [method@Gio.Settings.set] for doubles.
//
// It is a programmer error to give a @key that isn’t specified as
// having a `d` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) SetDouble(KeyVar string, ValueVar float64) bool {

	cret := xSettingsSetDouble(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetEnum func(uintptr, string, int) bool

// Looks up the enumerated type nick for @value and writes it to @key,
// within @settings.
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings or is not marked as an enumerated type, or for
// @value not to be a valid value for the named type.
//
// After performing the write, accessing @key directly with
// [method@Gio.Settings.get_string] will return the ‘nick’ associated with
// @value.
func (x *Settings) SetEnum(KeyVar string, ValueVar int) bool {

	cret := xSettingsSetEnum(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetFlags func(uintptr, string, uint) bool

// Looks up the flags type nicks for the bits specified by @value, puts
// them in an array of strings and writes the array to @key, within
// @settings.
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings or is not marked as a flags type, or for @value
// to contain any bits that are not value for the named type.
//
// After performing the write, accessing @key directly with
// [method@Gio.Settings.get_strv] will return an array of ‘nicks’; one for each
// bit in @value.
func (x *Settings) SetFlags(KeyVar string, ValueVar uint) bool {

	cret := xSettingsSetFlags(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetInt func(uintptr, string, int) bool

// Sets @key in @settings to @value.
//
// A convenience variant of [method@Gio.Settings.set] for 32-bit integers.
//
// It is a programmer error to give a @key that isn’t specified as
// having an `i` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) SetInt(KeyVar string, ValueVar int) bool {

	cret := xSettingsSetInt(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetInt64 func(uintptr, string, int64) bool

// Sets @key in @settings to @value.
//
// A convenience variant of [method@Gio.Settings.set] for 64-bit integers.
//
// It is a programmer error to give a @key that isn’t specified as
// having an `x` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) SetInt64(KeyVar string, ValueVar int64) bool {

	cret := xSettingsSetInt64(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetString func(uintptr, string, string) bool

// Sets @key in @settings to @value.
//
// A convenience variant of [method@Gio.Settings.set] for strings.
//
// It is a programmer error to give a @key that isn’t specified as
// having an `s` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) SetString(KeyVar string, ValueVar string) bool {

	cret := xSettingsSetString(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetStrv func(uintptr, string, []string) bool

// Sets @key in @settings to @value.
//
// A convenience variant of [method@Gio.Settings.set] for string arrays.  If
// @value is `NULL`, then @key is set to be the empty array.
//
// It is a programmer error to give a @key that isn’t specified as
// having an `as` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) SetStrv(KeyVar string, ValueVar []string) bool {

	cret := xSettingsSetStrv(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetUint func(uintptr, string, uint) bool

// Sets @key in @settings to @value.
//
// A convenience variant of [method@Gio.Settings.set] for 32-bit unsigned
// integers.
//
// It is a programmer error to give a @key that isn’t specified as
// having a `u` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) SetUint(KeyVar string, ValueVar uint) bool {

	cret := xSettingsSetUint(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetUint64 func(uintptr, string, uint64) bool

// Sets @key in @settings to @value.
//
// A convenience variant of [method@Gio.Settings.set] for 64-bit unsigned
// integers.
//
// It is a programmer error to give a @key that isn’t specified as
// having a `t` type in the schema for @settings (see [struct@GLib.VariantType]).
func (x *Settings) SetUint64(KeyVar string, ValueVar uint64) bool {

	cret := xSettingsSetUint64(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetValue func(uintptr, string, *glib.Variant) bool

// Sets @key in @settings to @value.
//
// It is a programmer error to give a @key that isn’t contained in the
// schema for @settings or for @value to have the incorrect type, per
// the schema.
//
// If @value is floating then this function consumes the reference.
func (x *Settings) SetValue(KeyVar string, ValueVar *glib.Variant) bool {

	cret := xSettingsSetValue(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

func (c *Settings) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Settings) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// GetPropertyDelayApply gets the "delay-apply" property.
// Whether the [class@Gio.Settings] object is in
// [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).
func (x *Settings) GetPropertyDelayApply() bool {
	var v gobject.Value
	x.GetProperty("delay-apply", &v)
	return v.GetBoolean()
}

// GetPropertyHasUnapplied gets the "has-unapplied" property.
// Whether the [class@Gio.Settings] object has outstanding changes.
//
// These changes will be applied when [method@Gio.Settings.apply] is called.
func (x *Settings) GetPropertyHasUnapplied() bool {
	var v gobject.Value
	x.GetProperty("has-unapplied", &v)
	return v.GetBoolean()
}

// SetPropertyPath sets the "path" property.
// The path within the backend where the settings are stored.
func (x *Settings) SetPropertyPath(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("path", &v)
}

// GetPropertyPath gets the "path" property.
// The path within the backend where the settings are stored.
func (x *Settings) GetPropertyPath() string {
	var v gobject.Value
	x.GetProperty("path", &v)
	return v.GetString()
}

// SetPropertySchema sets the "schema" property.
// The name of the schema that describes the types of keys
// for this [class@Gio.Settings] object.
//
// The type of this property is *not* [struct@Gio.SettingsSchema].
// [struct@Gio.SettingsSchema] has only existed since version 2.32 and
// unfortunately this name was used in previous versions to refer to
// the schema ID rather than the schema itself.  Take care to use the
// [property@Gio.Settings:settings-schema] property if you wish to pass in a
// [struct@Gio.SettingsSchema].
func (x *Settings) SetPropertySchema(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("schema", &v)
}

// GetPropertySchema gets the "schema" property.
// The name of the schema that describes the types of keys
// for this [class@Gio.Settings] object.
//
// The type of this property is *not* [struct@Gio.SettingsSchema].
// [struct@Gio.SettingsSchema] has only existed since version 2.32 and
// unfortunately this name was used in previous versions to refer to
// the schema ID rather than the schema itself.  Take care to use the
// [property@Gio.Settings:settings-schema] property if you wish to pass in a
// [struct@Gio.SettingsSchema].
func (x *Settings) GetPropertySchema() string {
	var v gobject.Value
	x.GetProperty("schema", &v)
	return v.GetString()
}

// SetPropertySchemaId sets the "schema-id" property.
// The name of the schema that describes the types of keys
// for this [class@Gio.Settings] object.
func (x *Settings) SetPropertySchemaId(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("schema-id", &v)
}

// GetPropertySchemaId gets the "schema-id" property.
// The name of the schema that describes the types of keys
// for this [class@Gio.Settings] object.
func (x *Settings) GetPropertySchemaId() string {
	var v gobject.Value
	x.GetProperty("schema-id", &v)
	return v.GetString()
}

// SetPropertySettingsSchema sets the "settings-schema" property.
// The [struct@Gio.SettingsSchema] describing the types of keys for this
// [class@Gio.Settings] object.
//
// Ideally, this property would be called [property@Gio.Settings:schema].
// [struct@Gio.SettingsSchema]
// has only existed since version 2.32, however, and before then the
// [property@Gio.Settings:schema] property was used to refer to the ID of the schema rather
// than the schema itself.  Take care.
func (x *Settings) SetPropertySettingsSchema(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("settings-schema", &v)
}

// GetPropertySettingsSchema gets the "settings-schema" property.
// The [struct@Gio.SettingsSchema] describing the types of keys for this
// [class@Gio.Settings] object.
//
// Ideally, this property would be called [property@Gio.Settings:schema].
// [struct@Gio.SettingsSchema]
// has only existed since version 2.32, however, and before then the
// [property@Gio.Settings:schema] property was used to refer to the ID of the schema rather
// than the schema itself.  Take care.
func (x *Settings) GetPropertySettingsSchema() uintptr {
	var v gobject.Value
	x.GetProperty("settings-schema", &v)
	return v.GetPointer()
}

// Emitted once per change event that affects this settings object.
//
// You should connect to this signal
// only if you are interested in viewing groups of changes before they
// are split out into multiple emissions of the [signal@Gio.Settings::changed] signal.
// For most use cases it is more appropriate to use the [signal@Gio.Settings::changed] signal.
//
// In the event that the change event applies to one or more specified
// keys, @keys will be an array of [alias@GLib.Quark]s of length @n_keys.  In the
// event that the change event applies to the [class@Gio.Settings] object as a
// whole (ie: potentially every key has been changed) then @keys will
// be `NULL` and @n_keys will be `0`.
//
// The default handler for this signal invokes the [signal@Gio.Settings::changed] signal
// for each affected key.  If any other connected handler returns
// true then this default functionality will be suppressed.
func (x *Settings) ConnectChangeEvent(cb *func(Settings, uintptr, int) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "change-event", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeysVarp uintptr, NKeysVarp int) bool {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, KeysVarp, NKeysVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "change-event", cbRefPtr)
}

// Emitted when a key has potentially changed.
//
// You should call one of the [method@Gio.Settings.get] calls to check the new
// value.
//
// This signal supports detailed connections.  You can connect to the
// detailed signal `changed::x` in order to only receive callbacks
// when key `x` changes.
//
// Note that @settings only emits this signal if you have read @key at
// least once while a signal handler was already connected for @key.
func (x *Settings) ConnectChanged(cb *func(Settings, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeyVarp string) {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, KeyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

// ConnectChangedWithDetail connects to the "changed" signal with a detail string.
// The detail is appended as "changed::<detail>".
func (x *Settings) ConnectChangedWithDetail(detail string, cb *func(Settings, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	signalName := fmt.Sprintf("changed::%s", detail)
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), signalName, cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeyVarp string) {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, KeyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), signalName, cbRefPtr)
}

// Emitted once per writability change event that affects this settings object.
//
// You should connect
// to this signal if you are interested in viewing groups of changes
// before they are split out into multiple emissions of the
// [signal@Gio.Settings::writable-changed] signal.  For most use cases it is more
// appropriate to use the [signal@Gio.Settings::writable-changed] signal.
//
// In the event that the writability change applies only to a single
// key, @key will be set to the [alias@GLib.Quark] for that key.  In the event
// that the writability change affects the entire settings object,
// @key will be `0`.
//
// The default handler for this signal invokes the [signal@Gio.Settings::writable-changed]
// and [signal@Gio.Settings::changed] signals for each affected key.  This is done because
// changes in writability might also imply changes in value (if for
// example, a new mandatory setting is introduced).  If any other
// connected handler returns true then this default functionality
// will be suppressed.
func (x *Settings) ConnectWritableChangeEvent(cb *func(Settings, uint) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "writable-change-event", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeyVarp uint) bool {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, KeyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "writable-change-event", cbRefPtr)
}

// Emitted when the writability of a key has potentially changed.
//
// You should call [method@Gio.Settings.is_writable] in order to determine the
// new status.
//
// This signal supports detailed connections.  You can connect to the
// detailed signal `writable-changed::x` in order to only receive
// callbacks when the writability of `x` changes.
func (x *Settings) ConnectWritableChanged(cb *func(Settings, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "writable-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeyVarp string) {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, KeyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "writable-changed", cbRefPtr)
}

// ConnectWritableChangedWithDetail connects to the "writable-changed" signal with a detail string.
// The detail is appended as "writable-changed::<detail>".
func (x *Settings) ConnectWritableChangedWithDetail(detail string, cb *func(Settings, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	signalName := fmt.Sprintf("writable-changed::%s", detail)
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), signalName, cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeyVarp string) {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, KeyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), signalName, cbRefPtr)
}

var xSettingsListRelocatableSchemas func() []string

// Deprecated.
func SettingsListRelocatableSchemas() []string {

	cret := xSettingsListRelocatableSchemas()
	return cret
}

var xSettingsListSchemas func() []string

// Deprecated.
func SettingsListSchemas() []string {

	cret := xSettingsListSchemas()
	return cret
}

var xSettingsSync func()

// Ensures that all pending operations are complete for the default backend.
//
// Writes made to a [class@Gio.Settings] are handled asynchronously.  For this
// reason, it is very unlikely that the changes have it to disk by the
// time [method@Gio.Settings.set] returns.
//
// This call will block until all of the writes have made it to the
// backend.  Since the main loop is not running, no change notifications
// will be dispatched during this call (but some may be queued by the
// time the call is done).
func SettingsSync() {

	xSettingsSync()

}

var xSettingsUnbind func(uintptr, string)

// Removes an existing binding for @property on @object.
//
// Note that bindings are automatically removed when the
// object is finalized, so it is rarely necessary to call this
// function.
func SettingsUnbind(ObjectVar *gobject.Object, PropertyVar string) {

	xSettingsUnbind(ObjectVar.GoPointer(), PropertyVar)

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSettingsBindFlagsGLibType, libs, "g_settings_bind_flags_get_type")

	core.PuregoSafeRegister(&xSettingsGLibType, libs, "g_settings_get_type")

	core.PuregoSafeRegister(&xNewSettings, libs, "g_settings_new")
	core.PuregoSafeRegister(&xNewSettingsFull, libs, "g_settings_new_full")
	core.PuregoSafeRegister(&xNewSettingsWithBackend, libs, "g_settings_new_with_backend")
	core.PuregoSafeRegister(&xNewSettingsWithBackendAndPath, libs, "g_settings_new_with_backend_and_path")
	core.PuregoSafeRegister(&xNewSettingsWithPath, libs, "g_settings_new_with_path")

	core.PuregoSafeRegister(&xSettingsApply, libs, "g_settings_apply")
	core.PuregoSafeRegister(&xSettingsBind, libs, "g_settings_bind")
	core.PuregoSafeRegister(&xSettingsBindWithMapping, libs, "g_settings_bind_with_mapping")
	core.PuregoSafeRegister(&xSettingsBindWithMappingClosures, libs, "g_settings_bind_with_mapping_closures")
	core.PuregoSafeRegister(&xSettingsBindWritable, libs, "g_settings_bind_writable")
	core.PuregoSafeRegister(&xSettingsCreateAction, libs, "g_settings_create_action")
	core.PuregoSafeRegister(&xSettingsDelay, libs, "g_settings_delay")
	core.PuregoSafeRegister(&xSettingsGet, libs, "g_settings_get")
	core.PuregoSafeRegister(&xSettingsGetBoolean, libs, "g_settings_get_boolean")
	core.PuregoSafeRegister(&xSettingsGetChild, libs, "g_settings_get_child")
	core.PuregoSafeRegister(&xSettingsGetDefaultValue, libs, "g_settings_get_default_value")
	core.PuregoSafeRegister(&xSettingsGetDouble, libs, "g_settings_get_double")
	core.PuregoSafeRegister(&xSettingsGetEnum, libs, "g_settings_get_enum")
	core.PuregoSafeRegister(&xSettingsGetFlags, libs, "g_settings_get_flags")
	core.PuregoSafeRegister(&xSettingsGetHasUnapplied, libs, "g_settings_get_has_unapplied")
	core.PuregoSafeRegister(&xSettingsGetInt, libs, "g_settings_get_int")
	core.PuregoSafeRegister(&xSettingsGetInt64, libs, "g_settings_get_int64")
	core.PuregoSafeRegister(&xSettingsGetMapped, libs, "g_settings_get_mapped")
	core.PuregoSafeRegister(&xSettingsGetRange, libs, "g_settings_get_range")
	core.PuregoSafeRegister(&xSettingsGetString, libs, "g_settings_get_string")
	core.PuregoSafeRegister(&xSettingsGetStrv, libs, "g_settings_get_strv")
	core.PuregoSafeRegister(&xSettingsGetUint, libs, "g_settings_get_uint")
	core.PuregoSafeRegister(&xSettingsGetUint64, libs, "g_settings_get_uint64")
	core.PuregoSafeRegister(&xSettingsGetUserValue, libs, "g_settings_get_user_value")
	core.PuregoSafeRegister(&xSettingsGetValue, libs, "g_settings_get_value")
	core.PuregoSafeRegister(&xSettingsIsWritable, libs, "g_settings_is_writable")
	core.PuregoSafeRegister(&xSettingsListChildren, libs, "g_settings_list_children")
	core.PuregoSafeRegister(&xSettingsListKeys, libs, "g_settings_list_keys")
	core.PuregoSafeRegister(&xSettingsRangeCheck, libs, "g_settings_range_check")
	core.PuregoSafeRegister(&xSettingsReset, libs, "g_settings_reset")
	core.PuregoSafeRegister(&xSettingsRevert, libs, "g_settings_revert")
	core.PuregoSafeRegister(&xSettingsSet, libs, "g_settings_set")
	core.PuregoSafeRegister(&xSettingsSetBoolean, libs, "g_settings_set_boolean")
	core.PuregoSafeRegister(&xSettingsSetDouble, libs, "g_settings_set_double")
	core.PuregoSafeRegister(&xSettingsSetEnum, libs, "g_settings_set_enum")
	core.PuregoSafeRegister(&xSettingsSetFlags, libs, "g_settings_set_flags")
	core.PuregoSafeRegister(&xSettingsSetInt, libs, "g_settings_set_int")
	core.PuregoSafeRegister(&xSettingsSetInt64, libs, "g_settings_set_int64")
	core.PuregoSafeRegister(&xSettingsSetString, libs, "g_settings_set_string")
	core.PuregoSafeRegister(&xSettingsSetStrv, libs, "g_settings_set_strv")
	core.PuregoSafeRegister(&xSettingsSetUint, libs, "g_settings_set_uint")
	core.PuregoSafeRegister(&xSettingsSetUint64, libs, "g_settings_set_uint64")
	core.PuregoSafeRegister(&xSettingsSetValue, libs, "g_settings_set_value")

	core.PuregoSafeRegister(&xSettingsListRelocatableSchemas, libs, "g_settings_list_relocatable_schemas")
	core.PuregoSafeRegister(&xSettingsListSchemas, libs, "g_settings_list_schemas")
	core.PuregoSafeRegister(&xSettingsSync, libs, "g_settings_sync")
	core.PuregoSafeRegister(&xSettingsUnbind, libs, "g_settings_unbind")

}
