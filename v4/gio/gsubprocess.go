// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// `GSubprocess` allows the creation of and interaction with child
// processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie:
// [class@Gio.InputStream], [class@Gio.OutputStream]). There are GIO-style APIs
// to wait for process termination (ie: cancellable and with an asynchronous
// variant).
//
// There is an API to force a process to terminate, as well as a
// race-free API for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such
// [method@Gio.OutputStream.splice_async].  This makes `GSubprocess`
// significantly more powerful and flexible than equivalent APIs in
// some other languages such as the `subprocess.py`
// included with Python.  For example, using `GSubprocess` one could
// create two child processes, reading standard output from the first,
// processing it, and writing to the input stream of the second, all
// without blocking the main loop.
//
// A powerful [method@Gio.Subprocess.communicate] API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy
// interaction with a subprocess that has been opened with pipes.
//
// `GSubprocess` defaults to tight control over the file descriptors open
// in the child process, avoiding dangling-FD issues that are caused by
// a simple `fork()`/`exec()`.  The only open file descriptors in the
// spawned process are ones that were explicitly specified by the
// `GSubprocess` API (unless `G_SUBPROCESS_FLAGS_INHERIT_FDS` was
// specified).
//
// `GSubprocess` will quickly reap all child processes as they exit,
// avoiding ‘zombie processes’ remaining around for long periods of
// time.  [method@Gio.Subprocess.wait] can be used to wait for this to happen,
// but it will happen even without the call being explicitly made.
//
// As a matter of principle, `GSubprocess` has no API that accepts
// shell-style space-separated strings.  It will, however, match the
// typical shell behaviour of searching the `PATH` for executables that do
// not contain a directory separator in their name. By default, the `PATH`
// of the current process is used.  You can specify
// `G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP` to use the `PATH` of the
// launcher environment instead.
//
// `GSubprocess` attempts to have a very simple API for most uses (ie:
// spawning a subprocess with arguments and support for most typical
// kinds of input and output redirection).  See [ctor@Gio.Subprocess.new]. The
// [class@Gio.SubprocessLauncher] API is provided for more complicated cases
// (advanced types of redirection, environment variable manipulation,
// change of working directory, child setup functions, etc).
//
// A typical use of `GSubprocess` will involve calling
// [ctor@Gio.Subprocess.new], followed by [method@Gio.Subprocess.wait_async] or
// [method@Gio.Subprocess.wait].  After the process exits, the status can be
// checked using functions such as [method@Gio.Subprocess.get_if_exited] (which
// are similar to the familiar `WIFEXITED`-style POSIX macros).
//
// Note that as of GLib 2.82, creating a `GSubprocess` causes the signal
// `SIGPIPE` to be ignored for the remainder of the program. If you are writing
// a command-line utility that uses `GSubprocess`, you may need to take into
// account the fact that your program will not automatically be killed
// if it tries to write to `stdout` after it has been closed.
type Subprocess struct {
	gobject.Object
}

var xSubprocessGLibType func() types.GType

func SubprocessGLibType() types.GType {
	return xSubprocessGLibType()
}

func SubprocessNewFromInternalPtr(ptr uintptr) *Subprocess {
	cls := &Subprocess{}
	cls.Ptr = ptr
	return cls
}

var xNewSubprocess func(SubprocessFlags, **glib.Error, string, ...interface{}) uintptr

// Create a new process with the given flags and varargs argument
// list.  By default, matching the g_spawn_async() defaults, the
// child's stdin will be set to the system null device, and
// stdout/stderr will be inherited from the parent.  You can use
// @flags to control this behavior.
//
// The argument list must be terminated with %NULL.
func NewSubprocess(FlagsVar SubprocessFlags, ErrorVar **glib.Error, Argv0Var string, varArgs ...interface{}) *Subprocess {
	var cls *Subprocess

	cret := xNewSubprocess(FlagsVar, ErrorVar, Argv0Var, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Subprocess{}
	cls.Ptr = cret
	return cls
}

var xNewSubprocessv func([]string, SubprocessFlags, **glib.Error) uintptr

// Create a new process with the given flags and argument list.
//
// The argument list is expected to be %NULL-terminated.
func NewSubprocessv(ArgvVar []string, FlagsVar SubprocessFlags) (*Subprocess, error) {
	var cls *Subprocess
	var cerr *glib.Error

	cret := xNewSubprocessv(ArgvVar, FlagsVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Subprocess{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSubprocessCommunicate func(uintptr, *glib.Bytes, uintptr, **glib.Bytes, **glib.Bytes, **glib.Error) bool

// Communicate with the subprocess until it terminates, and all input
// and output has been completed.
//
// If @stdin_buf is given, the subprocess must have been created with
// %G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
// stdin of the subprocess and the pipe is closed (ie: EOF).
//
// At the same time (as not to cause blocking when dealing with large
// amounts of data), if %G_SUBPROCESS_FLAGS_STDOUT_PIPE or
// %G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
// streams.  The data that was read is returned in @stdout and/or
// the @stderr.
//
// If the subprocess was created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// @stdout_buf will contain the data read from stdout.  Otherwise, for
// subprocesses not created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// @stdout_buf will be set to %NULL.  Similar provisions apply to
// @stderr_buf and %G_SUBPROCESS_FLAGS_STDERR_PIPE.
//
// As usual, any output variable may be given as %NULL to ignore it.
//
// If you desire the stdout and stderr data to be interleaved, create
// the subprocess with %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// %G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
// in @stdout_buf and @stderr_buf will be set to %NULL.
//
// In case of any error (including cancellation), %FALSE will be
// returned with @error set.  Some or all of the stdin data may have
// been written.  Any stdout or stderr data that has been read will be
// discarded. None of the out variables (aside from @error) will have
// been set to anything in particular and should not be inspected.
//
// In the case that %TRUE is returned, the subprocess has exited and the
// exit status inspection APIs (eg: g_subprocess_get_if_exited(),
// g_subprocess_get_exit_status()) may be used.
//
// You should not attempt to use any of the subprocess pipes after
// starting this function, since they may be left in strange states,
// even if the operation was cancelled.  You should especially not
// attempt to interact with the pipes while the operation is in progress
// (either from another thread or if using the asynchronous version).
func (x *Subprocess) Communicate(StdinBufVar *glib.Bytes, CancellableVar *Cancellable, StdoutBufVar **glib.Bytes, StderrBufVar **glib.Bytes) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessCommunicate(x.GoPointer(), StdinBufVar, CancellableVar.GoPointer(), StdoutBufVar, StderrBufVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessCommunicateAsync func(uintptr, *glib.Bytes, uintptr, uintptr, uintptr)

// Asynchronous version of g_subprocess_communicate().  Complete
// invocation with g_subprocess_communicate_finish().
func (x *Subprocess) CommunicateAsync(StdinBufVar *glib.Bytes, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xSubprocessCommunicateAsync(x.GoPointer(), StdinBufVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xSubprocessCommunicateFinish func(uintptr, uintptr, **glib.Bytes, **glib.Bytes, **glib.Error) bool

// Complete an invocation of g_subprocess_communicate_async().
func (x *Subprocess) CommunicateFinish(ResultVar AsyncResult, StdoutBufVar **glib.Bytes, StderrBufVar **glib.Bytes) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessCommunicateFinish(x.GoPointer(), ResultVar.GoPointer(), StdoutBufVar, StderrBufVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessCommunicateUtf8 func(uintptr, uintptr, uintptr, *string, *string, **glib.Error) bool

// Like g_subprocess_communicate(), but validates the output of the
// process as UTF-8, and returns it as a regular NUL terminated string.
//
// On error, @stdout_buf and @stderr_buf will be set to undefined values and
// should not be used.
func (x *Subprocess) CommunicateUtf8(StdinBufVar *string, CancellableVar *Cancellable, StdoutBufVar *string, StderrBufVar *string) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessCommunicateUtf8(x.GoPointer(), core.NullableStringToPtr(StdinBufVar), CancellableVar.GoPointer(), StdoutBufVar, StderrBufVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessCommunicateUtf8Async func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Asynchronous version of g_subprocess_communicate_utf8().  Complete
// invocation with g_subprocess_communicate_utf8_finish().
func (x *Subprocess) CommunicateUtf8Async(StdinBufVar *string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xSubprocessCommunicateUtf8Async(x.GoPointer(), core.NullableStringToPtr(StdinBufVar), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xSubprocessCommunicateUtf8Finish func(uintptr, uintptr, *string, *string, **glib.Error) bool

// Complete an invocation of g_subprocess_communicate_utf8_async().
func (x *Subprocess) CommunicateUtf8Finish(ResultVar AsyncResult, StdoutBufVar *string, StderrBufVar *string) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessCommunicateUtf8Finish(x.GoPointer(), ResultVar.GoPointer(), StdoutBufVar, StderrBufVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessForceExit func(uintptr)

// Use an operating-system specific method to attempt an immediate,
// forceful termination of the process.  There is no mechanism to
// determine whether or not the request itself was successful;
// however, you can use g_subprocess_wait() to monitor the status of
// the process after calling this function.
//
// On Unix, this function sends %SIGKILL.
func (x *Subprocess) ForceExit() {

	xSubprocessForceExit(x.GoPointer())

}

var xSubprocessGetExitStatus func(uintptr) int

// Check the exit status of the subprocess, given that it exited
// normally.  This is the value passed to the exit() system call or the
// return value from main.
//
// This is equivalent to the system WEXITSTATUS macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_exited() returned %TRUE.
func (x *Subprocess) GetExitStatus() int {

	cret := xSubprocessGetExitStatus(x.GoPointer())
	return cret
}

var xSubprocessGetIdentifier func(uintptr) string

// On UNIX, returns the process ID as a decimal string.
// On Windows, returns the result of GetProcessId() also as a string.
// If the subprocess has terminated, this will return %NULL.
func (x *Subprocess) GetIdentifier() string {

	cret := xSubprocessGetIdentifier(x.GoPointer())
	return cret
}

var xSubprocessGetIfExited func(uintptr) bool

// Check if the given subprocess exited normally (ie: by way of exit()
// or return from main()).
//
// This is equivalent to the system WIFEXITED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (x *Subprocess) GetIfExited() bool {

	cret := xSubprocessGetIfExited(x.GoPointer())
	return cret
}

var xSubprocessGetIfSignaled func(uintptr) bool

// Check if the given subprocess terminated in response to a signal.
//
// This is equivalent to the system WIFSIGNALED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (x *Subprocess) GetIfSignaled() bool {

	cret := xSubprocessGetIfSignaled(x.GoPointer())
	return cret
}

var xSubprocessGetStatus func(uintptr) int

// Gets the raw status code of the process, as from waitpid().
//
// This value has no particular meaning, but it can be used with the
// macros defined by the system headers such as WIFEXITED.  It can also
// be used with g_spawn_check_wait_status().
//
// It is more likely that you want to use g_subprocess_get_if_exited()
// followed by g_subprocess_get_exit_status().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (x *Subprocess) GetStatus() int {

	cret := xSubprocessGetStatus(x.GoPointer())
	return cret
}

var xSubprocessGetStderrPipe func(uintptr) uintptr

// Gets the #GInputStream from which to read the stderr output of
// @subprocess.
//
// The process must have been created with %G_SUBPROCESS_FLAGS_STDERR_PIPE,
// otherwise %NULL will be returned.
func (x *Subprocess) GetStderrPipe() *InputStream {
	var cls *InputStream

	cret := xSubprocessGetStderrPipe(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &InputStream{}
	cls.Ptr = cret
	return cls
}

var xSubprocessGetStdinPipe func(uintptr) uintptr

// Gets the #GOutputStream that you can write to in order to give data
// to the stdin of @subprocess.
//
// The process must have been created with %G_SUBPROCESS_FLAGS_STDIN_PIPE and
// not %G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise %NULL will be returned.
func (x *Subprocess) GetStdinPipe() *OutputStream {
	var cls *OutputStream

	cret := xSubprocessGetStdinPipe(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &OutputStream{}
	cls.Ptr = cret
	return cls
}

var xSubprocessGetStdoutPipe func(uintptr) uintptr

// Gets the #GInputStream from which to read the stdout output of
// @subprocess.
//
// The process must have been created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// otherwise %NULL will be returned.
func (x *Subprocess) GetStdoutPipe() *InputStream {
	var cls *InputStream

	cret := xSubprocessGetStdoutPipe(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &InputStream{}
	cls.Ptr = cret
	return cls
}

var xSubprocessGetSuccessful func(uintptr) bool

// Checks if the process was "successful".  A process is considered
// successful if it exited cleanly with an exit status of 0, either by
// way of the exit() system call or return from main().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (x *Subprocess) GetSuccessful() bool {

	cret := xSubprocessGetSuccessful(x.GoPointer())
	return cret
}

var xSubprocessGetTermSig func(uintptr) int

// Get the signal number that caused the subprocess to terminate, given
// that it terminated due to a signal.
//
// This is equivalent to the system WTERMSIG macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_signaled() returned %TRUE.
func (x *Subprocess) GetTermSig() int {

	cret := xSubprocessGetTermSig(x.GoPointer())
	return cret
}

var xSubprocessSendSignal func(uintptr, int)

// Sends the UNIX signal @signal_num to the subprocess, if it is still
// running.
//
// This API is race-free.  If the subprocess has terminated, it will not
// be signalled.
//
// This API is not available on Windows.
func (x *Subprocess) SendSignal(SignalNumVar int) {

	xSubprocessSendSignal(x.GoPointer(), SignalNumVar)

}

var xSubprocessWait func(uintptr, uintptr, **glib.Error) bool

// Synchronously wait for the subprocess to terminate.
//
// After the process terminates you can query its exit status with
// functions such as g_subprocess_get_if_exited() and
// g_subprocess_get_exit_status().
//
// This function does not fail in the case of the subprocess having
// abnormal termination.  See g_subprocess_wait_check() for that.
//
// Cancelling @cancellable doesn't kill the subprocess.  Call
// g_subprocess_force_exit() if it is desirable.
func (x *Subprocess) Wait(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessWait(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessWaitAsync func(uintptr, uintptr, uintptr, uintptr)

// Wait for the subprocess to terminate.
//
// This is the asynchronous version of g_subprocess_wait().
func (x *Subprocess) WaitAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xSubprocessWaitAsync(x.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xSubprocessWaitCheck func(uintptr, uintptr, **glib.Error) bool

// Combines g_subprocess_wait() with g_spawn_check_wait_status().
func (x *Subprocess) WaitCheck(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessWaitCheck(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessWaitCheckAsync func(uintptr, uintptr, uintptr, uintptr)

// Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
//
// This is the asynchronous version of g_subprocess_wait_check().
func (x *Subprocess) WaitCheckAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xSubprocessWaitCheckAsync(x.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xSubprocessWaitCheckFinish func(uintptr, uintptr, **glib.Error) bool

// Collects the result of a previous call to
// g_subprocess_wait_check_async().
func (x *Subprocess) WaitCheckFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessWaitCheckFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessWaitFinish func(uintptr, uintptr, **glib.Error) bool

// Collects the result of a previous call to
// g_subprocess_wait_async().
func (x *Subprocess) WaitFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessWaitFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *Subprocess) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Subprocess) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyArgv sets the "argv" property.
// Argument vector.
func (x *Subprocess) SetPropertyArgv(value []string) {
	var v gobject.Value
	v.Init(glib.StrvGetType())
	v.SetBoxed(uintptr(unsafe.Pointer(core.ByteSlice(value))))
	x.SetProperty("argv", &v)
}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [description][iface@Gio.Initable#description] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class’ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *Subprocess) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSubprocessGLibType, libs, "g_subprocess_get_type")

	core.PuregoSafeRegister(&xNewSubprocess, libs, "g_subprocess_new")
	core.PuregoSafeRegister(&xNewSubprocessv, libs, "g_subprocess_newv")

	core.PuregoSafeRegister(&xSubprocessCommunicate, libs, "g_subprocess_communicate")
	core.PuregoSafeRegister(&xSubprocessCommunicateAsync, libs, "g_subprocess_communicate_async")
	core.PuregoSafeRegister(&xSubprocessCommunicateFinish, libs, "g_subprocess_communicate_finish")
	core.PuregoSafeRegister(&xSubprocessCommunicateUtf8, libs, "g_subprocess_communicate_utf8")
	core.PuregoSafeRegister(&xSubprocessCommunicateUtf8Async, libs, "g_subprocess_communicate_utf8_async")
	core.PuregoSafeRegister(&xSubprocessCommunicateUtf8Finish, libs, "g_subprocess_communicate_utf8_finish")
	core.PuregoSafeRegister(&xSubprocessForceExit, libs, "g_subprocess_force_exit")
	core.PuregoSafeRegister(&xSubprocessGetExitStatus, libs, "g_subprocess_get_exit_status")
	core.PuregoSafeRegister(&xSubprocessGetIdentifier, libs, "g_subprocess_get_identifier")
	core.PuregoSafeRegister(&xSubprocessGetIfExited, libs, "g_subprocess_get_if_exited")
	core.PuregoSafeRegister(&xSubprocessGetIfSignaled, libs, "g_subprocess_get_if_signaled")
	core.PuregoSafeRegister(&xSubprocessGetStatus, libs, "g_subprocess_get_status")
	core.PuregoSafeRegister(&xSubprocessGetStderrPipe, libs, "g_subprocess_get_stderr_pipe")
	core.PuregoSafeRegister(&xSubprocessGetStdinPipe, libs, "g_subprocess_get_stdin_pipe")
	core.PuregoSafeRegister(&xSubprocessGetStdoutPipe, libs, "g_subprocess_get_stdout_pipe")
	core.PuregoSafeRegister(&xSubprocessGetSuccessful, libs, "g_subprocess_get_successful")
	core.PuregoSafeRegister(&xSubprocessGetTermSig, libs, "g_subprocess_get_term_sig")
	core.PuregoSafeRegister(&xSubprocessSendSignal, libs, "g_subprocess_send_signal")
	core.PuregoSafeRegister(&xSubprocessWait, libs, "g_subprocess_wait")
	core.PuregoSafeRegister(&xSubprocessWaitAsync, libs, "g_subprocess_wait_async")
	core.PuregoSafeRegister(&xSubprocessWaitCheck, libs, "g_subprocess_wait_check")
	core.PuregoSafeRegister(&xSubprocessWaitCheckAsync, libs, "g_subprocess_wait_check_async")
	core.PuregoSafeRegister(&xSubprocessWaitCheckFinish, libs, "g_subprocess_wait_check_finish")
	core.PuregoSafeRegister(&xSubprocessWaitFinish, libs, "g_subprocess_wait_finish")

}
