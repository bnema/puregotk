// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type SimpleProxyResolverClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr
}

func (x *SimpleProxyResolverClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGReserved1 sets the "_g_reserved1" callback function.
func (x *SimpleProxyResolverClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the "_g_reserved1" callback function.
func (x *SimpleProxyResolverClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the "_g_reserved2" callback function.
func (x *SimpleProxyResolverClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the "_g_reserved2" callback function.
func (x *SimpleProxyResolverClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the "_g_reserved3" callback function.
func (x *SimpleProxyResolverClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the "_g_reserved3" callback function.
func (x *SimpleProxyResolverClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the "_g_reserved4" callback function.
func (x *SimpleProxyResolverClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the "_g_reserved4" callback function.
func (x *SimpleProxyResolverClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the "_g_reserved5" callback function.
func (x *SimpleProxyResolverClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the "_g_reserved5" callback function.
func (x *SimpleProxyResolverClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

type SimpleProxyResolverPrivate struct {
	_ structs.HostLayout
}

func (x *SimpleProxyResolverPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GSimpleProxyResolver` is a simple [iface@Gio.ProxyResolver] implementation
// that handles a single default proxy, multiple URI-scheme-specific
// proxies, and a list of hosts that proxies should not be used for.
//
// `GSimpleProxyResolver` is never the default proxy resolver, but it
// can be used as the base class for another proxy resolver
// implementation, or it can be created and used manually, such as
// with [method@Gio.SocketClient.set_proxy_resolver].
type SimpleProxyResolver struct {
	gobject.Object
}

var xSimpleProxyResolverGLibType func() types.GType

func SimpleProxyResolverGLibType() types.GType {
	return xSimpleProxyResolverGLibType()
}

func SimpleProxyResolverNewFromInternalPtr(ptr uintptr) *SimpleProxyResolver {
	cls := &SimpleProxyResolver{}
	cls.Ptr = ptr
	return cls
}

var xSimpleProxyResolverSetDefaultProxy func(uintptr, uintptr)

// Sets the default proxy on @resolver, to be used for any URIs that
// don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
// via g_simple_proxy_resolver_set_uri_proxy().
//
// If @default_proxy starts with "socks://",
// #GSimpleProxyResolver will treat it as referring to all three of
// the socks5, socks4a, and socks4 proxy types.
func (x *SimpleProxyResolver) SetDefaultProxy(DefaultProxyVar *string) {

	xSimpleProxyResolverSetDefaultProxy(x.GoPointer(), core.NullableStringToPtr(DefaultProxyVar))

}

var xSimpleProxyResolverSetIgnoreHosts func(uintptr, []string)

// Sets the list of ignored hosts.
//
// See #GSimpleProxyResolver:ignore-hosts for more details on how the
// @ignore_hosts argument is interpreted.
func (x *SimpleProxyResolver) SetIgnoreHosts(IgnoreHostsVar []string) {

	xSimpleProxyResolverSetIgnoreHosts(x.GoPointer(), IgnoreHostsVar)

}

var xSimpleProxyResolverSetUriProxy func(uintptr, string, string)

// Adds a URI-scheme-specific proxy to @resolver; URIs whose scheme
// matches @uri_scheme (and which don't match
// #GSimpleProxyResolver:ignore-hosts) will be proxied via @proxy.
//
// As with #GSimpleProxyResolver:default-proxy, if @proxy starts with
// "socks://", #GSimpleProxyResolver will treat it
// as referring to all three of the socks5, socks4a, and socks4 proxy
// types.
func (x *SimpleProxyResolver) SetUriProxy(UriSchemeVar string, ProxyVar string) {

	xSimpleProxyResolverSetUriProxy(x.GoPointer(), UriSchemeVar, ProxyVar)

}

func (c *SimpleProxyResolver) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *SimpleProxyResolver) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyDefaultProxy sets the "default-proxy" property.
// The default proxy URI that will be used for any URI that doesn't
// match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
// of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
//
// Note that as a special case, if this URI starts with
// "socks://", #GSimpleProxyResolver will treat it as referring
// to all three of the socks5, socks4a, and socks4 proxy types.
func (x *SimpleProxyResolver) SetPropertyDefaultProxy(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("default-proxy", &v)
}

// GetPropertyDefaultProxy gets the "default-proxy" property.
// The default proxy URI that will be used for any URI that doesn't
// match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
// of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
//
// Note that as a special case, if this URI starts with
// "socks://", #GSimpleProxyResolver will treat it as referring
// to all three of the socks5, socks4a, and socks4 proxy types.
func (x *SimpleProxyResolver) GetPropertyDefaultProxy() string {
	var v gobject.Value
	x.GetProperty("default-proxy", &v)
	return v.GetString()
}

// SetPropertyIgnoreHosts sets the "ignore-hosts" property.
// A list of hostnames and IP addresses that the resolver should
// allow direct connections to.
//
// Entries can be in one of 4 formats:
//
//   - A hostname, such as "example.com", ".example.com", or
//     "*.example.com", any of which match "example.com" or
//     any subdomain of it.
//
//   - An IPv4 or IPv6 address, such as "192.168.1.1",
//     which matches only that address.
//
//   - A hostname or IP address followed by a port, such as
//     "example.com:80", which matches whatever the hostname or IP
//     address would match, but only for URLs with the (explicitly)
//     indicated port. In the case of an IPv6 address, the address
//     part must appear in brackets: "[::1]:443"
//
//   - An IP address range, given by a base address and prefix length,
//     such as "fe80::/10", which matches any address in that range.
//
// Note that when dealing with Unicode hostnames, the matching is
// done against the ASCII form of the name.
//
// Also note that hostname exclusions apply only to connections made
// to hosts identified by name, and IP address exclusions apply only
// to connections made to hosts identified by address. That is, if
// example.com has an address of 192.168.1.1, and the :ignore-hosts list
// contains only "192.168.1.1", then a connection to "example.com"
// (eg, via a #GNetworkAddress) will use the proxy, and a connection to
// "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
//
// These rules match the "ignore-hosts"/"noproxy" rules most
// commonly used by other applications.
func (x *SimpleProxyResolver) SetPropertyIgnoreHosts(value []string) {
	var v gobject.Value
	v.Init(glib.StrvGetType())
	v.SetBoxed(uintptr(unsafe.Pointer(core.ByteSlice(value))))
	x.SetProperty("ignore-hosts", &v)
}

// GetPropertyIgnoreHosts gets the "ignore-hosts" property.
// A list of hostnames and IP addresses that the resolver should
// allow direct connections to.
//
// Entries can be in one of 4 formats:
//
//   - A hostname, such as "example.com", ".example.com", or
//     "*.example.com", any of which match "example.com" or
//     any subdomain of it.
//
//   - An IPv4 or IPv6 address, such as "192.168.1.1",
//     which matches only that address.
//
//   - A hostname or IP address followed by a port, such as
//     "example.com:80", which matches whatever the hostname or IP
//     address would match, but only for URLs with the (explicitly)
//     indicated port. In the case of an IPv6 address, the address
//     part must appear in brackets: "[::1]:443"
//
//   - An IP address range, given by a base address and prefix length,
//     such as "fe80::/10", which matches any address in that range.
//
// Note that when dealing with Unicode hostnames, the matching is
// done against the ASCII form of the name.
//
// Also note that hostname exclusions apply only to connections made
// to hosts identified by name, and IP address exclusions apply only
// to connections made to hosts identified by address. That is, if
// example.com has an address of 192.168.1.1, and the :ignore-hosts list
// contains only "192.168.1.1", then a connection to "example.com"
// (eg, via a #GNetworkAddress) will use the proxy, and a connection to
// "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
//
// These rules match the "ignore-hosts"/"noproxy" rules most
// commonly used by other applications.
func (x *SimpleProxyResolver) GetPropertyIgnoreHosts() []string {
	var v gobject.Value
	x.GetProperty("ignore-hosts", &v)
	return core.GoStringSlice(v.GetBoxed())
}

// Checks if @resolver can be used on this system. (This is used
// internally; g_proxy_resolver_get_default() will only return a proxy
// resolver that returns %TRUE for this method.)
func (x *SimpleProxyResolver) IsSupported() bool {

	cret := XGProxyResolverIsSupported(x.GoPointer())
	return cret
}

// Looks into the system proxy configuration to determine what proxy,
// if any, to use to connect to @uri. The returned proxy URIs are of
// the form `&lt;protocol&gt;://[user[:password]@]host[:port]` or
// `direct://`, where `&lt;protocol&gt;` could be http, rtsp, socks
// or other proxying protocol.
//
// If you don't know what network protocol is being used on the
// socket, you should use `none` as the URI protocol.
// In this case, the resolver might still return a generic proxy type
// (such as SOCKS), but would not return protocol-specific proxy types
// (such as http).
//
// `direct://` is used when no proxy is needed.
// Direct connection should not be attempted unless it is part of the
// returned array of proxies.
func (x *SimpleProxyResolver) Lookup(UriVar string, CancellableVar *Cancellable) ([]string, error) {
	var cerr *glib.Error

	cret := XGProxyResolverLookup(x.GoPointer(), UriVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
// details.
func (x *SimpleProxyResolver) LookupAsync(UriVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGProxyResolverLookupAsync(x.GoPointer(), UriVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Call this function to obtain the array of proxy URIs when
// g_proxy_resolver_lookup_async() is complete. See
// g_proxy_resolver_lookup() for more details.
func (x *SimpleProxyResolver) LookupFinish(ResultVar AsyncResult) ([]string, error) {
	var cerr *glib.Error

	cret := XGProxyResolverLookupFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSimpleProxyResolverNew func(uintptr, []string) uintptr

// Creates a new #GSimpleProxyResolver. See
// #GSimpleProxyResolver:default-proxy and
// #GSimpleProxyResolver:ignore-hosts for more details on how the
// arguments are interpreted.
func SimpleProxyResolverNew(DefaultProxyVar *string, IgnoreHostsVar []string) *ProxyResolverBase {
	var cls *ProxyResolverBase

	cret := xSimpleProxyResolverNew(core.NullableStringToPtr(DefaultProxyVar), IgnoreHostsVar)

	if cret == 0 {
		return nil
	}
	cls = &ProxyResolverBase{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSimpleProxyResolverGLibType, libs, "g_simple_proxy_resolver_get_type")

	core.PuregoSafeRegister(&xSimpleProxyResolverSetDefaultProxy, libs, "g_simple_proxy_resolver_set_default_proxy")
	core.PuregoSafeRegister(&xSimpleProxyResolverSetIgnoreHosts, libs, "g_simple_proxy_resolver_set_ignore_hosts")
	core.PuregoSafeRegister(&xSimpleProxyResolverSetUriProxy, libs, "g_simple_proxy_resolver_set_uri_proxy")

	core.PuregoSafeRegister(&xSimpleProxyResolverNew, libs, "g_simple_proxy_resolver_new")

}
