// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type IOStreamClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xGetInputStream uintptr

	xGetOutputStream uintptr

	xCloseFn uintptr

	xCloseAsync uintptr

	xCloseFinish uintptr

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr

	xGReserved6 uintptr

	xGReserved7 uintptr

	xGReserved8 uintptr

	xGReserved9 uintptr

	xGReserved10 uintptr
}

func (x *IOStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetInputStream sets the callback function.
func (x *IOStreamClass) OverrideGetInputStream(cb func(*IOStream) *InputStream) {
	if cb == nil {
		x.xGetInputStream = 0
	} else {
		x.xGetInputStream = purego.NewCallback(func(StreamVarp uintptr) uintptr {
			ret := cb(IOStreamNewFromInternalPtr(StreamVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetInputStream gets the callback function.
func (x *IOStreamClass) GetGetInputStream() func(*IOStream) *InputStream {
	if x.xGetInputStream == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetInputStream)
	return func(StreamVar *IOStream) *InputStream {
		rawRet := rawCallback(StreamVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &InputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetOutputStream sets the callback function.
func (x *IOStreamClass) OverrideGetOutputStream(cb func(*IOStream) *OutputStream) {
	if cb == nil {
		x.xGetOutputStream = 0
	} else {
		x.xGetOutputStream = purego.NewCallback(func(StreamVarp uintptr) uintptr {
			ret := cb(IOStreamNewFromInternalPtr(StreamVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetOutputStream gets the callback function.
func (x *IOStreamClass) GetGetOutputStream() func(*IOStream) *OutputStream {
	if x.xGetOutputStream == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetOutputStream)
	return func(StreamVar *IOStream) *OutputStream {
		rawRet := rawCallback(StreamVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &OutputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCloseFn sets the callback function.
func (x *IOStreamClass) OverrideCloseFn(cb func(*IOStream, *Cancellable) bool) {
	if cb == nil {
		x.xCloseFn = 0
	} else {
		x.xCloseFn = purego.NewCallback(func(StreamVarp uintptr, CancellableVarp uintptr) bool {
			return cb(IOStreamNewFromInternalPtr(StreamVarp), CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetCloseFn gets the callback function.
func (x *IOStreamClass) GetCloseFn() func(*IOStream, *Cancellable) bool {
	if x.xCloseFn == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCloseFn)
	return func(StreamVar *IOStream, CancellableVar *Cancellable) bool {
		return rawCallback(StreamVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideCloseAsync sets the callback function.
func (x *IOStreamClass) OverrideCloseAsync(cb func(*IOStream, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xCloseAsync = 0
	} else {
		x.xCloseAsync = purego.NewCallback(func(StreamVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(IOStreamNewFromInternalPtr(StreamVarp), IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetCloseAsync gets the callback function.
func (x *IOStreamClass) GetCloseAsync() func(*IOStream, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xCloseAsync == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCloseAsync)
	return func(StreamVar *IOStream, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(StreamVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideCloseFinish sets the callback function.
func (x *IOStreamClass) OverrideCloseFinish(cb func(*IOStream, AsyncResult) bool) {
	if cb == nil {
		x.xCloseFinish = 0
	} else {
		x.xCloseFinish = purego.NewCallback(func(StreamVarp uintptr, ResultVarp uintptr) bool {
			return cb(IOStreamNewFromInternalPtr(StreamVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetCloseFinish gets the callback function.
func (x *IOStreamClass) GetCloseFinish() func(*IOStream, AsyncResult) bool {
	if x.xCloseFinish == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCloseFinish)
	return func(StreamVar *IOStream, ResultVar AsyncResult) bool {
		return rawCallback(StreamVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGReserved1 sets the callback function.
func (x *IOStreamClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the callback function.
func (x *IOStreamClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the callback function.
func (x *IOStreamClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the callback function.
func (x *IOStreamClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the callback function.
func (x *IOStreamClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the callback function.
func (x *IOStreamClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the callback function.
func (x *IOStreamClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the callback function.
func (x *IOStreamClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the callback function.
func (x *IOStreamClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the callback function.
func (x *IOStreamClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved6 sets the callback function.
func (x *IOStreamClass) OverrideGReserved6(cb func()) {
	if cb == nil {
		x.xGReserved6 = 0
	} else {
		x.xGReserved6 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved6 gets the callback function.
func (x *IOStreamClass) GetGReserved6() func() {
	if x.xGReserved6 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved6)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved7 sets the callback function.
func (x *IOStreamClass) OverrideGReserved7(cb func()) {
	if cb == nil {
		x.xGReserved7 = 0
	} else {
		x.xGReserved7 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved7 gets the callback function.
func (x *IOStreamClass) GetGReserved7() func() {
	if x.xGReserved7 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved7)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved8 sets the callback function.
func (x *IOStreamClass) OverrideGReserved8(cb func()) {
	if cb == nil {
		x.xGReserved8 = 0
	} else {
		x.xGReserved8 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved8 gets the callback function.
func (x *IOStreamClass) GetGReserved8() func() {
	if x.xGReserved8 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved8)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved9 sets the callback function.
func (x *IOStreamClass) OverrideGReserved9(cb func()) {
	if cb == nil {
		x.xGReserved9 = 0
	} else {
		x.xGReserved9 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved9 gets the callback function.
func (x *IOStreamClass) GetGReserved9() func() {
	if x.xGReserved9 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved9)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved10 sets the callback function.
func (x *IOStreamClass) OverrideGReserved10(cb func()) {
	if cb == nil {
		x.xGReserved10 = 0
	} else {
		x.xGReserved10 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved10 gets the callback function.
func (x *IOStreamClass) GetGReserved10() func() {
	if x.xGReserved10 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved10)
	return func() {
		rawCallback()
	}
}

type IOStreamPrivate struct {
	_ structs.HostLayout
}

func (x *IOStreamPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GIOStream` represents an object that has both read and write streams.
// Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for
// seekable streams, both streams may use the same position.
//
// Examples of `GIOStream` objects are [class@Gio.SocketConnection], which represents
// a two-way network connection; and [class@Gio.FileIOStream], which represents a
// file handle opened in read-write mode.
//
// To do the actual reading and writing you need to get the substreams
// with [method@Gio.IOStream.get_input_stream] and
// [method@Gio.IOStream.get_output_stream].
//
// The `GIOStream` object owns the input and the output streams, not the other
// way around, so keeping the substreams alive will not keep the `GIOStream`
// object alive. If the `GIOStream` object is freed it will be closed, thus
// closing the substreams, so even if the substreams stay alive they will
// always return `G_IO_ERROR_CLOSED` for all operations.
//
// To close a stream use [method@Gio.IOStream.close] which will close the common
// stream object and also the individual substreams. You can also close
// the substreams themselves. In most cases this only marks the
// substream as closed, so further I/O on it fails but common state in the
// `GIOStream` may still be open. However, some streams may support
// ‘half-closed’ states where one direction of the stream is actually shut down.
//
// Operations on `GIOStream`s cannot be started while another operation on the
// `GIOStream` or its substreams is in progress. Specifically, an application can
// read from the [class@Gio.InputStream] and write to the
// [class@Gio.OutputStream] simultaneously (either in separate threads, or as
// asynchronous operations in the same thread), but an application cannot start
// any `GIOStream` operation while there is a `GIOStream`, `GInputStream` or
// `GOutputStream` operation in progress, and an application can’t start any
// `GInputStream` or `GOutputStream` operation while there is a `GIOStream`
// operation in progress.
//
// This is a product of individual stream operations being associated with a
// given [type@GLib.MainContext] (the thread-default context at the time the
// operation was started), rather than entire streams being associated with a
// single `GMainContext`.
//
// GIO may run operations on `GIOStream`s from other (worker) threads, and this
// may be exposed to application code in the behaviour of wrapper streams, such
// as [class@Gio.BufferedInputStream] or [class@Gio.TlsConnection]. With such
// wrapper APIs, application code may only run operations on the base (wrapped)
// stream when the wrapper stream is idle. Note that the semantics of such
// operations may not be well-defined due to the state the wrapper stream leaves
// the base stream in (though they are guaranteed not to crash).
type IOStream struct {
	gobject.Object
}

var xIOStreamGLibType func() types.GType

func IOStreamGLibType() types.GType {
	return xIOStreamGLibType()
}

func IOStreamNewFromInternalPtr(ptr uintptr) *IOStream {
	cls := &IOStream{}
	cls.Ptr = ptr
	return cls
}

var xIOStreamClearPending func(uintptr)

// Clears the pending flag on @stream.
func (x *IOStream) ClearPending() {

	xIOStreamClearPending(x.GoPointer())

}

var xIOStreamClose func(uintptr, uintptr, **glib.Error) bool

// Closes the stream, releasing resources related to it. This will also
// close the individual input and output streams, if they are not already
// closed.
//
// Once the stream is closed, all other operations will return
// %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
// return an error.
//
// Closing a stream will automatically flush any outstanding buffers
// in the stream.
//
// Streams will be automatically closed when the last reference
// is dropped, but you might want to call this function to make sure
// resources are released as early as possible.
//
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for
// the individual stream for details.
//
// On failure the first error that happened will be reported, but the
// close operation will finish as much as possible. A stream that failed
// to close will still return %G_IO_ERROR_CLOSED for all operations.
// Still, it is important to check and report the error to the user,
// otherwise there might be a loss of data as all data might not be written.
//
// If @cancellable is not NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// Cancelling a close will still leave the stream closed, but some streams
// can use a faster close that doesn't block to e.g. check errors.
//
// The default implementation of this method just calls close on the
// individual input/output streams.
func (x *IOStream) Close(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xIOStreamClose(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xIOStreamCloseAsync func(uintptr, int, uintptr, uintptr, uintptr)

// Requests an asynchronous close of the stream, releasing resources
// related to it. When the operation is finished @callback will be
// called. You can then call g_io_stream_close_finish() to get
// the result of the operation.
//
// For behaviour details see g_io_stream_close().
//
// The asynchronous methods have a default fallback that uses threads
// to implement asynchronicity, so they are optional for inheriting
// classes. However, if you override one you must override all.
func (x *IOStream) CloseAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xIOStreamCloseAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xIOStreamCloseFinish func(uintptr, uintptr, **glib.Error) bool

// Closes a stream.
func (x *IOStream) CloseFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xIOStreamCloseFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xIOStreamGetInputStream func(uintptr) uintptr

// Gets the input stream for this object. This is used
// for reading.
func (x *IOStream) GetInputStream() *InputStream {
	var cls *InputStream

	cret := xIOStreamGetInputStream(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &InputStream{}
	cls.Ptr = cret
	return cls
}

var xIOStreamGetOutputStream func(uintptr) uintptr

// Gets the output stream for this object. This is used for
// writing.
func (x *IOStream) GetOutputStream() *OutputStream {
	var cls *OutputStream

	cret := xIOStreamGetOutputStream(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &OutputStream{}
	cls.Ptr = cret
	return cls
}

var xIOStreamHasPending func(uintptr) bool

// Checks if a stream has pending actions.
func (x *IOStream) HasPending() bool {

	cret := xIOStreamHasPending(x.GoPointer())
	return cret
}

var xIOStreamIsClosed func(uintptr) bool

// Checks if a stream is closed.
func (x *IOStream) IsClosed() bool {

	cret := xIOStreamIsClosed(x.GoPointer())
	return cret
}

var xIOStreamSetPending func(uintptr) bool

// Sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return %FALSE and set
// @error.
func (x *IOStream) SetPending() (bool, error) {
	var cerr *glib.Error

	cret := xIOStreamSetPending(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xIOStreamSpliceAsync func(uintptr, uintptr, IOStreamSpliceFlags, int, uintptr, uintptr, uintptr)

// Asynchronously splice the output stream of @stream1 to the input stream of
// @stream2, and splice the output stream of @stream2 to the input stream of
// @stream1.
//
// When the operation is finished @callback will be called.
// You can then call g_io_stream_splice_finish() to get the
// result of the operation.
func (x *IOStream) SpliceAsync(Stream2Var *IOStream, FlagsVar IOStreamSpliceFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xIOStreamSpliceAsync(x.GoPointer(), Stream2Var.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

func (c *IOStream) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *IOStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xIOStreamSpliceFinish func(uintptr, **glib.Error) bool

// Finishes an asynchronous io stream splice operation.
func IOStreamSpliceFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xIOStreamSpliceFinish(ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibrary("GIO", "libgio-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xIOStreamGLibType, lib, "g_io_stream_get_type")

	core.PuregoSafeRegister(&xIOStreamClearPending, lib, "g_io_stream_clear_pending")
	core.PuregoSafeRegister(&xIOStreamClose, lib, "g_io_stream_close")
	core.PuregoSafeRegister(&xIOStreamCloseAsync, lib, "g_io_stream_close_async")
	core.PuregoSafeRegister(&xIOStreamCloseFinish, lib, "g_io_stream_close_finish")
	core.PuregoSafeRegister(&xIOStreamGetInputStream, lib, "g_io_stream_get_input_stream")
	core.PuregoSafeRegister(&xIOStreamGetOutputStream, lib, "g_io_stream_get_output_stream")
	core.PuregoSafeRegister(&xIOStreamHasPending, lib, "g_io_stream_has_pending")
	core.PuregoSafeRegister(&xIOStreamIsClosed, lib, "g_io_stream_is_closed")
	core.PuregoSafeRegister(&xIOStreamSetPending, lib, "g_io_stream_set_pending")
	core.PuregoSafeRegister(&xIOStreamSpliceAsync, lib, "g_io_stream_splice_async")

	core.PuregoSafeRegister(&xIOStreamSpliceFinish, lib, "g_io_stream_splice_finish")

}
