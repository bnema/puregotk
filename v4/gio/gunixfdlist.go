// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type UnixFDListClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr
}

func (x *UnixFDListClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGReserved1 sets the callback function.
func (x *UnixFDListClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the callback function.
func (x *UnixFDListClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the callback function.
func (x *UnixFDListClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the callback function.
func (x *UnixFDListClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the callback function.
func (x *UnixFDListClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the callback function.
func (x *UnixFDListClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the callback function.
func (x *UnixFDListClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the callback function.
func (x *UnixFDListClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the callback function.
func (x *UnixFDListClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the callback function.
func (x *UnixFDListClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

type UnixFDListPrivate struct {
	_ structs.HostLayout
}

func (x *UnixFDListPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `GUnixFDList` contains a list of file descriptors.  It owns the file
// descriptors that it contains, closing them when finalized.
//
// It may be wrapped in a
// [`GUnixFDMessage`](../gio-unix/class.UnixFDMessage.html) and sent over a
// [class@Gio.Socket] in the `G_SOCKET_FAMILY_UNIX` family by using
// [method@Gio.Socket.send_message] and received using
// [method@Gio.Socket.receive_message].
//
// Before 2.74, `&lt;gio/gunixfdlist.h&gt;` belonged to the UNIX-specific GIO
// interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
//
// Since 2.74, the API is available for Windows.
type UnixFDList struct {
	gobject.Object
}

var xUnixFDListGLibType func() types.GType

func UnixFDListGLibType() types.GType {
	return xUnixFDListGLibType()
}

func UnixFDListNewFromInternalPtr(ptr uintptr) *UnixFDList {
	cls := &UnixFDList{}
	cls.Ptr = ptr
	return cls
}

var xNewUnixFDList func() uintptr

// Creates a new #GUnixFDList containing no file descriptors.
func NewUnixFDList() *UnixFDList {
	var cls *UnixFDList

	cret := xNewUnixFDList()

	if cret == 0 {
		return nil
	}
	cls = &UnixFDList{}
	cls.Ptr = cret
	return cls
}

var xNewUnixFDListFromArray func([]int, int) uintptr

// Creates a new #GUnixFDList containing the file descriptors given in
// @fds.  The file descriptors become the property of the new list and
// may no longer be used by the caller.  The array itself is owned by
// the caller.
//
// Each file descriptor in the array should be set to close-on-exec.
//
// If @n_fds is -1 then @fds must be terminated with -1.
func NewUnixFDListFromArray(FdsVar []int, NFdsVar int) *UnixFDList {
	var cls *UnixFDList

	cret := xNewUnixFDListFromArray(FdsVar, NFdsVar)

	if cret == 0 {
		return nil
	}
	cls = &UnixFDList{}
	cls.Ptr = cret
	return cls
}

var xUnixFDListAppend func(uintptr, int, **glib.Error) int

// Adds a file descriptor to @list.
//
// The file descriptor is duplicated using dup(). You keep your copy
// of the descriptor and the copy contained in @list will be closed
// when @list is finalized.
//
// A possible cause of failure is exceeding the per-process or
// system-wide file descriptor limit.
//
// The index of the file descriptor in the list is returned.  If you use
// this index with g_unix_fd_list_get() then you will receive back a
// duplicated copy of the same file descriptor.
func (x *UnixFDList) Append(FdVar int) (int, error) {
	var cerr *glib.Error

	cret := xUnixFDListAppend(x.GoPointer(), FdVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixFDListGet func(uintptr, int, **glib.Error) int

// Gets a file descriptor out of @list.
//
// @index_ specifies the index of the file descriptor to get.  It is a
// programmer error for @index_ to be out of range; see
// g_unix_fd_list_get_length().
//
// The file descriptor is duplicated using dup() and set as
// close-on-exec before being returned.  You must call close() on it
// when you are done.
//
// A possible cause of failure is exceeding the per-process or
// system-wide file descriptor limit.
func (x *UnixFDList) Get(IndexVar int) (int, error) {
	var cerr *glib.Error

	cret := xUnixFDListGet(x.GoPointer(), IndexVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixFDListGetLength func(uintptr) int

// Gets the length of @list (ie: the number of file descriptors
// contained within).
func (x *UnixFDList) GetLength() int {

	cret := xUnixFDListGetLength(x.GoPointer())
	return cret
}

var xUnixFDListPeekFds func(uintptr, int) uintptr

// Returns the array of file descriptors that is contained in this
// object.
//
// After this call, the descriptors remain the property of @list.  The
// caller must not close them and must not free the array.  The array is
// valid only until @list is changed in any way.
//
// If @length is non-%NULL then it is set to the number of file
// descriptors in the returned array. The returned array is also
// terminated with -1.
//
// This function never returns %NULL. In case there are no file
// descriptors contained in @list, an empty array is returned.
func (x *UnixFDList) PeekFds(LengthVar int) uintptr {

	cret := xUnixFDListPeekFds(x.GoPointer(), LengthVar)
	return cret
}

var xUnixFDListStealFds func(uintptr, int) uintptr

// Returns the array of file descriptors that is contained in this
// object.
//
// After this call, the descriptors are no longer contained in
// @list. Further calls will return an empty list (unless more
// descriptors have been added).
//
// The return result of this function must be freed with g_free().
// The caller is also responsible for closing all of the file
// descriptors.  The file descriptors in the array are set to
// close-on-exec.
//
// If @length is non-%NULL then it is set to the number of file
// descriptors in the returned array. The returned array is also
// terminated with -1.
//
// This function never returns %NULL. In case there are no file
// descriptors contained in @list, an empty array is returned.
func (x *UnixFDList) StealFds(LengthVar int) uintptr {

	cret := xUnixFDListStealFds(x.GoPointer(), LengthVar)
	return cret
}

func (c *UnixFDList) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *UnixFDList) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibrary("GIO", "libgio-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xUnixFDListGLibType, lib, "g_unix_fd_list_get_type")

	core.PuregoSafeRegister(&xNewUnixFDList, lib, "g_unix_fd_list_new")
	core.PuregoSafeRegister(&xNewUnixFDListFromArray, lib, "g_unix_fd_list_new_from_array")

	core.PuregoSafeRegister(&xUnixFDListAppend, lib, "g_unix_fd_list_append")
	core.PuregoSafeRegister(&xUnixFDListGet, lib, "g_unix_fd_list_get")
	core.PuregoSafeRegister(&xUnixFDListGetLength, lib, "g_unix_fd_list_get_length")
	core.PuregoSafeRegister(&xUnixFDListPeekFds, lib, "g_unix_fd_list_peek_fds")
	core.PuregoSafeRegister(&xUnixFDListStealFds, lib, "g_unix_fd_list_steal_fds")

}
