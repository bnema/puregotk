// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// `GMenu` is a simple implementation of [class@Gio.MenuModel].
// You populate a `GMenu` by adding [class@Gio.MenuItem] instances to it.
//
// There are some convenience functions to allow you to directly
// add items (avoiding [class@Gio.MenuItem]) for the common cases. To add
// a regular item, use [method@Gio.Menu.insert]. To add a section, use
// [method@Gio.Menu.insert_section]. To add a submenu, use
// [method@Gio.Menu.insert_submenu].
type Menu struct {
	MenuModel
}

var xMenuGLibType func() types.GType

func MenuGLibType() types.GType {
	return xMenuGLibType()
}

func MenuNewFromInternalPtr(ptr uintptr) *Menu {
	cls := &Menu{}
	cls.Ptr = ptr
	return cls
}

var xNewMenu func() uintptr

// Creates a new #GMenu.
//
// The new menu has no items.
func NewMenu() *Menu {
	var cls *Menu

	cret := xNewMenu()

	if cret == 0 {
		return nil
	}
	cls = &Menu{}
	cls.Ptr = cret
	return cls
}

var xMenuAppend func(uintptr, uintptr, uintptr)

// Convenience function for appending a normal menu item to the end of
// @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (x *Menu) Append(LabelVar *string, DetailedActionVar *string) {

	xMenuAppend(x.GoPointer(), core.NullableStringToPtr(LabelVar), core.NullableStringToPtr(DetailedActionVar))

}

var xMenuAppendItem func(uintptr, uintptr)

// Appends @item to the end of @menu.
//
// See g_menu_insert_item() for more information.
func (x *Menu) AppendItem(ItemVar *MenuItem) {

	xMenuAppendItem(x.GoPointer(), ItemVar.GoPointer())

}

var xMenuAppendSection func(uintptr, uintptr, uintptr)

// Convenience function for appending a section menu item to the end of
// @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
// more flexible alternative.
func (x *Menu) AppendSection(LabelVar *string, SectionVar *MenuModel) {

	xMenuAppendSection(x.GoPointer(), core.NullableStringToPtr(LabelVar), SectionVar.GoPointer())

}

var xMenuAppendSubmenu func(uintptr, uintptr, uintptr)

// Convenience function for appending a submenu menu item to the end of
// @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
// more flexible alternative.
func (x *Menu) AppendSubmenu(LabelVar *string, SubmenuVar *MenuModel) {

	xMenuAppendSubmenu(x.GoPointer(), core.NullableStringToPtr(LabelVar), SubmenuVar.GoPointer())

}

var xMenuFreeze func(uintptr)

// Marks @menu as frozen.
//
// After the menu is frozen, it is an error to attempt to make any
// changes to it.  In effect this means that the #GMenu API must no
// longer be used.
//
// This function causes g_menu_model_is_mutable() to begin returning
// %FALSE, which has some positive performance implications.
func (x *Menu) Freeze() {

	xMenuFreeze(x.GoPointer())

}

var xMenuInsert func(uintptr, int, uintptr, uintptr)

// Convenience function for inserting a normal menu item into @menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (x *Menu) Insert(PositionVar int, LabelVar *string, DetailedActionVar *string) {

	xMenuInsert(x.GoPointer(), PositionVar, core.NullableStringToPtr(LabelVar), core.NullableStringToPtr(DetailedActionVar))

}

var xMenuInsertItem func(uintptr, int, uintptr)

// Inserts @item into @menu.
//
// The "insertion" is actually done by copying all of the attribute and
// link values of @item and using them to form a new item within @menu.
// As such, @item itself is not really inserted, but rather, a menu item
// that is exactly the same as the one presently described by @item.
//
// This means that @item is essentially useless after the insertion
// occurs.  Any changes you make to it are ignored unless it is inserted
// again (at which point its updated values will be copied).
//
// You should probably just free @item once you're done.
//
// There are many convenience functions to take care of common cases.
// See g_menu_insert(), g_menu_insert_section() and
// g_menu_insert_submenu() as well as "prepend" and "append" variants of
// each of these functions.
func (x *Menu) InsertItem(PositionVar int, ItemVar *MenuItem) {

	xMenuInsertItem(x.GoPointer(), PositionVar, ItemVar.GoPointer())

}

var xMenuInsertSection func(uintptr, int, uintptr, uintptr)

// Convenience function for inserting a section menu item into @menu.
// Combine g_menu_item_new_section() and g_menu_insert_item() for a more
// flexible alternative.
func (x *Menu) InsertSection(PositionVar int, LabelVar *string, SectionVar *MenuModel) {

	xMenuInsertSection(x.GoPointer(), PositionVar, core.NullableStringToPtr(LabelVar), SectionVar.GoPointer())

}

var xMenuInsertSubmenu func(uintptr, int, uintptr, uintptr)

// Convenience function for inserting a submenu menu item into @menu.
// Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
// flexible alternative.
func (x *Menu) InsertSubmenu(PositionVar int, LabelVar *string, SubmenuVar *MenuModel) {

	xMenuInsertSubmenu(x.GoPointer(), PositionVar, core.NullableStringToPtr(LabelVar), SubmenuVar.GoPointer())

}

var xMenuPrepend func(uintptr, uintptr, uintptr)

// Convenience function for prepending a normal menu item to the start
// of @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (x *Menu) Prepend(LabelVar *string, DetailedActionVar *string) {

	xMenuPrepend(x.GoPointer(), core.NullableStringToPtr(LabelVar), core.NullableStringToPtr(DetailedActionVar))

}

var xMenuPrependItem func(uintptr, uintptr)

// Prepends @item to the start of @menu.
//
// See g_menu_insert_item() for more information.
func (x *Menu) PrependItem(ItemVar *MenuItem) {

	xMenuPrependItem(x.GoPointer(), ItemVar.GoPointer())

}

var xMenuPrependSection func(uintptr, uintptr, uintptr)

// Convenience function for prepending a section menu item to the start
// of @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for
// a more flexible alternative.
func (x *Menu) PrependSection(LabelVar *string, SectionVar *MenuModel) {

	xMenuPrependSection(x.GoPointer(), core.NullableStringToPtr(LabelVar), SectionVar.GoPointer())

}

var xMenuPrependSubmenu func(uintptr, uintptr, uintptr)

// Convenience function for prepending a submenu menu item to the start
// of @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
// a more flexible alternative.
func (x *Menu) PrependSubmenu(LabelVar *string, SubmenuVar *MenuModel) {

	xMenuPrependSubmenu(x.GoPointer(), core.NullableStringToPtr(LabelVar), SubmenuVar.GoPointer())

}

var xMenuRemove func(uintptr, int)

// Removes an item from the menu.
//
// @position gives the index of the item to remove.
//
// It is an error if position is not in range the range from 0 to one
// less than the number of items in the menu.
//
// It is not possible to remove items by identity since items are added
// to the menu simply by copying their links and attributes (ie:
// identity of the item itself is not preserved).
func (x *Menu) Remove(PositionVar int) {

	xMenuRemove(x.GoPointer(), PositionVar)

}

var xMenuRemoveAll func(uintptr)

// Removes all items in the menu.
func (x *Menu) RemoveAll() {

	xMenuRemoveAll(x.GoPointer())

}

func (c *Menu) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Menu) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// #GMenuItem is an opaque structure type.  You must access it using the
// functions below.
type MenuItem struct {
	gobject.Object
}

var xMenuItemGLibType func() types.GType

func MenuItemGLibType() types.GType {
	return xMenuItemGLibType()
}

func MenuItemNewFromInternalPtr(ptr uintptr) *MenuItem {
	cls := &MenuItem{}
	cls.Ptr = ptr
	return cls
}

var xNewMenuItem func(uintptr, uintptr) uintptr

// Creates a new #GMenuItem.
//
// If @label is non-%NULL it is used to set the "label" attribute of the
// new item.
//
// If @detailed_action is non-%NULL it is used to set the "action" and
// possibly the "target" attribute of the new item.  See
// g_menu_item_set_detailed_action() for more information.
func NewMenuItem(LabelVar *string, DetailedActionVar *string) *MenuItem {
	var cls *MenuItem

	cret := xNewMenuItem(core.NullableStringToPtr(LabelVar), core.NullableStringToPtr(DetailedActionVar))

	if cret == 0 {
		return nil
	}
	cls = &MenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewMenuItemFromModel func(uintptr, int) uintptr

// Creates a #GMenuItem as an exact copy of an existing menu item in a
// #GMenuModel.
//
// @item_index must be valid (ie: be sure to call
// g_menu_model_get_n_items() first).
func NewMenuItemFromModel(ModelVar *MenuModel, ItemIndexVar int) *MenuItem {
	var cls *MenuItem

	cret := xNewMenuItemFromModel(ModelVar.GoPointer(), ItemIndexVar)

	if cret == 0 {
		return nil
	}
	cls = &MenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewMenuItemSection func(uintptr, uintptr) uintptr

// Creates a new #GMenuItem representing a section.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
//
// The effect of having one menu appear as a section of another is
// exactly as it sounds: the items from @section become a direct part of
// the menu that @menu_item is added to.
//
// Visual separation is typically displayed between two non-empty
// sections.  If @label is non-%NULL then it will be incorporated into
// this visual indication.  This allows for labeled subsections of a
// menu.
//
// As a simple example, consider a typical "Edit" menu from a simple
// program.  It probably contains an "Undo" and "Redo" item, followed by
// a separator, followed by "Cut", "Copy" and "Paste".
//
// This would be accomplished by creating three #GMenu instances.  The
// first would be populated with the "Undo" and "Redo" items, and the
// second with the "Cut", "Copy" and "Paste" items.  The first and
// second menus would then be added as submenus of the third.  In XML
// format, this would look something like the following:
// |[
// &lt;menu id='edit-menu'&gt;
//
//	&lt;section&gt;
//	  &lt;item label='Undo'/&gt;
//	  &lt;item label='Redo'/&gt;
//	&lt;/section&gt;
//	&lt;section&gt;
//	  &lt;item label='Cut'/&gt;
//	  &lt;item label='Copy'/&gt;
//	  &lt;item label='Paste'/&gt;
//	&lt;/section&gt;
//
// &lt;/menu&gt;
// ]|
//
// The following example is exactly equivalent.  It is more illustrative
// of the exact relationship between the menus and items (keeping in
// mind that the 'link' element defines a new menu that is linked to the
// containing one).  The style of the second example is more verbose and
// difficult to read (and therefore not recommended except for the
// purpose of understanding what is really going on).
// |[
// &lt;menu id='edit-menu'&gt;
//
//	&lt;item&gt;
//	  &lt;link name='section'&gt;
//	    &lt;item label='Undo'/&gt;
//	    &lt;item label='Redo'/&gt;
//	  &lt;/link&gt;
//	&lt;/item&gt;
//	&lt;item&gt;
//	  &lt;link name='section'&gt;
//	    &lt;item label='Cut'/&gt;
//	    &lt;item label='Copy'/&gt;
//	    &lt;item label='Paste'/&gt;
//	  &lt;/link&gt;
//	&lt;/item&gt;
//
// &lt;/menu&gt;
// ]|
func NewMenuItemSection(LabelVar *string, SectionVar *MenuModel) *MenuItem {
	var cls *MenuItem

	cret := xNewMenuItemSection(core.NullableStringToPtr(LabelVar), SectionVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &MenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewMenuItemSubmenu func(uintptr, uintptr) uintptr

// Creates a new #GMenuItem representing a submenu.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
func NewMenuItemSubmenu(LabelVar *string, SubmenuVar *MenuModel) *MenuItem {
	var cls *MenuItem

	cret := xNewMenuItemSubmenu(core.NullableStringToPtr(LabelVar), SubmenuVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &MenuItem{}
	cls.Ptr = cret
	return cls
}

var xMenuItemGetAttribute func(uintptr, string, string, ...interface{}) bool

// Queries the named @attribute on @menu_item.
//
// If the attribute exists and matches the #GVariantType corresponding
// to @format_string then @format_string is used to deconstruct the
// value into the positional parameters and %TRUE is returned.
//
// If the attribute does not exist, or it does exist but has the wrong
// type, then the positional parameters are ignored and %FALSE is
// returned.
func (x *MenuItem) GetAttribute(AttributeVar string, FormatStringVar string, varArgs ...interface{}) bool {

	cret := xMenuItemGetAttribute(x.GoPointer(), AttributeVar, FormatStringVar, varArgs...)
	return cret
}

var xMenuItemGetAttributeValue func(uintptr, string, *glib.VariantType) *glib.Variant

// Queries the named @attribute on @menu_item.
//
// If @expected_type is specified and the attribute does not have this
// type, %NULL is returned.  %NULL is also returned if the attribute
// simply does not exist.
func (x *MenuItem) GetAttributeValue(AttributeVar string, ExpectedTypeVar *glib.VariantType) *glib.Variant {

	cret := xMenuItemGetAttributeValue(x.GoPointer(), AttributeVar, ExpectedTypeVar)
	return cret
}

var xMenuItemGetLink func(uintptr, string) uintptr

// Queries the named @link on @menu_item.
func (x *MenuItem) GetLink(LinkVar string) *MenuModel {
	var cls *MenuModel

	cret := xMenuItemGetLink(x.GoPointer(), LinkVar)

	if cret == 0 {
		return nil
	}
	cls = &MenuModel{}
	cls.Ptr = cret
	return cls
}

var xMenuItemSetActionAndTarget func(uintptr, uintptr, uintptr, ...interface{})

// Sets or unsets the "action" and "target" attributes of @menu_item.
//
// If @action is %NULL then both the "action" and "target" attributes
// are unset (and @format_string is ignored along with the positional
// parameters).
//
// If @action is non-%NULL then the "action" attribute is set.
// @format_string is then inspected.  If it is non-%NULL then the proper
// position parameters are collected to create a #GVariant instance to
// use as the target value.  If it is %NULL then the positional
// parameters are ignored and the "target" attribute is unset.
//
// See also g_menu_item_set_action_and_target_value() for an equivalent
// call that directly accepts a #GVariant.  See
// g_menu_item_set_detailed_action() for a more convenient version that
// works with string-typed targets.
//
// See also g_menu_item_set_action_and_target_value() for a
// description of the semantics of the action and target attributes.
func (x *MenuItem) SetActionAndTarget(ActionVar *string, FormatStringVar *string, varArgs ...interface{}) {

	xMenuItemSetActionAndTarget(x.GoPointer(), core.NullableStringToPtr(ActionVar), core.NullableStringToPtr(FormatStringVar), varArgs...)

}

var xMenuItemSetActionAndTargetValue func(uintptr, uintptr, *glib.Variant)

// Sets or unsets the "action" and "target" attributes of @menu_item.
//
// If @action is %NULL then both the "action" and "target" attributes
// are unset (and @target_value is ignored).
//
// If @action is non-%NULL then the "action" attribute is set.  The
// "target" attribute is then set to the value of @target_value if it is
// non-%NULL or unset otherwise.
//
// Normal menu items (ie: not submenu, section or other custom item
// types) are expected to have the "action" attribute set to identify
// the action that they are associated with.  The state type of the
// action help to determine the disposition of the menu item.  See
// #GAction and #GActionGroup for an overview of actions.
//
// In general, clicking on the menu item will result in activation of
// the named action with the "target" attribute given as the parameter
// to the action invocation.  If the "target" attribute is not set then
// the action is invoked with no parameter.
//
// If the action has no state then the menu item is usually drawn as a
// plain menu item (ie: with no additional decoration).
//
// If the action has a boolean state then the menu item is usually drawn
// as a toggle menu item (ie: with a checkmark or equivalent
// indication).  The item should be marked as 'toggled' or 'checked'
// when the boolean state is %TRUE.
//
// If the action has a string state then the menu item is usually drawn
// as a radio menu item (ie: with a radio bullet or equivalent
// indication).  The item should be marked as 'selected' when the string
// state is equal to the value of the @target property.
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_detailed_action() for two equivalent calls that are
// probably more convenient for most uses.
func (x *MenuItem) SetActionAndTargetValue(ActionVar *string, TargetValueVar *glib.Variant) {

	xMenuItemSetActionAndTargetValue(x.GoPointer(), core.NullableStringToPtr(ActionVar), TargetValueVar)

}

var xMenuItemSetAttribute func(uintptr, string, uintptr, ...interface{})

// Sets or unsets an attribute on @menu_item.
//
// The attribute to set or unset is specified by @attribute. This
// can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
// %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
// attribute name.
// Attribute names are restricted to lowercase characters, numbers
// and '-'. Furthermore, the names must begin with a lowercase character,
// must not end with a '-', and must not contain consecutive dashes.
//
// If @format_string is non-%NULL then the proper position parameters
// are collected to create a #GVariant instance to use as the attribute
// value.  If it is %NULL then the positional parameterrs are ignored
// and the named attribute is unset.
//
// See also g_menu_item_set_attribute_value() for an equivalent call
// that directly accepts a #GVariant.
func (x *MenuItem) SetAttribute(AttributeVar string, FormatStringVar *string, varArgs ...interface{}) {

	xMenuItemSetAttribute(x.GoPointer(), AttributeVar, core.NullableStringToPtr(FormatStringVar), varArgs...)

}

var xMenuItemSetAttributeValue func(uintptr, string, *glib.Variant)

// Sets or unsets an attribute on @menu_item.
//
// The attribute to set or unset is specified by @attribute. This
// can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
// %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
// attribute name.
// Attribute names are restricted to lowercase characters, numbers
// and '-'. Furthermore, the names must begin with a lowercase character,
// must not end with a '-', and must not contain consecutive dashes.
//
// must consist only of lowercase
// ASCII characters, digits and '-'.
//
// If @value is non-%NULL then it is used as the new value for the
// attribute.  If @value is %NULL then the attribute is unset. If
// the @value #GVariant is floating, it is consumed.
//
// See also g_menu_item_set_attribute() for a more convenient way to do
// the same.
func (x *MenuItem) SetAttributeValue(AttributeVar string, ValueVar *glib.Variant) {

	xMenuItemSetAttributeValue(x.GoPointer(), AttributeVar, ValueVar)

}

var xMenuItemSetDetailedAction func(uintptr, string)

// Sets the "action" and possibly the "target" attribute of @menu_item.
//
// The format of @detailed_action is the same format parsed by
// g_action_parse_detailed_name().
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but
// slightly less convenient) alternatives.
//
// See also g_menu_item_set_action_and_target_value() for a description of
// the semantics of the action and target attributes.
func (x *MenuItem) SetDetailedAction(DetailedActionVar string) {

	xMenuItemSetDetailedAction(x.GoPointer(), DetailedActionVar)

}

var xMenuItemSetIcon func(uintptr, uintptr)

// Sets (or unsets) the icon on @menu_item.
//
// This call is the same as calling g_icon_serialize() and using the
// result as the value to g_menu_item_set_attribute_value() for
// %G_MENU_ATTRIBUTE_ICON.
//
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu.  Don't use it on
// menu items corresponding to verbs (eg: stock icons for 'Save' or
// 'Quit').
//
// If @icon is %NULL then the icon is unset.
func (x *MenuItem) SetIcon(IconVar Icon) {

	xMenuItemSetIcon(x.GoPointer(), IconVar.GoPointer())

}

var xMenuItemSetLabel func(uintptr, uintptr)

// Sets or unsets the "label" attribute of @menu_item.
//
// If @label is non-%NULL it is used as the label for the menu item.  If
// it is %NULL then the label attribute is unset.
func (x *MenuItem) SetLabel(LabelVar *string) {

	xMenuItemSetLabel(x.GoPointer(), core.NullableStringToPtr(LabelVar))

}

var xMenuItemSetLink func(uintptr, string, uintptr)

// Creates a link from @menu_item to @model if non-%NULL, or unsets it.
//
// Links are used to establish a relationship between a particular menu
// item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
// associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
// is used to create a section. Other types of link can be used, but there
// is no guarantee that clients will be able to make sense of them.
// Link types are restricted to lowercase characters, numbers
// and '-'. Furthermore, the names must begin with a lowercase character,
// must not end with a '-', and must not contain consecutive dashes.
func (x *MenuItem) SetLink(LinkVar string, ModelVar *MenuModel) {

	xMenuItemSetLink(x.GoPointer(), LinkVar, ModelVar.GoPointer())

}

var xMenuItemSetSection func(uintptr, uintptr)

// Sets or unsets the "section" link of @menu_item to @section.
//
// The effect of having one menu appear as a section of another is
// exactly as it sounds: the items from @section become a direct part of
// the menu that @menu_item is added to.  See g_menu_item_new_section()
// for more information about what it means for a menu item to be a
// section.
func (x *MenuItem) SetSection(SectionVar *MenuModel) {

	xMenuItemSetSection(x.GoPointer(), SectionVar.GoPointer())

}

var xMenuItemSetSubmenu func(uintptr, uintptr)

// Sets or unsets the "submenu" link of @menu_item to @submenu.
//
// If @submenu is non-%NULL, it is linked to.  If it is %NULL then the
// link is unset.
//
// The effect of having one menu appear as a submenu of another is
// exactly as it sounds.
func (x *MenuItem) SetSubmenu(SubmenuVar *MenuModel) {

	xMenuItemSetSubmenu(x.GoPointer(), SubmenuVar.GoPointer())

}

func (c *MenuItem) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *MenuItem) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMenuGLibType, libs, "g_menu_get_type")

	core.PuregoSafeRegister(&xNewMenu, libs, "g_menu_new")

	core.PuregoSafeRegister(&xMenuAppend, libs, "g_menu_append")
	core.PuregoSafeRegister(&xMenuAppendItem, libs, "g_menu_append_item")
	core.PuregoSafeRegister(&xMenuAppendSection, libs, "g_menu_append_section")
	core.PuregoSafeRegister(&xMenuAppendSubmenu, libs, "g_menu_append_submenu")
	core.PuregoSafeRegister(&xMenuFreeze, libs, "g_menu_freeze")
	core.PuregoSafeRegister(&xMenuInsert, libs, "g_menu_insert")
	core.PuregoSafeRegister(&xMenuInsertItem, libs, "g_menu_insert_item")
	core.PuregoSafeRegister(&xMenuInsertSection, libs, "g_menu_insert_section")
	core.PuregoSafeRegister(&xMenuInsertSubmenu, libs, "g_menu_insert_submenu")
	core.PuregoSafeRegister(&xMenuPrepend, libs, "g_menu_prepend")
	core.PuregoSafeRegister(&xMenuPrependItem, libs, "g_menu_prepend_item")
	core.PuregoSafeRegister(&xMenuPrependSection, libs, "g_menu_prepend_section")
	core.PuregoSafeRegister(&xMenuPrependSubmenu, libs, "g_menu_prepend_submenu")
	core.PuregoSafeRegister(&xMenuRemove, libs, "g_menu_remove")
	core.PuregoSafeRegister(&xMenuRemoveAll, libs, "g_menu_remove_all")

	core.PuregoSafeRegister(&xMenuItemGLibType, libs, "g_menu_item_get_type")

	core.PuregoSafeRegister(&xNewMenuItem, libs, "g_menu_item_new")
	core.PuregoSafeRegister(&xNewMenuItemFromModel, libs, "g_menu_item_new_from_model")
	core.PuregoSafeRegister(&xNewMenuItemSection, libs, "g_menu_item_new_section")
	core.PuregoSafeRegister(&xNewMenuItemSubmenu, libs, "g_menu_item_new_submenu")

	core.PuregoSafeRegister(&xMenuItemGetAttribute, libs, "g_menu_item_get_attribute")
	core.PuregoSafeRegister(&xMenuItemGetAttributeValue, libs, "g_menu_item_get_attribute_value")
	core.PuregoSafeRegister(&xMenuItemGetLink, libs, "g_menu_item_get_link")
	core.PuregoSafeRegister(&xMenuItemSetActionAndTarget, libs, "g_menu_item_set_action_and_target")
	core.PuregoSafeRegister(&xMenuItemSetActionAndTargetValue, libs, "g_menu_item_set_action_and_target_value")
	core.PuregoSafeRegister(&xMenuItemSetAttribute, libs, "g_menu_item_set_attribute")
	core.PuregoSafeRegister(&xMenuItemSetAttributeValue, libs, "g_menu_item_set_attribute_value")
	core.PuregoSafeRegister(&xMenuItemSetDetailedAction, libs, "g_menu_item_set_detailed_action")
	core.PuregoSafeRegister(&xMenuItemSetIcon, libs, "g_menu_item_set_icon")
	core.PuregoSafeRegister(&xMenuItemSetLabel, libs, "g_menu_item_set_label")
	core.PuregoSafeRegister(&xMenuItemSetLink, libs, "g_menu_item_set_link")
	core.PuregoSafeRegister(&xMenuItemSetSection, libs, "g_menu_item_set_section")
	core.PuregoSafeRegister(&xMenuItemSetSubmenu, libs, "g_menu_item_set_submenu")

}
