// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

// Struct used in [func@Gio.DBusError.register_error_domain].
type DBusErrorEntry struct {
	_ structs.HostLayout

	ErrorCode int32

	DbusErrorName uintptr
}

func (x *DBusErrorEntry) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xDbusErrorEncodeGerror func(*glib.Error) string

// Creates a D-Bus error name to use for @error.
//
// If @error matches a registered error (see
// [func@Gio.DBusError.register_error]), the corresponding D-Bus error name
// will be returned.
//
// Otherwise the a name of the form
// `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
// will be used. This allows other GDBus applications to map the error
// on the wire back to a [type@GLib.Error] using
// [func@Gio.DBusError.new_for_dbus_error].
//
// This function is typically only used in object mappings to put a
// [type@GLib.Error] on the wire. Regular applications should not use it.
func DbusErrorEncodeGerror(ErrorVar *glib.Error) string {

	cret := xDbusErrorEncodeGerror(ErrorVar)
	return cret
}

var xDbusErrorGetRemoteError func(*glib.Error) string

// Gets the D-Bus error name used for @error, if any.
//
// This function is guaranteed to return a D-Bus error name for all
// [type@GLib.Error]s returned from functions handling remote method calls
// (for example, [method@Gio.DBusConnection.call_finish]) unless
// [func@Gio.DBusError.strip_remote_error] has already been used on @error.
func DbusErrorGetRemoteError(ErrorVar *glib.Error) string {

	cret := xDbusErrorGetRemoteError(ErrorVar)
	return cret
}

var xDbusErrorIsRemoteError func(*glib.Error) bool

// Checks if @error represents an error received via D-Bus from a remote peer.
//
// If so, use [func@Gio.DBusError.get_remote_error] to get the name of the error.
func DbusErrorIsRemoteError(ErrorVar *glib.Error) bool {

	cret := xDbusErrorIsRemoteError(ErrorVar)
	return cret
}

var xDbusErrorNewForDbusError func(string, string) *glib.Error

// Creates a [type@GLib.Error] based on the contents of @dbus_error_name and
// @dbus_error_message.
//
// Errors registered with [func@Gio.DBusError.register_error] will be looked
// up using @dbus_error_name and if a match is found, the error domain
// and code is used. Applications can use [func@Gio.DBusError.get_remote_error]
// to recover @dbus_error_name.
//
// If a match against a registered error is not found and the D-Bus
// error name is in a form as returned by [func@Gio.DBusError.encode_gerror]
// the error domain and code encoded in the name is used to
// create the [type@GLib.Error]. Also, @dbus_error_name is added to the error
// message such that it can be recovered with
// [func@Gio.DBusError.get_remote_error].
//
// Otherwise, a [type@GLib.Error] with the error code
// [error@Gio.IOErrorEnum.DBUS_ERROR]
// in the [error@Gio.IOErrorEnum] error domain is returned. Also, @dbus_error_name is
// added to the error message such that it can be recovered with
// [func@Gio.DBusError.get_remote_error].
//
// In all three cases, @dbus_error_name can always be recovered from the
// returned [type@GLib.Error] using the [func@Gio.DBusError.get_remote_error]
// function (unless [func@Gio.DBusError.strip_remote_error] hasnâ€™t been used on
// the returned error).
//
// This function is typically only used in object mappings to prepare
// [type@GLib.Error] instances for applications. Regular applications should not
// use it.
func DbusErrorNewForDbusError(DbusErrorNameVar string, DbusErrorMessageVar string) *glib.Error {

	cret := xDbusErrorNewForDbusError(DbusErrorNameVar, DbusErrorMessageVar)
	return cret
}

var xDbusErrorRegisterError func(glib.Quark, int, string) bool

// Creates an association mapping between @dbus_error_name and
// [type@GLib.Error]s specified by @error_domain and @error_code.
//
// This is typically done in the function that returns the [type@GLib.Quark] for
// an error domain.
func DbusErrorRegisterError(ErrorDomainVar glib.Quark, ErrorCodeVar int, DbusErrorNameVar string) bool {

	cret := xDbusErrorRegisterError(ErrorDomainVar, ErrorCodeVar, DbusErrorNameVar)
	return cret
}

var xDbusErrorRegisterErrorDomain func(string, uint, []DBusErrorEntry, uint)

// Helper function for associating a [type@GLib.Error] error domain with D-Bus
// error names.
//
// While @quark_volatile has a `volatile` qualifier, this is a historical
// artifact and the argument passed to it should not be `volatile`.
func DbusErrorRegisterErrorDomain(ErrorDomainQuarkNameVar string, QuarkVolatileVar uint, EntriesVar []DBusErrorEntry, NumEntriesVar uint) {

	xDbusErrorRegisterErrorDomain(ErrorDomainQuarkNameVar, QuarkVolatileVar, EntriesVar, NumEntriesVar)

}

var xDbusErrorStripRemoteError func(*glib.Error) bool

// Looks for extra information in the error message used to recover
// the D-Bus error name and strips it if found.
//
// If stripped, the
// message field in @error will correspond exactly to what was
// received on the wire.
//
// This is typically used when presenting errors to the end user.
func DbusErrorStripRemoteError(ErrorVar *glib.Error) bool {

	cret := xDbusErrorStripRemoteError(ErrorVar)
	return cret
}

var xDbusErrorUnregisterError func(glib.Quark, int, string) bool

// Destroys an association previously set up with
// [func@Gio.DBusError.register_error].
func DbusErrorUnregisterError(ErrorDomainVar glib.Quark, ErrorCodeVar int, DbusErrorNameVar string) bool {

	cret := xDbusErrorUnregisterError(ErrorDomainVar, ErrorCodeVar, DbusErrorNameVar)
	return cret
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xDbusErrorEncodeGerror, libs, "g_dbus_error_encode_gerror")
	core.PuregoSafeRegister(&xDbusErrorGetRemoteError, libs, "g_dbus_error_get_remote_error")
	core.PuregoSafeRegister(&xDbusErrorIsRemoteError, libs, "g_dbus_error_is_remote_error")
	core.PuregoSafeRegister(&xDbusErrorNewForDbusError, libs, "g_dbus_error_new_for_dbus_error")
	core.PuregoSafeRegister(&xDbusErrorRegisterError, libs, "g_dbus_error_register_error")
	core.PuregoSafeRegister(&xDbusErrorRegisterErrorDomain, libs, "g_dbus_error_register_error_domain")
	core.PuregoSafeRegister(&xDbusErrorStripRemoteError, libs, "g_dbus_error_strip_remote_error")
	core.PuregoSafeRegister(&xDbusErrorUnregisterError, libs, "g_dbus_error_unregister_error")

}
