// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// `GDBusAuthObserver` provides a mechanism for participating
// in how a [class@Gio.DBusServer] (or a [class@Gio.DBusConnection])
// authenticates remote peers.
//
// Simply instantiate a `GDBusAuthObserver` and connect to the
// signals you are interested in. Note that new signals may be added
// in the future.
//
// ## Controlling Authentication Mechanisms
//
// By default, a `GDBusServer` or server-side `GDBusConnection` will allow
// any authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such
// as Linux and the BSD family, you would use a signal handler like this:
//
// ```c
// static gboolean
// on_allow_mechanism (GDBusAuthObserver *observer,
//
//	const gchar       *mechanism,
//	gpointer           user_data)
//
//	{
//	  if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
//	    {
//	      return TRUE;
//	    }
//
//	  return FALSE;
//	}
//
// ```
//
// ## Controlling Authorization
//
// By default, a `GDBusServer` or server-side `GDBusConnection` will accept
// connections from any successfully authenticated user (but not from
// anonymous connections using the `ANONYMOUS` mechanism). If you only
// want to allow D-Bus connections from processes owned by the same uid
// as the server, since GLib 2.68, you should use the
// `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag. Itâ€™s equivalent
// to the following signal handler:
//
// ```c
// static gboolean
// on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//
//	GIOStream         *stream,
//	GCredentials      *credentials,
//	gpointer           user_data)
//
//	{
//	  gboolean authorized;
//
//	  authorized = FALSE;
//	  if (credentials != NULL)
//	    {
//	      GCredentials *own_credentials;
//	      own_credentials = g_credentials_new ();
//	      if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//	        authorized = TRUE;
//	      g_object_unref (own_credentials);
//	    }
//
//	  return authorized;
//	}
//
// ```
type DBusAuthObserver struct {
	gobject.Object
}

var xDBusAuthObserverGLibType func() types.GType

func DBusAuthObserverGLibType() types.GType {
	return xDBusAuthObserverGLibType()
}

func DBusAuthObserverNewFromInternalPtr(ptr uintptr) *DBusAuthObserver {
	cls := &DBusAuthObserver{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusAuthObserver func() uintptr

// Creates a new #GDBusAuthObserver object.
func NewDBusAuthObserver() *DBusAuthObserver {
	var cls *DBusAuthObserver

	cret := xNewDBusAuthObserver()

	if cret == 0 {
		return nil
	}
	cls = &DBusAuthObserver{}
	cls.Ptr = cret
	return cls
}

var xDBusAuthObserverAllowMechanism func(uintptr, string) bool

// Emits the #GDBusAuthObserver::allow-mechanism signal on @observer.
func (x *DBusAuthObserver) AllowMechanism(MechanismVar string) bool {

	cret := xDBusAuthObserverAllowMechanism(x.GoPointer(), MechanismVar)
	return cret
}

var xDBusAuthObserverAuthorizeAuthenticatedPeer func(uintptr, uintptr, uintptr) bool

// Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on @observer.
func (x *DBusAuthObserver) AuthorizeAuthenticatedPeer(StreamVar *IOStream, CredentialsVar *Credentials) bool {

	cret := xDBusAuthObserverAuthorizeAuthenticatedPeer(x.GoPointer(), StreamVar.GoPointer(), CredentialsVar.GoPointer())
	return cret
}

func (c *DBusAuthObserver) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *DBusAuthObserver) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted to check if @mechanism is allowed to be used.
func (x *DBusAuthObserver) ConnectAllowMechanism(cb *func(DBusAuthObserver, string) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "allow-mechanism", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, MechanismVarp string) bool {
		fa := DBusAuthObserver{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, MechanismVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "allow-mechanism", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted to check if a peer that is successfully authenticated
// is authorized.
func (x *DBusAuthObserver) ConnectAuthorizeAuthenticatedPeer(cb *func(DBusAuthObserver, uintptr, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "authorize-authenticated-peer", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, StreamVarp uintptr, CredentialsVarp uintptr) bool {
		fa := DBusAuthObserver{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, StreamVarp, CredentialsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "authorize-authenticated-peer", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xDBusAuthObserverGLibType, libs, "g_dbus_auth_observer_get_type")

	core.PuregoSafeRegister(&xNewDBusAuthObserver, libs, "g_dbus_auth_observer_new")

	core.PuregoSafeRegister(&xDBusAuthObserverAllowMechanism, libs, "g_dbus_auth_observer_allow_mechanism")
	core.PuregoSafeRegister(&xDBusAuthObserverAuthorizeAuthenticatedPeer, libs, "g_dbus_auth_observer_authorize_authenticated_peer")

}
