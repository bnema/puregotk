// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type CancellableClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xCancelled uintptr

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr
}

func (x *CancellableClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideCancelled sets the "cancelled" callback function.
func (x *CancellableClass) OverrideCancelled(cb func(*Cancellable)) {
	if cb == nil {
		x.xCancelled = 0
	} else {
		x.xCancelled = purego.NewCallback(func(CancellableVarp uintptr) {
			cb(CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetCancelled gets the "cancelled" callback function.
func (x *CancellableClass) GetCancelled() func(*Cancellable) {
	if x.xCancelled == 0 {
		return nil
	}
	var rawCallback func(CancellableVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCancelled)
	return func(CancellableVar *Cancellable) {
		rawCallback(CancellableVar.GoPointer())
	}
}

// OverrideGReserved1 sets the "_g_reserved1" callback function.
func (x *CancellableClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the "_g_reserved1" callback function.
func (x *CancellableClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the "_g_reserved2" callback function.
func (x *CancellableClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the "_g_reserved2" callback function.
func (x *CancellableClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the "_g_reserved3" callback function.
func (x *CancellableClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the "_g_reserved3" callback function.
func (x *CancellableClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the "_g_reserved4" callback function.
func (x *CancellableClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the "_g_reserved4" callback function.
func (x *CancellableClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the "_g_reserved5" callback function.
func (x *CancellableClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the "_g_reserved5" callback function.
func (x *CancellableClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

type CancellablePrivate struct {
	_ structs.HostLayout
}

func (x *CancellablePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GCancellable` allows operations to be cancelled.
//
// `GCancellable` is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and
// asynchronous operations.
type Cancellable struct {
	gobject.Object
}

var xCancellableGLibType func() types.GType

func CancellableGLibType() types.GType {
	return xCancellableGLibType()
}

func CancellableNewFromInternalPtr(ptr uintptr) *Cancellable {
	cls := &Cancellable{}
	cls.Ptr = ptr
	return cls
}

var xNewCancellable func() uintptr

// Creates a new #GCancellable object.
//
// Applications that want to start one or more operations
// that should be cancellable should create a #GCancellable
// and pass it to the operations.
//
// One #GCancellable can be used in multiple consecutive
// operations or in multiple concurrent operations.
func NewCancellable() *Cancellable {
	var cls *Cancellable

	cret := xNewCancellable()

	if cret == 0 {
		return nil
	}
	cls = &Cancellable{}
	cls.Ptr = cret
	return cls
}

var xCancellableCancel func(uintptr)

// Will set @cancellable to cancelled, and will emit the
// #GCancellable::cancelled signal. (However, see the warning about
// race conditions in the documentation for that signal if you are
// planning to connect to it.)
//
// This function is thread-safe. In other words, you can safely call
// it from a thread other than the one running the operation that was
// passed the @cancellable.
//
// If @cancellable is %NULL, this function returns immediately for convenience.
//
// The convention within GIO is that cancelling an asynchronous
// operation causes it to complete asynchronously. That is, if you
// cancel the operation from the same thread in which it is running,
// then the operation's #GAsyncReadyCallback will not be invoked until
// the application returns to the main loop.
//
// It is safe (although useless, since it will be a no-op) to call
// this function from a [signal@Gio.Cancellable::cancelled] signal handler.
func (x *Cancellable) Cancel() {

	xCancellableCancel(x.GoPointer())

}

var xCancellableConnect func(uintptr, uintptr, uintptr, uintptr) uint

// Convenience function to connect to the #GCancellable::cancelled
// signal. Also handles the race condition that may happen
// if the cancellable is cancelled right before connecting.
//
// @callback is called exactly once each time @cancellable is cancelled,
// either directly at the time of the connect if @cancellable is already
// cancelled, or when @cancellable is cancelled in some thread.
// In case the cancellable is reset via [method@Gio.Cancellable.reset]
// then the callback can be called again if the @cancellable is cancelled and
// if it had not been previously cancelled at the time
// [method@Gio.Cancellable.connect] was called (e.g. if the connection actually
// took place, returning a non-zero value).
//
// @data_destroy_func will be called when the handler is
// disconnected, or immediately if the cancellable is already
// cancelled.
//
// See #GCancellable::cancelled for details on how to use this.
//
// Since GLib 2.40, the lock protecting @cancellable is not held when
// @callback is invoked. This lifts a restriction in place for
// earlier GLib versions which now makes it easier to write cleanup
// code that unconditionally invokes e.g. [method@Gio.Cancellable.cancel].
// Note that since 2.82 GLib still holds a lock during the callback but itâ€™s
// designed in a way that most of the [class@Gio.Cancellable] methods can be
// called, including [method@Gio.Cancellable.cancel] or
// [method@GObject.Object.unref].
//
// There are still some methods that will deadlock (by design) when
// called from the [signal@Gio.Cancellable::cancelled] callbacks:
//   - [method@Gio.Cancellable.connect]
//   - [method@Gio.Cancellable.disconnect]
//   - [method@Gio.Cancellable.reset]
//   - [method@Gio.Cancellable.make_pollfd]
//   - [method@Gio.Cancellable.release_fd]
func (x *Cancellable) Connect(CallbackVar *gobject.Callback, DataVar uintptr, DataDestroyFuncVar *glib.DestroyNotify) uint {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	var DataDestroyFuncVarRef uintptr
	if DataDestroyFuncVar != nil {
		DataDestroyFuncVarPtr := uintptr(unsafe.Pointer(DataDestroyFuncVar))
		if cbRefPtr, ok := glib.GetCallback(DataDestroyFuncVarPtr); ok {
			DataDestroyFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DataDestroyFuncVar
				cbFn(arg0)
			}
			DataDestroyFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DataDestroyFuncVarPtr, DataDestroyFuncVarRef, DataDestroyFuncVar)
		}
	}

	cret := xCancellableConnect(x.GoPointer(), CallbackVarRef, DataVar, DataDestroyFuncVarRef)

	return cret
}

var xCancellableDisconnect func(uintptr, uint)

// Disconnects a handler from a cancellable instance similar to
// g_signal_handler_disconnect().  Additionally, in the event that a
// signal handler is currently running, this call will block until the
// handler has finished.  Calling this function from a
// #GCancellable::cancelled signal handler will therefore result in a
// deadlock.
//
// This avoids a race condition where a thread cancels at the
// same time as the cancellable operation is finished and the
// signal handler is removed. See #GCancellable::cancelled for
// details on how to use this.
//
// If @cancellable is %NULL or @handler_id is `0` this function does
// nothing.
func (x *Cancellable) Disconnect(HandlerIdVar uint) {

	xCancellableDisconnect(x.GoPointer(), HandlerIdVar)

}

var xCancellableGetFd func(uintptr) int

// Gets the file descriptor for a cancellable job. This can be used to
// implement cancellable operations on Unix systems. The returned fd will
// turn readable when @cancellable is cancelled.
//
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done
// with g_cancellable_reset().
//
// After a successful return from this function, you should use
// g_cancellable_release_fd() to free up resources allocated for
// the returned file descriptor.
//
// See also g_cancellable_make_pollfd().
func (x *Cancellable) GetFd() int {

	cret := xCancellableGetFd(x.GoPointer())

	return cret
}

var xCancellableIsCancelled func(uintptr) bool

// Checks if a cancellable job has been cancelled.
func (x *Cancellable) IsCancelled() bool {

	cret := xCancellableIsCancelled(x.GoPointer())

	return cret
}

var xCancellableMakePollfd func(uintptr, *glib.PollFD) bool

// Creates a #GPollFD corresponding to @cancellable; this can be passed
// to g_poll() and used to poll for cancellation. This is useful both
// for unix systems without a native poll and for portability to
// windows.
//
// When this function returns %TRUE, you should use
// g_cancellable_release_fd() to free up resources allocated for the
// @pollfd. After a %FALSE return, do not call g_cancellable_release_fd().
//
// If this function returns %FALSE, either no @cancellable was given or
// resource limits prevent this function from allocating the necessary
// structures for polling. (On Linux, you will likely have reached
// the maximum number of file descriptors.) The suggested way to handle
// these cases is to ignore the @cancellable.
//
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done
// with g_cancellable_reset().
//
// Note that in the event that a [signal@Gio.Cancellable::cancelled] signal handler is
// currently running, this call will block until the handler has finished.
// Calling this function from a signal handler will therefore result in a
// deadlock.
func (x *Cancellable) MakePollfd(PollfdVar *glib.PollFD) bool {

	cret := xCancellableMakePollfd(x.GoPointer(), PollfdVar)

	return cret
}

var xCancellablePopCurrent func(uintptr)

// Pops @cancellable off the cancellable stack (verifying that @cancellable
// is on the top of the stack).
func (x *Cancellable) PopCurrent() {

	xCancellablePopCurrent(x.GoPointer())

}

var xCancellablePushCurrent func(uintptr)

// Pushes @cancellable onto the cancellable stack. The current
// cancellable can then be received using g_cancellable_get_current().
//
// This is useful when implementing cancellable operations in
// code that does not allow you to pass down the cancellable object.
//
// This is typically called automatically by e.g. #GFile operations,
// so you rarely have to call this yourself.
func (x *Cancellable) PushCurrent() {

	xCancellablePushCurrent(x.GoPointer())

}

var xCancellableReleaseFd func(uintptr)

// Releases a resources previously allocated by g_cancellable_get_fd()
// or g_cancellable_make_pollfd().
//
// For compatibility reasons with older releases, calling this function
// is not strictly required, the resources will be automatically freed
// when the @cancellable is finalized. However, the @cancellable will
// block scarce file descriptors until it is finalized if this function
// is not called. This can cause the application to run out of file
// descriptors when many #GCancellables are used at the same time.
//
// Note that in the event that a [signal@Gio.Cancellable::cancelled] signal handler is
// currently running, this call will block until the handler has finished.
// Calling this function from a signal handler will therefore result in a
// deadlock.
func (x *Cancellable) ReleaseFd() {

	xCancellableReleaseFd(x.GoPointer())

}

var xCancellableReset func(uintptr)

// Resets @cancellable to its uncancelled state.
//
// If cancellable is currently in use by any cancellable operation
// then the behavior of this function is undefined.
//
// Note that it is generally not a good idea to reuse an existing
// cancellable for more operations after it has been cancelled once,
// as this function might tempt you to do. The recommended practice
// is to drop the reference to a cancellable after cancelling it,
// and let it die with the outstanding async operations. You should
// create a fresh cancellable for further async operations.
//
// In the event that a [signal@Gio.Cancellable::cancelled] signal handler is currently
// running, this call will block until the handler has finished.
// Calling this function from a signal handler will therefore result in a
// deadlock.
func (x *Cancellable) Reset() {

	xCancellableReset(x.GoPointer())

}

var xCancellableSetErrorIfCancelled func(uintptr) bool

// If the @cancellable is cancelled, sets the error to notify
// that the operation was cancelled.
func (x *Cancellable) SetErrorIfCancelled() (bool, error) {
	var cerr *glib.Error

	cret := xCancellableSetErrorIfCancelled(x.GoPointer())

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xCancellableSourceNew func(uintptr) *glib.Source

// Creates a source that triggers if @cancellable is cancelled and
// calls its callback of type #GCancellableSourceFunc. This is
// primarily useful for attaching to another (non-cancellable) source
// with g_source_add_child_source() to add cancellability to it.
//
// For convenience, you can call this with a %NULL #GCancellable,
// in which case the source will never trigger.
//
// The new #GSource will hold a reference to the #GCancellable.
func (x *Cancellable) SourceNew() *glib.Source {

	cret := xCancellableSourceNew(x.GoPointer())

	return cret
}

func (c *Cancellable) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Cancellable) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the operation has been cancelled.
//
// Can be used by implementations of cancellable operations. If the
// operation is cancelled from another thread, the signal will be
// emitted in the thread that cancelled the operation, not the
// thread that is running the operation.
//
// Note that disconnecting from this signal (or any signal) in a
// multi-threaded program is prone to race conditions. For instance
// it is possible that a signal handler may be invoked even after
// a call to g_signal_handler_disconnect() for that handler has
// already returned.
//
// There is also a problem when cancellation happens right before
// connecting to the signal. If this happens the signal will
// unexpectedly not be emitted, and checking before connecting to
// the signal leaves a race condition where this is still happening.
//
// In order to make it safe and easy to connect handlers there
// are two helper functions: g_cancellable_connect() and
// g_cancellable_disconnect() which protect against problems
// like this.
//
// An example of how to us this:
// |[&lt;!-- language="C" --&gt;
//
//	// Make sure we don't do unnecessary work if already cancelled
//	if (g_cancellable_set_error_if_cancelled (cancellable, error))
//	  return;
//
//	// Set up all the data needed to be able to handle cancellation
//	// of the operation
//	my_data = my_data_new (...);
//
//	id = 0;
//	if (cancellable)
//	  id = g_cancellable_connect (cancellable,
//				      G_CALLBACK (cancelled_handler)
//				      data, NULL);
//
//	// cancellable operation here...
//
//	g_cancellable_disconnect (cancellable, id);
//
//	// cancelled_handler is never called after this, it is now safe
//	// to free the data
//	my_data_free (my_data);
//
// ]|
//
// Note that the cancelled signal is emitted in the thread that
// the user cancelled from, which may be the main thread. So, the
// cancellable signal should not do something that can block.
func (x *Cancellable) ConnectCancelled(cb *func(Cancellable)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "cancelled", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Cancellable{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "cancelled", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

var xCancellableGetCurrent func() uintptr

// Gets the top cancellable from the stack.
func CancellableGetCurrent() *Cancellable {
	var cls *Cancellable

	cret := xCancellableGetCurrent()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Cancellable{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCancellableGLibType, libs, "g_cancellable_get_type")

	core.PuregoSafeRegister(&xNewCancellable, libs, "g_cancellable_new")

	core.PuregoSafeRegister(&xCancellableCancel, libs, "g_cancellable_cancel")
	core.PuregoSafeRegister(&xCancellableConnect, libs, "g_cancellable_connect")
	core.PuregoSafeRegister(&xCancellableDisconnect, libs, "g_cancellable_disconnect")
	core.PuregoSafeRegister(&xCancellableGetFd, libs, "g_cancellable_get_fd")
	core.PuregoSafeRegister(&xCancellableIsCancelled, libs, "g_cancellable_is_cancelled")
	core.PuregoSafeRegister(&xCancellableMakePollfd, libs, "g_cancellable_make_pollfd")
	core.PuregoSafeRegister(&xCancellablePopCurrent, libs, "g_cancellable_pop_current")
	core.PuregoSafeRegister(&xCancellablePushCurrent, libs, "g_cancellable_push_current")
	core.PuregoSafeRegister(&xCancellableReleaseFd, libs, "g_cancellable_release_fd")
	core.PuregoSafeRegister(&xCancellableReset, libs, "g_cancellable_reset")
	core.PuregoSafeRegister(&xCancellableSetErrorIfCancelled, libs, "g_cancellable_set_error_if_cancelled")
	core.PuregoSafeRegister(&xCancellableSourceNew, libs, "g_cancellable_source_new")

	core.PuregoSafeRegister(&xCancellableGetCurrent, libs, "g_cancellable_get_current")

}
