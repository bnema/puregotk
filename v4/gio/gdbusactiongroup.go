// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"runtime"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// `GDBusActionGroup` is an implementation of the [iface@Gio.ActionGroup]
// interface.
//
// `GDBusActionGroup` can be used as a proxy for an action group
// that is exported over D-Bus with [method@Gio.DBusConnection.export_action_group].
type DBusActionGroup struct {
	gobject.Object
}

var xDBusActionGroupGLibType func() types.GType

func DBusActionGroupGLibType() types.GType {
	return xDBusActionGroupGLibType()
}

func DBusActionGroupNewFromInternalPtr(ptr uintptr) *DBusActionGroup {
	cls := &DBusActionGroup{}
	cls.Ptr = ptr
	return cls
}

func (c *DBusActionGroup) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *DBusActionGroup) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emits the [signal@Gio.ActionGroup::action-added] signal on @action_group.
//
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (x *DBusActionGroup) ActionAdded(ActionNameVar string) {

	XGActionGroupActionAdded(x.GoPointer(), ActionNameVar)

}

// Emits the [signal@Gio.ActionGroup::action-enabled-changed] signal on @action_group.
//
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (x *DBusActionGroup) ActionEnabledChanged(ActionNameVar string, EnabledVar bool) {

	XGActionGroupActionEnabledChanged(x.GoPointer(), ActionNameVar, EnabledVar)

}

// Emits the [signal@Gio.ActionGroup::action-removed] signal on @action_group.
//
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (x *DBusActionGroup) ActionRemoved(ActionNameVar string) {

	XGActionGroupActionRemoved(x.GoPointer(), ActionNameVar)

}

// Emits the [signal@Gio.ActionGroup::action-state-changed] signal on @action_group.
//
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (x *DBusActionGroup) ActionStateChanged(ActionNameVar string, StateVar *glib.Variant) {

	XGActionGroupActionStateChanged(x.GoPointer(), ActionNameVar, StateVar)

}

// Activate the named action within @action_group.
//
// If the action is expecting a parameter, then the correct type of
// parameter must be given as @parameter.  If the action is expecting no
// parameters then @parameter must be `NULL`.  See
// [method@Gio.ActionGroup.get_action_parameter_type].
//
// If the [type@Gio.ActionGroup] implementation supports asynchronous remote
// activation over D-Bus, this call may return before the relevant
// D-Bus traffic has been sent, or any replies have been received. In
// order to block on such asynchronous activation calls,
// [method@Gio.DBusConnection.flush] should be called prior to the code, which
// depends on the result of the action activation. Without flushing
// the D-Bus connection, there is no guarantee that the action would
// have been activated.
//
// The following code which runs in a remote app instance, shows an
// example of a ‘quit’ action being activated on the primary app
// instance over D-Bus. Here [method@Gio.DBusConnection.flush] is called
// before `exit()`. Without `g_dbus_connection_flush()`, the ‘quit’ action
// may fail to be activated on the primary instance.
//
// ```c
// // call ‘quit’ action on primary instance
// g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
//
// // make sure the action is activated now
// g_dbus_connection_flush (…);
//
// g_debug ("Application has been terminated. Exiting.");
//
// exit (0);
// ```
func (x *DBusActionGroup) ActivateAction(ActionNameVar string, ParameterVar *glib.Variant) {

	XGActionGroupActivateAction(x.GoPointer(), ActionNameVar, ParameterVar)

}

// Request for the state of the named action within @action_group to be
// changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See [method@Gio.ActionGroup.get_action_state_type].
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See [method@Gio.ActionGroup.get_action_state_hint].
//
// If the @value GVariant is floating, it is consumed.
func (x *DBusActionGroup) ChangeActionState(ActionNameVar string, ValueVar *glib.Variant) {

	XGActionGroupChangeActionState(x.GoPointer(), ActionNameVar, ValueVar)

}

// Checks if the named action within @action_group is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *DBusActionGroup) GetActionEnabled(ActionNameVar string) bool {

	cret := XGActionGroupGetActionEnabled(x.GoPointer(), ActionNameVar)

	return cret
}

// Queries the type of the parameter that must be given when activating
// the named action within @action_group.
//
// When activating the action using [method@Gio.ActionGroup.activate_action],
// the [type@GLib.Variant] given to that function must be of the type returned
// by this function.
//
// In the case that this function returns `NULL`, you must not give any
// [type@GLib.Variant], but `NULL` instead.
//
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different parameter type.
func (x *DBusActionGroup) GetActionParameterType(ActionNameVar string) *glib.VariantType {

	cret := XGActionGroupGetActionParameterType(x.GoPointer(), ActionNameVar)

	return cret
}

// Queries the current state of the named action within @action_group.
//
// If the action is not stateful then `NULL` will be returned.  If the
// action is stateful then the type of the return value is the type
// given by [method@Gio.ActionGroup.get_action_state_type].
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *DBusActionGroup) GetActionState(ActionNameVar string) *glib.Variant {

	cret := XGActionGroupGetActionState(x.GoPointer(), ActionNameVar)

	return cret
}

// Requests a hint about the valid range of values for the state of the
// named action within @action_group.
//
// If `NULL` is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a [type@GLib.Variant] array is returned then each item in the array is a
// possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *DBusActionGroup) GetActionStateHint(ActionNameVar string) *glib.Variant {

	cret := XGActionGroupGetActionStateHint(x.GoPointer(), ActionNameVar)

	return cret
}

// Queries the type of the state of the named action within
// @action_group.
//
// If the action is stateful then this function returns the
// [type@GLib.VariantType] of the state.  All calls to
// [method@Gio.ActionGroup.change_action_state] must give a [type@GLib.Variant] of this
// type and [method@Gio.ActionGroup.get_action_state] will return a [type@GLib.Variant]
// of the same type.
//
// If the action is not stateful then this function will return `NULL`.
// In that case, [method@Gio.ActionGroup.get_action_state] will return `NULL`
// and you must not call [method@Gio.ActionGroup.change_action_state].
//
// The state type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different state type.
func (x *DBusActionGroup) GetActionStateType(ActionNameVar string) *glib.VariantType {

	cret := XGActionGroupGetActionStateType(x.GoPointer(), ActionNameVar)

	return cret
}

// Checks if the named action exists within @action_group.
func (x *DBusActionGroup) HasAction(ActionNameVar string) bool {

	cret := XGActionGroupHasAction(x.GoPointer(), ActionNameVar)

	return cret
}

// Lists the actions contained within @action_group.
//
// The caller is responsible for freeing the list with [func@GLib.strfreev] when
// it is no longer required.
func (x *DBusActionGroup) ListActions() []string {

	cret := XGActionGroupListActions(x.GoPointer())

	return cret
}

// Queries all aspects of the named action within an @action_group.
//
// This function acquires the information available from
// [method@Gio.ActionGroup.has_action], [method@Gio.ActionGroup.get_action_enabled],
// [method@Gio.ActionGroup.get_action_parameter_type],
// [method@Gio.ActionGroup.get_action_state_type],
// [method@Gio.ActionGroup.get_action_state_hint] and
// [method@Gio.ActionGroup.get_action_state] with a single function call.
//
// This provides two main benefits.
//
// The first is the improvement in efficiency that comes with not having
// to perform repeated lookups of the action in order to discover
// different things about it.  The second is that implementing
// [type@Gio.ActionGroup] can now be done by only overriding this one virtual
// function.
//
// The interface provides a default implementation of this function that
// calls the individual functions, as required, to fetch the
// information.  The interface also provides default implementations of
// those functions that call this function.  All implementations,
// therefore, must override either this function or all of the others.
//
// If the action exists, `TRUE` is returned and any of the requested
// fields (as indicated by having a non-`NULL` reference passed in) are
// filled.  If the action doesn’t exist, `FALSE` is returned and the
// fields may or may not have been modified.
func (x *DBusActionGroup) QueryAction(ActionNameVar string, EnabledVar *bool, ParameterTypeVar **glib.VariantType, StateTypeVar **glib.VariantType, StateHintVar **glib.Variant, StateVar **glib.Variant) bool {

	cret := XGActionGroupQueryAction(x.GoPointer(), ActionNameVar, EnabledVar, ParameterTypeVar, StateTypeVar, StateHintVar, StateVar)

	return cret
}

// Activates the remote action.
//
// This is the same as g_action_group_activate_action() except that it
// allows for provision of "platform data" to be sent along with the
// activation request.  This typically contains details such as the user
// interaction timestamp or startup notification information.
//
// @platform_data must be non-%NULL and must have the type
// %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
func (x *DBusActionGroup) ActivateActionFull(ActionNameVar string, ParameterVar *glib.Variant, PlatformDataVar *glib.Variant) {

	XGRemoteActionGroupActivateActionFull(x.GoPointer(), ActionNameVar, ParameterVar, PlatformDataVar)

}

// Changes the state of a remote action.
//
// This is the same as g_action_group_change_action_state() except that
// it allows for provision of "platform data" to be sent along with the
// state change request.  This typically contains details such as the
// user interaction timestamp or startup notification information.
//
// @platform_data must be non-%NULL and must have the type
// %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
func (x *DBusActionGroup) ChangeActionStateFull(ActionNameVar string, ValueVar *glib.Variant, PlatformDataVar *glib.Variant) {

	XGRemoteActionGroupChangeActionStateFull(x.GoPointer(), ActionNameVar, ValueVar, PlatformDataVar)

}

var xDBusActionGroupGet func(uintptr, uintptr, string) uintptr

// Obtains a #GDBusActionGroup for the action group which is exported at
// the given @bus_name and @object_path.
//
// The thread default main context is taken at the time of this call.
// All signals on the menu model (and any linked models) are reported
// with respect to this context.  All calls on the returned menu model
// (and linked models) must also originate from this same context, with
// the thread default main context unchanged.
//
// This call is non-blocking.  The returned action group may or may not
// already be filled in.  The correct thing to do is connect the signals
// for the action group to monitor for changes and then to call
// g_action_group_list_actions() to get the initial list.
func DBusActionGroupGet(ConnectionVar *DBusConnection, BusNameVar *string, ObjectPathVar string) *DBusActionGroup {
	var cls *DBusActionGroup

	BusNameVarPtr, BusNameVarBytes := core.NullableStringToPtr(BusNameVar)

	cret := xDBusActionGroupGet(ConnectionVar.GoPointer(), BusNameVarPtr, ObjectPathVar)

	runtime.KeepAlive(BusNameVarBytes)

	if cret == 0 {
		return nil
	}
	cls = &DBusActionGroup{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xDBusActionGroupGLibType, libs, "g_dbus_action_group_get_type")

	core.PuregoSafeRegister(&xDBusActionGroupGet, libs, "g_dbus_action_group_get")

}
