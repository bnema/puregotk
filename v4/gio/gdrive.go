// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Interface for creating #GDrive implementations.
type DriveIface struct {
	_ structs.HostLayout

	GIface uintptr

	xChanged uintptr

	xDisconnected uintptr

	xEjectButton uintptr

	xGetName uintptr

	xGetIcon uintptr

	xHasVolumes uintptr

	xGetVolumes uintptr

	xIsMediaRemovable uintptr

	xHasMedia uintptr

	xIsMediaCheckAutomatic uintptr

	xCanEject uintptr

	xCanPollForMedia uintptr

	xEject uintptr

	xEjectFinish uintptr

	xPollForMedia uintptr

	xPollForMediaFinish uintptr

	xGetIdentifier uintptr

	xEnumerateIdentifiers uintptr

	xGetStartStopType uintptr

	xCanStart uintptr

	xCanStartDegraded uintptr

	xStart uintptr

	xStartFinish uintptr

	xCanStop uintptr

	xStop uintptr

	xStopFinish uintptr

	xStopButton uintptr

	xEjectWithOperation uintptr

	xEjectWithOperationFinish uintptr

	xGetSortKey uintptr

	xGetSymbolicIcon uintptr

	xIsRemovable uintptr
}

func (x *DriveIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideChanged sets the callback function.
func (x *DriveIface) OverrideChanged(cb func(Drive)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(DriveVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetChanged gets the callback function.
func (x *DriveIface) GetChanged() func(Drive) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(DriveVar Drive) {
		rawCallback(DriveVar.GoPointer())
	}
}

// OverrideDisconnected sets the callback function.
func (x *DriveIface) OverrideDisconnected(cb func(Drive)) {
	if cb == nil {
		x.xDisconnected = 0
	} else {
		x.xDisconnected = purego.NewCallback(func(DriveVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetDisconnected gets the callback function.
func (x *DriveIface) GetDisconnected() func(Drive) {
	if x.xDisconnected == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xDisconnected)
	return func(DriveVar Drive) {
		rawCallback(DriveVar.GoPointer())
	}
}

// OverrideEjectButton sets the callback function.
func (x *DriveIface) OverrideEjectButton(cb func(Drive)) {
	if cb == nil {
		x.xEjectButton = 0
	} else {
		x.xEjectButton = purego.NewCallback(func(DriveVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetEjectButton gets the callback function.
func (x *DriveIface) GetEjectButton() func(Drive) {
	if x.xEjectButton == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEjectButton)
	return func(DriveVar Drive) {
		rawCallback(DriveVar.GoPointer())
	}
}

// OverrideGetName sets the callback function.
func (x *DriveIface) OverrideGetName(cb func(Drive) string) {
	if cb == nil {
		x.xGetName = 0
	} else {
		x.xGetName = purego.NewCallback(func(DriveVarp uintptr) string {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetGetName gets the callback function.
func (x *DriveIface) GetGetName() func(Drive) string {
	if x.xGetName == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetName)
	return func(DriveVar Drive) string {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideGetIcon sets the callback function.
func (x *DriveIface) OverrideGetIcon(cb func(Drive) *IconBase) {
	if cb == nil {
		x.xGetIcon = 0
	} else {
		x.xGetIcon = purego.NewCallback(func(DriveVarp uintptr) uintptr {
			ret := cb(&DriveBase{Ptr: DriveVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetIcon gets the callback function.
func (x *DriveIface) GetGetIcon() func(Drive) *IconBase {
	if x.xGetIcon == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetIcon)
	return func(DriveVar Drive) *IconBase {
		rawRet := rawCallback(DriveVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideHasVolumes sets the callback function.
func (x *DriveIface) OverrideHasVolumes(cb func(Drive) bool) {
	if cb == nil {
		x.xHasVolumes = 0
	} else {
		x.xHasVolumes = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetHasVolumes gets the callback function.
func (x *DriveIface) GetHasVolumes() func(Drive) bool {
	if x.xHasVolumes == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xHasVolumes)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideGetVolumes sets the callback function.
func (x *DriveIface) OverrideGetVolumes(cb func(Drive) *glib.List) {
	if cb == nil {
		x.xGetVolumes = 0
	} else {
		x.xGetVolumes = purego.NewCallback(func(DriveVarp uintptr) *glib.List {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetGetVolumes gets the callback function.
func (x *DriveIface) GetGetVolumes() func(Drive) *glib.List {
	if x.xGetVolumes == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xGetVolumes)
	return func(DriveVar Drive) *glib.List {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideIsMediaRemovable sets the callback function.
func (x *DriveIface) OverrideIsMediaRemovable(cb func(Drive) bool) {
	if cb == nil {
		x.xIsMediaRemovable = 0
	} else {
		x.xIsMediaRemovable = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetIsMediaRemovable gets the callback function.
func (x *DriveIface) GetIsMediaRemovable() func(Drive) bool {
	if x.xIsMediaRemovable == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsMediaRemovable)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideHasMedia sets the callback function.
func (x *DriveIface) OverrideHasMedia(cb func(Drive) bool) {
	if cb == nil {
		x.xHasMedia = 0
	} else {
		x.xHasMedia = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetHasMedia gets the callback function.
func (x *DriveIface) GetHasMedia() func(Drive) bool {
	if x.xHasMedia == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xHasMedia)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideIsMediaCheckAutomatic sets the callback function.
func (x *DriveIface) OverrideIsMediaCheckAutomatic(cb func(Drive) bool) {
	if cb == nil {
		x.xIsMediaCheckAutomatic = 0
	} else {
		x.xIsMediaCheckAutomatic = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetIsMediaCheckAutomatic gets the callback function.
func (x *DriveIface) GetIsMediaCheckAutomatic() func(Drive) bool {
	if x.xIsMediaCheckAutomatic == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsMediaCheckAutomatic)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideCanEject sets the callback function.
func (x *DriveIface) OverrideCanEject(cb func(Drive) bool) {
	if cb == nil {
		x.xCanEject = 0
	} else {
		x.xCanEject = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetCanEject gets the callback function.
func (x *DriveIface) GetCanEject() func(Drive) bool {
	if x.xCanEject == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanEject)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideCanPollForMedia sets the callback function.
func (x *DriveIface) OverrideCanPollForMedia(cb func(Drive) bool) {
	if cb == nil {
		x.xCanPollForMedia = 0
	} else {
		x.xCanPollForMedia = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetCanPollForMedia gets the callback function.
func (x *DriveIface) GetCanPollForMedia() func(Drive) bool {
	if x.xCanPollForMedia == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanPollForMedia)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideEject sets the callback function.
func (x *DriveIface) OverrideEject(cb func(Drive, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEject = 0
	} else {
		x.xEject = purego.NewCallback(func(DriveVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEject gets the callback function.
func (x *DriveIface) GetEject() func(Drive, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEject == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEject)
	return func(DriveVar Drive, FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(DriveVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEjectFinish sets the callback function.
func (x *DriveIface) OverrideEjectFinish(cb func(Drive, AsyncResult) bool) {
	if cb == nil {
		x.xEjectFinish = 0
	} else {
		x.xEjectFinish = purego.NewCallback(func(DriveVarp uintptr, ResultVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetEjectFinish gets the callback function.
func (x *DriveIface) GetEjectFinish() func(Drive, AsyncResult) bool {
	if x.xEjectFinish == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEjectFinish)
	return func(DriveVar Drive, ResultVar AsyncResult) bool {
		return rawCallback(DriveVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverridePollForMedia sets the callback function.
func (x *DriveIface) OverridePollForMedia(cb func(Drive, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xPollForMedia = 0
	} else {
		x.xPollForMedia = purego.NewCallback(func(DriveVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp}, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetPollForMedia gets the callback function.
func (x *DriveIface) GetPollForMedia() func(Drive, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xPollForMedia == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPollForMedia)
	return func(DriveVar Drive, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(DriveVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverridePollForMediaFinish sets the callback function.
func (x *DriveIface) OverridePollForMediaFinish(cb func(Drive, AsyncResult) bool) {
	if cb == nil {
		x.xPollForMediaFinish = 0
	} else {
		x.xPollForMediaFinish = purego.NewCallback(func(DriveVarp uintptr, ResultVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetPollForMediaFinish gets the callback function.
func (x *DriveIface) GetPollForMediaFinish() func(Drive, AsyncResult) bool {
	if x.xPollForMediaFinish == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xPollForMediaFinish)
	return func(DriveVar Drive, ResultVar AsyncResult) bool {
		return rawCallback(DriveVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGetIdentifier sets the callback function.
func (x *DriveIface) OverrideGetIdentifier(cb func(Drive, string) string) {
	if cb == nil {
		x.xGetIdentifier = 0
	} else {
		x.xGetIdentifier = purego.NewCallback(func(DriveVarp uintptr, KindVarp string) string {
			return cb(&DriveBase{Ptr: DriveVarp}, KindVarp)
		})
	}
}

// GetGetIdentifier gets the callback function.
func (x *DriveIface) GetGetIdentifier() func(Drive, string) string {
	if x.xGetIdentifier == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, KindVarp string) string
	purego.RegisterFunc(&rawCallback, x.xGetIdentifier)
	return func(DriveVar Drive, KindVar string) string {
		return rawCallback(DriveVar.GoPointer(), KindVar)
	}
}

// OverrideEnumerateIdentifiers sets the callback function.
func (x *DriveIface) OverrideEnumerateIdentifiers(cb func(Drive) []string) {
	if cb == nil {
		x.xEnumerateIdentifiers = 0
	} else {
		x.xEnumerateIdentifiers = purego.NewCallback(func(DriveVarp uintptr) []string {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetEnumerateIdentifiers gets the callback function.
func (x *DriveIface) GetEnumerateIdentifiers() func(Drive) []string {
	if x.xEnumerateIdentifiers == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) []string
	purego.RegisterFunc(&rawCallback, x.xEnumerateIdentifiers)
	return func(DriveVar Drive) []string {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideGetStartStopType sets the callback function.
func (x *DriveIface) OverrideGetStartStopType(cb func(Drive) DriveStartStopType) {
	if cb == nil {
		x.xGetStartStopType = 0
	} else {
		x.xGetStartStopType = purego.NewCallback(func(DriveVarp uintptr) DriveStartStopType {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetGetStartStopType gets the callback function.
func (x *DriveIface) GetGetStartStopType() func(Drive) DriveStartStopType {
	if x.xGetStartStopType == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) DriveStartStopType
	purego.RegisterFunc(&rawCallback, x.xGetStartStopType)
	return func(DriveVar Drive) DriveStartStopType {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideCanStart sets the callback function.
func (x *DriveIface) OverrideCanStart(cb func(Drive) bool) {
	if cb == nil {
		x.xCanStart = 0
	} else {
		x.xCanStart = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetCanStart gets the callback function.
func (x *DriveIface) GetCanStart() func(Drive) bool {
	if x.xCanStart == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanStart)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideCanStartDegraded sets the callback function.
func (x *DriveIface) OverrideCanStartDegraded(cb func(Drive) bool) {
	if cb == nil {
		x.xCanStartDegraded = 0
	} else {
		x.xCanStartDegraded = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetCanStartDegraded gets the callback function.
func (x *DriveIface) GetCanStartDegraded() func(Drive) bool {
	if x.xCanStartDegraded == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanStartDegraded)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideStart sets the callback function.
func (x *DriveIface) OverrideStart(cb func(Drive, DriveStartFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xStart = 0
	} else {
		x.xStart = purego.NewCallback(func(DriveVarp uintptr, FlagsVarp DriveStartFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetStart gets the callback function.
func (x *DriveIface) GetStart() func(Drive, DriveStartFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xStart == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, FlagsVarp DriveStartFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xStart)
	return func(DriveVar Drive, FlagsVar DriveStartFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(DriveVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideStartFinish sets the callback function.
func (x *DriveIface) OverrideStartFinish(cb func(Drive, AsyncResult) bool) {
	if cb == nil {
		x.xStartFinish = 0
	} else {
		x.xStartFinish = purego.NewCallback(func(DriveVarp uintptr, ResultVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetStartFinish gets the callback function.
func (x *DriveIface) GetStartFinish() func(Drive, AsyncResult) bool {
	if x.xStartFinish == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xStartFinish)
	return func(DriveVar Drive, ResultVar AsyncResult) bool {
		return rawCallback(DriveVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideCanStop sets the callback function.
func (x *DriveIface) OverrideCanStop(cb func(Drive) bool) {
	if cb == nil {
		x.xCanStop = 0
	} else {
		x.xCanStop = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetCanStop gets the callback function.
func (x *DriveIface) GetCanStop() func(Drive) bool {
	if x.xCanStop == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanStop)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideStop sets the callback function.
func (x *DriveIface) OverrideStop(cb func(Drive, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xStop = 0
	} else {
		x.xStop = purego.NewCallback(func(DriveVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetStop gets the callback function.
func (x *DriveIface) GetStop() func(Drive, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xStop == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xStop)
	return func(DriveVar Drive, FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(DriveVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideStopFinish sets the callback function.
func (x *DriveIface) OverrideStopFinish(cb func(Drive, AsyncResult) bool) {
	if cb == nil {
		x.xStopFinish = 0
	} else {
		x.xStopFinish = purego.NewCallback(func(DriveVarp uintptr, ResultVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetStopFinish gets the callback function.
func (x *DriveIface) GetStopFinish() func(Drive, AsyncResult) bool {
	if x.xStopFinish == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xStopFinish)
	return func(DriveVar Drive, ResultVar AsyncResult) bool {
		return rawCallback(DriveVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideStopButton sets the callback function.
func (x *DriveIface) OverrideStopButton(cb func(Drive)) {
	if cb == nil {
		x.xStopButton = 0
	} else {
		x.xStopButton = purego.NewCallback(func(DriveVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetStopButton gets the callback function.
func (x *DriveIface) GetStopButton() func(Drive) {
	if x.xStopButton == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xStopButton)
	return func(DriveVar Drive) {
		rawCallback(DriveVar.GoPointer())
	}
}

// OverrideEjectWithOperation sets the callback function.
func (x *DriveIface) OverrideEjectWithOperation(cb func(Drive, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEjectWithOperation = 0
	} else {
		x.xEjectWithOperation = purego.NewCallback(func(DriveVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&DriveBase{Ptr: DriveVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEjectWithOperation gets the callback function.
func (x *DriveIface) GetEjectWithOperation() func(Drive, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEjectWithOperation == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEjectWithOperation)
	return func(DriveVar Drive, FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(DriveVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEjectWithOperationFinish sets the callback function.
func (x *DriveIface) OverrideEjectWithOperationFinish(cb func(Drive, AsyncResult) bool) {
	if cb == nil {
		x.xEjectWithOperationFinish = 0
	} else {
		x.xEjectWithOperationFinish = purego.NewCallback(func(DriveVarp uintptr, ResultVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetEjectWithOperationFinish gets the callback function.
func (x *DriveIface) GetEjectWithOperationFinish() func(Drive, AsyncResult) bool {
	if x.xEjectWithOperationFinish == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEjectWithOperationFinish)
	return func(DriveVar Drive, ResultVar AsyncResult) bool {
		return rawCallback(DriveVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGetSortKey sets the callback function.
func (x *DriveIface) OverrideGetSortKey(cb func(Drive) string) {
	if cb == nil {
		x.xGetSortKey = 0
	} else {
		x.xGetSortKey = purego.NewCallback(func(DriveVarp uintptr) string {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetGetSortKey gets the callback function.
func (x *DriveIface) GetGetSortKey() func(Drive) string {
	if x.xGetSortKey == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetSortKey)
	return func(DriveVar Drive) string {
		return rawCallback(DriveVar.GoPointer())
	}
}

// OverrideGetSymbolicIcon sets the callback function.
func (x *DriveIface) OverrideGetSymbolicIcon(cb func(Drive) *IconBase) {
	if cb == nil {
		x.xGetSymbolicIcon = 0
	} else {
		x.xGetSymbolicIcon = purego.NewCallback(func(DriveVarp uintptr) uintptr {
			ret := cb(&DriveBase{Ptr: DriveVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetSymbolicIcon gets the callback function.
func (x *DriveIface) GetGetSymbolicIcon() func(Drive) *IconBase {
	if x.xGetSymbolicIcon == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetSymbolicIcon)
	return func(DriveVar Drive) *IconBase {
		rawRet := rawCallback(DriveVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideIsRemovable sets the callback function.
func (x *DriveIface) OverrideIsRemovable(cb func(Drive) bool) {
	if cb == nil {
		x.xIsRemovable = 0
	} else {
		x.xIsRemovable = purego.NewCallback(func(DriveVarp uintptr) bool {
			return cb(&DriveBase{Ptr: DriveVarp})
		})
	}
}

// GetIsRemovable gets the callback function.
func (x *DriveIface) GetIsRemovable() func(Drive) bool {
	if x.xIsRemovable == 0 {
		return nil
	}
	var rawCallback func(DriveVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsRemovable)
	return func(DriveVar Drive) bool {
		return rawCallback(DriveVar.GoPointer())
	}
}

// #GDrive - this represent a piece of hardware connected to the machine.
// It's generally only created for removable hardware or hardware with
// removable media.
//
// #GDrive is a container class for #GVolume objects that stem from
// the same piece of media. As such, #GDrive abstracts a drive with
// (or without) removable media and provides operations for querying
// whether media is available, determining whether media change is
// automatically detected and ejecting the media.
//
// If the #GDrive reports that media isn't automatically detected, one
// can poll for media; typically one should not do this periodically
// as a poll for media operation is potentially expensive and may
// spin up the drive creating noise.
//
// #GDrive supports starting and stopping drives with authentication
// support for the former. This can be used to support a diverse set
// of use cases including connecting/disconnecting iSCSI devices,
// powering down external disk enclosures and starting/stopping
// multi-disk devices such as RAID devices. Note that the actual
// semantics and side-effects of starting/stopping a #GDrive may vary
// according to implementation. To choose the correct verbs in e.g. a
// file manager, use g_drive_get_start_stop_type().
//
// For porting from GnomeVFS note that there is no equivalent of
// #GDrive in that API.
type Drive interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	CanEject() bool
	CanPollForMedia() bool
	CanStart() bool
	CanStartDegraded() bool
	CanStop() bool
	Eject(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectFinish(ResultVar AsyncResult) (bool, error)
	EjectWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectWithOperationFinish(ResultVar AsyncResult) (bool, error)
	EnumerateIdentifiers() []string
	GetIcon() *IconBase
	GetIdentifier(KindVar string) string
	GetName() string
	GetSortKey() string
	GetStartStopType() DriveStartStopType
	GetSymbolicIcon() *IconBase
	GetVolumes() *glib.List
	HasMedia() bool
	HasVolumes() bool
	IsMediaCheckAutomatic() bool
	IsMediaRemovable() bool
	IsRemovable() bool
	PollForMedia(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	PollForMediaFinish(ResultVar AsyncResult) (bool, error)
	Start(FlagsVar DriveStartFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	StartFinish(ResultVar AsyncResult) (bool, error)
	Stop(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	StopFinish(ResultVar AsyncResult) (bool, error)
}

var xDriveGLibType func() types.GType

func DriveGLibType() types.GType {
	return xDriveGLibType()
}

type DriveBase struct {
	Ptr uintptr
}

func (x *DriveBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *DriveBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Checks if a drive can be ejected.
func (x *DriveBase) CanEject() bool {

	cret := XGDriveCanEject(x.GoPointer())
	return cret
}

// Checks if a drive can be polled for media changes.
func (x *DriveBase) CanPollForMedia() bool {

	cret := XGDriveCanPollForMedia(x.GoPointer())
	return cret
}

// Checks if a drive can be started.
func (x *DriveBase) CanStart() bool {

	cret := XGDriveCanStart(x.GoPointer())
	return cret
}

// Checks if a drive can be started degraded.
func (x *DriveBase) CanStartDegraded() bool {

	cret := XGDriveCanStartDegraded(x.GoPointer())
	return cret
}

// Checks if a drive can be stopped.
func (x *DriveBase) CanStop() bool {

	cret := XGDriveCanStop(x.GoPointer())
	return cret
}

// Asynchronously ejects a drive.
//
// When the operation is finished, @callback will be called.
// You can then call g_drive_eject_finish() to obtain the
// result of the operation.
func (x *DriveBase) Eject(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDriveEject(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes ejecting a drive.
func (x *DriveBase) EjectFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDriveEjectFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Ejects a drive. This is an asynchronous operation, and is
// finished by calling g_drive_eject_with_operation_finish() with the @drive
// and #GAsyncResult data returned in the @callback.
func (x *DriveBase) EjectWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDriveEjectWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes ejecting a drive. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *DriveBase) EjectWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDriveEjectWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the kinds of identifiers that @drive has.
// Use g_drive_get_identifier() to obtain the identifiers
// themselves.
func (x *DriveBase) EnumerateIdentifiers() []string {

	cret := XGDriveEnumerateIdentifiers(x.GoPointer())
	return cret
}

// Gets the icon for @drive.
func (x *DriveBase) GetIcon() *IconBase {
	var cls *IconBase

	cret := XGDriveGetIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Gets the identifier of the given kind for @drive. The only
// identifier currently available is
// %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
func (x *DriveBase) GetIdentifier(KindVar string) string {

	cret := XGDriveGetIdentifier(x.GoPointer(), KindVar)
	return cret
}

// Gets the name of @drive.
func (x *DriveBase) GetName() string {

	cret := XGDriveGetName(x.GoPointer())
	return cret
}

// Gets the sort key for @drive, if any.
func (x *DriveBase) GetSortKey() string {

	cret := XGDriveGetSortKey(x.GoPointer())
	return cret
}

// Gets a hint about how a drive can be started/stopped.
func (x *DriveBase) GetStartStopType() DriveStartStopType {

	cret := XGDriveGetStartStopType(x.GoPointer())
	return cret
}

// Gets the icon for @drive.
func (x *DriveBase) GetSymbolicIcon() *IconBase {
	var cls *IconBase

	cret := XGDriveGetSymbolicIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Get a list of mountable volumes for @drive.
//
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (x *DriveBase) GetVolumes() *glib.List {

	cret := XGDriveGetVolumes(x.GoPointer())
	return cret
}

// Checks if the @drive has media. Note that the OS may not be polling
// the drive for media changes; see g_drive_is_media_check_automatic()
// for more details.
func (x *DriveBase) HasMedia() bool {

	cret := XGDriveHasMedia(x.GoPointer())
	return cret
}

// Check if @drive has any mountable volumes.
func (x *DriveBase) HasVolumes() bool {

	cret := XGDriveHasVolumes(x.GoPointer())
	return cret
}

// Checks if @drive is capable of automatically detecting media changes.
func (x *DriveBase) IsMediaCheckAutomatic() bool {

	cret := XGDriveIsMediaCheckAutomatic(x.GoPointer())
	return cret
}

// Checks if the @drive supports removable media.
func (x *DriveBase) IsMediaRemovable() bool {

	cret := XGDriveIsMediaRemovable(x.GoPointer())
	return cret
}

// Checks if the #GDrive and/or its media is considered removable by the user.
// See g_drive_is_media_removable().
func (x *DriveBase) IsRemovable() bool {

	cret := XGDriveIsRemovable(x.GoPointer())
	return cret
}

// Asynchronously polls @drive to see if media has been inserted or removed.
//
// When the operation is finished, @callback will be called.
// You can then call g_drive_poll_for_media_finish() to obtain the
// result of the operation.
func (x *DriveBase) PollForMedia(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDrivePollForMedia(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an operation started with g_drive_poll_for_media() on a drive.
func (x *DriveBase) PollForMediaFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDrivePollForMediaFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously starts a drive.
//
// When the operation is finished, @callback will be called.
// You can then call g_drive_start_finish() to obtain the
// result of the operation.
func (x *DriveBase) Start(FlagsVar DriveStartFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDriveStart(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes starting a drive.
func (x *DriveBase) StartFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDriveStartFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously stops a drive.
//
// When the operation is finished, @callback will be called.
// You can then call g_drive_stop_finish() to obtain the
// result of the operation.
func (x *DriveBase) Stop(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDriveStop(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes stopping a drive.
func (x *DriveBase) StopFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDriveStopFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var XGDriveCanEject func(uintptr) bool
var XGDriveCanPollForMedia func(uintptr) bool
var XGDriveCanStart func(uintptr) bool
var XGDriveCanStartDegraded func(uintptr) bool
var XGDriveCanStop func(uintptr) bool
var XGDriveEject func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGDriveEjectFinish func(uintptr, uintptr, **glib.Error) bool
var XGDriveEjectWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGDriveEjectWithOperationFinish func(uintptr, uintptr, **glib.Error) bool
var XGDriveEnumerateIdentifiers func(uintptr) []string
var XGDriveGetIcon func(uintptr) uintptr
var XGDriveGetIdentifier func(uintptr, string) string
var XGDriveGetName func(uintptr) string
var XGDriveGetSortKey func(uintptr) string
var XGDriveGetStartStopType func(uintptr) DriveStartStopType
var XGDriveGetSymbolicIcon func(uintptr) uintptr
var XGDriveGetVolumes func(uintptr) *glib.List
var XGDriveHasMedia func(uintptr) bool
var XGDriveHasVolumes func(uintptr) bool
var XGDriveIsMediaCheckAutomatic func(uintptr) bool
var XGDriveIsMediaRemovable func(uintptr) bool
var XGDriveIsRemovable func(uintptr) bool
var XGDrivePollForMedia func(uintptr, uintptr, uintptr, uintptr)
var XGDrivePollForMediaFinish func(uintptr, uintptr, **glib.Error) bool
var XGDriveStart func(uintptr, DriveStartFlags, uintptr, uintptr, uintptr, uintptr)
var XGDriveStartFinish func(uintptr, uintptr, **glib.Error) bool
var XGDriveStop func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGDriveStopFinish func(uintptr, uintptr, **glib.Error) bool

const (
	// The string used to obtain a Unix device path with g_drive_get_identifier().
	DRIVE_IDENTIFIER_KIND_UNIX_DEVICE string = "unix-device"
)

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibrary("GIO", "libgio-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xDriveGLibType, lib, "g_drive_get_type")

	core.PuregoSafeRegister(&XGDriveCanEject, lib, "g_drive_can_eject")
	core.PuregoSafeRegister(&XGDriveCanPollForMedia, lib, "g_drive_can_poll_for_media")
	core.PuregoSafeRegister(&XGDriveCanStart, lib, "g_drive_can_start")
	core.PuregoSafeRegister(&XGDriveCanStartDegraded, lib, "g_drive_can_start_degraded")
	core.PuregoSafeRegister(&XGDriveCanStop, lib, "g_drive_can_stop")
	core.PuregoSafeRegister(&XGDriveEject, lib, "g_drive_eject")
	core.PuregoSafeRegister(&XGDriveEjectFinish, lib, "g_drive_eject_finish")
	core.PuregoSafeRegister(&XGDriveEjectWithOperation, lib, "g_drive_eject_with_operation")
	core.PuregoSafeRegister(&XGDriveEjectWithOperationFinish, lib, "g_drive_eject_with_operation_finish")
	core.PuregoSafeRegister(&XGDriveEnumerateIdentifiers, lib, "g_drive_enumerate_identifiers")
	core.PuregoSafeRegister(&XGDriveGetIcon, lib, "g_drive_get_icon")
	core.PuregoSafeRegister(&XGDriveGetIdentifier, lib, "g_drive_get_identifier")
	core.PuregoSafeRegister(&XGDriveGetName, lib, "g_drive_get_name")
	core.PuregoSafeRegister(&XGDriveGetSortKey, lib, "g_drive_get_sort_key")
	core.PuregoSafeRegister(&XGDriveGetStartStopType, lib, "g_drive_get_start_stop_type")
	core.PuregoSafeRegister(&XGDriveGetSymbolicIcon, lib, "g_drive_get_symbolic_icon")
	core.PuregoSafeRegister(&XGDriveGetVolumes, lib, "g_drive_get_volumes")
	core.PuregoSafeRegister(&XGDriveHasMedia, lib, "g_drive_has_media")
	core.PuregoSafeRegister(&XGDriveHasVolumes, lib, "g_drive_has_volumes")
	core.PuregoSafeRegister(&XGDriveIsMediaCheckAutomatic, lib, "g_drive_is_media_check_automatic")
	core.PuregoSafeRegister(&XGDriveIsMediaRemovable, lib, "g_drive_is_media_removable")
	core.PuregoSafeRegister(&XGDriveIsRemovable, lib, "g_drive_is_removable")
	core.PuregoSafeRegister(&XGDrivePollForMedia, lib, "g_drive_poll_for_media")
	core.PuregoSafeRegister(&XGDrivePollForMediaFinish, lib, "g_drive_poll_for_media_finish")
	core.PuregoSafeRegister(&XGDriveStart, lib, "g_drive_start")
	core.PuregoSafeRegister(&XGDriveStartFinish, lib, "g_drive_start_finish")
	core.PuregoSafeRegister(&XGDriveStop, lib, "g_drive_stop")
	core.PuregoSafeRegister(&XGDriveStopFinish, lib, "g_drive_stop_finish")

}
