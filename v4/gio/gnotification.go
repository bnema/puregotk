// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"runtime"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// `GNotification` is a mechanism for creating a notification to be shown
// to the user — typically as a pop-up notification presented by the
// desktop environment shell.
//
// The key difference between `GNotification` and other similar APIs is
// that, if supported by the desktop environment, notifications sent
// with `GNotification` will persist after the application has exited,
// and even across system reboots.
//
// Since the user may click on a notification while the application is
// not running, applications using `GNotification` should be able to be
// started as a D-Bus service, using [class@Gio.Application].
//
// In order for `GNotification` to work, the application must have installed
// a `.desktop` file. For example:
// ```
// [Desktop Entry]
// Name=Test Application
// Comment=Description of what Test Application does
// Exec=gnome-test-application
// Icon=org.gnome.TestApplication
// Terminal=false
// Type=Application
// Categories=GNOME;GTK;TestApplication Category;
// StartupNotify=true
// DBusActivatable=true
// X-GNOME-UsesNotifications=true
// ```
//
// The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
// that this application uses notifications, so it can be listed in the
// Control Center’s ‘Notifications’ panel.
//
// The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
// where `org.gnome.TestApplication` is the ID passed to
// [ctor@Gio.Application.new].
//
// User interaction with a notification (either the default action, or
// buttons) must be associated with actions on the application (ie:
// `app.` actions).  It is not possible to route user interaction
// through the notification itself, because the object will not exist if
// the application is autostarted as a result of a notification being
// clicked.
//
// A notification can be sent with [method@Gio.Application.send_notification].
type Notification struct {
	gobject.Object
}

var xNotificationGLibType func() types.GType

func NotificationGLibType() types.GType {
	return xNotificationGLibType()
}

func NotificationNewFromInternalPtr(ptr uintptr) *Notification {
	cls := &Notification{}
	cls.Ptr = ptr
	return cls
}

var xNewNotification func(string) uintptr

// Creates a new #GNotification with @title as its title.
//
// After populating @notification with more details, it can be sent to
// the desktop shell with g_application_send_notification(). Changing
// any properties after this call will not have any effect until
// resending @notification.
func NewNotification(TitleVar string) *Notification {
	var cls *Notification

	cret := xNewNotification(TitleVar)

	if cret == 0 {
		return nil
	}
	cls = &Notification{}
	cls.Ptr = cret
	return cls
}

var xNotificationAddButton func(uintptr, string, string)

// Adds a button to @notification that activates the action in
// @detailed_action when clicked. That action must be an
// application-wide action (starting with "app."). If @detailed_action
// contains a target, the action will be activated with that target as
// its parameter.
//
// See g_action_parse_detailed_name() for a description of the format
// for @detailed_action.
func (x *Notification) AddButton(LabelVar string, DetailedActionVar string) {

	xNotificationAddButton(x.GoPointer(), LabelVar, DetailedActionVar)

}

var xNotificationAddButtonWithTarget func(uintptr, string, string, uintptr, ...interface{})

// Adds a button to @notification that activates @action when clicked.
// @action must be an application-wide action (it must start with "app.").
//
// If @target_format is given, it is used to collect remaining
// positional parameters into a #GVariant instance, similar to
// g_variant_new(). @action will be activated with that #GVariant as its
// parameter.
func (x *Notification) AddButtonWithTarget(LabelVar string, ActionVar string, TargetFormatVar *string, varArgs ...interface{}) {

	TargetFormatVarPtr, TargetFormatVarBytes := core.NullableStringToPtr(TargetFormatVar)

	xNotificationAddButtonWithTarget(x.GoPointer(), LabelVar, ActionVar, TargetFormatVarPtr, varArgs...)

	runtime.KeepAlive(TargetFormatVarBytes)

}

var xNotificationAddButtonWithTargetValue func(uintptr, string, string, *glib.Variant)

// Adds a button to @notification that activates @action when clicked.
// @action must be an application-wide action (it must start with "app.").
//
// If @target is non-%NULL, @action will be activated with @target as
// its parameter.
func (x *Notification) AddButtonWithTargetValue(LabelVar string, ActionVar string, TargetVar *glib.Variant) {

	xNotificationAddButtonWithTargetValue(x.GoPointer(), LabelVar, ActionVar, TargetVar)

}

var xNotificationSetBody func(uintptr, uintptr)

// Sets the body of @notification to @body.
func (x *Notification) SetBody(BodyVar *string) {

	BodyVarPtr, BodyVarBytes := core.NullableStringToPtr(BodyVar)

	xNotificationSetBody(x.GoPointer(), BodyVarPtr)

	runtime.KeepAlive(BodyVarBytes)

}

var xNotificationSetCategory func(uintptr, uintptr)

// Sets the type of @notification to @category. Categories have a main
// type like `email`, `im` or `device` and can have a detail separated
// by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
// helps the notification server to select proper feedback to the user.
//
// Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
func (x *Notification) SetCategory(CategoryVar *string) {

	CategoryVarPtr, CategoryVarBytes := core.NullableStringToPtr(CategoryVar)

	xNotificationSetCategory(x.GoPointer(), CategoryVarPtr)

	runtime.KeepAlive(CategoryVarBytes)

}

var xNotificationSetDefaultAction func(uintptr, string)

// Sets the default action of @notification to @detailed_action. This
// action is activated when the notification is clicked on.
//
// The action in @detailed_action must be an application-wide action (it
// must start with "app."). If @detailed_action contains a target, the
// given action will be activated with that target as its parameter.
// See g_action_parse_detailed_name() for a description of the format
// for @detailed_action.
//
// When no default action is set, the application that the notification
// was sent on is activated.
func (x *Notification) SetDefaultAction(DetailedActionVar string) {

	xNotificationSetDefaultAction(x.GoPointer(), DetailedActionVar)

}

var xNotificationSetDefaultActionAndTarget func(uintptr, string, uintptr, ...interface{})

// Sets the default action of @notification to @action. This action is
// activated when the notification is clicked on. It must be an
// application-wide action (it must start with "app.").
//
// If @target_format is given, it is used to collect remaining
// positional parameters into a #GVariant instance, similar to
// g_variant_new(). @action will be activated with that #GVariant as its
// parameter.
//
// When no default action is set, the application that the notification
// was sent on is activated.
func (x *Notification) SetDefaultActionAndTarget(ActionVar string, TargetFormatVar *string, varArgs ...interface{}) {

	TargetFormatVarPtr, TargetFormatVarBytes := core.NullableStringToPtr(TargetFormatVar)

	xNotificationSetDefaultActionAndTarget(x.GoPointer(), ActionVar, TargetFormatVarPtr, varArgs...)

	runtime.KeepAlive(TargetFormatVarBytes)

}

var xNotificationSetDefaultActionAndTargetValue func(uintptr, string, *glib.Variant)

// Sets the default action of @notification to @action. This action is
// activated when the notification is clicked on. It must be an
// application-wide action (start with "app.").
//
// If @target is non-%NULL, @action will be activated with @target as
// its parameter. If @target is floating, it will be consumed.
//
// When no default action is set, the application that the notification
// was sent on is activated.
func (x *Notification) SetDefaultActionAndTargetValue(ActionVar string, TargetVar *glib.Variant) {

	xNotificationSetDefaultActionAndTargetValue(x.GoPointer(), ActionVar, TargetVar)

}

var xNotificationSetIcon func(uintptr, uintptr)

// Sets the icon of @notification to @icon.
func (x *Notification) SetIcon(IconVar Icon) {

	xNotificationSetIcon(x.GoPointer(), IconVar.GoPointer())

}

var xNotificationSetPriority func(uintptr, NotificationPriority)

// Sets the priority of @notification to @priority. See
// #GNotificationPriority for possible values.
func (x *Notification) SetPriority(PriorityVar NotificationPriority) {

	xNotificationSetPriority(x.GoPointer(), PriorityVar)

}

var xNotificationSetTitle func(uintptr, string)

// Sets the title of @notification to @title.
func (x *Notification) SetTitle(TitleVar string) {

	xNotificationSetTitle(x.GoPointer(), TitleVar)

}

var xNotificationSetUrgent func(uintptr, bool)

// Deprecated in favor of g_notification_set_priority().
func (x *Notification) SetUrgent(UrgentVar bool) {

	xNotificationSetUrgent(x.GoPointer(), UrgentVar)

}

func (c *Notification) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Notification) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xNotificationGLibType, libs, "g_notification_get_type")

	core.PuregoSafeRegister(&xNewNotification, libs, "g_notification_new")

	core.PuregoSafeRegister(&xNotificationAddButton, libs, "g_notification_add_button")
	core.PuregoSafeRegister(&xNotificationAddButtonWithTarget, libs, "g_notification_add_button_with_target")
	core.PuregoSafeRegister(&xNotificationAddButtonWithTargetValue, libs, "g_notification_add_button_with_target_value")
	core.PuregoSafeRegister(&xNotificationSetBody, libs, "g_notification_set_body")
	core.PuregoSafeRegister(&xNotificationSetCategory, libs, "g_notification_set_category")
	core.PuregoSafeRegister(&xNotificationSetDefaultAction, libs, "g_notification_set_default_action")
	core.PuregoSafeRegister(&xNotificationSetDefaultActionAndTarget, libs, "g_notification_set_default_action_and_target")
	core.PuregoSafeRegister(&xNotificationSetDefaultActionAndTargetValue, libs, "g_notification_set_default_action_and_target_value")
	core.PuregoSafeRegister(&xNotificationSetIcon, libs, "g_notification_set_icon")
	core.PuregoSafeRegister(&xNotificationSetPriority, libs, "g_notification_set_priority")
	core.PuregoSafeRegister(&xNotificationSetTitle, libs, "g_notification_set_title")
	core.PuregoSafeRegister(&xNotificationSetUrgent, libs, "g_notification_set_urgent")

}
