// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The virtual function table for #GDebugController.
type DebugControllerInterface struct {
	_ structs.HostLayout

	GIface uintptr
}

func (x *DebugControllerInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GDebugController` is an interface to expose control of debugging features and
// debug output.
//
// It is implemented on Linux using [class@Gio.DebugControllerDBus], which
// exposes a D-Bus interface to allow authenticated peers to control debug
// features in this process.
//
// Whether debug output is enabled is exposed as
// [property@Gio.DebugController:debug-enabled]. This controls
// [func@GLib.log_set_debug_enabled] by default. Application code may
// connect to the [signal@GObject.Object::notify] signal for it
// to control other parts of its debug infrastructure as necessary.
//
// If your application or service is using the default GLib log writer function,
// creating one of the built-in implementations of `GDebugController` should be
// all thatâ€™s needed to dynamically enable or disable debug output.
type DebugController interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	GetDebugEnabled() bool
	SetDebugEnabled(DebugEnabledVar bool)
}

var xDebugControllerGLibType func() types.GType

func DebugControllerGLibType() types.GType {
	return xDebugControllerGLibType()
}

type DebugControllerBase struct {
	Ptr uintptr
}

func (x *DebugControllerBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *DebugControllerBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Get the value of #GDebugController:debug-enabled.
func (x *DebugControllerBase) GetDebugEnabled() bool {

	cret := XGDebugControllerGetDebugEnabled(x.GoPointer())

	return cret
}

// Set the value of #GDebugController:debug-enabled.
func (x *DebugControllerBase) SetDebugEnabled(DebugEnabledVar bool) {

	XGDebugControllerSetDebugEnabled(x.GoPointer(), DebugEnabledVar)

}

// SetPropertyDebugEnabled sets the "debug-enabled" property.
// %TRUE if debug output should be exposed (for example by forwarding it to
// the journal), %FALSE otherwise.
func (x *DebugControllerBase) SetPropertyDebugEnabled(value bool) {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	obj.SetProperty("debug-enabled", &v)
}

// GetPropertyDebugEnabled gets the "debug-enabled" property.
// %TRUE if debug output should be exposed (for example by forwarding it to
// the journal), %FALSE otherwise.
func (x *DebugControllerBase) GetPropertyDebugEnabled() bool {
	obj := gobject.Object{}
	obj.Ptr = x.GoPointer()
	var v gobject.Value
	obj.GetProperty("debug-enabled", &v)
	return v.GetBoolean()
}

var XGDebugControllerGetDebugEnabled func(uintptr) bool
var XGDebugControllerSetDebugEnabled func(uintptr, bool)

const (
	// Extension point for debug control functionality.
	// See [Extending GIO](overview.html#extending-gio).
	DEBUG_CONTROLLER_EXTENSION_POINT_NAME string = "gio-debug-controller"
)

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xDebugControllerGLibType, libs, "g_debug_controller_get_type")

	core.PuregoSafeRegister(&XGDebugControllerGetDebugEnabled, libs, "g_debug_controller_get_debug_enabled")
	core.PuregoSafeRegister(&XGDebugControllerSetDebugEnabled, libs, "g_debug_controller_set_debug_enabled")

}
