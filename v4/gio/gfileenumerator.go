// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type FileEnumeratorClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xNextFile uintptr

	xCloseFn uintptr

	xNextFilesAsync uintptr

	xNextFilesFinish uintptr

	xCloseAsync uintptr

	xCloseFinish uintptr

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr

	xGReserved6 uintptr

	xGReserved7 uintptr
}

func (x *FileEnumeratorClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideNextFile sets the callback function.
func (x *FileEnumeratorClass) OverrideNextFile(cb func(*FileEnumerator, *Cancellable) *FileInfo) {
	if cb == nil {
		x.xNextFile = 0
	} else {
		x.xNextFile = purego.NewCallback(func(EnumeratorVarp uintptr, CancellableVarp uintptr) uintptr {
			ret := cb(FileEnumeratorNewFromInternalPtr(EnumeratorVarp), CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetNextFile gets the callback function.
func (x *FileEnumeratorClass) GetNextFile() func(*FileEnumerator, *Cancellable) *FileInfo {
	if x.xNextFile == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xNextFile)
	return func(EnumeratorVar *FileEnumerator, CancellableVar *Cancellable) *FileInfo {
		rawRet := rawCallback(EnumeratorVar.GoPointer(), CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInfo{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCloseFn sets the callback function.
func (x *FileEnumeratorClass) OverrideCloseFn(cb func(*FileEnumerator, *Cancellable) bool) {
	if cb == nil {
		x.xCloseFn = 0
	} else {
		x.xCloseFn = purego.NewCallback(func(EnumeratorVarp uintptr, CancellableVarp uintptr) bool {
			return cb(FileEnumeratorNewFromInternalPtr(EnumeratorVarp), CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetCloseFn gets the callback function.
func (x *FileEnumeratorClass) GetCloseFn() func(*FileEnumerator, *Cancellable) bool {
	if x.xCloseFn == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCloseFn)
	return func(EnumeratorVar *FileEnumerator, CancellableVar *Cancellable) bool {
		return rawCallback(EnumeratorVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideNextFilesAsync sets the callback function.
func (x *FileEnumeratorClass) OverrideNextFilesAsync(cb func(*FileEnumerator, int, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xNextFilesAsync = 0
	} else {
		x.xNextFilesAsync = purego.NewCallback(func(EnumeratorVarp uintptr, NumFilesVarp int, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(FileEnumeratorNewFromInternalPtr(EnumeratorVarp), NumFilesVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetNextFilesAsync gets the callback function.
func (x *FileEnumeratorClass) GetNextFilesAsync() func(*FileEnumerator, int, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xNextFilesAsync == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, NumFilesVarp int, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xNextFilesAsync)
	return func(EnumeratorVar *FileEnumerator, NumFilesVar int, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(EnumeratorVar.GoPointer(), NumFilesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideNextFilesFinish sets the callback function.
func (x *FileEnumeratorClass) OverrideNextFilesFinish(cb func(*FileEnumerator, AsyncResult) *glib.List) {
	if cb == nil {
		x.xNextFilesFinish = 0
	} else {
		x.xNextFilesFinish = purego.NewCallback(func(EnumeratorVarp uintptr, ResultVarp uintptr) *glib.List {
			return cb(FileEnumeratorNewFromInternalPtr(EnumeratorVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetNextFilesFinish gets the callback function.
func (x *FileEnumeratorClass) GetNextFilesFinish() func(*FileEnumerator, AsyncResult) *glib.List {
	if x.xNextFilesFinish == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, ResultVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xNextFilesFinish)
	return func(EnumeratorVar *FileEnumerator, ResultVar AsyncResult) *glib.List {
		return rawCallback(EnumeratorVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideCloseAsync sets the callback function.
func (x *FileEnumeratorClass) OverrideCloseAsync(cb func(*FileEnumerator, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xCloseAsync = 0
	} else {
		x.xCloseAsync = purego.NewCallback(func(EnumeratorVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(FileEnumeratorNewFromInternalPtr(EnumeratorVarp), IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetCloseAsync gets the callback function.
func (x *FileEnumeratorClass) GetCloseAsync() func(*FileEnumerator, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xCloseAsync == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCloseAsync)
	return func(EnumeratorVar *FileEnumerator, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(EnumeratorVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideCloseFinish sets the callback function.
func (x *FileEnumeratorClass) OverrideCloseFinish(cb func(*FileEnumerator, AsyncResult) bool) {
	if cb == nil {
		x.xCloseFinish = 0
	} else {
		x.xCloseFinish = purego.NewCallback(func(EnumeratorVarp uintptr, ResultVarp uintptr) bool {
			return cb(FileEnumeratorNewFromInternalPtr(EnumeratorVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetCloseFinish gets the callback function.
func (x *FileEnumeratorClass) GetCloseFinish() func(*FileEnumerator, AsyncResult) bool {
	if x.xCloseFinish == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCloseFinish)
	return func(EnumeratorVar *FileEnumerator, ResultVar AsyncResult) bool {
		return rawCallback(EnumeratorVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGReserved1 sets the callback function.
func (x *FileEnumeratorClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the callback function.
func (x *FileEnumeratorClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the callback function.
func (x *FileEnumeratorClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the callback function.
func (x *FileEnumeratorClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the callback function.
func (x *FileEnumeratorClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the callback function.
func (x *FileEnumeratorClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the callback function.
func (x *FileEnumeratorClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the callback function.
func (x *FileEnumeratorClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the callback function.
func (x *FileEnumeratorClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the callback function.
func (x *FileEnumeratorClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved6 sets the callback function.
func (x *FileEnumeratorClass) OverrideGReserved6(cb func()) {
	if cb == nil {
		x.xGReserved6 = 0
	} else {
		x.xGReserved6 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved6 gets the callback function.
func (x *FileEnumeratorClass) GetGReserved6() func() {
	if x.xGReserved6 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved6)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved7 sets the callback function.
func (x *FileEnumeratorClass) OverrideGReserved7(cb func()) {
	if cb == nil {
		x.xGReserved7 = 0
	} else {
		x.xGReserved7 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved7 gets the callback function.
func (x *FileEnumeratorClass) GetGReserved7() func() {
	if x.xGReserved7 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved7)
	return func() {
		rawCallback()
	}
}

type FileEnumeratorPrivate struct {
	_ structs.HostLayout
}

func (x *FileEnumeratorPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GFileEnumerator` allows you to operate on a set of [iface@Gio.File] objects,
// returning a [class@Gio.FileInfo] structure for each file enumerated (e.g.
// [method@Gio.File.enumerate_children] will return a `GFileEnumerator` for each
// of the children within a directory).
//
// To get the next file's information from a `GFileEnumerator`, use
// [method@Gio.FileEnumerator.next_file] or its asynchronous version,
// [method@Gio.FileEnumerator.next_files_async]. Note that the asynchronous
// version will return a list of [class@Gio.FileInfo] objects, whereas the
// synchronous will only return the next file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix
// platforms; for more information, see [method@GLib.Dir.read_name].  On Unix,
// when operating on local files, returned files will be sorted by
// inode number.  Effectively you can assume that the ordering of
// returned files will be stable between successive calls (and
// applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your
// application code.
//
// To close a `GFileEnumerator`, use [method@Gio.FileEnumerator.close], or
// its asynchronous version, [method@Gio.FileEnumerator.close_async]. Once
// a `GFileEnumerator` is closed, no further actions may be performed
// on it, and it should be freed with [method@GObject.Object.unref].
type FileEnumerator struct {
	gobject.Object
}

var xFileEnumeratorGLibType func() types.GType

func FileEnumeratorGLibType() types.GType {
	return xFileEnumeratorGLibType()
}

func FileEnumeratorNewFromInternalPtr(ptr uintptr) *FileEnumerator {
	cls := &FileEnumerator{}
	cls.Ptr = ptr
	return cls
}

var xFileEnumeratorClose func(uintptr, uintptr, **glib.Error) bool

// Releases all resources used by this enumerator, making the
// enumerator return %G_IO_ERROR_CLOSED on all calls.
//
// This will be automatically called when the last reference
// is dropped, but you might want to call this function to make
// sure resources are released as early as possible.
func (x *FileEnumerator) Close(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xFileEnumeratorClose(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileEnumeratorCloseAsync func(uintptr, int, uintptr, uintptr, uintptr)

// Asynchronously closes the file enumerator.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
// g_file_enumerator_close_finish().
func (x *FileEnumerator) CloseAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xFileEnumeratorCloseAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xFileEnumeratorCloseFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes closing a file enumerator, started from g_file_enumerator_close_async().
//
// If the file enumerator was already closed when g_file_enumerator_close_async()
// was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
// return %FALSE. If the file enumerator had pending operation when the close
// operation was started, then this function will report %G_IO_ERROR_PENDING, and
// return %FALSE.  If @cancellable was not %NULL, then the operation may have been
// cancelled by triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
// returned.
func (x *FileEnumerator) CloseFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xFileEnumeratorCloseFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileEnumeratorGetChild func(uintptr, uintptr) uintptr

// Return a new #GFile which refers to the file named by @info in the source
// directory of @enumerator.  This function is primarily intended to be used
// inside loops with g_file_enumerator_next_file().
//
// To use this, %G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
// attributes list used when creating the #GFileEnumerator.
//
// This is a convenience method that's equivalent to:
// |[&lt;!-- language="C" --&gt;
//
//	gchar *name = g_file_info_get_name (info);
//	GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
//	                                 name);
//
// ]|
func (x *FileEnumerator) GetChild(InfoVar *FileInfo) *FileBase {
	var cls *FileBase

	cret := xFileEnumeratorGetChild(x.GoPointer(), InfoVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileEnumeratorGetContainer func(uintptr) uintptr

// Get the #GFile container which is being enumerated.
func (x *FileEnumerator) GetContainer() *FileBase {
	var cls *FileBase

	cret := xFileEnumeratorGetContainer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileEnumeratorHasPending func(uintptr) bool

// Checks if the file enumerator has pending operations.
func (x *FileEnumerator) HasPending() bool {

	cret := xFileEnumeratorHasPending(x.GoPointer())
	return cret
}

var xFileEnumeratorIsClosed func(uintptr) bool

// Checks if the file enumerator has been closed.
func (x *FileEnumerator) IsClosed() bool {

	cret := xFileEnumeratorIsClosed(x.GoPointer())
	return cret
}

var xFileEnumeratorIterate func(uintptr, uintptr, *uintptr, uintptr, **glib.Error) bool

// This is a version of g_file_enumerator_next_file() that's easier to
// use correctly from C programs.  With g_file_enumerator_next_file(),
// the gboolean return value signifies "end of iteration or error", which
// requires allocation of a temporary #GError.
//
// In contrast, with this function, a %FALSE return from
// g_file_enumerator_iterate() *always* means
// "error".  End of iteration is signaled by @out_info or @out_child being %NULL.
//
// Another crucial difference is that the references for @out_info and
// @out_child are owned by @direnum (they are cached as hidden
// properties).  You must not unref them in your own code.  This makes
// memory management significantly easier for C code in combination
// with loops.
//
// Finally, this function optionally allows retrieving a #GFile as
// well.
//
// You must specify at least one of @out_info or @out_child.
//
// The code pattern for correctly using g_file_enumerator_iterate() from C
// is:
//
// |[
// direnum = g_file_enumerate_children (file, ...);
// while (TRUE)
//
//	{
//	  GFileInfo *info;
//	  if (!g_file_enumerator_iterate (direnum, &amp;info, NULL, cancellable, error))
//	    goto out;
//	  if (!info)
//	    break;
//	  ... do stuff with "info"; do not unref it! ...
//	}
//
// out:
//
//	g_object_unref (direnum); // Note: frees the last @info
//
// ]|
func (x *FileEnumerator) Iterate(OutInfoVar **FileInfo, OutChildVar *File, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xFileEnumeratorIterate(x.GoPointer(), *gobject.ConvertPtr(OutInfoVar), gobject.ConvertPtr(OutChildVar), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileEnumeratorNextFile func(uintptr, uintptr, **glib.Error) uintptr

// Returns information for the next file in the enumerated object.
// Will block until the information is available. The #GFileInfo
// returned from this function will contain attributes that match the
// attribute string that was passed when the #GFileEnumerator was created.
//
// See the documentation of #GFileEnumerator for information about the
// order of returned files.
//
// On error, returns %NULL and sets @error to the error. If the
// enumerator is at the end, %NULL will be returned and @error will
// be unset.
func (x *FileEnumerator) NextFile(CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := xFileEnumeratorNextFile(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileEnumeratorNextFilesAsync func(uintptr, int, int, uintptr, uintptr, uintptr)

// Request information for a number of files from the enumerator asynchronously.
// When all I/O for the operation is finished the @callback will be called with
// the requested information.
//
// See the documentation of #GFileEnumerator for information about the
// order of returned files.
//
// Once the end of the enumerator is reached, or if an error occurs, the
// @callback will be called with an empty list. In this case, the previous call
// to g_file_enumerator_next_files_async() will typically have returned fewer
// than @num_files items.
//
// If a request is cancelled the callback will be called with
// %G_IO_ERROR_CANCELLED.
//
// This leads to the following pseudo-code usage:
// |[
// g_autoptr(GFile) dir = get_directory ();
// g_autoptr(GFileEnumerator) enumerator = NULL;
// g_autolist(GFileInfo) files = NULL;
// g_autoptr(GError) local_error = NULL;
//
// enumerator = yield g_file_enumerate_children_async (dir,
//
//	G_FILE_ATTRIBUTE_STANDARD_NAME ","
//	G_FILE_ATTRIBUTE_STANDARD_TYPE,
//	G_FILE_QUERY_INFO_NONE,
//	G_PRIORITY_DEFAULT,
//	cancellable,
//	…,
//	&amp;local_error);
//
// if (enumerator == NULL)
//
//	g_error ("Error enumerating: %s", local_error-&gt;message);
//
// // Loop until no files are returned, either because the end of the enumerator
// // has been reached, or an error was returned.
// do
//
//	{
//	  files = yield g_file_enumerator_next_files_async (enumerator,
//	                                                    5,  // number of files to request
//	                                                    G_PRIORITY_DEFAULT,
//	                                                    cancellable,
//	                                                    …,
//	                                                    &amp;local_error);
//
//	  // Process the returned files, but don’t assume that exactly 5 were returned.
//	  for (GList *l = files; l != NULL; l = l-&gt;next)
//	    {
//	      GFileInfo *info = l-&gt;data;
//	      handle_file_info (info);
//	    }
//	}
//
// while (files != NULL);
//
// if (local_error != NULL &amp;&amp;
//
//	  !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
//	g_error ("Error while enumerating: %s", local_error-&gt;message);
//
// ]|
//
// During an async request no other sync and async calls are allowed, and will
// result in %G_IO_ERROR_PENDING errors.
//
// Any outstanding I/O request with higher priority (lower numerical value) will
// be executed before an outstanding request with lower priority. Default
// priority is %G_PRIORITY_DEFAULT.
func (x *FileEnumerator) NextFilesAsync(NumFilesVar int, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xFileEnumeratorNextFilesAsync(x.GoPointer(), NumFilesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xFileEnumeratorNextFilesFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
func (x *FileEnumerator) NextFilesFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xFileEnumeratorNextFilesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileEnumeratorSetPending func(uintptr, bool)

// Sets the file enumerator as having pending operations.
func (x *FileEnumerator) SetPending(PendingVar bool) {

	xFileEnumeratorSetPending(x.GoPointer(), PendingVar)

}

func (c *FileEnumerator) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *FileEnumerator) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibrary("GIO", "libgio-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFileEnumeratorGLibType, lib, "g_file_enumerator_get_type")

	core.PuregoSafeRegister(&xFileEnumeratorClose, lib, "g_file_enumerator_close")
	core.PuregoSafeRegister(&xFileEnumeratorCloseAsync, lib, "g_file_enumerator_close_async")
	core.PuregoSafeRegister(&xFileEnumeratorCloseFinish, lib, "g_file_enumerator_close_finish")
	core.PuregoSafeRegister(&xFileEnumeratorGetChild, lib, "g_file_enumerator_get_child")
	core.PuregoSafeRegister(&xFileEnumeratorGetContainer, lib, "g_file_enumerator_get_container")
	core.PuregoSafeRegister(&xFileEnumeratorHasPending, lib, "g_file_enumerator_has_pending")
	core.PuregoSafeRegister(&xFileEnumeratorIsClosed, lib, "g_file_enumerator_is_closed")
	core.PuregoSafeRegister(&xFileEnumeratorIterate, lib, "g_file_enumerator_iterate")
	core.PuregoSafeRegister(&xFileEnumeratorNextFile, lib, "g_file_enumerator_next_file")
	core.PuregoSafeRegister(&xFileEnumeratorNextFilesAsync, lib, "g_file_enumerator_next_files_async")
	core.PuregoSafeRegister(&xFileEnumeratorNextFilesFinish, lib, "g_file_enumerator_next_files_finish")
	core.PuregoSafeRegister(&xFileEnumeratorSetPending, lib, "g_file_enumerator_set_pending")

}
