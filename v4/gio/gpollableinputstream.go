// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The interface for pollable input streams.
//
// The default implementation of @can_poll always returns %TRUE.
//
// The default implementation of @read_nonblocking calls
// g_pollable_input_stream_is_readable(), and then calls
// g_input_stream_read() if it returns %TRUE. This means you only need
// to override it if it is possible that your @is_readable
// implementation may return %TRUE when the stream is not actually
// readable.
type PollableInputStreamInterface struct {
	_ structs.HostLayout

	GIface uintptr

	xCanPoll uintptr

	xIsReadable uintptr

	xCreateSource uintptr

	xReadNonblocking uintptr
}

func (x *PollableInputStreamInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideCanPoll sets the "can_poll" callback function.
// Checks if the #GPollableInputStream instance is actually pollable
func (x *PollableInputStreamInterface) OverrideCanPoll(cb func(PollableInputStream) bool) {
	if cb == nil {
		x.xCanPoll = 0
	} else {
		x.xCanPoll = purego.NewCallback(func(StreamVarp uintptr) bool {
			return cb(&PollableInputStreamBase{Ptr: StreamVarp})
		})
	}
}

// GetCanPoll gets the "can_poll" callback function.
// Checks if the #GPollableInputStream instance is actually pollable
func (x *PollableInputStreamInterface) GetCanPoll() func(PollableInputStream) bool {
	if x.xCanPoll == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanPoll)
	return func(StreamVar PollableInputStream) bool {
		return rawCallback(StreamVar.GoPointer())
	}
}

// OverrideIsReadable sets the "is_readable" callback function.
// Checks if the stream is readable
func (x *PollableInputStreamInterface) OverrideIsReadable(cb func(PollableInputStream) bool) {
	if cb == nil {
		x.xIsReadable = 0
	} else {
		x.xIsReadable = purego.NewCallback(func(StreamVarp uintptr) bool {
			return cb(&PollableInputStreamBase{Ptr: StreamVarp})
		})
	}
}

// GetIsReadable gets the "is_readable" callback function.
// Checks if the stream is readable
func (x *PollableInputStreamInterface) GetIsReadable() func(PollableInputStream) bool {
	if x.xIsReadable == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsReadable)
	return func(StreamVar PollableInputStream) bool {
		return rawCallback(StreamVar.GoPointer())
	}
}

// OverrideCreateSource sets the "create_source" callback function.
// Creates a #GSource to poll the stream
func (x *PollableInputStreamInterface) OverrideCreateSource(cb func(PollableInputStream, *Cancellable) *glib.Source) {
	if cb == nil {
		x.xCreateSource = 0
	} else {
		x.xCreateSource = purego.NewCallback(func(StreamVarp uintptr, CancellableVarp uintptr) *glib.Source {
			return cb(&PollableInputStreamBase{Ptr: StreamVarp}, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetCreateSource gets the "create_source" callback function.
// Creates a #GSource to poll the stream
func (x *PollableInputStreamInterface) GetCreateSource() func(PollableInputStream, *Cancellable) *glib.Source {
	if x.xCreateSource == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, CancellableVarp uintptr) *glib.Source
	purego.RegisterFunc(&rawCallback, x.xCreateSource)
	return func(StreamVar PollableInputStream, CancellableVar *Cancellable) *glib.Source {
		return rawCallback(StreamVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideReadNonblocking sets the "read_nonblocking" callback function.
// Does a non-blocking read or returns
//
//	%G_IO_ERROR_WOULD_BLOCK
func (x *PollableInputStreamInterface) OverrideReadNonblocking(cb func(PollableInputStream, *[]byte, uint) int) {
	if cb == nil {
		x.xReadNonblocking = 0
	} else {
		x.xReadNonblocking = purego.NewCallback(func(StreamVarp uintptr, BufferVarp *[]byte, CountVarp uint) int {
			return cb(&PollableInputStreamBase{Ptr: StreamVarp}, BufferVarp, CountVarp)
		})
	}
}

// GetReadNonblocking gets the "read_nonblocking" callback function.
// Does a non-blocking read or returns
//
//	%G_IO_ERROR_WOULD_BLOCK
func (x *PollableInputStreamInterface) GetReadNonblocking() func(PollableInputStream, *[]byte, uint) int {
	if x.xReadNonblocking == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, BufferVarp *[]byte, CountVarp uint) int
	purego.RegisterFunc(&rawCallback, x.xReadNonblocking)
	return func(StreamVar PollableInputStream, BufferVar *[]byte, CountVar uint) int {
		return rawCallback(StreamVar.GoPointer(), BufferVar, CountVar)
	}
}

// `GPollableInputStream` is implemented by [class@Gio.InputStream]s that
// can be polled for readiness to read. This can be used when
// interfacing with a non-GIO API that expects
// UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
//
// Some classes may implement `GPollableInputStream` but have only certain
// instances of that class be pollable. If [method@Gio.PollableInputStream.can_poll]
// returns false, then the behavior of other `GPollableInputStream` methods is
// undefined.
type PollableInputStream interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	CanPoll() bool
	CreateSource(CancellableVar *Cancellable) *glib.Source
	IsReadable() bool
	ReadNonblocking(BufferVar *[]byte, CountVar uint, CancellableVar *Cancellable) (int, error)
}

var xPollableInputStreamGLibType func() types.GType

func PollableInputStreamGLibType() types.GType {
	return xPollableInputStreamGLibType()
}

type PollableInputStreamBase struct {
	Ptr uintptr
}

func (x *PollableInputStreamBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *PollableInputStreamBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Checks if @stream is actually pollable. Some classes may implement
// #GPollableInputStream but have only certain instances of that class
// be pollable. If this method returns %FALSE, then the behavior of
// other #GPollableInputStream methods is undefined.
//
// For any given stream, the value returned by this method is constant;
// a stream cannot switch from pollable to non-pollable or vice versa.
func (x *PollableInputStreamBase) CanPoll() bool {

	cret := XGPollableInputStreamCanPoll(x.GoPointer())

	return cret
}

// Creates a #GSource that triggers when @stream can be read, or
// @cancellable is triggered or an error occurs. The callback on the
// source is of the #GPollableSourceFunc type.
//
// As with g_pollable_input_stream_is_readable(), it is possible that
// the stream may not actually be readable even after the source
// triggers, so you should use g_pollable_input_stream_read_nonblocking()
// rather than g_input_stream_read() from the callback.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *PollableInputStreamBase) CreateSource(CancellableVar *Cancellable) *glib.Source {

	cret := XGPollableInputStreamCreateSource(x.GoPointer(), CancellableVar.GoPointer())

	return cret
}

// Checks if @stream can be read.
//
// Note that some stream types may not be able to implement this 100%
// reliably, and it is possible that a call to g_input_stream_read()
// after this returns %TRUE would still block. To guarantee
// non-blocking behavior, you should always use
// g_pollable_input_stream_read_nonblocking(), which will return a
// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *PollableInputStreamBase) IsReadable() bool {

	cret := XGPollableInputStreamIsReadable(x.GoPointer())

	return cret
}

// Attempts to read up to @count bytes from @stream into @buffer, as
// with g_input_stream_read(). If @stream is not currently readable,
// this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
// use g_pollable_input_stream_create_source() to create a #GSource
// that will be triggered when @stream is readable.
//
// Note that since this method never blocks, you cannot actually
// use @cancellable to cancel it. However, it will return an error
// if @cancellable has already been cancelled when you call, which
// may happen if you call this method after a source triggers due
// to having been cancelled.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *PollableInputStreamBase) ReadNonblocking(BufferVar *[]byte, CountVar uint, CancellableVar *Cancellable) (int, error) {
	var cerr *glib.Error

	cret := XGPollableInputStreamReadNonblocking(x.GoPointer(), BufferVar, CountVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var XGPollableInputStreamCanPoll func(uintptr) bool
var XGPollableInputStreamCreateSource func(uintptr, uintptr) *glib.Source
var XGPollableInputStreamIsReadable func(uintptr) bool
var XGPollableInputStreamReadNonblocking func(uintptr, *[]byte, uint, uintptr, **glib.Error) int

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPollableInputStreamGLibType, libs, "g_pollable_input_stream_get_type")

	core.PuregoSafeRegister(&XGPollableInputStreamCanPoll, libs, "g_pollable_input_stream_can_poll")
	core.PuregoSafeRegister(&XGPollableInputStreamCreateSource, libs, "g_pollable_input_stream_create_source")
	core.PuregoSafeRegister(&XGPollableInputStreamIsReadable, libs, "g_pollable_input_stream_is_readable")
	core.PuregoSafeRegister(&XGPollableInputStreamReadNonblocking, libs, "g_pollable_input_stream_read_nonblocking")

}
