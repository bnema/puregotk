// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Class structure for #GSettingsBackend.
type SettingsBackendClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xRead uintptr

	xGetWritable uintptr

	xWrite uintptr

	xWriteTree uintptr

	xReset uintptr

	xSubscribe uintptr

	xUnsubscribe uintptr

	xSync uintptr

	xGetPermission uintptr

	xReadUserValue uintptr

	Padding [23]uintptr
}

func (x *SettingsBackendClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideRead sets the "read" callback function.
// virtual method to read a key's value
func (x *SettingsBackendClass) OverrideRead(cb func(*SettingsBackend, string, *glib.VariantType, bool) *glib.Variant) {
	if cb == nil {
		x.xRead = 0
	} else {
		x.xRead = purego.NewCallback(func(BackendVarp uintptr, KeyVarp string, ExpectedTypeVarp *glib.VariantType, DefaultValueVarp bool) *glib.Variant {
			return cb(SettingsBackendNewFromInternalPtr(BackendVarp), KeyVarp, ExpectedTypeVarp, DefaultValueVarp)
		})
	}
}

// GetRead gets the "read" callback function.
// virtual method to read a key's value
func (x *SettingsBackendClass) GetRead() func(*SettingsBackend, string, *glib.VariantType, bool) *glib.Variant {
	if x.xRead == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, KeyVarp string, ExpectedTypeVarp *glib.VariantType, DefaultValueVarp bool) *glib.Variant
	purego.RegisterFunc(&rawCallback, x.xRead)
	return func(BackendVar *SettingsBackend, KeyVar string, ExpectedTypeVar *glib.VariantType, DefaultValueVar bool) *glib.Variant {
		return rawCallback(BackendVar.GoPointer(), KeyVar, ExpectedTypeVar, DefaultValueVar)
	}
}

// OverrideGetWritable sets the "get_writable" callback function.
// virtual method to get if a key is writable
func (x *SettingsBackendClass) OverrideGetWritable(cb func(*SettingsBackend, string) bool) {
	if cb == nil {
		x.xGetWritable = 0
	} else {
		x.xGetWritable = purego.NewCallback(func(BackendVarp uintptr, KeyVarp string) bool {
			return cb(SettingsBackendNewFromInternalPtr(BackendVarp), KeyVarp)
		})
	}
}

// GetGetWritable gets the "get_writable" callback function.
// virtual method to get if a key is writable
func (x *SettingsBackendClass) GetGetWritable() func(*SettingsBackend, string) bool {
	if x.xGetWritable == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, KeyVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xGetWritable)
	return func(BackendVar *SettingsBackend, KeyVar string) bool {
		return rawCallback(BackendVar.GoPointer(), KeyVar)
	}
}

// OverrideWrite sets the "write" callback function.
// virtual method to change key's value
func (x *SettingsBackendClass) OverrideWrite(cb func(*SettingsBackend, string, *glib.Variant, uintptr) bool) {
	if cb == nil {
		x.xWrite = 0
	} else {
		x.xWrite = purego.NewCallback(func(BackendVarp uintptr, KeyVarp string, ValueVarp *glib.Variant, OriginTagVarp uintptr) bool {
			return cb(SettingsBackendNewFromInternalPtr(BackendVarp), KeyVarp, ValueVarp, OriginTagVarp)
		})
	}
}

// GetWrite gets the "write" callback function.
// virtual method to change key's value
func (x *SettingsBackendClass) GetWrite() func(*SettingsBackend, string, *glib.Variant, uintptr) bool {
	if x.xWrite == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, KeyVarp string, ValueVarp *glib.Variant, OriginTagVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xWrite)
	return func(BackendVar *SettingsBackend, KeyVar string, ValueVar *glib.Variant, OriginTagVar uintptr) bool {
		return rawCallback(BackendVar.GoPointer(), KeyVar, ValueVar, OriginTagVar)
	}
}

// OverrideWriteTree sets the "write_tree" callback function.
// virtual method to change a tree of keys
func (x *SettingsBackendClass) OverrideWriteTree(cb func(*SettingsBackend, *glib.Tree, uintptr) bool) {
	if cb == nil {
		x.xWriteTree = 0
	} else {
		x.xWriteTree = purego.NewCallback(func(BackendVarp uintptr, TreeVarp *glib.Tree, OriginTagVarp uintptr) bool {
			return cb(SettingsBackendNewFromInternalPtr(BackendVarp), TreeVarp, OriginTagVarp)
		})
	}
}

// GetWriteTree gets the "write_tree" callback function.
// virtual method to change a tree of keys
func (x *SettingsBackendClass) GetWriteTree() func(*SettingsBackend, *glib.Tree, uintptr) bool {
	if x.xWriteTree == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, TreeVarp *glib.Tree, OriginTagVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xWriteTree)
	return func(BackendVar *SettingsBackend, TreeVar *glib.Tree, OriginTagVar uintptr) bool {
		return rawCallback(BackendVar.GoPointer(), TreeVar, OriginTagVar)
	}
}

// OverrideReset sets the "reset" callback function.
// virtual method to reset state
func (x *SettingsBackendClass) OverrideReset(cb func(*SettingsBackend, string, uintptr)) {
	if cb == nil {
		x.xReset = 0
	} else {
		x.xReset = purego.NewCallback(func(BackendVarp uintptr, KeyVarp string, OriginTagVarp uintptr) {
			cb(SettingsBackendNewFromInternalPtr(BackendVarp), KeyVarp, OriginTagVarp)
		})
	}
}

// GetReset gets the "reset" callback function.
// virtual method to reset state
func (x *SettingsBackendClass) GetReset() func(*SettingsBackend, string, uintptr) {
	if x.xReset == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, KeyVarp string, OriginTagVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xReset)
	return func(BackendVar *SettingsBackend, KeyVar string, OriginTagVar uintptr) {
		rawCallback(BackendVar.GoPointer(), KeyVar, OriginTagVar)
	}
}

// OverrideSubscribe sets the "subscribe" callback function.
// virtual method to subscribe to key changes
func (x *SettingsBackendClass) OverrideSubscribe(cb func(*SettingsBackend, string)) {
	if cb == nil {
		x.xSubscribe = 0
	} else {
		x.xSubscribe = purego.NewCallback(func(BackendVarp uintptr, NameVarp string) {
			cb(SettingsBackendNewFromInternalPtr(BackendVarp), NameVarp)
		})
	}
}

// GetSubscribe gets the "subscribe" callback function.
// virtual method to subscribe to key changes
func (x *SettingsBackendClass) GetSubscribe() func(*SettingsBackend, string) {
	if x.xSubscribe == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, NameVarp string)
	purego.RegisterFunc(&rawCallback, x.xSubscribe)
	return func(BackendVar *SettingsBackend, NameVar string) {
		rawCallback(BackendVar.GoPointer(), NameVar)
	}
}

// OverrideUnsubscribe sets the "unsubscribe" callback function.
// virtual method to unsubscribe to key changes
func (x *SettingsBackendClass) OverrideUnsubscribe(cb func(*SettingsBackend, string)) {
	if cb == nil {
		x.xUnsubscribe = 0
	} else {
		x.xUnsubscribe = purego.NewCallback(func(BackendVarp uintptr, NameVarp string) {
			cb(SettingsBackendNewFromInternalPtr(BackendVarp), NameVarp)
		})
	}
}

// GetUnsubscribe gets the "unsubscribe" callback function.
// virtual method to unsubscribe to key changes
func (x *SettingsBackendClass) GetUnsubscribe() func(*SettingsBackend, string) {
	if x.xUnsubscribe == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, NameVarp string)
	purego.RegisterFunc(&rawCallback, x.xUnsubscribe)
	return func(BackendVar *SettingsBackend, NameVar string) {
		rawCallback(BackendVar.GoPointer(), NameVar)
	}
}

// OverrideSync sets the "sync" callback function.
// virtual method to sync state
func (x *SettingsBackendClass) OverrideSync(cb func(*SettingsBackend)) {
	if cb == nil {
		x.xSync = 0
	} else {
		x.xSync = purego.NewCallback(func(BackendVarp uintptr) {
			cb(SettingsBackendNewFromInternalPtr(BackendVarp))
		})
	}
}

// GetSync gets the "sync" callback function.
// virtual method to sync state
func (x *SettingsBackendClass) GetSync() func(*SettingsBackend) {
	if x.xSync == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSync)
	return func(BackendVar *SettingsBackend) {
		rawCallback(BackendVar.GoPointer())
	}
}

// OverrideGetPermission sets the "get_permission" callback function.
// virtual method to get permission of a key
func (x *SettingsBackendClass) OverrideGetPermission(cb func(*SettingsBackend, string) *Permission) {
	if cb == nil {
		x.xGetPermission = 0
	} else {
		x.xGetPermission = purego.NewCallback(func(BackendVarp uintptr, PathVarp string) uintptr {
			ret := cb(SettingsBackendNewFromInternalPtr(BackendVarp), PathVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetPermission gets the "get_permission" callback function.
// virtual method to get permission of a key
func (x *SettingsBackendClass) GetGetPermission() func(*SettingsBackend, string) *Permission {
	if x.xGetPermission == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, PathVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetPermission)
	return func(BackendVar *SettingsBackend, PathVar string) *Permission {
		rawRet := rawCallback(BackendVar.GoPointer(), PathVar)
		if rawRet == 0 {
			return nil
		}
		ret := &Permission{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideReadUserValue sets the "read_user_value" callback function.
// virtual method to read user's key value
func (x *SettingsBackendClass) OverrideReadUserValue(cb func(*SettingsBackend, string, *glib.VariantType) *glib.Variant) {
	if cb == nil {
		x.xReadUserValue = 0
	} else {
		x.xReadUserValue = purego.NewCallback(func(BackendVarp uintptr, KeyVarp string, ExpectedTypeVarp *glib.VariantType) *glib.Variant {
			return cb(SettingsBackendNewFromInternalPtr(BackendVarp), KeyVarp, ExpectedTypeVarp)
		})
	}
}

// GetReadUserValue gets the "read_user_value" callback function.
// virtual method to read user's key value
func (x *SettingsBackendClass) GetReadUserValue() func(*SettingsBackend, string, *glib.VariantType) *glib.Variant {
	if x.xReadUserValue == 0 {
		return nil
	}
	var rawCallback func(BackendVarp uintptr, KeyVarp string, ExpectedTypeVarp *glib.VariantType) *glib.Variant
	purego.RegisterFunc(&rawCallback, x.xReadUserValue)
	return func(BackendVar *SettingsBackend, KeyVar string, ExpectedTypeVar *glib.VariantType) *glib.Variant {
		return rawCallback(BackendVar.GoPointer(), KeyVar, ExpectedTypeVar)
	}
}

type SettingsBackendPrivate struct {
	_ structs.HostLayout
}

func (x *SettingsBackendPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

const (
	// Extension point for #GSettingsBackend functionality.
	SETTINGS_BACKEND_EXTENSION_POINT_NAME string = "gsettings-backend"
)

var xKeyfileSettingsBackendNew func(string, string, uintptr) uintptr

// Creates a keyfile-backed [class@Gio.SettingsBackend].
//
// The filename of the keyfile to use is given by @filename.
//
// All settings read to or written from the backend must fall under the
// path given in @root_path (which must start and end with a slash and
// not contain two consecutive slashes).  @root_path may be `"/"`.
//
// If @root_group is non-`NULL` then it specifies the name of the keyfile
// group used for keys that are written directly below @root_path.  For
// example, if @root_path is `"/apps/example/"` and @root_group is
// `"toplevel"`, then setting the key `"/apps/example/enabled"` to true will
// cause the following to appear in the keyfile:
//
// ```
// [toplevel]
// enabled=true
// ```
//
// If @root_group is `NULL` then it is not permitted to store keys
// directly below the @root_path.
//
// For keys not stored directly below @root_path (ie: in a sub-path),
// the name of the subpath (with the final slash stripped) is used as
// the name of the keyfile group.  To continue the example, if
// `"/apps/example/profiles/default/font-size"` were set to
// `12` then the following would appear in the keyfile:
//
// ```
// [profiles/default]
// font-size=12
// ```
//
// The backend will refuse writes (and return writability as being
// false) for keys outside of @root_path and, in the event that
// @root_group is `NULL`, also for keys directly under @root_path.
// Writes will also be refused if the backend detects that it has the
// inability to rewrite the keyfile (ie: the containing directory is not
// writable).
//
// There is no checking done for your key namespace clashing with the
// syntax of the key file format.  For example, if you have `[` or `]`
// characters in your path names or `=` in your key names you may be in
// trouble.
//
// The backend reads default values from a keyfile called `defaults` in
// the directory specified by the `GKeyfileSettingsBackend:defaults-dir`
// property, and a list of locked keys from a text file with the name `locks` in
// the same location.
func KeyfileSettingsBackendNew(FilenameVar string, RootPathVar string, RootGroupVar *string) *SettingsBackend {
	var cls *SettingsBackend

	RootGroupVarPtr := core.GStrdupNullable(RootGroupVar)
	defer core.GFreeNullable(RootGroupVarPtr)

	cret := xKeyfileSettingsBackendNew(FilenameVar, RootPathVar, RootGroupVarPtr)

	if cret == 0 {
		return nil
	}
	cls = &SettingsBackend{}
	cls.Ptr = cret
	return cls
}

var xMemorySettingsBackendNew func() uintptr

// Creates a memory-backed #GSettingsBackend.
//
// This backend allows changes to settings, but does not write them
// to any backing storage, so the next time you run your application,
// the memory backend will start out with the default values again.
func MemorySettingsBackendNew() *SettingsBackend {
	var cls *SettingsBackend

	cret := xMemorySettingsBackendNew()

	if cret == 0 {
		return nil
	}
	cls = &SettingsBackend{}
	cls.Ptr = cret
	return cls
}

var xNullSettingsBackendNew func() uintptr

// Creates a readonly #GSettingsBackend.
//
// This backend does not allow changes to settings, so all settings
// will always have their default values.
func NullSettingsBackendNew() *SettingsBackend {
	var cls *SettingsBackend

	cret := xNullSettingsBackendNew()

	if cret == 0 {
		return nil
	}
	cls = &SettingsBackend{}
	cls.Ptr = cret
	return cls
}

// The `GSettingsBackend` interface defines a generic interface for
// non-strictly-typed data that is stored in a hierarchy. To implement
// an alternative storage backend for [class@Gio.Settings], you need to
// implement the `GSettingsBackend` interface and then make it implement the
// extension point `G_SETTINGS_BACKEND_EXTENSION_POINT_NAME`.
//
// The interface defines methods for reading and writing values, a
// method for determining if writing of certain values will fail
// (lockdown) and a change notification mechanism.
//
// The semantics of the interface are very precisely defined and
// implementations must carefully adhere to the expectations of
// callers that are documented on each of the interface methods.
//
// Some of the `GSettingsBackend` functions accept or return a
// [struct@GLib.Tree]. These trees always have strings as keys and
// [struct@GLib.Variant] as values.
//
// The `GSettingsBackend` API is exported to allow third-party
// implementations, but does not carry the same stability guarantees
// as the public GIO API. For this reason, you have to define the
// C preprocessor symbol `G_SETTINGS_ENABLE_BACKEND` before including
// `gio/gsettingsbackend.h`.
type SettingsBackend struct {
	gobject.Object
}

var xSettingsBackendGLibType func() types.GType

func SettingsBackendGLibType() types.GType {
	return xSettingsBackendGLibType()
}

func SettingsBackendNewFromInternalPtr(ptr uintptr) *SettingsBackend {
	cls := &SettingsBackend{}
	cls.Ptr = ptr
	return cls
}

var xSettingsBackendChanged func(uintptr, string, uintptr)

// Signals that a single key has possibly changed.  Backend
// implementations should call this if a key has possibly changed its
// value.
//
// @key must be a valid key (ie starting with a slash, not containing
// '//', and not ending with a slash).
//
// The implementation must call this function during any call to
// g_settings_backend_write(), before the call returns (except in the
// case that no keys are actually changed and it cares to detect this
// fact).  It may not rely on the existence of a mainloop for
// dispatching the signal later.
//
// The implementation may call this function at any other time it likes
// in response to other events (such as changes occurring outside of the
// program).  These calls may originate from a mainloop or may originate
// in response to any other action (including from calls to
// g_settings_backend_write()).
//
// In the case that this call is in response to a call to
// g_settings_backend_write() then @origin_tag must be set to the same
// value that was passed to that call.
func (x *SettingsBackend) Changed(KeyVar string, OriginTagVar uintptr) {

	xSettingsBackendChanged(x.GoPointer(), KeyVar, OriginTagVar)

}

var xSettingsBackendChangedTree func(uintptr, *glib.Tree, uintptr)

// This call is a convenience wrapper.  It gets the list of changes from
// @tree, computes the longest common prefix and calls
// g_settings_backend_changed().
func (x *SettingsBackend) ChangedTree(TreeVar *glib.Tree, OriginTagVar uintptr) {

	xSettingsBackendChangedTree(x.GoPointer(), TreeVar, OriginTagVar)

}

var xSettingsBackendKeysChanged func(uintptr, string, []string, uintptr)

// Signals that a list of keys have possibly changed.  Backend
// implementations should call this if keys have possibly changed their
// values.
//
// @path must be a valid path (ie starting and ending with a slash and
// not containing '//').  Each string in @items must form a valid key
// name when @path is prefixed to it (ie: each item must not start or
// end with '/' and must not contain '//').
//
// The meaning of this signal is that any of the key names resulting
// from the concatenation of @path with each item in @items may have
// changed.
//
// The same rules for when notifications must occur apply as per
// g_settings_backend_changed().  These two calls can be used
// interchangeably if exactly one item has changed (although in that
// case g_settings_backend_changed() is definitely preferred).
//
// For efficiency reasons, the implementation should strive for @path to
// be as long as possible (ie: the longest common prefix of all of the
// keys that were changed) but this is not strictly required.
func (x *SettingsBackend) KeysChanged(PathVar string, ItemsVar []string, OriginTagVar uintptr) {

	xSettingsBackendKeysChanged(x.GoPointer(), PathVar, ItemsVar, OriginTagVar)

}

var xSettingsBackendPathChanged func(uintptr, string, uintptr)

// Signals that all keys below a given path may have possibly changed.
// Backend implementations should call this if an entire path of keys
// have possibly changed their values.
//
// @path must be a valid path (ie starting and ending with a slash and
// not containing '//').
//
// The meaning of this signal is that any of the key which has a name
// starting with @path may have changed.
//
// The same rules for when notifications must occur apply as per
// g_settings_backend_changed().  This call might be an appropriate
// reasponse to a 'reset' call but implementations are also free to
// explicitly list the keys that were affected by that call if they can
// easily do so.
//
// For efficiency reasons, the implementation should strive for @path to
// be as long as possible (ie: the longest common prefix of all of the
// keys that were changed) but this is not strictly required.  As an
// example, if this function is called with the path of "/" then every
// single key in the application will be notified of a possible change.
func (x *SettingsBackend) PathChanged(PathVar string, OriginTagVar uintptr) {

	xSettingsBackendPathChanged(x.GoPointer(), PathVar, OriginTagVar)

}

var xSettingsBackendPathWritableChanged func(uintptr, string)

// Signals that the writability of all keys below a given path may have
// changed.
//
// Since GSettings performs no locking operations for itself, this call
// will always be made in response to external events.
func (x *SettingsBackend) PathWritableChanged(PathVar string) {

	xSettingsBackendPathWritableChanged(x.GoPointer(), PathVar)

}

var xSettingsBackendWritableChanged func(uintptr, string)

// Signals that the writability of a single key has possibly changed.
//
// Since GSettings performs no locking operations for itself, this call
// will always be made in response to external events.
func (x *SettingsBackend) WritableChanged(KeyVar string) {

	xSettingsBackendWritableChanged(x.GoPointer(), KeyVar)

}

func (c *SettingsBackend) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *SettingsBackend) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xSettingsBackendFlattenTree func(*glib.Tree, *string, *[]string, *uintptr)

// Calculate the longest common prefix of all keys in a tree and write
// out an array of the key names relative to that prefix and,
// optionally, the value to store at each of those keys.
//
// You must free the value returned in @path, @keys and @values using
// g_free().  You should not attempt to free or unref the contents of
// @keys or @values.
func SettingsBackendFlattenTree(TreeVar *glib.Tree, PathVar *string, KeysVar *[]string, ValuesVar *uintptr) {

	xSettingsBackendFlattenTree(TreeVar, PathVar, KeysVar, ValuesVar)

}

var xSettingsBackendGetDefault func() uintptr

// Returns the default #GSettingsBackend. It is possible to override
// the default by setting the `GSETTINGS_BACKEND` environment variable
// to the name of a settings backend.
//
// The user gets a reference to the backend.
func SettingsBackendGetDefault() *SettingsBackend {
	var cls *SettingsBackend

	cret := xSettingsBackendGetDefault()

	if cret == 0 {
		return nil
	}
	cls = &SettingsBackend{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xKeyfileSettingsBackendNew, libs, "g_keyfile_settings_backend_new")
	core.PuregoSafeRegister(&xMemorySettingsBackendNew, libs, "g_memory_settings_backend_new")
	core.PuregoSafeRegister(&xNullSettingsBackendNew, libs, "g_null_settings_backend_new")

	core.PuregoSafeRegister(&xSettingsBackendGLibType, libs, "g_settings_backend_get_type")

	core.PuregoSafeRegister(&xSettingsBackendChanged, libs, "g_settings_backend_changed")
	core.PuregoSafeRegister(&xSettingsBackendChangedTree, libs, "g_settings_backend_changed_tree")
	core.PuregoSafeRegister(&xSettingsBackendKeysChanged, libs, "g_settings_backend_keys_changed")
	core.PuregoSafeRegister(&xSettingsBackendPathChanged, libs, "g_settings_backend_path_changed")
	core.PuregoSafeRegister(&xSettingsBackendPathWritableChanged, libs, "g_settings_backend_path_writable_changed")
	core.PuregoSafeRegister(&xSettingsBackendWritableChanged, libs, "g_settings_backend_writable_changed")

	core.PuregoSafeRegister(&xSettingsBackendFlattenTree, libs, "g_settings_backend_flatten_tree")
	core.PuregoSafeRegister(&xSettingsBackendGetDefault, libs, "g_settings_backend_get_default")

}
