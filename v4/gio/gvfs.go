// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// This function type is used by g_vfs_register_uri_scheme() to make it
// possible for a client to associate a URI scheme to a different #GFile
// implementation.
//
// The client should return a reference to the new file that has been
// created for @uri, or %NULL to continue with the default implementation.
type VfsFileLookupFunc func(uintptr, string, uintptr) uintptr

type VfsClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xIsActive uintptr

	xGetFileForPath uintptr

	xGetFileForUri uintptr

	xGetSupportedUriSchemes uintptr

	xParseName uintptr

	xLocalFileAddInfo uintptr

	xAddWritableNamespaces uintptr

	xLocalFileSetAttributes uintptr

	xLocalFileRemoved uintptr

	xLocalFileMoved uintptr

	xDeserializeIcon uintptr

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr

	xGReserved6 uintptr
}

func (x *VfsClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideIsActive sets the "is_active" callback function.
func (x *VfsClass) OverrideIsActive(cb func(*Vfs) bool) {
	if cb == nil {
		x.xIsActive = 0
	} else {
		x.xIsActive = purego.NewCallback(func(VfsVarp uintptr) bool {
			return cb(VfsNewFromInternalPtr(VfsVarp))
		})
	}
}

// GetIsActive gets the "is_active" callback function.
func (x *VfsClass) GetIsActive() func(*Vfs) bool {
	if x.xIsActive == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsActive)
	return func(VfsVar *Vfs) bool {
		return rawCallback(VfsVar.GoPointer())
	}
}

// OverrideGetFileForPath sets the "get_file_for_path" callback function.
func (x *VfsClass) OverrideGetFileForPath(cb func(*Vfs, string) *FileBase) {
	if cb == nil {
		x.xGetFileForPath = 0
	} else {
		x.xGetFileForPath = purego.NewCallback(func(VfsVarp uintptr, PathVarp string) uintptr {
			ret := cb(VfsNewFromInternalPtr(VfsVarp), PathVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetFileForPath gets the "get_file_for_path" callback function.
func (x *VfsClass) GetGetFileForPath() func(*Vfs, string) *FileBase {
	if x.xGetFileForPath == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, PathVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetFileForPath)
	return func(VfsVar *Vfs, PathVar string) *FileBase {
		rawRet := rawCallback(VfsVar.GoPointer(), PathVar)
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetFileForUri sets the "get_file_for_uri" callback function.
func (x *VfsClass) OverrideGetFileForUri(cb func(*Vfs, string) *FileBase) {
	if cb == nil {
		x.xGetFileForUri = 0
	} else {
		x.xGetFileForUri = purego.NewCallback(func(VfsVarp uintptr, UriVarp string) uintptr {
			ret := cb(VfsNewFromInternalPtr(VfsVarp), UriVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetFileForUri gets the "get_file_for_uri" callback function.
func (x *VfsClass) GetGetFileForUri() func(*Vfs, string) *FileBase {
	if x.xGetFileForUri == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, UriVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetFileForUri)
	return func(VfsVar *Vfs, UriVar string) *FileBase {
		rawRet := rawCallback(VfsVar.GoPointer(), UriVar)
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetSupportedUriSchemes sets the "get_supported_uri_schemes" callback function.
func (x *VfsClass) OverrideGetSupportedUriSchemes(cb func(*Vfs) []string) {
	if cb == nil {
		x.xGetSupportedUriSchemes = 0
	} else {
		x.xGetSupportedUriSchemes = purego.NewCallback(func(VfsVarp uintptr) []string {
			return cb(VfsNewFromInternalPtr(VfsVarp))
		})
	}
}

// GetGetSupportedUriSchemes gets the "get_supported_uri_schemes" callback function.
func (x *VfsClass) GetGetSupportedUriSchemes() func(*Vfs) []string {
	if x.xGetSupportedUriSchemes == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr) []string
	purego.RegisterFunc(&rawCallback, x.xGetSupportedUriSchemes)
	return func(VfsVar *Vfs) []string {
		return rawCallback(VfsVar.GoPointer())
	}
}

// OverrideParseName sets the "parse_name" callback function.
func (x *VfsClass) OverrideParseName(cb func(*Vfs, string) *FileBase) {
	if cb == nil {
		x.xParseName = 0
	} else {
		x.xParseName = purego.NewCallback(func(VfsVarp uintptr, ParseNameVarp string) uintptr {
			ret := cb(VfsNewFromInternalPtr(VfsVarp), ParseNameVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetParseName gets the "parse_name" callback function.
func (x *VfsClass) GetParseName() func(*Vfs, string) *FileBase {
	if x.xParseName == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, ParseNameVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xParseName)
	return func(VfsVar *Vfs, ParseNameVar string) *FileBase {
		rawRet := rawCallback(VfsVar.GoPointer(), ParseNameVar)
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideLocalFileAddInfo sets the "local_file_add_info" callback function.
func (x *VfsClass) OverrideLocalFileAddInfo(cb func(*Vfs, string, uint64, *FileAttributeMatcher, *FileInfo, *Cancellable, uintptr, *glib.DestroyNotify)) {
	if cb == nil {
		x.xLocalFileAddInfo = 0
	} else {
		x.xLocalFileAddInfo = purego.NewCallback(func(VfsVarp uintptr, FilenameVarp string, DeviceVarp uint64, AttributeMatcherVarp *FileAttributeMatcher, InfoVarp uintptr, CancellableVarp uintptr, ExtraDataVarp uintptr, FreeExtraDataVarp uintptr) {
			cb(VfsNewFromInternalPtr(VfsVarp), FilenameVarp, DeviceVarp, AttributeMatcherVarp, FileInfoNewFromInternalPtr(InfoVarp), CancellableNewFromInternalPtr(CancellableVarp), ExtraDataVarp, (*glib.DestroyNotify)(unsafe.Pointer(FreeExtraDataVarp)))
		})
	}
}

// GetLocalFileAddInfo gets the "local_file_add_info" callback function.
func (x *VfsClass) GetLocalFileAddInfo() func(*Vfs, string, uint64, *FileAttributeMatcher, *FileInfo, *Cancellable, uintptr, *glib.DestroyNotify) {
	if x.xLocalFileAddInfo == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, FilenameVarp string, DeviceVarp uint64, AttributeMatcherVarp *FileAttributeMatcher, InfoVarp uintptr, CancellableVarp uintptr, ExtraDataVarp uintptr, FreeExtraDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLocalFileAddInfo)
	return func(VfsVar *Vfs, FilenameVar string, DeviceVar uint64, AttributeMatcherVar *FileAttributeMatcher, InfoVar *FileInfo, CancellableVar *Cancellable, ExtraDataVar uintptr, FreeExtraDataVar *glib.DestroyNotify) {
		rawCallback(VfsVar.GoPointer(), FilenameVar, DeviceVar, AttributeMatcherVar, InfoVar.GoPointer(), CancellableVar.GoPointer(), ExtraDataVar, glib.NewCallback(FreeExtraDataVar))
	}
}

// OverrideAddWritableNamespaces sets the "add_writable_namespaces" callback function.
func (x *VfsClass) OverrideAddWritableNamespaces(cb func(*Vfs, *FileAttributeInfoList)) {
	if cb == nil {
		x.xAddWritableNamespaces = 0
	} else {
		x.xAddWritableNamespaces = purego.NewCallback(func(VfsVarp uintptr, ListVarp *FileAttributeInfoList) {
			cb(VfsNewFromInternalPtr(VfsVarp), ListVarp)
		})
	}
}

// GetAddWritableNamespaces gets the "add_writable_namespaces" callback function.
func (x *VfsClass) GetAddWritableNamespaces() func(*Vfs, *FileAttributeInfoList) {
	if x.xAddWritableNamespaces == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, ListVarp *FileAttributeInfoList)
	purego.RegisterFunc(&rawCallback, x.xAddWritableNamespaces)
	return func(VfsVar *Vfs, ListVar *FileAttributeInfoList) {
		rawCallback(VfsVar.GoPointer(), ListVar)
	}
}

// OverrideLocalFileSetAttributes sets the "local_file_set_attributes" callback function.
func (x *VfsClass) OverrideLocalFileSetAttributes(cb func(*Vfs, string, *FileInfo, FileQueryInfoFlags, *Cancellable) bool) {
	if cb == nil {
		x.xLocalFileSetAttributes = 0
	} else {
		x.xLocalFileSetAttributes = purego.NewCallback(func(VfsVarp uintptr, FilenameVarp string, InfoVarp uintptr, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) bool {
			return cb(VfsNewFromInternalPtr(VfsVarp), FilenameVarp, FileInfoNewFromInternalPtr(InfoVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetLocalFileSetAttributes gets the "local_file_set_attributes" callback function.
func (x *VfsClass) GetLocalFileSetAttributes() func(*Vfs, string, *FileInfo, FileQueryInfoFlags, *Cancellable) bool {
	if x.xLocalFileSetAttributes == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, FilenameVarp string, InfoVarp uintptr, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xLocalFileSetAttributes)
	return func(VfsVar *Vfs, FilenameVar string, InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool {
		return rawCallback(VfsVar.GoPointer(), FilenameVar, InfoVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
	}
}

// OverrideLocalFileRemoved sets the "local_file_removed" callback function.
func (x *VfsClass) OverrideLocalFileRemoved(cb func(*Vfs, string)) {
	if cb == nil {
		x.xLocalFileRemoved = 0
	} else {
		x.xLocalFileRemoved = purego.NewCallback(func(VfsVarp uintptr, FilenameVarp string) {
			cb(VfsNewFromInternalPtr(VfsVarp), FilenameVarp)
		})
	}
}

// GetLocalFileRemoved gets the "local_file_removed" callback function.
func (x *VfsClass) GetLocalFileRemoved() func(*Vfs, string) {
	if x.xLocalFileRemoved == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, FilenameVarp string)
	purego.RegisterFunc(&rawCallback, x.xLocalFileRemoved)
	return func(VfsVar *Vfs, FilenameVar string) {
		rawCallback(VfsVar.GoPointer(), FilenameVar)
	}
}

// OverrideLocalFileMoved sets the "local_file_moved" callback function.
func (x *VfsClass) OverrideLocalFileMoved(cb func(*Vfs, string, string)) {
	if cb == nil {
		x.xLocalFileMoved = 0
	} else {
		x.xLocalFileMoved = purego.NewCallback(func(VfsVarp uintptr, SourceVarp string, DestVarp string) {
			cb(VfsNewFromInternalPtr(VfsVarp), SourceVarp, DestVarp)
		})
	}
}

// GetLocalFileMoved gets the "local_file_moved" callback function.
func (x *VfsClass) GetLocalFileMoved() func(*Vfs, string, string) {
	if x.xLocalFileMoved == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, SourceVarp string, DestVarp string)
	purego.RegisterFunc(&rawCallback, x.xLocalFileMoved)
	return func(VfsVar *Vfs, SourceVar string, DestVar string) {
		rawCallback(VfsVar.GoPointer(), SourceVar, DestVar)
	}
}

// OverrideDeserializeIcon sets the "deserialize_icon" callback function.
func (x *VfsClass) OverrideDeserializeIcon(cb func(*Vfs, *glib.Variant) *IconBase) {
	if cb == nil {
		x.xDeserializeIcon = 0
	} else {
		x.xDeserializeIcon = purego.NewCallback(func(VfsVarp uintptr, ValueVarp *glib.Variant) uintptr {
			ret := cb(VfsNewFromInternalPtr(VfsVarp), ValueVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetDeserializeIcon gets the "deserialize_icon" callback function.
func (x *VfsClass) GetDeserializeIcon() func(*Vfs, *glib.Variant) *IconBase {
	if x.xDeserializeIcon == 0 {
		return nil
	}
	var rawCallback func(VfsVarp uintptr, ValueVarp *glib.Variant) uintptr
	purego.RegisterFunc(&rawCallback, x.xDeserializeIcon)
	return func(VfsVar *Vfs, ValueVar *glib.Variant) *IconBase {
		rawRet := rawCallback(VfsVar.GoPointer(), ValueVar)
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGReserved1 sets the "_g_reserved1" callback function.
func (x *VfsClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the "_g_reserved1" callback function.
func (x *VfsClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the "_g_reserved2" callback function.
func (x *VfsClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the "_g_reserved2" callback function.
func (x *VfsClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the "_g_reserved3" callback function.
func (x *VfsClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the "_g_reserved3" callback function.
func (x *VfsClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the "_g_reserved4" callback function.
func (x *VfsClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the "_g_reserved4" callback function.
func (x *VfsClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the "_g_reserved5" callback function.
func (x *VfsClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the "_g_reserved5" callback function.
func (x *VfsClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved6 sets the "_g_reserved6" callback function.
func (x *VfsClass) OverrideGReserved6(cb func()) {
	if cb == nil {
		x.xGReserved6 = 0
	} else {
		x.xGReserved6 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved6 gets the "_g_reserved6" callback function.
func (x *VfsClass) GetGReserved6() func() {
	if x.xGReserved6 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved6)
	return func() {
		rawCallback()
	}
}

const (
	// Extension point for #GVfs functionality.
	// See [Extending GIO](overview.html#extending-gio).
	VFS_EXTENSION_POINT_NAME string = "gio-vfs"
)

// Entry point for using GIO functionality.
type Vfs struct {
	gobject.Object
}

var xVfsGLibType func() types.GType

func VfsGLibType() types.GType {
	return xVfsGLibType()
}

func VfsNewFromInternalPtr(ptr uintptr) *Vfs {
	cls := &Vfs{}
	cls.Ptr = ptr
	return cls
}

var xVfsGetFileForPath func(uintptr, string) uintptr

// Gets a #GFile for @path.
func (x *Vfs) GetFileForPath(PathVar string) *FileBase {
	var cls *FileBase

	cret := xVfsGetFileForPath(x.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xVfsGetFileForUri func(uintptr, string) uintptr

// Gets a #GFile for @uri.
//
// This operation never fails, but the returned object
// might not support any I/O operation if the URI
// is malformed or if the URI scheme is not supported.
func (x *Vfs) GetFileForUri(UriVar string) *FileBase {
	var cls *FileBase

	cret := xVfsGetFileForUri(x.GoPointer(), UriVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xVfsGetSupportedUriSchemes func(uintptr) []string

// Gets a list of URI schemes supported by @vfs.
func (x *Vfs) GetSupportedUriSchemes() []string {

	cret := xVfsGetSupportedUriSchemes(x.GoPointer())

	return cret
}

var xVfsIsActive func(uintptr) bool

// Checks if the VFS is active.
func (x *Vfs) IsActive() bool {

	cret := xVfsIsActive(x.GoPointer())

	return cret
}

var xVfsParseName func(uintptr, string) uintptr

// This operation never fails, but the returned object might
// not support any I/O operations if the @parse_name cannot
// be parsed by the #GVfs module.
func (x *Vfs) ParseName(ParseNameVar string) *FileBase {
	var cls *FileBase

	cret := xVfsParseName(x.GoPointer(), ParseNameVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xVfsRegisterUriScheme func(uintptr, string, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) bool

// Registers @uri_func and @parse_name_func as the #GFile URI and parse name
// lookup functions for URIs with a scheme matching @scheme.
// Note that @scheme is registered only within the running application, as
// opposed to desktop-wide as it happens with GVfs backends.
//
// When a #GFile is requested with an URI containing @scheme (e.g. through
// g_file_new_for_uri()), @uri_func will be called to allow a custom
// constructor. The implementation of @uri_func should not be blocking, and
// must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
//
// When g_file_parse_name() is called with a parse name obtained from such file,
// @parse_name_func will be called to allow the #GFile to be created again. In
// that case, it's responsibility of @parse_name_func to make sure the parse
// name matches what the custom #GFile implementation returned when
// g_file_get_parse_name() was previously called. The implementation of
// @parse_name_func should not be blocking, and must not call
// g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
//
// It's an error to call this function twice with the same scheme. To unregister
// a custom URI scheme, use g_vfs_unregister_uri_scheme().
func (x *Vfs) RegisterUriScheme(SchemeVar string, UriFuncVar *VfsFileLookupFunc, UriDataVar uintptr, UriDestroyVar *glib.DestroyNotify, ParseNameFuncVar *VfsFileLookupFunc, ParseNameDataVar uintptr, ParseNameDestroyVar *glib.DestroyNotify) bool {

	var UriFuncVarRef uintptr
	if UriFuncVar != nil {
		UriFuncVarPtr := uintptr(unsafe.Pointer(UriFuncVar))
		if cbRefPtr, ok := glib.GetCallback(UriFuncVarPtr); ok {
			UriFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 string, arg2 uintptr) uintptr {
				cbFn := *UriFuncVar
				return cbFn(arg0, arg1, arg2)
			}
			UriFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(UriFuncVarPtr, UriFuncVarRef)
		}
	}

	var UriDestroyVarRef uintptr
	if UriDestroyVar != nil {
		UriDestroyVarPtr := uintptr(unsafe.Pointer(UriDestroyVar))
		if cbRefPtr, ok := glib.GetCallback(UriDestroyVarPtr); ok {
			UriDestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *UriDestroyVar
				cbFn(arg0)
			}
			UriDestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(UriDestroyVarPtr, UriDestroyVarRef)
		}
	}

	var ParseNameFuncVarRef uintptr
	if ParseNameFuncVar != nil {
		ParseNameFuncVarPtr := uintptr(unsafe.Pointer(ParseNameFuncVar))
		if cbRefPtr, ok := glib.GetCallback(ParseNameFuncVarPtr); ok {
			ParseNameFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 string, arg2 uintptr) uintptr {
				cbFn := *ParseNameFuncVar
				return cbFn(arg0, arg1, arg2)
			}
			ParseNameFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(ParseNameFuncVarPtr, ParseNameFuncVarRef)
		}
	}

	var ParseNameDestroyVarRef uintptr
	if ParseNameDestroyVar != nil {
		ParseNameDestroyVarPtr := uintptr(unsafe.Pointer(ParseNameDestroyVar))
		if cbRefPtr, ok := glib.GetCallback(ParseNameDestroyVarPtr); ok {
			ParseNameDestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *ParseNameDestroyVar
				cbFn(arg0)
			}
			ParseNameDestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(ParseNameDestroyVarPtr, ParseNameDestroyVarRef)
		}
	}

	cret := xVfsRegisterUriScheme(x.GoPointer(), SchemeVar, UriFuncVarRef, UriDataVar, UriDestroyVarRef, ParseNameFuncVarRef, ParseNameDataVar, ParseNameDestroyVarRef)

	return cret
}

var xVfsUnregisterUriScheme func(uintptr, string) bool

// Unregisters the URI handler for @scheme previously registered with
// g_vfs_register_uri_scheme().
func (x *Vfs) UnregisterUriScheme(SchemeVar string) bool {

	cret := xVfsUnregisterUriScheme(x.GoPointer(), SchemeVar)

	return cret
}

func (c *Vfs) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Vfs) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xVfsGetDefault func() uintptr

// Gets the default #GVfs for the system.
func VfsGetDefault() *Vfs {
	var cls *Vfs

	cret := xVfsGetDefault()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Vfs{}
	cls.Ptr = cret
	return cls
}

var xVfsGetLocal func() uintptr

// Gets the local #GVfs for the system.
func VfsGetLocal() *Vfs {
	var cls *Vfs

	cret := xVfsGetLocal()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Vfs{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xVfsGLibType, libs, "g_vfs_get_type")

	core.PuregoSafeRegister(&xVfsGetFileForPath, libs, "g_vfs_get_file_for_path")
	core.PuregoSafeRegister(&xVfsGetFileForUri, libs, "g_vfs_get_file_for_uri")
	core.PuregoSafeRegister(&xVfsGetSupportedUriSchemes, libs, "g_vfs_get_supported_uri_schemes")
	core.PuregoSafeRegister(&xVfsIsActive, libs, "g_vfs_is_active")
	core.PuregoSafeRegister(&xVfsParseName, libs, "g_vfs_parse_name")
	core.PuregoSafeRegister(&xVfsRegisterUriScheme, libs, "g_vfs_register_uri_scheme")
	core.PuregoSafeRegister(&xVfsUnregisterUriScheme, libs, "g_vfs_unregister_uri_scheme")

	core.PuregoSafeRegister(&xVfsGetDefault, libs, "g_vfs_get_default")
	core.PuregoSafeRegister(&xVfsGetLocal, libs, "g_vfs_get_local")

}
