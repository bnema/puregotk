// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

var xIoSchedulerCancelAllJobs func()

// Cancels all cancellable I/O jobs.
//
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
func IoSchedulerCancelAllJobs() {

	xIoSchedulerCancelAllJobs()

}

var xIoSchedulerPushJob func(uintptr, uintptr, uintptr, int, uintptr)

// Schedules the I/O job to run in another thread.
//
// @notify will be called on @user_data after @job_func has returned,
// regardless whether the job was cancelled or has run to completion.
//
// If @cancellable is not %NULL, it can be used to cancel the I/O job
// by calling g_cancellable_cancel() or by calling
// g_io_scheduler_cancel_all_jobs().
func IoSchedulerPushJob(JobFuncVar *IOSchedulerJobFunc, UserDataVar uintptr, NotifyVar *glib.DestroyNotify, IoPriorityVar int, CancellableVar *Cancellable) {

	var JobFuncVarRef uintptr
	if JobFuncVar != nil {
		JobFuncVarPtr := uintptr(unsafe.Pointer(JobFuncVar))
		if cbRefPtr, ok := glib.GetCallback(JobFuncVarPtr); ok {
			JobFuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 *IOSchedulerJob, arg1 uintptr, arg2 uintptr) bool {
				cbFn := *JobFuncVar
				return cbFn(arg0, arg1, arg2)
			}
			JobFuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(JobFuncVarPtr, JobFuncVarRef)
		}
	}

	var NotifyVarRef uintptr
	if NotifyVar != nil {
		NotifyVarPtr := uintptr(unsafe.Pointer(NotifyVar))
		if cbRefPtr, ok := glib.GetCallback(NotifyVarPtr); ok {
			NotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *NotifyVar
				cbFn(arg0)
			}
			NotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(NotifyVarPtr, NotifyVarRef)
		}
	}

	xIoSchedulerPushJob(JobFuncVarRef, UserDataVar, NotifyVarRef, IoPriorityVar, CancellableVar.GoPointer())

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xIoSchedulerCancelAllJobs, libs, "g_io_scheduler_cancel_all_jobs")
	core.PuregoSafeRegister(&xIoSchedulerPushJob, libs, "g_io_scheduler_push_job")

}
