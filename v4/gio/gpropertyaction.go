// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A `GPropertyAction` is a way to get a [iface@Gio.Action] with a state value
// reflecting and controlling the value of a [class@GObject.Object] property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value
// matches the requirements as specified in the [type@GObject.ParamSpec]).
//
// Only the most common types are presently supported.  Booleans are
// mapped to booleans, strings to strings, signed/unsigned integers to
// int32/uint32 and floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and
// conversion will automatically be performed between the enum value and
// ‘nick’ string as per the [type@GObject.EnumValue] table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not
// supported and probably never will be.
//
// Properties of [type@GLib.Variant] types are not currently supported.
//
// If the property is boolean-valued then the action will have a `NULL`
// parameter type, and activating the action (with no parameter) will
// toggle the value of the property.
//
// In all other cases, the parameter type will correspond to the type of
// the property.
//
// The general idea here is to reduce the number of locations where a
// particular piece of state is kept (and therefore has to be synchronised
// between). `GPropertyAction` does not have a separate state that is kept
// in sync with the property value — its state is the property value.
//
// For example, it might be useful to create a [iface@Gio.Action] corresponding
// to the `visible-child-name` property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html)
// so that the current page can be switched from a menu.  The active radio
// indication in the menu is then directly determined from the active page of
// the `GtkStack`.
//
// An anti-example would be binding the `active-id` property on a
// [`GtkComboBox`](https://docs.gtk.org/gtk4/class.ComboBox.html). This is
// because the state of the combo box itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the `visible-child-name`
// property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html) if
// this value is actually stored in [class@Gio.Settings].  In that case, the
// real source of the value is* [class@Gio.Settings].  If you want
// a [iface@Gio.Action] to control a setting stored in [class@Gio.Settings],
// see [method@Gio.Settings.create_action] instead, and possibly combine its
// use with [method@Gio.Settings.bind].
type PropertyAction struct {
	gobject.Object
}

var xPropertyActionGLibType func() types.GType

func PropertyActionGLibType() types.GType {
	return xPropertyActionGLibType()
}

func PropertyActionNewFromInternalPtr(ptr uintptr) *PropertyAction {
	cls := &PropertyAction{}
	cls.Ptr = ptr
	return cls
}

var xNewPropertyAction func(string, uintptr, string) uintptr

// Creates a #GAction corresponding to the value of property
// @property_name on @object.
//
// The property must be existent and readable and writable (and not
// construct-only).
//
// This function takes a reference on @object and doesn't release it
// until the action is destroyed.
func NewPropertyAction(NameVar string, ObjectVar *gobject.Object, PropertyNameVar string) *PropertyAction {
	var cls *PropertyAction

	cret := xNewPropertyAction(NameVar, ObjectVar.GoPointer(), PropertyNameVar)

	if cret == 0 {
		return nil
	}
	cls = &PropertyAction{}
	cls.Ptr = cret
	return cls
}

func (c *PropertyAction) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *PropertyAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Activates the action.
//
// @parameter must be the correct type of parameter for the action (ie:
// the parameter type given at construction time).  If the parameter
// type was `NULL` then @parameter must also be `NULL`.
//
// If the @parameter [type@GLib.Variant] is floating, it is consumed.
func (x *PropertyAction) Activate(ParameterVar *glib.Variant) {

	XGActionActivate(x.GoPointer(), ParameterVar)

}

// Request for the state of @action to be changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See [method@Gio.Action.get_state_type].
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See [method@Gio.Action.get_state_hint].
//
// If the @value [type@GLib.Variant] is floating, it is consumed.
func (x *PropertyAction) ChangeState(ValueVar *glib.Variant) {

	XGActionChangeState(x.GoPointer(), ValueVar)

}

// Checks if @action is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *PropertyAction) GetEnabled() bool {

	cret := XGActionGetEnabled(x.GoPointer())
	return cret
}

// Queries the name of @action.
func (x *PropertyAction) GetName() string {

	cret := XGActionGetName(x.GoPointer())
	return cret
}

// Queries the type of the parameter that must be given when activating
// @action.
//
// When activating the action using [method@Gio.Action.activate], the
// [type@GLib.Variant] given to that function must be of the type returned by
// this function.
//
// In the case that this function returns `NULL`, you must not give any
// [type@GLib.Variant], but `NULL` instead.
func (x *PropertyAction) GetParameterType() *glib.VariantType {

	cret := XGActionGetParameterType(x.GoPointer())
	return cret
}

// Queries the current state of @action.
//
// If the action is not stateful then `NULL` will be returned.  If the
// action is stateful then the type of the return value is the type
// given by [method@Gio.Action.get_state_type].
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *PropertyAction) GetState() *glib.Variant {

	cret := XGActionGetState(x.GoPointer())
	return cret
}

// Requests a hint about the valid range of values for the state of
// @action.
//
// If `NULL` is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a [type@GLib.Variant] array is returned then each item in the array is a
// possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *PropertyAction) GetStateHint() *glib.Variant {

	cret := XGActionGetStateHint(x.GoPointer())
	return cret
}

// Queries the type of the state of @action.
//
// If the action is stateful (e.g. created with
// [ctor@Gio.SimpleAction.new_stateful]) then this function returns the
// [type@GLib.VariantType] of the state.  This is the type of the initial value
// given as the state. All calls to [method@Gio.Action.change_state] must give a
// [type@GLib.Variant] of this type and [method@Gio.Action.get_state] will return a
// [type@GLib.Variant] of the same type.
//
// If the action is not stateful (e.g. created with [ctor@Gio.SimpleAction.new])
// then this function will return `NULL`. In that case, [method@Gio.Action.get_state]
// will return `NULL` and you must not call [method@Gio.Action.change_state].
func (x *PropertyAction) GetStateType() *glib.VariantType {

	cret := XGActionGetStateType(x.GoPointer())
	return cret
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xPropertyActionGLibType, libs, "g_property_action_get_type")

	core.PuregoSafeRegister(&xNewPropertyAction, libs, "g_property_action_new")

}
