// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// `GDBusServer` is a helper for listening to and accepting D-Bus
// connections. This can be used to create a new D-Bus server, allowing two
// peers to use the D-Bus protocol for their own specialized communication.
// A server instance provided in this way will not perform message routing or
// implement the
// [`org.freedesktop.DBus` interface](https://dbus.freedesktop.org/doc/dbus-specification.html#message-bus-messages).
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use [func@Gio.bus_own_name].
//
// An example of peer-to-peer communication with GDBus can be found
// in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal `GDBusServer` will accept connections from any
// peer. In many use-cases it will be necessary to add a
// [class@Gio.DBusAuthObserver] that only accepts connections that have
// successfully authenticated as the same user that is running the
// `GDBusServer`. Since GLib 2.68 this can be achieved more simply by passing
// the `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag to the
// server.
type DBusServer struct {
	gobject.Object
}

var xDBusServerGLibType func() types.GType

func DBusServerGLibType() types.GType {
	return xDBusServerGLibType()
}

func DBusServerNewFromInternalPtr(ptr uintptr) *DBusServer {
	cls := &DBusServer{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusServerSync func(string, DBusServerFlags, string, uintptr, uintptr, **glib.Error) uintptr

// Creates a new D-Bus server that listens on the first address in
// @address that works.
//
// Once constructed, you can use g_dbus_server_get_client_address() to
// get a D-Bus address string that clients can use to connect.
//
// To have control over the available authentication mechanisms and
// the users that are authorized to connect, it is strongly recommended
// to provide a non-%NULL #GDBusAuthObserver.
//
// Connect to the #GDBusServer::new-connection signal to handle
// incoming connections.
//
// The returned #GDBusServer isn't active - you have to start it with
// g_dbus_server_start().
//
// #GDBusServer is used in this [example](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
//
// This is a synchronous failable constructor. There is currently no
// asynchronous version.
func NewDBusServerSync(AddressVar string, FlagsVar DBusServerFlags, GuidVar string, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable) (*DBusServer, error) {
	var cls *DBusServer
	var cerr *glib.Error

	cret := xNewDBusServerSync(AddressVar, FlagsVar, GuidVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusServer{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusServerGetClientAddress func(uintptr) string

// Gets a
// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
// string that can be used by clients to connect to @server.
//
// This is valid and non-empty if initializing the #GDBusServer succeeded.
func (x *DBusServer) GetClientAddress() string {

	cret := xDBusServerGetClientAddress(x.GoPointer())
	return cret
}

var xDBusServerGetFlags func(uintptr) DBusServerFlags

// Gets the flags for @server.
func (x *DBusServer) GetFlags() DBusServerFlags {

	cret := xDBusServerGetFlags(x.GoPointer())
	return cret
}

var xDBusServerGetGuid func(uintptr) string

// Gets the GUID for @server, as provided to g_dbus_server_new_sync().
func (x *DBusServer) GetGuid() string {

	cret := xDBusServerGetGuid(x.GoPointer())
	return cret
}

var xDBusServerIsActive func(uintptr) bool

// Gets whether @server is active.
func (x *DBusServer) IsActive() bool {

	cret := xDBusServerIsActive(x.GoPointer())
	return cret
}

var xDBusServerStart func(uintptr)

// Starts @server.
func (x *DBusServer) Start() {

	xDBusServerStart(x.GoPointer())

}

var xDBusServerStop func(uintptr)

// Stops @server.
func (x *DBusServer) Stop() {

	xDBusServerStop(x.GoPointer())

}

func (c *DBusServer) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *DBusServer) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// GetPropertyActive gets the "active" property.
// Whether the server is currently active.
func (x *DBusServer) GetPropertyActive() bool {
	var v gobject.Value
	x.GetProperty("active", &v)
	return v.GetBoolean()
}

// SetPropertyAddress sets the "address" property.
// The D-Bus address to listen on.
func (x *DBusServer) SetPropertyAddress(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("address", &v)
}

// GetPropertyAddress gets the "address" property.
// The D-Bus address to listen on.
func (x *DBusServer) GetPropertyAddress() string {
	var v gobject.Value
	x.GetProperty("address", &v)
	return v.GetString()
}

// GetPropertyClientAddress gets the "client-address" property.
// The D-Bus address that clients can use.
func (x *DBusServer) GetPropertyClientAddress() string {
	var v gobject.Value
	x.GetProperty("client-address", &v)
	return v.GetString()
}

// SetPropertyGuid sets the "guid" property.
// The GUID of the server.
//
// See #GDBusConnection:guid for more details.
func (x *DBusServer) SetPropertyGuid(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("guid", &v)
}

// GetPropertyGuid gets the "guid" property.
// The GUID of the server.
//
// See #GDBusConnection:guid for more details.
func (x *DBusServer) GetPropertyGuid() string {
	var v gobject.Value
	x.GetProperty("guid", &v)
	return v.GetString()
}

// Emitted when a new authenticated connection has been made. Use
// g_dbus_connection_get_peer_credentials() to figure out what
// identity (if any), was authenticated.
//
// If you want to accept the connection, take a reference to the
// @connection object and return %TRUE. When you are done with the
// connection call g_dbus_connection_close() and give up your
// reference. Note that the other peer may disconnect at any time -
// a typical thing to do when accepting a connection is to listen to
// the #GDBusConnection::closed signal.
//
// If #GDBusServer:flags contains %G_DBUS_SERVER_FLAGS_RUN_IN_THREAD
// then the signal is emitted in a new thread dedicated to the
// connection. Otherwise the signal is emitted in the thread-default
// main context (see [method@GLib.MainContext.push_thread_default])
// of the thread that @server was constructed in.
//
// You are guaranteed that signal handlers for this signal runs
// before incoming messages on @connection are processed. This means
// that it's suitable to call g_dbus_connection_register_object() or
// similar from the signal handler.
func (x *DBusServer) ConnectNewConnection(cb *func(DBusServer, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "new-connection", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ConnectionVarp uintptr) bool {
		fa := DBusServer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ConnectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "new-connection", cbRefPtr)
}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [description][iface@Gio.Initable#description] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a classâ€™ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *DBusServer) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xDBusServerGLibType, libs, "g_dbus_server_get_type")

	core.PuregoSafeRegister(&xNewDBusServerSync, libs, "g_dbus_server_new_sync")

	core.PuregoSafeRegister(&xDBusServerGetClientAddress, libs, "g_dbus_server_get_client_address")
	core.PuregoSafeRegister(&xDBusServerGetFlags, libs, "g_dbus_server_get_flags")
	core.PuregoSafeRegister(&xDBusServerGetGuid, libs, "g_dbus_server_get_guid")
	core.PuregoSafeRegister(&xDBusServerIsActive, libs, "g_dbus_server_is_active")
	core.PuregoSafeRegister(&xDBusServerStart, libs, "g_dbus_server_start")
	core.PuregoSafeRegister(&xDBusServerStop, libs, "g_dbus_server_stop")

}
