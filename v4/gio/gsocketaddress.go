// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type SocketAddressClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xGetFamily uintptr

	xGetNativeSize uintptr

	xToNative uintptr
}

func (x *SocketAddressClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetFamily sets the "get_family" callback function.
func (x *SocketAddressClass) OverrideGetFamily(cb func(*SocketAddress) SocketFamily) {
	if cb == nil {
		x.xGetFamily = 0
	} else {
		x.xGetFamily = purego.NewCallback(func(AddressVarp uintptr) SocketFamily {
			return cb(SocketAddressNewFromInternalPtr(AddressVarp))
		})
	}
}

// GetGetFamily gets the "get_family" callback function.
func (x *SocketAddressClass) GetGetFamily() func(*SocketAddress) SocketFamily {
	if x.xGetFamily == 0 {
		return nil
	}
	var rawCallback func(AddressVarp uintptr) SocketFamily
	purego.RegisterFunc(&rawCallback, x.xGetFamily)
	return func(AddressVar *SocketAddress) SocketFamily {
		return rawCallback(AddressVar.GoPointer())
	}
}

// OverrideGetNativeSize sets the "get_native_size" callback function.
func (x *SocketAddressClass) OverrideGetNativeSize(cb func(*SocketAddress) int) {
	if cb == nil {
		x.xGetNativeSize = 0
	} else {
		x.xGetNativeSize = purego.NewCallback(func(AddressVarp uintptr) int {
			return cb(SocketAddressNewFromInternalPtr(AddressVarp))
		})
	}
}

// GetGetNativeSize gets the "get_native_size" callback function.
func (x *SocketAddressClass) GetGetNativeSize() func(*SocketAddress) int {
	if x.xGetNativeSize == 0 {
		return nil
	}
	var rawCallback func(AddressVarp uintptr) int
	purego.RegisterFunc(&rawCallback, x.xGetNativeSize)
	return func(AddressVar *SocketAddress) int {
		return rawCallback(AddressVar.GoPointer())
	}
}

// OverrideToNative sets the "to_native" callback function.
func (x *SocketAddressClass) OverrideToNative(cb func(*SocketAddress, uintptr, uint) bool) {
	if cb == nil {
		x.xToNative = 0
	} else {
		x.xToNative = purego.NewCallback(func(AddressVarp uintptr, DestVarp uintptr, DestlenVarp uint) bool {
			return cb(SocketAddressNewFromInternalPtr(AddressVarp), DestVarp, DestlenVarp)
		})
	}
}

// GetToNative gets the "to_native" callback function.
func (x *SocketAddressClass) GetToNative() func(*SocketAddress, uintptr, uint) bool {
	if x.xToNative == 0 {
		return nil
	}
	var rawCallback func(AddressVarp uintptr, DestVarp uintptr, DestlenVarp uint) bool
	purego.RegisterFunc(&rawCallback, x.xToNative)
	return func(AddressVar *SocketAddress, DestVar uintptr, DestlenVar uint) bool {
		return rawCallback(AddressVar.GoPointer(), DestVar, DestlenVar)
	}
}

// `GSocketAddress` is the equivalent of
// [`struct sockaddr`](man:sockaddr(3type)) and its subtypes in the BSD sockets
// API. This is an abstract class; use [class@Gio.InetSocketAddress] for
// internet sockets, or [class@Gio.UnixSocketAddress] for UNIX domain sockets.
type SocketAddress struct {
	gobject.Object
}

var xSocketAddressGLibType func() types.GType

func SocketAddressGLibType() types.GType {
	return xSocketAddressGLibType()
}

func SocketAddressNewFromInternalPtr(ptr uintptr) *SocketAddress {
	cls := &SocketAddress{}
	cls.Ptr = ptr
	return cls
}

var xNewSocketAddressFromNative func(uintptr, uint) uintptr

// Creates a #GSocketAddress subclass corresponding to the native
// struct sockaddr @native.
func NewSocketAddressFromNative(NativeVar uintptr, LenVar uint) *SocketAddress {
	var cls *SocketAddress

	cret := xNewSocketAddressFromNative(NativeVar, LenVar)

	if cret == 0 {
		return nil
	}
	cls = &SocketAddress{}
	cls.Ptr = cret
	return cls
}

var xSocketAddressGetFamily func(uintptr) SocketFamily

// Gets the socket family type of @address.
func (x *SocketAddress) GetFamily() SocketFamily {

	cret := xSocketAddressGetFamily(x.GoPointer())

	return cret
}

var xSocketAddressGetNativeSize func(uintptr) int

// Gets the size of @address's native struct sockaddr.
// You can use this to allocate memory to pass to
// g_socket_address_to_native().
func (x *SocketAddress) GetNativeSize() int {

	cret := xSocketAddressGetNativeSize(x.GoPointer())

	return cret
}

var xSocketAddressToNative func(uintptr, uintptr, uint, **glib.Error) bool

// Converts a #GSocketAddress to a native struct sockaddr, which can
// be passed to low-level functions like connect() or bind().
//
// If not enough space is available, a %G_IO_ERROR_NO_SPACE error
// is returned. If the address type is not known on the system
// then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
func (x *SocketAddress) ToNative(DestVar uintptr, DestlenVar uint) (bool, error) {
	var cerr *glib.Error

	cret := xSocketAddressToNative(x.GoPointer(), DestVar, DestlenVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *SocketAddress) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *SocketAddress) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Creates a #GSocketAddressEnumerator for @connectable.
func (x *SocketAddress) Enumerate() *SocketAddressEnumerator {
	var cls *SocketAddressEnumerator

	cret := XGSocketConnectableEnumerate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SocketAddressEnumerator{}
	cls.Ptr = cret
	return cls
}

// Creates a #GSocketAddressEnumerator for @connectable that will
// return a #GProxyAddress for each of its addresses that you must connect
// to via a proxy.
//
// If @connectable does not implement
// g_socket_connectable_proxy_enumerate(), this will fall back to
// calling g_socket_connectable_enumerate().
func (x *SocketAddress) ProxyEnumerate() *SocketAddressEnumerator {
	var cls *SocketAddressEnumerator

	cret := XGSocketConnectableProxyEnumerate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SocketAddressEnumerator{}
	cls.Ptr = cret
	return cls
}

// Format a #GSocketConnectable as a string. This is a human-readable format for
// use in debugging output, and is not a stable serialization format. It is not
// suitable for use in user interfaces as it exposes too much information for a
// user.
//
// If the #GSocketConnectable implementation does not support string formatting,
// the implementationâ€™s type name will be returned as a fallback.
func (x *SocketAddress) ToString() string {

	cret := XGSocketConnectableToString(x.GoPointer())

	return cret
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSocketAddressGLibType, libs, "g_socket_address_get_type")

	core.PuregoSafeRegister(&xNewSocketAddressFromNative, libs, "g_socket_address_new_from_native")

	core.PuregoSafeRegister(&xSocketAddressGetFamily, libs, "g_socket_address_get_family")
	core.PuregoSafeRegister(&xSocketAddressGetNativeSize, libs, "g_socket_address_get_native_size")
	core.PuregoSafeRegister(&xSocketAddressToNative, libs, "g_socket_address_to_native")

}
