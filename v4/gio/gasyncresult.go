// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Interface definition for [iface@Gio.AsyncResult].
type AsyncResultIface struct {
	_ structs.HostLayout

	GIface uintptr

	xGetUserData uintptr

	xGetSourceObject uintptr

	xIsTagged uintptr
}

func (x *AsyncResultIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetUserData sets the "get_user_data" callback function.
// Gets the user data passed to the callback.
func (x *AsyncResultIface) OverrideGetUserData(cb func(AsyncResult) uintptr) {
	if cb == nil {
		x.xGetUserData = 0
	} else {
		x.xGetUserData = purego.NewCallback(func(ResVarp uintptr) uintptr {
			return cb(&AsyncResultBase{Ptr: ResVarp})
		})
	}
}

// GetGetUserData gets the "get_user_data" callback function.
// Gets the user data passed to the callback.
func (x *AsyncResultIface) GetGetUserData() func(AsyncResult) uintptr {
	if x.xGetUserData == 0 {
		return nil
	}
	var rawCallback func(ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetUserData)
	return func(ResVar AsyncResult) uintptr {
		return rawCallback(ResVar.GoPointer())
	}
}

// OverrideGetSourceObject sets the "get_source_object" callback function.
// Gets the source object that issued the asynchronous operation.
func (x *AsyncResultIface) OverrideGetSourceObject(cb func(AsyncResult) *gobject.Object) {
	if cb == nil {
		x.xGetSourceObject = 0
	} else {
		x.xGetSourceObject = purego.NewCallback(func(ResVarp uintptr) uintptr {
			ret := cb(&AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetSourceObject gets the "get_source_object" callback function.
// Gets the source object that issued the asynchronous operation.
func (x *AsyncResultIface) GetGetSourceObject() func(AsyncResult) *gobject.Object {
	if x.xGetSourceObject == 0 {
		return nil
	}
	var rawCallback func(ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetSourceObject)
	return func(ResVar AsyncResult) *gobject.Object {
		rawRet := rawCallback(ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &gobject.Object{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideIsTagged sets the "is_tagged" callback function.
// Checks if a result is tagged with a particular source.
func (x *AsyncResultIface) OverrideIsTagged(cb func(AsyncResult, uintptr) bool) {
	if cb == nil {
		x.xIsTagged = 0
	} else {
		x.xIsTagged = purego.NewCallback(func(ResVarp uintptr, SourceTagVarp uintptr) bool {
			return cb(&AsyncResultBase{Ptr: ResVarp}, SourceTagVarp)
		})
	}
}

// GetIsTagged gets the "is_tagged" callback function.
// Checks if a result is tagged with a particular source.
func (x *AsyncResultIface) GetIsTagged() func(AsyncResult, uintptr) bool {
	if x.xIsTagged == 0 {
		return nil
	}
	var rawCallback func(ResVarp uintptr, SourceTagVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsTagged)
	return func(ResVar AsyncResult, SourceTagVar uintptr) bool {
		return rawCallback(ResVar.GoPointer(), SourceTagVar)
	}
}

// `GAsyncResult` provides a base class for implementing asynchronous function results.
//
// Asynchronous operations are broken up into two separate operations
// which are chained together by a `GAsyncReadyCallback`. To begin
// an asynchronous operation, provide a `GAsyncReadyCallback` to the
// asynchronous function. This callback will be triggered when the
// operation has completed, and must be run in a later iteration of
// the thread-default main context (see
// [method@GLib.MainContext.push_thread_default]) from where the operation was
// initiated. It will be passed a `GAsyncResult` instance filled with the
// details of the operation's success or failure, the object the asynchronous
// function was started for and any error codes returned. The asynchronous
// callback function is then expected to call the corresponding `_finish()`
// function, passing the object the function was called for, the
// `GAsyncResult` instance, and (optionally) an @error to grab any
// error conditions that may have occurred.
//
// The `_finish()` function for an operation takes the generic result
// (of type `GAsyncResult`) and returns the specific result that the
// operation in question yields (e.g. a [class@Gio.FileEnumerator] for a
// "enumerate children" operation). If the result or error status of the
// operation is not needed, there is no need to call the `_finish()`
// function; GIO will take care of cleaning up the result and error
// information after the `GAsyncReadyCallback` returns. You can pass
// `NULL` for the `GAsyncReadyCallback` if you don't need to take any
// action at all after the operation completes. Applications may also
// take a reference to the `GAsyncResult` and call `_finish()` later;
// however, the `_finish()` function may be called at most once.
//
// Example of a typical asynchronous operation flow:
//
// ```c
// void _theoretical_frobnitz_async (Theoretical         *t,
//
//	GCancellable        *c,
//	GAsyncReadyCallback  cb,
//	gpointer             u);
//
// gboolean _theoretical_frobnitz_finish (Theoretical   *t,
//
//	GAsyncResult  *res,
//	GError       **e);
//
// static void
// frobnitz_result_func (GObject      *source_object,
//
//	GAsyncResult *res,
//	gpointer      user_data)
//
//	{
//	  gboolean success = FALSE;
//
//	  success = _theoretical_frobnitz_finish (source_object, res, NULL);
//
//	  if (success)
//	    g_printf ("Hurray!\n");
//	  else
//	    g_printf ("Uh oh!\n");
//
//	  ...
//
// }
//
// int main (int argc, void *argv[])
//
//	{
//	   ...
//
//	   _theoretical_frobnitz_async (theoretical_data,
//	                                NULL,
//	                                frobnitz_result_func,
//	                                NULL);
//
//	   ...
//	}
//
// ```
//
// The callback for an asynchronous operation is called only once, and is
// always called, even in the case of a cancelled operation. On cancellation
// the result is a `G_IO_ERROR_CANCELLED` error.
//
// ## I/O Priority
//
// Many I/O-related asynchronous operations have a priority parameter,
// which is used in certain cases to determine the order in which
// operations are executed. They are not used to determine system-wide
// I/O scheduling. Priorities are integers, with lower numbers indicating
// higher priority. It is recommended to choose priorities between
// `G_PRIORITY_LOW` and `G_PRIORITY_HIGH`, with `G_PRIORITY_DEFAULT`
// as a default.
type AsyncResult interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	GetSourceObject() *gobject.Object
	GetUserData() uintptr
	IsTagged(SourceTagVar uintptr) bool
	LegacyPropagateError() (bool, error)
}

var xAsyncResultGLibType func() types.GType

func AsyncResultGLibType() types.GType {
	return xAsyncResultGLibType()
}

type AsyncResultBase struct {
	Ptr uintptr
}

func (x *AsyncResultBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *AsyncResultBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Gets the source object from a [iface@Gio.AsyncResult].
func (x *AsyncResultBase) GetSourceObject() *gobject.Object {
	var cls *gobject.Object

	cret := XGAsyncResultGetSourceObject(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Gets the user data from a [iface@Gio.AsyncResult].
func (x *AsyncResultBase) GetUserData() uintptr {

	cret := XGAsyncResultGetUserData(x.GoPointer())
	return cret
}

// Checks if @res has the given @source_tag (generally a function
// pointer indicating the function @res was created by).
func (x *AsyncResultBase) IsTagged(SourceTagVar uintptr) bool {

	cret := XGAsyncResultIsTagged(x.GoPointer(), SourceTagVar)
	return cret
}

// If @res is a [class@Gio.SimpleAsyncResult], this is equivalent to
// [method@Gio.SimpleAsyncResult.propagate_error]. Otherwise it returns
// `FALSE`.
//
// This can be used for legacy error handling in async `*_finish()`
// wrapper functions that traditionally handled [class@Gio.SimpleAsyncResult]
// error returns themselves rather than calling into the virtual method.
// This should not be used in new code; [iface@Gio.AsyncResult] errors that are
// set by virtual methods should also be extracted by virtual methods,
// to enable subclasses to chain up correctly.
func (x *AsyncResultBase) LegacyPropagateError() (bool, error) {
	var cerr *glib.Error

	cret := XGAsyncResultLegacyPropagateError(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var XGAsyncResultGetSourceObject func(uintptr) uintptr
var XGAsyncResultGetUserData func(uintptr) uintptr
var XGAsyncResultIsTagged func(uintptr, uintptr) bool
var XGAsyncResultLegacyPropagateError func(uintptr) bool

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAsyncResultGLibType, libs, "g_async_result_get_type")

	core.PuregoSafeRegister(&XGAsyncResultGetSourceObject, libs, "g_async_result_get_source_object")
	core.PuregoSafeRegister(&XGAsyncResultGetUserData, libs, "g_async_result_get_user_data")
	core.PuregoSafeRegister(&XGAsyncResultIsTagged, libs, "g_async_result_is_tagged")
	core.PuregoSafeRegister(&XGAsyncResultLegacyPropagateError, libs, "g_async_result_legacy_propagate_error")

}
