// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// GIconIface is used to implement GIcon types for various
// different systems. See #GThemedIcon and #GLoadableIcon for
// examples of how to implement this interface.
type IconIface struct {
	_ structs.HostLayout

	GIface uintptr

	xHash uintptr

	xEqual uintptr

	xToTokens uintptr

	xFromTokens uintptr

	xSerialize uintptr
}

func (x *IconIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideHash sets the "hash" callback function.
// A hash for a given #GIcon.
func (x *IconIface) OverrideHash(cb func(Icon) uint) {
	if cb == nil {
		x.xHash = 0
	} else {
		x.xHash = purego.NewCallback(func(IconVarp uintptr) uint {
			return cb(&IconBase{Ptr: IconVarp})
		})
	}
}

// GetHash gets the "hash" callback function.
// A hash for a given #GIcon.
func (x *IconIface) GetHash() func(Icon) uint {
	if x.xHash == 0 {
		return nil
	}
	var rawCallback func(IconVarp uintptr) uint
	purego.RegisterFunc(&rawCallback, x.xHash)
	return func(IconVar Icon) uint {
		return rawCallback(IconVar.GoPointer())
	}
}

// OverrideEqual sets the "equal" callback function.
// Checks if two #GIcons are equal.
func (x *IconIface) OverrideEqual(cb func(Icon, Icon) bool) {
	if cb == nil {
		x.xEqual = 0
	} else {
		x.xEqual = purego.NewCallback(func(Icon1Varp uintptr, Icon2Varp uintptr) bool {
			return cb(&IconBase{Ptr: Icon1Varp}, &IconBase{Ptr: Icon2Varp})
		})
	}
}

// GetEqual gets the "equal" callback function.
// Checks if two #GIcons are equal.
func (x *IconIface) GetEqual() func(Icon, Icon) bool {
	if x.xEqual == 0 {
		return nil
	}
	var rawCallback func(Icon1Varp uintptr, Icon2Varp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEqual)
	return func(Icon1Var Icon, Icon2Var Icon) bool {
		return rawCallback(Icon1Var.GoPointer(), Icon2Var.GoPointer())
	}
}

// OverrideToTokens sets the "to_tokens" callback function.
// Serializes a #GIcon into tokens. The tokens must not
// contain any whitespace. Don't implement if the #GIcon can't be
// serialized (Since 2.20).
func (x *IconIface) OverrideToTokens(cb func(Icon, *[]string, *int) bool) {
	if cb == nil {
		x.xToTokens = 0
	} else {
		x.xToTokens = purego.NewCallback(func(IconVarp uintptr, TokensVarp *[]string, OutVersionVarp *int) bool {
			return cb(&IconBase{Ptr: IconVarp}, TokensVarp, OutVersionVarp)
		})
	}
}

// GetToTokens gets the "to_tokens" callback function.
// Serializes a #GIcon into tokens. The tokens must not
// contain any whitespace. Don't implement if the #GIcon can't be
// serialized (Since 2.20).
func (x *IconIface) GetToTokens() func(Icon, *[]string, *int) bool {
	if x.xToTokens == 0 {
		return nil
	}
	var rawCallback func(IconVarp uintptr, TokensVarp *[]string, OutVersionVarp *int) bool
	purego.RegisterFunc(&rawCallback, x.xToTokens)
	return func(IconVar Icon, TokensVar *[]string, OutVersionVar *int) bool {
		return rawCallback(IconVar.GoPointer(), TokensVar, OutVersionVar)
	}
}

// OverrideFromTokens sets the "from_tokens" callback function.
// Constructs a #GIcon from tokens. Set the #GError if
// the tokens are malformed. Don't implement if the #GIcon can't be
// serialized (Since 2.20).
func (x *IconIface) OverrideFromTokens(cb func(string, int, int) *IconBase) {
	if cb == nil {
		x.xFromTokens = 0
	} else {
		x.xFromTokens = purego.NewCallback(func(TokensVarp string, NumTokensVarp int, VersionVarp int) uintptr {
			ret := cb(TokensVarp, NumTokensVarp, VersionVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetFromTokens gets the "from_tokens" callback function.
// Constructs a #GIcon from tokens. Set the #GError if
// the tokens are malformed. Don't implement if the #GIcon can't be
// serialized (Since 2.20).
func (x *IconIface) GetFromTokens() func(string, int, int) *IconBase {
	if x.xFromTokens == 0 {
		return nil
	}
	var rawCallback func(TokensVarp string, NumTokensVarp int, VersionVarp int) uintptr
	purego.RegisterFunc(&rawCallback, x.xFromTokens)
	return func(TokensVar string, NumTokensVar int, VersionVar int) *IconBase {
		rawRet := rawCallback(TokensVar, NumTokensVar, VersionVar)
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideSerialize sets the "serialize" callback function.
// Serializes a #GIcon into a #GVariant. Since: 2.38
func (x *IconIface) OverrideSerialize(cb func(Icon) *glib.Variant) {
	if cb == nil {
		x.xSerialize = 0
	} else {
		x.xSerialize = purego.NewCallback(func(IconVarp uintptr) *glib.Variant {
			return cb(&IconBase{Ptr: IconVarp})
		})
	}
}

// GetSerialize gets the "serialize" callback function.
// Serializes a #GIcon into a #GVariant. Since: 2.38
func (x *IconIface) GetSerialize() func(Icon) *glib.Variant {
	if x.xSerialize == 0 {
		return nil
	}
	var rawCallback func(IconVarp uintptr) *glib.Variant
	purego.RegisterFunc(&rawCallback, x.xSerialize)
	return func(IconVar Icon) *glib.Variant {
		return rawCallback(IconVar.GoPointer())
	}
}

// `GIcon` is a very minimal interface for icons. It provides functions
// for checking the equality of two icons, hashing of icons and
// serializing an icon to and from strings.
//
// `GIcon` does not provide the actual pixmap for the icon as this is out
// of GIO's scope, however implementations of `GIcon` may contain the name
// of an icon (see [class@Gio.ThemedIcon]), or the path to an icon
// (see [iface@Gio.LoadableIcon]).
//
// To obtain a hash of a `GIcon`, see [method@Gio.Icon.hash].
//
// To check if two `GIcon`s are equal, see [method@Gio.Icon.equal].
//
// For serializing a `GIcon`, use [method@Gio.Icon.serialize] and
// [func@Gio.Icon.deserialize].
//
// If you want to consume `GIcon` (for example, in a toolkit) you must
// be prepared to handle at least the three following cases:
// [iface@Gio.LoadableIcon], [class@Gio.ThemedIcon] and [class@Gio.EmblemedIcon].
// It may also make sense to have fast-paths for other cases (like handling
// [`GdkPixbuf`](https://docs.gtk.org/gdk-pixbuf/class.Pixbuf.html) directly,
// for example) but all compliant `GIcon` implementations outside of GIO must
// implement [iface@Gio.LoadableIcon].
//
// If your application or library provides one or more `GIcon`
// implementations you need to ensure that your new implementation also
// implements [iface@Gio.LoadableIcon].  Additionally, you must provide an
// implementation of [method@Gio.Icon.serialize] that gives a result that is
// understood by [func@Gio.Icon.deserialize], yielding one of the built-in
// icon types.
type Icon interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	Equal(Icon2Var Icon) bool
	Hash() uint
	Serialize() *glib.Variant
	ToString() string
}

var xIconGLibType func() types.GType

func IconGLibType() types.GType {
	return xIconGLibType()
}

type IconBase struct {
	Ptr uintptr
}

func (x *IconBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *IconBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Checks if two icons are equal.
func (x *IconBase) Equal(Icon2Var Icon) bool {

	cret := XGIconEqual(x.GoPointer(), Icon2Var.GoPointer())
	return cret
}

// Gets a hash for an icon.
func (x *IconBase) Hash() uint {

	cret := XGIconHash(x.GoPointer())
	return cret
}

// Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
// back by calling g_icon_deserialize() on the returned value.
// As serialization will avoid using raw icon data when possible, it only
// makes sense to transfer the #GVariant between processes on the same machine,
// (as opposed to over the network), and within the same file system namespace.
func (x *IconBase) Serialize() *glib.Variant {

	cret := XGIconSerialize(x.GoPointer())
	return cret
}

// Generates a textual representation of @icon that can be used for
// serialization such as when passing @icon to a different process or
// saving it to persistent storage. Use g_icon_new_for_string() to
// get @icon back from the returned string.
//
// The encoding of the returned string is proprietary to #GIcon except
// in the following two cases
//
//   - If @icon is a #GFileIcon, the returned string is a native path
//     (such as `/path/to/my icon.png`) without escaping
//     if the #GFile for @icon is a native file.  If the file is not
//     native, the returned string is the result of g_file_get_uri()
//     (such as `sftp://path/to/my%20icon.png`).
//
//   - If @icon is a #GThemedIcon with exactly one name and no fallbacks,
//     the encoding is simply the name (such as `network-server`).
func (x *IconBase) ToString() string {

	cret := XGIconToString(x.GoPointer())
	return cret
}

var XGIconEqual func(uintptr, uintptr) bool
var XGIconHash func(uintptr) uint
var XGIconSerialize func(uintptr) *glib.Variant
var XGIconToString func(uintptr) string

var xIconDeserialize func(*glib.Variant) uintptr

// Deserializes a #GIcon previously serialized using g_icon_serialize().
func IconDeserialize(ValueVar *glib.Variant) *IconBase {
	var cls *IconBase

	cret := xIconDeserialize(ValueVar)

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

var xIconNewForString func(string, **glib.Error) uintptr

// Generate a #GIcon instance from @str. This function can fail if
// @str is not valid - see g_icon_to_string() for discussion.
//
// If your application or library provides one or more #GIcon
// implementations you need to ensure that each #GType is registered
// with the type system prior to calling g_icon_new_for_string().
func IconNewForString(StrVar string) (*IconBase, error) {
	var cls *IconBase
	var cerr *glib.Error

	cret := xIconNewForString(StrVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &IconBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xIconDeserialize, libs, "g_icon_deserialize")
	core.PuregoSafeRegister(&xIconNewForString, libs, "g_icon_new_for_string")

	core.PuregoSafeRegister(&xIconGLibType, libs, "g_icon_get_type")

	core.PuregoSafeRegister(&XGIconEqual, libs, "g_icon_equal")
	core.PuregoSafeRegister(&XGIconHash, libs, "g_icon_hash")
	core.PuregoSafeRegister(&XGIconSerialize, libs, "g_icon_serialize")
	core.PuregoSafeRegister(&XGIconToString, libs, "g_icon_to_string")

}
