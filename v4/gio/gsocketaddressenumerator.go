// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Class structure for #GSocketAddressEnumerator.
type SocketAddressEnumeratorClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xNext uintptr

	xNextAsync uintptr

	xNextFinish uintptr
}

func (x *SocketAddressEnumeratorClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideNext sets the "next" callback function.
// Virtual method for g_socket_address_enumerator_next().
func (x *SocketAddressEnumeratorClass) OverrideNext(cb func(*SocketAddressEnumerator, *Cancellable) *SocketAddress) {
	if cb == nil {
		x.xNext = 0
	} else {
		x.xNext = purego.NewCallback(func(EnumeratorVarp uintptr, CancellableVarp uintptr) uintptr {
			ret := cb(SocketAddressEnumeratorNewFromInternalPtr(EnumeratorVarp), CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetNext gets the "next" callback function.
// Virtual method for g_socket_address_enumerator_next().
func (x *SocketAddressEnumeratorClass) GetNext() func(*SocketAddressEnumerator, *Cancellable) *SocketAddress {
	if x.xNext == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xNext)
	return func(EnumeratorVar *SocketAddressEnumerator, CancellableVar *Cancellable) *SocketAddress {
		rawRet := rawCallback(EnumeratorVar.GoPointer(), CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &SocketAddress{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideNextAsync sets the "next_async" callback function.
// Virtual method for g_socket_address_enumerator_next_async().
func (x *SocketAddressEnumeratorClass) OverrideNextAsync(cb func(*SocketAddressEnumerator, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xNextAsync = 0
	} else {
		x.xNextAsync = purego.NewCallback(func(EnumeratorVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(SocketAddressEnumeratorNewFromInternalPtr(EnumeratorVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetNextAsync gets the "next_async" callback function.
// Virtual method for g_socket_address_enumerator_next_async().
func (x *SocketAddressEnumeratorClass) GetNextAsync() func(*SocketAddressEnumerator, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xNextAsync == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xNextAsync)
	return func(EnumeratorVar *SocketAddressEnumerator, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(EnumeratorVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideNextFinish sets the "next_finish" callback function.
// Virtual method for g_socket_address_enumerator_next_finish().
func (x *SocketAddressEnumeratorClass) OverrideNextFinish(cb func(*SocketAddressEnumerator, AsyncResult) *SocketAddress) {
	if cb == nil {
		x.xNextFinish = 0
	} else {
		x.xNextFinish = purego.NewCallback(func(EnumeratorVarp uintptr, ResultVarp uintptr) uintptr {
			ret := cb(SocketAddressEnumeratorNewFromInternalPtr(EnumeratorVarp), &AsyncResultBase{Ptr: ResultVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetNextFinish gets the "next_finish" callback function.
// Virtual method for g_socket_address_enumerator_next_finish().
func (x *SocketAddressEnumeratorClass) GetNextFinish() func(*SocketAddressEnumerator, AsyncResult) *SocketAddress {
	if x.xNextFinish == 0 {
		return nil
	}
	var rawCallback func(EnumeratorVarp uintptr, ResultVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xNextFinish)
	return func(EnumeratorVar *SocketAddressEnumerator, ResultVar AsyncResult) *SocketAddress {
		rawRet := rawCallback(EnumeratorVar.GoPointer(), ResultVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &SocketAddress{}
		ret.Ptr = rawRet
		return ret
	}
}

// `GSocketAddressEnumerator` is an enumerator type for
// [class@Gio.SocketAddress] instances. It is returned by enumeration functions
// such as [method@Gio.SocketConnectable.enumerate], which returns a
// `GSocketAddressEnumerator` to list each [class@Gio.SocketAddress] which could
// be used to connect to that [iface@Gio.SocketConnectable].
//
// Enumeration is typically a blocking operation, so the asynchronous methods
// [method@Gio.SocketAddressEnumerator.next_async] and
// [method@Gio.SocketAddressEnumerator.next_finish] should be used where
// possible.
//
// Each `GSocketAddressEnumerator` can only be enumerated once. Once
// [method@Gio.SocketAddressEnumerator.next] has returned `NULL`, further
// enumeration with that `GSocketAddressEnumerator` is not possible, and it can
// be unreffed.
type SocketAddressEnumerator struct {
	gobject.Object
}

var xSocketAddressEnumeratorGLibType func() types.GType

func SocketAddressEnumeratorGLibType() types.GType {
	return xSocketAddressEnumeratorGLibType()
}

func SocketAddressEnumeratorNewFromInternalPtr(ptr uintptr) *SocketAddressEnumerator {
	cls := &SocketAddressEnumerator{}
	cls.Ptr = ptr
	return cls
}

var xSocketAddressEnumeratorNext func(uintptr, uintptr, **glib.Error) uintptr

// Retrieves the next #GSocketAddress from @enumerator. Note that this
// may block for some amount of time. (Eg, a #GNetworkAddress may need
// to do a DNS lookup before it can return an address.) Use
// g_socket_address_enumerator_next_async() if you need to avoid
// blocking.
//
// If @enumerator is expected to yield addresses, but for some reason
// is unable to (eg, because of a DNS error), then the first call to
// g_socket_address_enumerator_next() will return an appropriate error
// in `*error`. However, if the first call to
// g_socket_address_enumerator_next() succeeds, then any further
// internal errors (other than @cancellable being triggered) will be
// ignored.
func (x *SocketAddressEnumerator) Next(CancellableVar *Cancellable) (*SocketAddress, error) {
	var cls *SocketAddress
	var cerr *glib.Error

	cret := xSocketAddressEnumeratorNext(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &SocketAddress{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSocketAddressEnumeratorNextAsync func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously retrieves the next #GSocketAddress from @enumerator
// and then calls @callback, which must call
// g_socket_address_enumerator_next_finish() to get the result.
//
// It is an error to call this multiple times before the previous callback has finished.
func (x *SocketAddressEnumerator) NextAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xSocketAddressEnumeratorNextAsync(x.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xSocketAddressEnumeratorNextFinish func(uintptr, uintptr, **glib.Error) uintptr

// Retrieves the result of a completed call to
// g_socket_address_enumerator_next_async(). See
// g_socket_address_enumerator_next() for more information about
// error handling.
func (x *SocketAddressEnumerator) NextFinish(ResultVar AsyncResult) (*SocketAddress, error) {
	var cls *SocketAddress
	var cerr *glib.Error

	cret := xSocketAddressEnumeratorNextFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &SocketAddress{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func (c *SocketAddressEnumerator) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *SocketAddressEnumerator) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSocketAddressEnumeratorGLibType, libs, "g_socket_address_enumerator_get_type")

	core.PuregoSafeRegister(&xSocketAddressEnumeratorNext, libs, "g_socket_address_enumerator_next")
	core.PuregoSafeRegister(&xSocketAddressEnumeratorNextAsync, libs, "g_socket_address_enumerator_next_async")
	core.PuregoSafeRegister(&xSocketAddressEnumeratorNextFinish, libs, "g_socket_address_enumerator_next_finish")

}
