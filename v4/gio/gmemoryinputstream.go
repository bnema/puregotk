// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type MemoryInputStreamClass struct {
	_ structs.HostLayout

	ParentClass InputStreamClass

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr
}

func (x *MemoryInputStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGReserved1 sets the "_g_reserved1" callback function.
func (x *MemoryInputStreamClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the "_g_reserved1" callback function.
func (x *MemoryInputStreamClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the "_g_reserved2" callback function.
func (x *MemoryInputStreamClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the "_g_reserved2" callback function.
func (x *MemoryInputStreamClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the "_g_reserved3" callback function.
func (x *MemoryInputStreamClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the "_g_reserved3" callback function.
func (x *MemoryInputStreamClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the "_g_reserved4" callback function.
func (x *MemoryInputStreamClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the "_g_reserved4" callback function.
func (x *MemoryInputStreamClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the "_g_reserved5" callback function.
func (x *MemoryInputStreamClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the "_g_reserved5" callback function.
func (x *MemoryInputStreamClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

type MemoryInputStreamPrivate struct {
	_ structs.HostLayout
}

func (x *MemoryInputStreamPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GMemoryInputStream` is a class for using arbitrary
// memory chunks as input for GIO streaming input operations.
//
// As of GLib 2.34, `GMemoryInputStream` implements
// [iface@Gio.PollableInputStream].
type MemoryInputStream struct {
	InputStream
}

var xMemoryInputStreamGLibType func() types.GType

func MemoryInputStreamGLibType() types.GType {
	return xMemoryInputStreamGLibType()
}

func MemoryInputStreamNewFromInternalPtr(ptr uintptr) *MemoryInputStream {
	cls := &MemoryInputStream{}
	cls.Ptr = ptr
	return cls
}

var xNewMemoryInputStream func() uintptr

// Creates a new empty #GMemoryInputStream.
func NewMemoryInputStream() *MemoryInputStream {
	var cls *MemoryInputStream

	cret := xNewMemoryInputStream()

	if cret == 0 {
		return nil
	}
	cls = &MemoryInputStream{}
	cls.Ptr = cret
	return cls
}

var xNewMemoryInputStreamFromBytes func(*glib.Bytes) uintptr

// Creates a new #GMemoryInputStream with data from the given @bytes.
func NewMemoryInputStreamFromBytes(BytesVar *glib.Bytes) *MemoryInputStream {
	var cls *MemoryInputStream

	cret := xNewMemoryInputStreamFromBytes(BytesVar)

	if cret == 0 {
		return nil
	}
	cls = &MemoryInputStream{}
	cls.Ptr = cret
	return cls
}

var xNewMemoryInputStreamFromData func([]byte, int, uintptr) uintptr

// Creates a new #GMemoryInputStream with data in memory of a given size.
func NewMemoryInputStreamFromData(DataVar []byte, LenVar int, DestroyVar *glib.DestroyNotify) *MemoryInputStream {
	var cls *MemoryInputStream

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	cret := xNewMemoryInputStreamFromData(DataVar, LenVar, DestroyVarRef)

	if cret == 0 {
		return nil
	}
	cls = &MemoryInputStream{}
	cls.Ptr = cret
	return cls
}

var xMemoryInputStreamAddBytes func(uintptr, *glib.Bytes)

// Appends @bytes to data that can be read from the input stream.
func (x *MemoryInputStream) AddBytes(BytesVar *glib.Bytes) {

	xMemoryInputStreamAddBytes(x.GoPointer(), BytesVar)

}

var xMemoryInputStreamAddData func(uintptr, []byte, int, uintptr)

// Appends @data to data that can be read from the input stream
func (x *MemoryInputStream) AddData(DataVar []byte, LenVar int, DestroyVar *glib.DestroyNotify) {

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	xMemoryInputStreamAddData(x.GoPointer(), DataVar, LenVar, DestroyVarRef)

}

func (c *MemoryInputStream) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *MemoryInputStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Checks if @stream is actually pollable. Some classes may implement
// #GPollableInputStream but have only certain instances of that class
// be pollable. If this method returns %FALSE, then the behavior of
// other #GPollableInputStream methods is undefined.
//
// For any given stream, the value returned by this method is constant;
// a stream cannot switch from pollable to non-pollable or vice versa.
func (x *MemoryInputStream) CanPoll() bool {

	cret := XGPollableInputStreamCanPoll(x.GoPointer())

	return cret
}

// Creates a #GSource that triggers when @stream can be read, or
// @cancellable is triggered or an error occurs. The callback on the
// source is of the #GPollableSourceFunc type.
//
// As with g_pollable_input_stream_is_readable(), it is possible that
// the stream may not actually be readable even after the source
// triggers, so you should use g_pollable_input_stream_read_nonblocking()
// rather than g_input_stream_read() from the callback.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *MemoryInputStream) CreateSource(CancellableVar *Cancellable) *glib.Source {

	cret := XGPollableInputStreamCreateSource(x.GoPointer(), CancellableVar.GoPointer())

	return cret
}

// Checks if @stream can be read.
//
// Note that some stream types may not be able to implement this 100%
// reliably, and it is possible that a call to g_input_stream_read()
// after this returns %TRUE would still block. To guarantee
// non-blocking behavior, you should always use
// g_pollable_input_stream_read_nonblocking(), which will return a
// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *MemoryInputStream) IsReadable() bool {

	cret := XGPollableInputStreamIsReadable(x.GoPointer())

	return cret
}

// Attempts to read up to @count bytes from @stream into @buffer, as
// with g_input_stream_read(). If @stream is not currently readable,
// this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
// use g_pollable_input_stream_create_source() to create a #GSource
// that will be triggered when @stream is readable.
//
// Note that since this method never blocks, you cannot actually
// use @cancellable to cancel it. However, it will return an error
// if @cancellable has already been cancelled when you call, which
// may happen if you call this method after a source triggers due
// to having been cancelled.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *MemoryInputStream) ReadNonblocking(BufferVar *[]byte, CountVar uint, CancellableVar *Cancellable) (int, error) {
	var cerr *glib.Error

	cret := XGPollableInputStreamReadNonblocking(x.GoPointer(), BufferVar, CountVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tests if the stream supports the #GSeekableIface.
func (x *MemoryInputStream) CanSeek() bool {

	cret := XGSeekableCanSeek(x.GoPointer())

	return cret
}

// Tests if the length of the stream can be adjusted with
// g_seekable_truncate().
func (x *MemoryInputStream) CanTruncate() bool {

	cret := XGSeekableCanTruncate(x.GoPointer())

	return cret
}

// Seeks in the stream by the given @offset, modified by @type.
//
// Attempting to seek past the end of the stream will have different
// results depending on if the stream is fixed-sized or resizable.  If
// the stream is resizable then seeking past the end and then writing
// will result in zeros filling the empty space.  Seeking past the end
// of a resizable stream and reading will result in EOF.  Seeking past
// the end of a fixed-sized stream will fail.
//
// Any operation that would result in a negative offset will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *MemoryInputStream) Seek(OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableSeek(x.GoPointer(), OffsetVar, TypeVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tells the current position within the stream.
func (x *MemoryInputStream) Tell() int64 {

	cret := XGSeekableTell(x.GoPointer())

	return cret
}

// Sets the length of the stream to @offset. If the stream was previously
// larger than @offset, the extra data is discarded. If the stream was
// previously shorter than @offset, it is extended with NUL ('\0') bytes.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (x *MemoryInputStream) Truncate(OffsetVar int64, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableTruncate(x.GoPointer(), OffsetVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMemoryInputStreamGLibType, libs, "g_memory_input_stream_get_type")

	core.PuregoSafeRegister(&xNewMemoryInputStream, libs, "g_memory_input_stream_new")
	core.PuregoSafeRegister(&xNewMemoryInputStreamFromBytes, libs, "g_memory_input_stream_new_from_bytes")
	core.PuregoSafeRegister(&xNewMemoryInputStreamFromData, libs, "g_memory_input_stream_new_from_data")

	core.PuregoSafeRegister(&xMemoryInputStreamAddBytes, libs, "g_memory_input_stream_add_bytes")
	core.PuregoSafeRegister(&xMemoryInputStreamAddData, libs, "g_memory_input_stream_add_data")

}
