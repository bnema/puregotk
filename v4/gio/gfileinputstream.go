// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type FileInputStreamClass struct {
	_ structs.HostLayout

	ParentClass InputStreamClass

	xTell uintptr

	xCanSeek uintptr

	xSeek uintptr

	xQueryInfo uintptr

	xQueryInfoAsync uintptr

	xQueryInfoFinish uintptr

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr
}

func (x *FileInputStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideTell sets the "tell" callback function.
func (x *FileInputStreamClass) OverrideTell(cb func(*FileInputStream) int64) {
	if cb == nil {
		x.xTell = 0
	} else {
		x.xTell = purego.NewCallback(func(StreamVarp uintptr) int64 {
			return cb(FileInputStreamNewFromInternalPtr(StreamVarp))
		})
	}
}

// GetTell gets the "tell" callback function.
func (x *FileInputStreamClass) GetTell() func(*FileInputStream) int64 {
	if x.xTell == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr) int64
	purego.RegisterFunc(&rawCallback, x.xTell)
	return func(StreamVar *FileInputStream) int64 {
		return rawCallback(StreamVar.GoPointer())
	}
}

// OverrideCanSeek sets the "can_seek" callback function.
func (x *FileInputStreamClass) OverrideCanSeek(cb func(*FileInputStream) bool) {
	if cb == nil {
		x.xCanSeek = 0
	} else {
		x.xCanSeek = purego.NewCallback(func(StreamVarp uintptr) bool {
			return cb(FileInputStreamNewFromInternalPtr(StreamVarp))
		})
	}
}

// GetCanSeek gets the "can_seek" callback function.
func (x *FileInputStreamClass) GetCanSeek() func(*FileInputStream) bool {
	if x.xCanSeek == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanSeek)
	return func(StreamVar *FileInputStream) bool {
		return rawCallback(StreamVar.GoPointer())
	}
}

// OverrideSeek sets the "seek" callback function.
func (x *FileInputStreamClass) OverrideSeek(cb func(*FileInputStream, int64, glib.SeekType, *Cancellable) bool) {
	if cb == nil {
		x.xSeek = 0
	} else {
		x.xSeek = purego.NewCallback(func(StreamVarp uintptr, OffsetVarp int64, TypeVarp glib.SeekType, CancellableVarp uintptr) bool {
			return cb(FileInputStreamNewFromInternalPtr(StreamVarp), OffsetVarp, TypeVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetSeek gets the "seek" callback function.
func (x *FileInputStreamClass) GetSeek() func(*FileInputStream, int64, glib.SeekType, *Cancellable) bool {
	if x.xSeek == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, OffsetVarp int64, TypeVarp glib.SeekType, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSeek)
	return func(StreamVar *FileInputStream, OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) bool {
		return rawCallback(StreamVar.GoPointer(), OffsetVar, TypeVar, CancellableVar.GoPointer())
	}
}

// OverrideQueryInfo sets the "query_info" callback function.
func (x *FileInputStreamClass) OverrideQueryInfo(cb func(*FileInputStream, string, *Cancellable) *FileInfo) {
	if cb == nil {
		x.xQueryInfo = 0
	} else {
		x.xQueryInfo = purego.NewCallback(func(StreamVarp uintptr, AttributesVarp string, CancellableVarp uintptr) uintptr {
			ret := cb(FileInputStreamNewFromInternalPtr(StreamVarp), AttributesVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetQueryInfo gets the "query_info" callback function.
func (x *FileInputStreamClass) GetQueryInfo() func(*FileInputStream, string, *Cancellable) *FileInfo {
	if x.xQueryInfo == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, AttributesVarp string, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xQueryInfo)
	return func(StreamVar *FileInputStream, AttributesVar string, CancellableVar *Cancellable) *FileInfo {
		rawRet := rawCallback(StreamVar.GoPointer(), AttributesVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInfo{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideQueryInfoAsync sets the "query_info_async" callback function.
func (x *FileInputStreamClass) OverrideQueryInfoAsync(cb func(*FileInputStream, string, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xQueryInfoAsync = 0
	} else {
		x.xQueryInfoAsync = purego.NewCallback(func(StreamVarp uintptr, AttributesVarp string, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(FileInputStreamNewFromInternalPtr(StreamVarp), AttributesVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetQueryInfoAsync gets the "query_info_async" callback function.
func (x *FileInputStreamClass) GetQueryInfoAsync() func(*FileInputStream, string, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xQueryInfoAsync == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, AttributesVarp string, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xQueryInfoAsync)
	return func(StreamVar *FileInputStream, AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(StreamVar.GoPointer(), AttributesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideQueryInfoFinish sets the "query_info_finish" callback function.
func (x *FileInputStreamClass) OverrideQueryInfoFinish(cb func(*FileInputStream, AsyncResult) *FileInfo) {
	if cb == nil {
		x.xQueryInfoFinish = 0
	} else {
		x.xQueryInfoFinish = purego.NewCallback(func(StreamVarp uintptr, ResultVarp uintptr) uintptr {
			ret := cb(FileInputStreamNewFromInternalPtr(StreamVarp), &AsyncResultBase{Ptr: ResultVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetQueryInfoFinish gets the "query_info_finish" callback function.
func (x *FileInputStreamClass) GetQueryInfoFinish() func(*FileInputStream, AsyncResult) *FileInfo {
	if x.xQueryInfoFinish == 0 {
		return nil
	}
	var rawCallback func(StreamVarp uintptr, ResultVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xQueryInfoFinish)
	return func(StreamVar *FileInputStream, ResultVar AsyncResult) *FileInfo {
		rawRet := rawCallback(StreamVar.GoPointer(), ResultVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInfo{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGReserved1 sets the "_g_reserved1" callback function.
func (x *FileInputStreamClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the "_g_reserved1" callback function.
func (x *FileInputStreamClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the "_g_reserved2" callback function.
func (x *FileInputStreamClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the "_g_reserved2" callback function.
func (x *FileInputStreamClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the "_g_reserved3" callback function.
func (x *FileInputStreamClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the "_g_reserved3" callback function.
func (x *FileInputStreamClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the "_g_reserved4" callback function.
func (x *FileInputStreamClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the "_g_reserved4" callback function.
func (x *FileInputStreamClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the "_g_reserved5" callback function.
func (x *FileInputStreamClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the "_g_reserved5" callback function.
func (x *FileInputStreamClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

type FileInputStreamPrivate struct {
	_ structs.HostLayout
}

func (x *FileInputStreamPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GFileInputStream` provides input streams that take their
// content from a file.
//
// `GFileInputStream` implements [iface@Gio.Seekable], which allows the input
// stream to jump to arbitrary positions in the file, provided the
// filesystem of the file allows it. To find the position of a file
// input stream, use [method@Gio.Seekable.tell]. To find out if a file input
// stream supports seeking, use [vfunc@Gio.Seekable.can_seek].
// To position a file input stream, use [vfunc@Gio.Seekable.seek].
type FileInputStream struct {
	InputStream
}

var xFileInputStreamGLibType func() types.GType

func FileInputStreamGLibType() types.GType {
	return xFileInputStreamGLibType()
}

func FileInputStreamNewFromInternalPtr(ptr uintptr) *FileInputStream {
	cls := &FileInputStream{}
	cls.Ptr = ptr
	return cls
}

var xFileInputStreamQueryInfo func(uintptr, string, uintptr, **glib.Error) uintptr

// Queries a file input stream the given @attributes. This function blocks
// while querying the stream. For the asynchronous (non-blocking) version
// of this function, see g_file_input_stream_query_info_async(). While the
// stream is blocked, the stream will set the pending flag internally, and
// any other operations on the stream will fail with %G_IO_ERROR_PENDING.
func (x *FileInputStream) QueryInfo(AttributesVar string, CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := xFileInputStreamQueryInfo(x.GoPointer(), AttributesVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileInputStreamQueryInfoAsync func(uintptr, string, int, uintptr, uintptr, uintptr)

// Queries the stream information asynchronously.
// When the operation is finished @callback will be called.
// You can then call g_file_input_stream_query_info_finish()
// to get the result of the operation.
//
// For the synchronous version of this function,
// see g_file_input_stream_query_info().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set
func (x *FileInputStream) QueryInfoAsync(AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xFileInputStreamQueryInfoAsync(x.GoPointer(), AttributesVar, IoPriorityVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xFileInputStreamQueryInfoFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes an asynchronous info query operation.
func (x *FileInputStream) QueryInfoFinish(ResultVar AsyncResult) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := xFileInputStreamQueryInfoFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func (c *FileInputStream) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *FileInputStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Tests if the stream supports the #GSeekableIface.
func (x *FileInputStream) CanSeek() bool {

	cret := XGSeekableCanSeek(x.GoPointer())

	return cret
}

// Tests if the length of the stream can be adjusted with
// g_seekable_truncate().
func (x *FileInputStream) CanTruncate() bool {

	cret := XGSeekableCanTruncate(x.GoPointer())

	return cret
}

// Seeks in the stream by the given @offset, modified by @type.
//
// Attempting to seek past the end of the stream will have different
// results depending on if the stream is fixed-sized or resizable.  If
// the stream is resizable then seeking past the end and then writing
// will result in zeros filling the empty space.  Seeking past the end
// of a resizable stream and reading will result in EOF.  Seeking past
// the end of a fixed-sized stream will fail.
//
// Any operation that would result in a negative offset will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileInputStream) Seek(OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableSeek(x.GoPointer(), OffsetVar, TypeVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tells the current position within the stream.
func (x *FileInputStream) Tell() int64 {

	cret := XGSeekableTell(x.GoPointer())

	return cret
}

// Sets the length of the stream to @offset. If the stream was previously
// larger than @offset, the extra data is discarded. If the stream was
// previously shorter than @offset, it is extended with NUL ('\0') bytes.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (x *FileInputStream) Truncate(OffsetVar int64, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableTruncate(x.GoPointer(), OffsetVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xFileInputStreamGLibType, libs, "g_file_input_stream_get_type")

	core.PuregoSafeRegister(&xFileInputStreamQueryInfo, libs, "g_file_input_stream_query_info")
	core.PuregoSafeRegister(&xFileInputStreamQueryInfoAsync, libs, "g_file_input_stream_query_info_async")
	core.PuregoSafeRegister(&xFileInputStreamQueryInfoFinish, libs, "g_file_input_stream_query_info_finish")

}
