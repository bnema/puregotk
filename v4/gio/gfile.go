// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// An interface for writing VFS file handles.
type FileIface struct {
	_ structs.HostLayout

	GIface uintptr

	xDup uintptr

	xHash uintptr

	xEqual uintptr

	xIsNative uintptr

	xHasUriScheme uintptr

	xGetUriScheme uintptr

	xGetBasename uintptr

	xGetPath uintptr

	xGetUri uintptr

	xGetParseName uintptr

	xGetParent uintptr

	xPrefixMatches uintptr

	xGetRelativePath uintptr

	xResolveRelativePath uintptr

	xGetChildForDisplayName uintptr

	xEnumerateChildren uintptr

	xEnumerateChildrenAsync uintptr

	xEnumerateChildrenFinish uintptr

	xQueryInfo uintptr

	xQueryInfoAsync uintptr

	xQueryInfoFinish uintptr

	xQueryFilesystemInfo uintptr

	xQueryFilesystemInfoAsync uintptr

	xQueryFilesystemInfoFinish uintptr

	xFindEnclosingMount uintptr

	xFindEnclosingMountAsync uintptr

	xFindEnclosingMountFinish uintptr

	xSetDisplayName uintptr

	xSetDisplayNameAsync uintptr

	xSetDisplayNameFinish uintptr

	xQuerySettableAttributes uintptr

	xQuerySettableAttributesAsync uintptr

	xQuerySettableAttributesFinish uintptr

	xQueryWritableNamespaces uintptr

	xQueryWritableNamespacesAsync uintptr

	xQueryWritableNamespacesFinish uintptr

	xSetAttribute uintptr

	xSetAttributesFromInfo uintptr

	xSetAttributesAsync uintptr

	xSetAttributesFinish uintptr

	xReadFn uintptr

	xReadAsync uintptr

	xReadFinish uintptr

	xAppendTo uintptr

	xAppendToAsync uintptr

	xAppendToFinish uintptr

	xCreate uintptr

	xCreateAsync uintptr

	xCreateFinish uintptr

	xReplace uintptr

	xReplaceAsync uintptr

	xReplaceFinish uintptr

	xDeleteFile uintptr

	xDeleteFileAsync uintptr

	xDeleteFileFinish uintptr

	xTrash uintptr

	xTrashAsync uintptr

	xTrashFinish uintptr

	xMakeDirectory uintptr

	xMakeDirectoryAsync uintptr

	xMakeDirectoryFinish uintptr

	xMakeSymbolicLink uintptr

	xMakeSymbolicLinkAsync uintptr

	xMakeSymbolicLinkFinish uintptr

	xCopy uintptr

	xCopyAsync uintptr

	xCopyFinish uintptr

	xMove uintptr

	xMoveAsync uintptr

	xMoveFinish uintptr

	xMountMountable uintptr

	xMountMountableFinish uintptr

	xUnmountMountable uintptr

	xUnmountMountableFinish uintptr

	xEjectMountable uintptr

	xEjectMountableFinish uintptr

	xMountEnclosingVolume uintptr

	xMountEnclosingVolumeFinish uintptr

	xMonitorDir uintptr

	xMonitorFile uintptr

	xOpenReadwrite uintptr

	xOpenReadwriteAsync uintptr

	xOpenReadwriteFinish uintptr

	xCreateReadwrite uintptr

	xCreateReadwriteAsync uintptr

	xCreateReadwriteFinish uintptr

	xReplaceReadwrite uintptr

	xReplaceReadwriteAsync uintptr

	xReplaceReadwriteFinish uintptr

	xStartMountable uintptr

	xStartMountableFinish uintptr

	xStopMountable uintptr

	xStopMountableFinish uintptr

	SupportsThreadContexts bool

	xUnmountMountableWithOperation uintptr

	xUnmountMountableWithOperationFinish uintptr

	xEjectMountableWithOperation uintptr

	xEjectMountableWithOperationFinish uintptr

	xPollMountable uintptr

	xPollMountableFinish uintptr

	xMeasureDiskUsage uintptr

	xMeasureDiskUsageAsync uintptr

	xMeasureDiskUsageFinish uintptr

	xQueryExists uintptr
}

func (x *FileIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideDup sets the callback function.
// Duplicates a #GFile.
func (x *FileIface) OverrideDup(cb func(File) *FileBase) {
	if cb == nil {
		x.xDup = 0
	} else {
		x.xDup = purego.NewCallback(func(FileVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetDup gets the callback function.
// Duplicates a #GFile.
func (x *FileIface) GetDup() func(File) *FileBase {
	if x.xDup == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xDup)
	return func(FileVar File) *FileBase {
		rawRet := rawCallback(FileVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideHash sets the callback function.
// Creates a hash of a #GFile.
func (x *FileIface) OverrideHash(cb func(File) uint) {
	if cb == nil {
		x.xHash = 0
	} else {
		x.xHash = purego.NewCallback(func(FileVarp uintptr) uint {
			return cb(&FileBase{Ptr: FileVarp})
		})
	}
}

// GetHash gets the callback function.
// Creates a hash of a #GFile.
func (x *FileIface) GetHash() func(File) uint {
	if x.xHash == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) uint
	purego.RegisterFunc(&rawCallback, x.xHash)
	return func(FileVar File) uint {
		return rawCallback(FileVar.GoPointer())
	}
}

// OverrideEqual sets the callback function.
// Checks equality of two given #GFiles.
func (x *FileIface) OverrideEqual(cb func(File, File) bool) {
	if cb == nil {
		x.xEqual = 0
	} else {
		x.xEqual = purego.NewCallback(func(File1Varp uintptr, File2Varp uintptr) bool {
			return cb(&FileBase{Ptr: File1Varp}, &FileBase{Ptr: File2Varp})
		})
	}
}

// GetEqual gets the callback function.
// Checks equality of two given #GFiles.
func (x *FileIface) GetEqual() func(File, File) bool {
	if x.xEqual == 0 {
		return nil
	}
	var rawCallback func(File1Varp uintptr, File2Varp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEqual)
	return func(File1Var File, File2Var File) bool {
		return rawCallback(File1Var.GoPointer(), File2Var.GoPointer())
	}
}

// OverrideIsNative sets the callback function.
// Checks to see if a file is native to the system.
func (x *FileIface) OverrideIsNative(cb func(File) bool) {
	if cb == nil {
		x.xIsNative = 0
	} else {
		x.xIsNative = purego.NewCallback(func(FileVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp})
		})
	}
}

// GetIsNative gets the callback function.
// Checks to see if a file is native to the system.
func (x *FileIface) GetIsNative() func(File) bool {
	if x.xIsNative == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsNative)
	return func(FileVar File) bool {
		return rawCallback(FileVar.GoPointer())
	}
}

// OverrideHasUriScheme sets the callback function.
// Checks to see if a #GFile has a given URI scheme.
func (x *FileIface) OverrideHasUriScheme(cb func(File, string) bool) {
	if cb == nil {
		x.xHasUriScheme = 0
	} else {
		x.xHasUriScheme = purego.NewCallback(func(FileVarp uintptr, UriSchemeVarp string) bool {
			return cb(&FileBase{Ptr: FileVarp}, UriSchemeVarp)
		})
	}
}

// GetHasUriScheme gets the callback function.
// Checks to see if a #GFile has a given URI scheme.
func (x *FileIface) GetHasUriScheme() func(File, string) bool {
	if x.xHasUriScheme == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, UriSchemeVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xHasUriScheme)
	return func(FileVar File, UriSchemeVar string) bool {
		return rawCallback(FileVar.GoPointer(), UriSchemeVar)
	}
}

// OverrideGetUriScheme sets the callback function.
// Gets the URI scheme for a #GFile.
func (x *FileIface) OverrideGetUriScheme(cb func(File) string) {
	if cb == nil {
		x.xGetUriScheme = 0
	} else {
		x.xGetUriScheme = purego.NewCallback(func(FileVarp uintptr) string {
			return cb(&FileBase{Ptr: FileVarp})
		})
	}
}

// GetGetUriScheme gets the callback function.
// Gets the URI scheme for a #GFile.
func (x *FileIface) GetGetUriScheme() func(File) string {
	if x.xGetUriScheme == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetUriScheme)
	return func(FileVar File) string {
		return rawCallback(FileVar.GoPointer())
	}
}

// OverrideGetBasename sets the callback function.
// Gets the basename for a given #GFile.
func (x *FileIface) OverrideGetBasename(cb func(File) string) {
	if cb == nil {
		x.xGetBasename = 0
	} else {
		x.xGetBasename = purego.NewCallback(func(FileVarp uintptr) string {
			return cb(&FileBase{Ptr: FileVarp})
		})
	}
}

// GetGetBasename gets the callback function.
// Gets the basename for a given #GFile.
func (x *FileIface) GetGetBasename() func(File) string {
	if x.xGetBasename == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetBasename)
	return func(FileVar File) string {
		return rawCallback(FileVar.GoPointer())
	}
}

// OverrideGetPath sets the callback function.
// Gets the current path within a #GFile.
func (x *FileIface) OverrideGetPath(cb func(File) string) {
	if cb == nil {
		x.xGetPath = 0
	} else {
		x.xGetPath = purego.NewCallback(func(FileVarp uintptr) string {
			return cb(&FileBase{Ptr: FileVarp})
		})
	}
}

// GetGetPath gets the callback function.
// Gets the current path within a #GFile.
func (x *FileIface) GetGetPath() func(File) string {
	if x.xGetPath == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetPath)
	return func(FileVar File) string {
		return rawCallback(FileVar.GoPointer())
	}
}

// OverrideGetUri sets the callback function.
// Gets a URI for the path within a #GFile.
func (x *FileIface) OverrideGetUri(cb func(File) string) {
	if cb == nil {
		x.xGetUri = 0
	} else {
		x.xGetUri = purego.NewCallback(func(FileVarp uintptr) string {
			return cb(&FileBase{Ptr: FileVarp})
		})
	}
}

// GetGetUri gets the callback function.
// Gets a URI for the path within a #GFile.
func (x *FileIface) GetGetUri() func(File) string {
	if x.xGetUri == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetUri)
	return func(FileVar File) string {
		return rawCallback(FileVar.GoPointer())
	}
}

// OverrideGetParseName sets the callback function.
// Gets the parsed name for the #GFile.
func (x *FileIface) OverrideGetParseName(cb func(File) string) {
	if cb == nil {
		x.xGetParseName = 0
	} else {
		x.xGetParseName = purego.NewCallback(func(FileVarp uintptr) string {
			return cb(&FileBase{Ptr: FileVarp})
		})
	}
}

// GetGetParseName gets the callback function.
// Gets the parsed name for the #GFile.
func (x *FileIface) GetGetParseName() func(File) string {
	if x.xGetParseName == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetParseName)
	return func(FileVar File) string {
		return rawCallback(FileVar.GoPointer())
	}
}

// OverrideGetParent sets the callback function.
// Gets the parent directory for the #GFile.
func (x *FileIface) OverrideGetParent(cb func(File) *FileBase) {
	if cb == nil {
		x.xGetParent = 0
	} else {
		x.xGetParent = purego.NewCallback(func(FileVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetParent gets the callback function.
// Gets the parent directory for the #GFile.
func (x *FileIface) GetGetParent() func(File) *FileBase {
	if x.xGetParent == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetParent)
	return func(FileVar File) *FileBase {
		rawRet := rawCallback(FileVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverridePrefixMatches sets the callback function.
// Checks whether a #GFile contains a specified file.
func (x *FileIface) OverridePrefixMatches(cb func(File, File) bool) {
	if cb == nil {
		x.xPrefixMatches = 0
	} else {
		x.xPrefixMatches = purego.NewCallback(func(PrefixVarp uintptr, FileVarp uintptr) bool {
			return cb(&FileBase{Ptr: PrefixVarp}, &FileBase{Ptr: FileVarp})
		})
	}
}

// GetPrefixMatches gets the callback function.
// Checks whether a #GFile contains a specified file.
func (x *FileIface) GetPrefixMatches() func(File, File) bool {
	if x.xPrefixMatches == 0 {
		return nil
	}
	var rawCallback func(PrefixVarp uintptr, FileVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xPrefixMatches)
	return func(PrefixVar File, FileVar File) bool {
		return rawCallback(PrefixVar.GoPointer(), FileVar.GoPointer())
	}
}

// OverrideGetRelativePath sets the callback function.
// Gets the path for a #GFile relative to a given path.
func (x *FileIface) OverrideGetRelativePath(cb func(File, File) string) {
	if cb == nil {
		x.xGetRelativePath = 0
	} else {
		x.xGetRelativePath = purego.NewCallback(func(ParentVarp uintptr, DescendantVarp uintptr) string {
			return cb(&FileBase{Ptr: ParentVarp}, &FileBase{Ptr: DescendantVarp})
		})
	}
}

// GetGetRelativePath gets the callback function.
// Gets the path for a #GFile relative to a given path.
func (x *FileIface) GetGetRelativePath() func(File, File) string {
	if x.xGetRelativePath == 0 {
		return nil
	}
	var rawCallback func(ParentVarp uintptr, DescendantVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetRelativePath)
	return func(ParentVar File, DescendantVar File) string {
		return rawCallback(ParentVar.GoPointer(), DescendantVar.GoPointer())
	}
}

// OverrideResolveRelativePath sets the callback function.
// Resolves a relative path for a #GFile to an absolute path.
func (x *FileIface) OverrideResolveRelativePath(cb func(File, string) *FileBase) {
	if cb == nil {
		x.xResolveRelativePath = 0
	} else {
		x.xResolveRelativePath = purego.NewCallback(func(FileVarp uintptr, RelativePathVarp string) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, RelativePathVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetResolveRelativePath gets the callback function.
// Resolves a relative path for a #GFile to an absolute path.
func (x *FileIface) GetResolveRelativePath() func(File, string) *FileBase {
	if x.xResolveRelativePath == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, RelativePathVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xResolveRelativePath)
	return func(FileVar File, RelativePathVar string) *FileBase {
		rawRet := rawCallback(FileVar.GoPointer(), RelativePathVar)
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetChildForDisplayName sets the callback function.
// Gets the child #GFile for a given display name.
func (x *FileIface) OverrideGetChildForDisplayName(cb func(File, string) *FileBase) {
	if cb == nil {
		x.xGetChildForDisplayName = 0
	} else {
		x.xGetChildForDisplayName = purego.NewCallback(func(FileVarp uintptr, DisplayNameVarp string) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, DisplayNameVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetChildForDisplayName gets the callback function.
// Gets the child #GFile for a given display name.
func (x *FileIface) GetGetChildForDisplayName() func(File, string) *FileBase {
	if x.xGetChildForDisplayName == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, DisplayNameVarp string) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetChildForDisplayName)
	return func(FileVar File, DisplayNameVar string) *FileBase {
		rawRet := rawCallback(FileVar.GoPointer(), DisplayNameVar)
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideEnumerateChildren sets the callback function.
// Gets a #GFileEnumerator with the children of a #GFile.
func (x *FileIface) OverrideEnumerateChildren(cb func(File, string, FileQueryInfoFlags, *Cancellable) *FileEnumerator) {
	if cb == nil {
		x.xEnumerateChildren = 0
	} else {
		x.xEnumerateChildren = purego.NewCallback(func(FileVarp uintptr, AttributesVarp string, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, AttributesVarp, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetEnumerateChildren gets the callback function.
// Gets a #GFileEnumerator with the children of a #GFile.
func (x *FileIface) GetEnumerateChildren() func(File, string, FileQueryInfoFlags, *Cancellable) *FileEnumerator {
	if x.xEnumerateChildren == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, AttributesVarp string, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xEnumerateChildren)
	return func(FileVar File, AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) *FileEnumerator {
		rawRet := rawCallback(FileVar.GoPointer(), AttributesVar, FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileEnumerator{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideEnumerateChildrenAsync sets the callback function.
// Asynchronously gets a #GFileEnumerator with the children of a #GFile.
func (x *FileIface) OverrideEnumerateChildrenAsync(cb func(File, string, FileQueryInfoFlags, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEnumerateChildrenAsync = 0
	} else {
		x.xEnumerateChildrenAsync = purego.NewCallback(func(FileVarp uintptr, AttributesVarp string, FlagsVarp FileQueryInfoFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, AttributesVarp, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEnumerateChildrenAsync gets the callback function.
// Asynchronously gets a #GFileEnumerator with the children of a #GFile.
func (x *FileIface) GetEnumerateChildrenAsync() func(File, string, FileQueryInfoFlags, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEnumerateChildrenAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, AttributesVarp string, FlagsVarp FileQueryInfoFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEnumerateChildrenAsync)
	return func(FileVar File, AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), AttributesVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEnumerateChildrenFinish sets the callback function.
// Finishes asynchronously enumerating the children.
func (x *FileIface) OverrideEnumerateChildrenFinish(cb func(File, AsyncResult) *FileEnumerator) {
	if cb == nil {
		x.xEnumerateChildrenFinish = 0
	} else {
		x.xEnumerateChildrenFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetEnumerateChildrenFinish gets the callback function.
// Finishes asynchronously enumerating the children.
func (x *FileIface) GetEnumerateChildrenFinish() func(File, AsyncResult) *FileEnumerator {
	if x.xEnumerateChildrenFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xEnumerateChildrenFinish)
	return func(FileVar File, ResVar AsyncResult) *FileEnumerator {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileEnumerator{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideQueryInfo sets the callback function.
// Gets the #GFileInfo for a #GFile.
func (x *FileIface) OverrideQueryInfo(cb func(File, string, FileQueryInfoFlags, *Cancellable) *FileInfo) {
	if cb == nil {
		x.xQueryInfo = 0
	} else {
		x.xQueryInfo = purego.NewCallback(func(FileVarp uintptr, AttributesVarp string, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, AttributesVarp, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetQueryInfo gets the callback function.
// Gets the #GFileInfo for a #GFile.
func (x *FileIface) GetQueryInfo() func(File, string, FileQueryInfoFlags, *Cancellable) *FileInfo {
	if x.xQueryInfo == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, AttributesVarp string, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xQueryInfo)
	return func(FileVar File, AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) *FileInfo {
		rawRet := rawCallback(FileVar.GoPointer(), AttributesVar, FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInfo{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideQueryInfoAsync sets the callback function.
// Asynchronously gets the #GFileInfo for a #GFile.
func (x *FileIface) OverrideQueryInfoAsync(cb func(File, string, FileQueryInfoFlags, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xQueryInfoAsync = 0
	} else {
		x.xQueryInfoAsync = purego.NewCallback(func(FileVarp uintptr, AttributesVarp string, FlagsVarp FileQueryInfoFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, AttributesVarp, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetQueryInfoAsync gets the callback function.
// Asynchronously gets the #GFileInfo for a #GFile.
func (x *FileIface) GetQueryInfoAsync() func(File, string, FileQueryInfoFlags, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xQueryInfoAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, AttributesVarp string, FlagsVarp FileQueryInfoFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xQueryInfoAsync)
	return func(FileVar File, AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), AttributesVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideQueryInfoFinish sets the callback function.
// Finishes an asynchronous query info operation.
func (x *FileIface) OverrideQueryInfoFinish(cb func(File, AsyncResult) *FileInfo) {
	if cb == nil {
		x.xQueryInfoFinish = 0
	} else {
		x.xQueryInfoFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetQueryInfoFinish gets the callback function.
// Finishes an asynchronous query info operation.
func (x *FileIface) GetQueryInfoFinish() func(File, AsyncResult) *FileInfo {
	if x.xQueryInfoFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xQueryInfoFinish)
	return func(FileVar File, ResVar AsyncResult) *FileInfo {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInfo{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideQueryFilesystemInfo sets the callback function.
// Gets a #GFileInfo for the file system #GFile is on.
func (x *FileIface) OverrideQueryFilesystemInfo(cb func(File, string, *Cancellable) *FileInfo) {
	if cb == nil {
		x.xQueryFilesystemInfo = 0
	} else {
		x.xQueryFilesystemInfo = purego.NewCallback(func(FileVarp uintptr, AttributesVarp string, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, AttributesVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetQueryFilesystemInfo gets the callback function.
// Gets a #GFileInfo for the file system #GFile is on.
func (x *FileIface) GetQueryFilesystemInfo() func(File, string, *Cancellable) *FileInfo {
	if x.xQueryFilesystemInfo == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, AttributesVarp string, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xQueryFilesystemInfo)
	return func(FileVar File, AttributesVar string, CancellableVar *Cancellable) *FileInfo {
		rawRet := rawCallback(FileVar.GoPointer(), AttributesVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInfo{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideQueryFilesystemInfoAsync sets the callback function.
// Asynchronously gets a #GFileInfo for the file system #GFile is on.
func (x *FileIface) OverrideQueryFilesystemInfoAsync(cb func(File, string, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xQueryFilesystemInfoAsync = 0
	} else {
		x.xQueryFilesystemInfoAsync = purego.NewCallback(func(FileVarp uintptr, AttributesVarp string, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, AttributesVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetQueryFilesystemInfoAsync gets the callback function.
// Asynchronously gets a #GFileInfo for the file system #GFile is on.
func (x *FileIface) GetQueryFilesystemInfoAsync() func(File, string, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xQueryFilesystemInfoAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, AttributesVarp string, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xQueryFilesystemInfoAsync)
	return func(FileVar File, AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), AttributesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideQueryFilesystemInfoFinish sets the callback function.
// Finishes asynchronously getting the file system info.
func (x *FileIface) OverrideQueryFilesystemInfoFinish(cb func(File, AsyncResult) *FileInfo) {
	if cb == nil {
		x.xQueryFilesystemInfoFinish = 0
	} else {
		x.xQueryFilesystemInfoFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetQueryFilesystemInfoFinish gets the callback function.
// Finishes asynchronously getting the file system info.
func (x *FileIface) GetQueryFilesystemInfoFinish() func(File, AsyncResult) *FileInfo {
	if x.xQueryFilesystemInfoFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xQueryFilesystemInfoFinish)
	return func(FileVar File, ResVar AsyncResult) *FileInfo {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInfo{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideFindEnclosingMount sets the callback function.
// Gets a #GMount for the #GFile.
func (x *FileIface) OverrideFindEnclosingMount(cb func(File, *Cancellable) *MountBase) {
	if cb == nil {
		x.xFindEnclosingMount = 0
	} else {
		x.xFindEnclosingMount = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetFindEnclosingMount gets the callback function.
// Gets a #GMount for the #GFile.
func (x *FileIface) GetFindEnclosingMount() func(File, *Cancellable) *MountBase {
	if x.xFindEnclosingMount == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xFindEnclosingMount)
	return func(FileVar File, CancellableVar *Cancellable) *MountBase {
		rawRet := rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &MountBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideFindEnclosingMountAsync sets the callback function.
// Asynchronously gets the #GMount for a #GFile.
func (x *FileIface) OverrideFindEnclosingMountAsync(cb func(File, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xFindEnclosingMountAsync = 0
	} else {
		x.xFindEnclosingMountAsync = purego.NewCallback(func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetFindEnclosingMountAsync gets the callback function.
// Asynchronously gets the #GMount for a #GFile.
func (x *FileIface) GetFindEnclosingMountAsync() func(File, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xFindEnclosingMountAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xFindEnclosingMountAsync)
	return func(FileVar File, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideFindEnclosingMountFinish sets the callback function.
// Finishes asynchronously getting the volume.
func (x *FileIface) OverrideFindEnclosingMountFinish(cb func(File, AsyncResult) *MountBase) {
	if cb == nil {
		x.xFindEnclosingMountFinish = 0
	} else {
		x.xFindEnclosingMountFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetFindEnclosingMountFinish gets the callback function.
// Finishes asynchronously getting the volume.
func (x *FileIface) GetFindEnclosingMountFinish() func(File, AsyncResult) *MountBase {
	if x.xFindEnclosingMountFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xFindEnclosingMountFinish)
	return func(FileVar File, ResVar AsyncResult) *MountBase {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &MountBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideSetDisplayName sets the callback function.
// Sets the display name for a #GFile.
func (x *FileIface) OverrideSetDisplayName(cb func(File, string, *Cancellable) *FileBase) {
	if cb == nil {
		x.xSetDisplayName = 0
	} else {
		x.xSetDisplayName = purego.NewCallback(func(FileVarp uintptr, DisplayNameVarp string, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, DisplayNameVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetSetDisplayName gets the callback function.
// Sets the display name for a #GFile.
func (x *FileIface) GetSetDisplayName() func(File, string, *Cancellable) *FileBase {
	if x.xSetDisplayName == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, DisplayNameVarp string, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xSetDisplayName)
	return func(FileVar File, DisplayNameVar string, CancellableVar *Cancellable) *FileBase {
		rawRet := rawCallback(FileVar.GoPointer(), DisplayNameVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideSetDisplayNameAsync sets the callback function.
// Asynchronously sets a #GFile's display name.
func (x *FileIface) OverrideSetDisplayNameAsync(cb func(File, string, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xSetDisplayNameAsync = 0
	} else {
		x.xSetDisplayNameAsync = purego.NewCallback(func(FileVarp uintptr, DisplayNameVarp string, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, DisplayNameVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetSetDisplayNameAsync gets the callback function.
// Asynchronously sets a #GFile's display name.
func (x *FileIface) GetSetDisplayNameAsync() func(File, string, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xSetDisplayNameAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, DisplayNameVarp string, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSetDisplayNameAsync)
	return func(FileVar File, DisplayNameVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), DisplayNameVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideSetDisplayNameFinish sets the callback function.
// Finishes asynchronously setting a #GFile's display name.
func (x *FileIface) OverrideSetDisplayNameFinish(cb func(File, AsyncResult) *FileBase) {
	if cb == nil {
		x.xSetDisplayNameFinish = 0
	} else {
		x.xSetDisplayNameFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetSetDisplayNameFinish gets the callback function.
// Finishes asynchronously setting a #GFile's display name.
func (x *FileIface) GetSetDisplayNameFinish() func(File, AsyncResult) *FileBase {
	if x.xSetDisplayNameFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xSetDisplayNameFinish)
	return func(FileVar File, ResVar AsyncResult) *FileBase {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideQuerySettableAttributes sets the callback function.
// Returns a list of #GFileAttributeInfos that can be set.
func (x *FileIface) OverrideQuerySettableAttributes(cb func(File, *Cancellable) *FileAttributeInfoList) {
	if cb == nil {
		x.xQuerySettableAttributes = 0
	} else {
		x.xQuerySettableAttributes = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) *FileAttributeInfoList {
			return cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetQuerySettableAttributes gets the callback function.
// Returns a list of #GFileAttributeInfos that can be set.
func (x *FileIface) GetQuerySettableAttributes() func(File, *Cancellable) *FileAttributeInfoList {
	if x.xQuerySettableAttributes == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) *FileAttributeInfoList
	purego.RegisterFunc(&rawCallback, x.xQuerySettableAttributes)
	return func(FileVar File, CancellableVar *Cancellable) *FileAttributeInfoList {
		return rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideQuerySettableAttributesAsync sets the callback function.
// Asynchronously gets a list of #GFileAttributeInfos that can be set.
func (x *FileIface) OverrideQuerySettableAttributesAsync(cb func()) {
	if cb == nil {
		x.xQuerySettableAttributesAsync = 0
	} else {
		x.xQuerySettableAttributesAsync = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetQuerySettableAttributesAsync gets the callback function.
// Asynchronously gets a list of #GFileAttributeInfos that can be set.
func (x *FileIface) GetQuerySettableAttributesAsync() func() {
	if x.xQuerySettableAttributesAsync == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xQuerySettableAttributesAsync)
	return func() {
		rawCallback()
	}
}

// OverrideQuerySettableAttributesFinish sets the callback function.
// Finishes asynchronously querying settable attributes.
func (x *FileIface) OverrideQuerySettableAttributesFinish(cb func()) {
	if cb == nil {
		x.xQuerySettableAttributesFinish = 0
	} else {
		x.xQuerySettableAttributesFinish = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetQuerySettableAttributesFinish gets the callback function.
// Finishes asynchronously querying settable attributes.
func (x *FileIface) GetQuerySettableAttributesFinish() func() {
	if x.xQuerySettableAttributesFinish == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xQuerySettableAttributesFinish)
	return func() {
		rawCallback()
	}
}

// OverrideQueryWritableNamespaces sets the callback function.
// Returns a list of #GFileAttributeInfo namespaces that are writable.
func (x *FileIface) OverrideQueryWritableNamespaces(cb func(File, *Cancellable) *FileAttributeInfoList) {
	if cb == nil {
		x.xQueryWritableNamespaces = 0
	} else {
		x.xQueryWritableNamespaces = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) *FileAttributeInfoList {
			return cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetQueryWritableNamespaces gets the callback function.
// Returns a list of #GFileAttributeInfo namespaces that are writable.
func (x *FileIface) GetQueryWritableNamespaces() func(File, *Cancellable) *FileAttributeInfoList {
	if x.xQueryWritableNamespaces == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) *FileAttributeInfoList
	purego.RegisterFunc(&rawCallback, x.xQueryWritableNamespaces)
	return func(FileVar File, CancellableVar *Cancellable) *FileAttributeInfoList {
		return rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideQueryWritableNamespacesAsync sets the callback function.
// Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.
func (x *FileIface) OverrideQueryWritableNamespacesAsync(cb func()) {
	if cb == nil {
		x.xQueryWritableNamespacesAsync = 0
	} else {
		x.xQueryWritableNamespacesAsync = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetQueryWritableNamespacesAsync gets the callback function.
// Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.
func (x *FileIface) GetQueryWritableNamespacesAsync() func() {
	if x.xQueryWritableNamespacesAsync == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xQueryWritableNamespacesAsync)
	return func() {
		rawCallback()
	}
}

// OverrideQueryWritableNamespacesFinish sets the callback function.
// Finishes asynchronously querying the writable namespaces.
func (x *FileIface) OverrideQueryWritableNamespacesFinish(cb func()) {
	if cb == nil {
		x.xQueryWritableNamespacesFinish = 0
	} else {
		x.xQueryWritableNamespacesFinish = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetQueryWritableNamespacesFinish gets the callback function.
// Finishes asynchronously querying the writable namespaces.
func (x *FileIface) GetQueryWritableNamespacesFinish() func() {
	if x.xQueryWritableNamespacesFinish == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xQueryWritableNamespacesFinish)
	return func() {
		rawCallback()
	}
}

// OverrideSetAttribute sets the callback function.
// Sets a #GFileAttributeInfo.
func (x *FileIface) OverrideSetAttribute(cb func(File, string, FileAttributeType, uintptr, FileQueryInfoFlags, *Cancellable) bool) {
	if cb == nil {
		x.xSetAttribute = 0
	} else {
		x.xSetAttribute = purego.NewCallback(func(FileVarp uintptr, AttributeVarp string, TypeVarp FileAttributeType, ValuePVarp uintptr, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, AttributeVarp, TypeVarp, ValuePVarp, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetSetAttribute gets the callback function.
// Sets a #GFileAttributeInfo.
func (x *FileIface) GetSetAttribute() func(File, string, FileAttributeType, uintptr, FileQueryInfoFlags, *Cancellable) bool {
	if x.xSetAttribute == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, AttributeVarp string, TypeVarp FileAttributeType, ValuePVarp uintptr, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSetAttribute)
	return func(FileVar File, AttributeVar string, TypeVar FileAttributeType, ValuePVar uintptr, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool {
		return rawCallback(FileVar.GoPointer(), AttributeVar, TypeVar, ValuePVar, FlagsVar, CancellableVar.GoPointer())
	}
}

// OverrideSetAttributesFromInfo sets the callback function.
// Sets a #GFileAttributeInfo with information from a #GFileInfo.
func (x *FileIface) OverrideSetAttributesFromInfo(cb func(File, *FileInfo, FileQueryInfoFlags, *Cancellable) bool) {
	if cb == nil {
		x.xSetAttributesFromInfo = 0
	} else {
		x.xSetAttributesFromInfo = purego.NewCallback(func(FileVarp uintptr, InfoVarp uintptr, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, FileInfoNewFromInternalPtr(InfoVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetSetAttributesFromInfo gets the callback function.
// Sets a #GFileAttributeInfo with information from a #GFileInfo.
func (x *FileIface) GetSetAttributesFromInfo() func(File, *FileInfo, FileQueryInfoFlags, *Cancellable) bool {
	if x.xSetAttributesFromInfo == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, InfoVarp uintptr, FlagsVarp FileQueryInfoFlags, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSetAttributesFromInfo)
	return func(FileVar File, InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool {
		return rawCallback(FileVar.GoPointer(), InfoVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
	}
}

// OverrideSetAttributesAsync sets the callback function.
// Asynchronously sets a file's attributes.
func (x *FileIface) OverrideSetAttributesAsync(cb func(File, *FileInfo, FileQueryInfoFlags, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xSetAttributesAsync = 0
	} else {
		x.xSetAttributesAsync = purego.NewCallback(func(FileVarp uintptr, InfoVarp uintptr, FlagsVarp FileQueryInfoFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FileInfoNewFromInternalPtr(InfoVarp), FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetSetAttributesAsync gets the callback function.
// Asynchronously sets a file's attributes.
func (x *FileIface) GetSetAttributesAsync() func(File, *FileInfo, FileQueryInfoFlags, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xSetAttributesAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, InfoVarp uintptr, FlagsVarp FileQueryInfoFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSetAttributesAsync)
	return func(FileVar File, InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), InfoVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideSetAttributesFinish sets the callback function.
// Finishes setting a file's attributes asynchronously.
func (x *FileIface) OverrideSetAttributesFinish(cb func(File, AsyncResult, **FileInfo) bool) {
	if cb == nil {
		x.xSetAttributesFinish = 0
	} else {
		x.xSetAttributesFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr, InfoVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp}, (**FileInfo)(unsafe.Pointer(InfoVarp)))
		})
	}
}

// GetSetAttributesFinish gets the callback function.
// Finishes setting a file's attributes asynchronously.
func (x *FileIface) GetSetAttributesFinish() func(File, AsyncResult, **FileInfo) bool {
	if x.xSetAttributesFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr, InfoVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSetAttributesFinish)
	return func(FileVar File, ResultVar AsyncResult, InfoVar **FileInfo) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer(), *gobject.ConvertPtr(InfoVar))
	}
}

// OverrideReadFn sets the callback function.
// Reads a file asynchronously.
func (x *FileIface) OverrideReadFn(cb func(File, *Cancellable) *FileInputStream) {
	if cb == nil {
		x.xReadFn = 0
	} else {
		x.xReadFn = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetReadFn gets the callback function.
// Reads a file asynchronously.
func (x *FileIface) GetReadFn() func(File, *Cancellable) *FileInputStream {
	if x.xReadFn == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xReadFn)
	return func(FileVar File, CancellableVar *Cancellable) *FileInputStream {
		rawRet := rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideReadAsync sets the callback function.
// Asynchronously reads a file.
func (x *FileIface) OverrideReadAsync(cb func(File, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xReadAsync = 0
	} else {
		x.xReadAsync = purego.NewCallback(func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetReadAsync gets the callback function.
// Asynchronously reads a file.
func (x *FileIface) GetReadAsync() func(File, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xReadAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xReadAsync)
	return func(FileVar File, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideReadFinish sets the callback function.
// Finishes asynchronously reading a file.
func (x *FileIface) OverrideReadFinish(cb func(File, AsyncResult) *FileInputStream) {
	if cb == nil {
		x.xReadFinish = 0
	} else {
		x.xReadFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetReadFinish gets the callback function.
// Finishes asynchronously reading a file.
func (x *FileIface) GetReadFinish() func(File, AsyncResult) *FileInputStream {
	if x.xReadFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xReadFinish)
	return func(FileVar File, ResVar AsyncResult) *FileInputStream {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileInputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideAppendTo sets the callback function.
// Writes to the end of a file.
func (x *FileIface) OverrideAppendTo(cb func(File, FileCreateFlags, *Cancellable) *FileOutputStream) {
	if cb == nil {
		x.xAppendTo = 0
	} else {
		x.xAppendTo = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetAppendTo gets the callback function.
// Writes to the end of a file.
func (x *FileIface) GetAppendTo() func(File, FileCreateFlags, *Cancellable) *FileOutputStream {
	if x.xAppendTo == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xAppendTo)
	return func(FileVar File, FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileOutputStream {
		rawRet := rawCallback(FileVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileOutputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideAppendToAsync sets the callback function.
// Asynchronously writes to the end of a file.
func (x *FileIface) OverrideAppendToAsync(cb func(File, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xAppendToAsync = 0
	} else {
		x.xAppendToAsync = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetAppendToAsync gets the callback function.
// Asynchronously writes to the end of a file.
func (x *FileIface) GetAppendToAsync() func(File, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xAppendToAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xAppendToAsync)
	return func(FileVar File, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideAppendToFinish sets the callback function.
// Finishes an asynchronous file append operation.
func (x *FileIface) OverrideAppendToFinish(cb func(File, AsyncResult) *FileOutputStream) {
	if cb == nil {
		x.xAppendToFinish = 0
	} else {
		x.xAppendToFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetAppendToFinish gets the callback function.
// Finishes an asynchronous file append operation.
func (x *FileIface) GetAppendToFinish() func(File, AsyncResult) *FileOutputStream {
	if x.xAppendToFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xAppendToFinish)
	return func(FileVar File, ResVar AsyncResult) *FileOutputStream {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileOutputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCreate sets the callback function.
// Creates a new file.
func (x *FileIface) OverrideCreate(cb func(File, FileCreateFlags, *Cancellable) *FileOutputStream) {
	if cb == nil {
		x.xCreate = 0
	} else {
		x.xCreate = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetCreate gets the callback function.
// Creates a new file.
func (x *FileIface) GetCreate() func(File, FileCreateFlags, *Cancellable) *FileOutputStream {
	if x.xCreate == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xCreate)
	return func(FileVar File, FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileOutputStream {
		rawRet := rawCallback(FileVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileOutputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCreateAsync sets the callback function.
// Asynchronously creates a file.
func (x *FileIface) OverrideCreateAsync(cb func(File, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xCreateAsync = 0
	} else {
		x.xCreateAsync = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetCreateAsync gets the callback function.
// Asynchronously creates a file.
func (x *FileIface) GetCreateAsync() func(File, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xCreateAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCreateAsync)
	return func(FileVar File, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideCreateFinish sets the callback function.
// Finishes asynchronously creating a file.
func (x *FileIface) OverrideCreateFinish(cb func(File, AsyncResult) *FileOutputStream) {
	if cb == nil {
		x.xCreateFinish = 0
	} else {
		x.xCreateFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetCreateFinish gets the callback function.
// Finishes asynchronously creating a file.
func (x *FileIface) GetCreateFinish() func(File, AsyncResult) *FileOutputStream {
	if x.xCreateFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xCreateFinish)
	return func(FileVar File, ResVar AsyncResult) *FileOutputStream {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileOutputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideReplace sets the callback function.
// Replaces the contents of a file.
func (x *FileIface) OverrideReplace(cb func(File, string, bool, FileCreateFlags, *Cancellable) *FileOutputStream) {
	if cb == nil {
		x.xReplace = 0
	} else {
		x.xReplace = purego.NewCallback(func(FileVarp uintptr, EtagVarp string, MakeBackupVarp bool, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, EtagVarp, MakeBackupVarp, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetReplace gets the callback function.
// Replaces the contents of a file.
func (x *FileIface) GetReplace() func(File, string, bool, FileCreateFlags, *Cancellable) *FileOutputStream {
	if x.xReplace == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, EtagVarp string, MakeBackupVarp bool, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xReplace)
	return func(FileVar File, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileOutputStream {
		rawRet := rawCallback(FileVar.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileOutputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideReplaceAsync sets the callback function.
// Asynchronously replaces the contents of a file.
func (x *FileIface) OverrideReplaceAsync(cb func(File, string, bool, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xReplaceAsync = 0
	} else {
		x.xReplaceAsync = purego.NewCallback(func(FileVarp uintptr, EtagVarp string, MakeBackupVarp bool, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, EtagVarp, MakeBackupVarp, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetReplaceAsync gets the callback function.
// Asynchronously replaces the contents of a file.
func (x *FileIface) GetReplaceAsync() func(File, string, bool, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xReplaceAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, EtagVarp string, MakeBackupVarp bool, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xReplaceAsync)
	return func(FileVar File, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideReplaceFinish sets the callback function.
// Finishes asynchronously replacing a file.
func (x *FileIface) OverrideReplaceFinish(cb func(File, AsyncResult) *FileOutputStream) {
	if cb == nil {
		x.xReplaceFinish = 0
	} else {
		x.xReplaceFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetReplaceFinish gets the callback function.
// Finishes asynchronously replacing a file.
func (x *FileIface) GetReplaceFinish() func(File, AsyncResult) *FileOutputStream {
	if x.xReplaceFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xReplaceFinish)
	return func(FileVar File, ResVar AsyncResult) *FileOutputStream {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileOutputStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideDeleteFile sets the callback function.
// Deletes a file.
func (x *FileIface) OverrideDeleteFile(cb func(File, *Cancellable) bool) {
	if cb == nil {
		x.xDeleteFile = 0
	} else {
		x.xDeleteFile = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetDeleteFile gets the callback function.
// Deletes a file.
func (x *FileIface) GetDeleteFile() func(File, *Cancellable) bool {
	if x.xDeleteFile == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xDeleteFile)
	return func(FileVar File, CancellableVar *Cancellable) bool {
		return rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideDeleteFileAsync sets the callback function.
// Asynchronously deletes a file.
func (x *FileIface) OverrideDeleteFileAsync(cb func(File, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xDeleteFileAsync = 0
	} else {
		x.xDeleteFileAsync = purego.NewCallback(func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetDeleteFileAsync gets the callback function.
// Asynchronously deletes a file.
func (x *FileIface) GetDeleteFileAsync() func(File, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xDeleteFileAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xDeleteFileAsync)
	return func(FileVar File, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideDeleteFileFinish sets the callback function.
// Finishes an asynchronous delete.
func (x *FileIface) OverrideDeleteFileFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xDeleteFileFinish = 0
	} else {
		x.xDeleteFileFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetDeleteFileFinish gets the callback function.
// Finishes an asynchronous delete.
func (x *FileIface) GetDeleteFileFinish() func(File, AsyncResult) bool {
	if x.xDeleteFileFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xDeleteFileFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideTrash sets the callback function.
// Sends a #GFile to the Trash location.
func (x *FileIface) OverrideTrash(cb func(File, *Cancellable) bool) {
	if cb == nil {
		x.xTrash = 0
	} else {
		x.xTrash = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetTrash gets the callback function.
// Sends a #GFile to the Trash location.
func (x *FileIface) GetTrash() func(File, *Cancellable) bool {
	if x.xTrash == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xTrash)
	return func(FileVar File, CancellableVar *Cancellable) bool {
		return rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideTrashAsync sets the callback function.
// Asynchronously sends a #GFile to the Trash location.
func (x *FileIface) OverrideTrashAsync(cb func(File, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xTrashAsync = 0
	} else {
		x.xTrashAsync = purego.NewCallback(func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetTrashAsync gets the callback function.
// Asynchronously sends a #GFile to the Trash location.
func (x *FileIface) GetTrashAsync() func(File, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xTrashAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xTrashAsync)
	return func(FileVar File, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideTrashFinish sets the callback function.
// Finishes an asynchronous file trashing operation.
func (x *FileIface) OverrideTrashFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xTrashFinish = 0
	} else {
		x.xTrashFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetTrashFinish gets the callback function.
// Finishes an asynchronous file trashing operation.
func (x *FileIface) GetTrashFinish() func(File, AsyncResult) bool {
	if x.xTrashFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xTrashFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideMakeDirectory sets the callback function.
// Makes a directory.
func (x *FileIface) OverrideMakeDirectory(cb func(File, *Cancellable) bool) {
	if cb == nil {
		x.xMakeDirectory = 0
	} else {
		x.xMakeDirectory = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetMakeDirectory gets the callback function.
// Makes a directory.
func (x *FileIface) GetMakeDirectory() func(File, *Cancellable) bool {
	if x.xMakeDirectory == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xMakeDirectory)
	return func(FileVar File, CancellableVar *Cancellable) bool {
		return rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideMakeDirectoryAsync sets the callback function.
// Asynchronously makes a directory.
func (x *FileIface) OverrideMakeDirectoryAsync(cb func(File, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xMakeDirectoryAsync = 0
	} else {
		x.xMakeDirectoryAsync = purego.NewCallback(func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetMakeDirectoryAsync gets the callback function.
// Asynchronously makes a directory.
func (x *FileIface) GetMakeDirectoryAsync() func(File, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xMakeDirectoryAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMakeDirectoryAsync)
	return func(FileVar File, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideMakeDirectoryFinish sets the callback function.
// Finishes making a directory asynchronously.
func (x *FileIface) OverrideMakeDirectoryFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xMakeDirectoryFinish = 0
	} else {
		x.xMakeDirectoryFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetMakeDirectoryFinish gets the callback function.
// Finishes making a directory asynchronously.
func (x *FileIface) GetMakeDirectoryFinish() func(File, AsyncResult) bool {
	if x.xMakeDirectoryFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xMakeDirectoryFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideMakeSymbolicLink sets the callback function.
// Makes a symbolic link. %NULL if symbolic
//
//	links are unsupported.
func (x *FileIface) OverrideMakeSymbolicLink(cb func(File, string, *Cancellable) bool) {
	if cb == nil {
		x.xMakeSymbolicLink = 0
	} else {
		x.xMakeSymbolicLink = purego.NewCallback(func(FileVarp uintptr, SymlinkValueVarp string, CancellableVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, SymlinkValueVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetMakeSymbolicLink gets the callback function.
// Makes a symbolic link. %NULL if symbolic
//
//	links are unsupported.
func (x *FileIface) GetMakeSymbolicLink() func(File, string, *Cancellable) bool {
	if x.xMakeSymbolicLink == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, SymlinkValueVarp string, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xMakeSymbolicLink)
	return func(FileVar File, SymlinkValueVar string, CancellableVar *Cancellable) bool {
		return rawCallback(FileVar.GoPointer(), SymlinkValueVar, CancellableVar.GoPointer())
	}
}

// OverrideMakeSymbolicLinkAsync sets the callback function.
// Asynchronously makes a symbolic link
func (x *FileIface) OverrideMakeSymbolicLinkAsync(cb func(File, string, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xMakeSymbolicLinkAsync = 0
	} else {
		x.xMakeSymbolicLinkAsync = purego.NewCallback(func(FileVarp uintptr, SymlinkValueVarp string, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, SymlinkValueVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetMakeSymbolicLinkAsync gets the callback function.
// Asynchronously makes a symbolic link
func (x *FileIface) GetMakeSymbolicLinkAsync() func(File, string, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xMakeSymbolicLinkAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, SymlinkValueVarp string, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMakeSymbolicLinkAsync)
	return func(FileVar File, SymlinkValueVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), SymlinkValueVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideMakeSymbolicLinkFinish sets the callback function.
// Finishes making a symbolic link asynchronously.
func (x *FileIface) OverrideMakeSymbolicLinkFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xMakeSymbolicLinkFinish = 0
	} else {
		x.xMakeSymbolicLinkFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetMakeSymbolicLinkFinish gets the callback function.
// Finishes making a symbolic link asynchronously.
func (x *FileIface) GetMakeSymbolicLinkFinish() func(File, AsyncResult) bool {
	if x.xMakeSymbolicLinkFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xMakeSymbolicLinkFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideCopy sets the callback function.
// Copies a file. %NULL if copying is unsupported, which will
//
//	cause `GFile` to use a fallback copy method where it reads from the
//	source and writes to the destination.
func (x *FileIface) OverrideCopy(cb func(File, File, FileCopyFlags, *Cancellable, *FileProgressCallback, uintptr) bool) {
	if cb == nil {
		x.xCopy = 0
	} else {
		x.xCopy = purego.NewCallback(func(SourceVarp uintptr, DestinationVarp uintptr, FlagsVarp FileCopyFlags, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressCallbackDataVarp uintptr) bool {
			return cb(&FileBase{Ptr: SourceVarp}, &FileBase{Ptr: DestinationVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*FileProgressCallback)(unsafe.Pointer(ProgressCallbackVarp)), ProgressCallbackDataVarp)
		})
	}
}

// GetCopy gets the callback function.
// Copies a file. %NULL if copying is unsupported, which will
//
//	cause `GFile` to use a fallback copy method where it reads from the
//	source and writes to the destination.
func (x *FileIface) GetCopy() func(File, File, FileCopyFlags, *Cancellable, *FileProgressCallback, uintptr) bool {
	if x.xCopy == 0 {
		return nil
	}
	var rawCallback func(SourceVarp uintptr, DestinationVarp uintptr, FlagsVarp FileCopyFlags, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressCallbackDataVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCopy)
	return func(SourceVar File, DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) bool {
		return rawCallback(SourceVar.GoPointer(), DestinationVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressCallbackDataVar)
	}
}

// OverrideCopyAsync sets the callback function.
// Asynchronously copies a file.
func (x *FileIface) OverrideCopyAsync(cb func(File, File, FileCopyFlags, int, *Cancellable, *FileProgressCallback, uintptr, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xCopyAsync = 0
	} else {
		x.xCopyAsync = purego.NewCallback(func(SourceVarp uintptr, DestinationVarp uintptr, FlagsVarp FileCopyFlags, IoPriorityVarp int, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressCallbackDataVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: SourceVarp}, &FileBase{Ptr: DestinationVarp}, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*FileProgressCallback)(unsafe.Pointer(ProgressCallbackVarp)), ProgressCallbackDataVarp, (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetCopyAsync gets the callback function.
// Asynchronously copies a file.
func (x *FileIface) GetCopyAsync() func(File, File, FileCopyFlags, int, *Cancellable, *FileProgressCallback, uintptr, *AsyncReadyCallback, uintptr) {
	if x.xCopyAsync == 0 {
		return nil
	}
	var rawCallback func(SourceVarp uintptr, DestinationVarp uintptr, FlagsVarp FileCopyFlags, IoPriorityVarp int, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressCallbackDataVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCopyAsync)
	return func(SourceVar File, DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(SourceVar.GoPointer(), DestinationVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressCallbackDataVar, glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideCopyFinish sets the callback function.
// Finishes an asynchronous copy operation.
func (x *FileIface) OverrideCopyFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xCopyFinish = 0
	} else {
		x.xCopyFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
		})
	}
}

// GetCopyFinish gets the callback function.
// Finishes an asynchronous copy operation.
func (x *FileIface) GetCopyFinish() func(File, AsyncResult) bool {
	if x.xCopyFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCopyFinish)
	return func(FileVar File, ResVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
	}
}

// OverrideMove sets the callback function.
// Moves a file.
func (x *FileIface) OverrideMove(cb func(File, File, FileCopyFlags, *Cancellable, *FileProgressCallback, uintptr) bool) {
	if cb == nil {
		x.xMove = 0
	} else {
		x.xMove = purego.NewCallback(func(SourceVarp uintptr, DestinationVarp uintptr, FlagsVarp FileCopyFlags, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressCallbackDataVarp uintptr) bool {
			return cb(&FileBase{Ptr: SourceVarp}, &FileBase{Ptr: DestinationVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*FileProgressCallback)(unsafe.Pointer(ProgressCallbackVarp)), ProgressCallbackDataVarp)
		})
	}
}

// GetMove gets the callback function.
// Moves a file.
func (x *FileIface) GetMove() func(File, File, FileCopyFlags, *Cancellable, *FileProgressCallback, uintptr) bool {
	if x.xMove == 0 {
		return nil
	}
	var rawCallback func(SourceVarp uintptr, DestinationVarp uintptr, FlagsVarp FileCopyFlags, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressCallbackDataVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xMove)
	return func(SourceVar File, DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) bool {
		return rawCallback(SourceVar.GoPointer(), DestinationVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressCallbackDataVar)
	}
}

// OverrideMoveAsync sets the callback function.
// Asynchronously moves a file. Since: 2.72
func (x *FileIface) OverrideMoveAsync(cb func(File, File, FileCopyFlags, int, *Cancellable, *FileProgressCallback, uintptr, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xMoveAsync = 0
	} else {
		x.xMoveAsync = purego.NewCallback(func(SourceVarp uintptr, DestinationVarp uintptr, FlagsVarp FileCopyFlags, IoPriorityVarp int, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressCallbackDataVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: SourceVarp}, &FileBase{Ptr: DestinationVarp}, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*FileProgressCallback)(unsafe.Pointer(ProgressCallbackVarp)), ProgressCallbackDataVarp, (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetMoveAsync gets the callback function.
// Asynchronously moves a file. Since: 2.72
func (x *FileIface) GetMoveAsync() func(File, File, FileCopyFlags, int, *Cancellable, *FileProgressCallback, uintptr, *AsyncReadyCallback, uintptr) {
	if x.xMoveAsync == 0 {
		return nil
	}
	var rawCallback func(SourceVarp uintptr, DestinationVarp uintptr, FlagsVarp FileCopyFlags, IoPriorityVarp int, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressCallbackDataVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMoveAsync)
	return func(SourceVar File, DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(SourceVar.GoPointer(), DestinationVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressCallbackDataVar, glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideMoveFinish sets the callback function.
// Finishes an asynchronous move operation. Since: 2.72
func (x *FileIface) OverrideMoveFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xMoveFinish = 0
	} else {
		x.xMoveFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetMoveFinish gets the callback function.
// Finishes an asynchronous move operation. Since: 2.72
func (x *FileIface) GetMoveFinish() func(File, AsyncResult) bool {
	if x.xMoveFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xMoveFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideMountMountable sets the callback function.
// Mounts a mountable object.
func (x *FileIface) OverrideMountMountable(cb func(File, MountMountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xMountMountable = 0
	} else {
		x.xMountMountable = purego.NewCallback(func(FileVarp uintptr, FlagsVarp MountMountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetMountMountable gets the callback function.
// Mounts a mountable object.
func (x *FileIface) GetMountMountable() func(File, MountMountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xMountMountable == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp MountMountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMountMountable)
	return func(FileVar File, FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideMountMountableFinish sets the callback function.
// Finishes a mounting operation.
func (x *FileIface) OverrideMountMountableFinish(cb func(File, AsyncResult) *FileBase) {
	if cb == nil {
		x.xMountMountableFinish = 0
	} else {
		x.xMountMountableFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetMountMountableFinish gets the callback function.
// Finishes a mounting operation.
func (x *FileIface) GetMountMountableFinish() func(File, AsyncResult) *FileBase {
	if x.xMountMountableFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xMountMountableFinish)
	return func(FileVar File, ResultVar AsyncResult) *FileBase {
		rawRet := rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideUnmountMountable sets the callback function.
// Unmounts a mountable object.
func (x *FileIface) OverrideUnmountMountable(cb func(File, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xUnmountMountable = 0
	} else {
		x.xUnmountMountable = purego.NewCallback(func(FileVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetUnmountMountable gets the callback function.
// Unmounts a mountable object.
func (x *FileIface) GetUnmountMountable() func(File, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xUnmountMountable == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnmountMountable)
	return func(FileVar File, FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideUnmountMountableFinish sets the callback function.
// Finishes an unmount operation.
func (x *FileIface) OverrideUnmountMountableFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xUnmountMountableFinish = 0
	} else {
		x.xUnmountMountableFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetUnmountMountableFinish gets the callback function.
// Finishes an unmount operation.
func (x *FileIface) GetUnmountMountableFinish() func(File, AsyncResult) bool {
	if x.xUnmountMountableFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xUnmountMountableFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideEjectMountable sets the callback function.
// Ejects a mountable.
func (x *FileIface) OverrideEjectMountable(cb func(File, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEjectMountable = 0
	} else {
		x.xEjectMountable = purego.NewCallback(func(FileVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEjectMountable gets the callback function.
// Ejects a mountable.
func (x *FileIface) GetEjectMountable() func(File, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEjectMountable == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEjectMountable)
	return func(FileVar File, FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEjectMountableFinish sets the callback function.
// Finishes an eject operation.
func (x *FileIface) OverrideEjectMountableFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xEjectMountableFinish = 0
	} else {
		x.xEjectMountableFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetEjectMountableFinish gets the callback function.
// Finishes an eject operation.
func (x *FileIface) GetEjectMountableFinish() func(File, AsyncResult) bool {
	if x.xEjectMountableFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEjectMountableFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideMountEnclosingVolume sets the callback function.
// Mounts a specified location.
func (x *FileIface) OverrideMountEnclosingVolume(cb func(File, MountMountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xMountEnclosingVolume = 0
	} else {
		x.xMountEnclosingVolume = purego.NewCallback(func(LocationVarp uintptr, FlagsVarp MountMountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: LocationVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetMountEnclosingVolume gets the callback function.
// Mounts a specified location.
func (x *FileIface) GetMountEnclosingVolume() func(File, MountMountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xMountEnclosingVolume == 0 {
		return nil
	}
	var rawCallback func(LocationVarp uintptr, FlagsVarp MountMountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMountEnclosingVolume)
	return func(LocationVar File, FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(LocationVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideMountEnclosingVolumeFinish sets the callback function.
// Finishes mounting a specified location.
func (x *FileIface) OverrideMountEnclosingVolumeFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xMountEnclosingVolumeFinish = 0
	} else {
		x.xMountEnclosingVolumeFinish = purego.NewCallback(func(LocationVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: LocationVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetMountEnclosingVolumeFinish gets the callback function.
// Finishes mounting a specified location.
func (x *FileIface) GetMountEnclosingVolumeFinish() func(File, AsyncResult) bool {
	if x.xMountEnclosingVolumeFinish == 0 {
		return nil
	}
	var rawCallback func(LocationVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xMountEnclosingVolumeFinish)
	return func(LocationVar File, ResultVar AsyncResult) bool {
		return rawCallback(LocationVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideMonitorDir sets the callback function.
// Creates a #GFileMonitor for the location.
func (x *FileIface) OverrideMonitorDir(cb func(File, FileMonitorFlags, *Cancellable) *FileMonitor) {
	if cb == nil {
		x.xMonitorDir = 0
	} else {
		x.xMonitorDir = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileMonitorFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetMonitorDir gets the callback function.
// Creates a #GFileMonitor for the location.
func (x *FileIface) GetMonitorDir() func(File, FileMonitorFlags, *Cancellable) *FileMonitor {
	if x.xMonitorDir == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileMonitorFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xMonitorDir)
	return func(FileVar File, FlagsVar FileMonitorFlags, CancellableVar *Cancellable) *FileMonitor {
		rawRet := rawCallback(FileVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileMonitor{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideMonitorFile sets the callback function.
// Creates a #GFileMonitor for the location.
func (x *FileIface) OverrideMonitorFile(cb func(File, FileMonitorFlags, *Cancellable) *FileMonitor) {
	if cb == nil {
		x.xMonitorFile = 0
	} else {
		x.xMonitorFile = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileMonitorFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetMonitorFile gets the callback function.
// Creates a #GFileMonitor for the location.
func (x *FileIface) GetMonitorFile() func(File, FileMonitorFlags, *Cancellable) *FileMonitor {
	if x.xMonitorFile == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileMonitorFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xMonitorFile)
	return func(FileVar File, FlagsVar FileMonitorFlags, CancellableVar *Cancellable) *FileMonitor {
		rawRet := rawCallback(FileVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileMonitor{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideOpenReadwrite sets the callback function.
// Open file read/write. Since 2.22.
func (x *FileIface) OverrideOpenReadwrite(cb func(File, *Cancellable) *FileIOStream) {
	if cb == nil {
		x.xOpenReadwrite = 0
	} else {
		x.xOpenReadwrite = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetOpenReadwrite gets the callback function.
// Open file read/write. Since 2.22.
func (x *FileIface) GetOpenReadwrite() func(File, *Cancellable) *FileIOStream {
	if x.xOpenReadwrite == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xOpenReadwrite)
	return func(FileVar File, CancellableVar *Cancellable) *FileIOStream {
		rawRet := rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileIOStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideOpenReadwriteAsync sets the callback function.
// Asynchronously opens file read/write. Since 2.22.
func (x *FileIface) OverrideOpenReadwriteAsync(cb func(File, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xOpenReadwriteAsync = 0
	} else {
		x.xOpenReadwriteAsync = purego.NewCallback(func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetOpenReadwriteAsync gets the callback function.
// Asynchronously opens file read/write. Since 2.22.
func (x *FileIface) GetOpenReadwriteAsync() func(File, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xOpenReadwriteAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xOpenReadwriteAsync)
	return func(FileVar File, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideOpenReadwriteFinish sets the callback function.
// Finishes an asynchronous open read/write. Since 2.22.
func (x *FileIface) OverrideOpenReadwriteFinish(cb func(File, AsyncResult) *FileIOStream) {
	if cb == nil {
		x.xOpenReadwriteFinish = 0
	} else {
		x.xOpenReadwriteFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetOpenReadwriteFinish gets the callback function.
// Finishes an asynchronous open read/write. Since 2.22.
func (x *FileIface) GetOpenReadwriteFinish() func(File, AsyncResult) *FileIOStream {
	if x.xOpenReadwriteFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xOpenReadwriteFinish)
	return func(FileVar File, ResVar AsyncResult) *FileIOStream {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileIOStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCreateReadwrite sets the callback function.
// Creates file read/write. Since 2.22.
func (x *FileIface) OverrideCreateReadwrite(cb func(File, FileCreateFlags, *Cancellable) *FileIOStream) {
	if cb == nil {
		x.xCreateReadwrite = 0
	} else {
		x.xCreateReadwrite = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetCreateReadwrite gets the callback function.
// Creates file read/write. Since 2.22.
func (x *FileIface) GetCreateReadwrite() func(File, FileCreateFlags, *Cancellable) *FileIOStream {
	if x.xCreateReadwrite == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xCreateReadwrite)
	return func(FileVar File, FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileIOStream {
		rawRet := rawCallback(FileVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileIOStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCreateReadwriteAsync sets the callback function.
// Asynchronously creates file read/write. Since 2.22.
func (x *FileIface) OverrideCreateReadwriteAsync(cb func(File, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xCreateReadwriteAsync = 0
	} else {
		x.xCreateReadwriteAsync = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetCreateReadwriteAsync gets the callback function.
// Asynchronously creates file read/write. Since 2.22.
func (x *FileIface) GetCreateReadwriteAsync() func(File, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xCreateReadwriteAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xCreateReadwriteAsync)
	return func(FileVar File, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideCreateReadwriteFinish sets the callback function.
// Finishes an asynchronous creates read/write. Since 2.22.
func (x *FileIface) OverrideCreateReadwriteFinish(cb func(File, AsyncResult) *FileIOStream) {
	if cb == nil {
		x.xCreateReadwriteFinish = 0
	} else {
		x.xCreateReadwriteFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetCreateReadwriteFinish gets the callback function.
// Finishes an asynchronous creates read/write. Since 2.22.
func (x *FileIface) GetCreateReadwriteFinish() func(File, AsyncResult) *FileIOStream {
	if x.xCreateReadwriteFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xCreateReadwriteFinish)
	return func(FileVar File, ResVar AsyncResult) *FileIOStream {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileIOStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideReplaceReadwrite sets the callback function.
// Replaces file read/write. Since 2.22.
func (x *FileIface) OverrideReplaceReadwrite(cb func(File, string, bool, FileCreateFlags, *Cancellable) *FileIOStream) {
	if cb == nil {
		x.xReplaceReadwrite = 0
	} else {
		x.xReplaceReadwrite = purego.NewCallback(func(FileVarp uintptr, EtagVarp string, MakeBackupVarp bool, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, EtagVarp, MakeBackupVarp, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetReplaceReadwrite gets the callback function.
// Replaces file read/write. Since 2.22.
func (x *FileIface) GetReplaceReadwrite() func(File, string, bool, FileCreateFlags, *Cancellable) *FileIOStream {
	if x.xReplaceReadwrite == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, EtagVarp string, MakeBackupVarp bool, FlagsVarp FileCreateFlags, CancellableVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xReplaceReadwrite)
	return func(FileVar File, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileIOStream {
		rawRet := rawCallback(FileVar.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileIOStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideReplaceReadwriteAsync sets the callback function.
// Asynchronously replaces file read/write. Since 2.22.
func (x *FileIface) OverrideReplaceReadwriteAsync(cb func(File, string, bool, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xReplaceReadwriteAsync = 0
	} else {
		x.xReplaceReadwriteAsync = purego.NewCallback(func(FileVarp uintptr, EtagVarp string, MakeBackupVarp bool, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, EtagVarp, MakeBackupVarp, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetReplaceReadwriteAsync gets the callback function.
// Asynchronously replaces file read/write. Since 2.22.
func (x *FileIface) GetReplaceReadwriteAsync() func(File, string, bool, FileCreateFlags, int, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xReplaceReadwriteAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, EtagVarp string, MakeBackupVarp bool, FlagsVarp FileCreateFlags, IoPriorityVarp int, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xReplaceReadwriteAsync)
	return func(FileVar File, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideReplaceReadwriteFinish sets the callback function.
// Finishes an asynchronous replace read/write. Since 2.22.
func (x *FileIface) OverrideReplaceReadwriteFinish(cb func(File, AsyncResult) *FileIOStream) {
	if cb == nil {
		x.xReplaceReadwriteFinish = 0
	} else {
		x.xReplaceReadwriteFinish = purego.NewCallback(func(FileVarp uintptr, ResVarp uintptr) uintptr {
			ret := cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetReplaceReadwriteFinish gets the callback function.
// Finishes an asynchronous replace read/write. Since 2.22.
func (x *FileIface) GetReplaceReadwriteFinish() func(File, AsyncResult) *FileIOStream {
	if x.xReplaceReadwriteFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xReplaceReadwriteFinish)
	return func(FileVar File, ResVar AsyncResult) *FileIOStream {
		rawRet := rawCallback(FileVar.GoPointer(), ResVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileIOStream{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideStartMountable sets the callback function.
// Starts a mountable object. Since 2.22.
func (x *FileIface) OverrideStartMountable(cb func(File, DriveStartFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xStartMountable = 0
	} else {
		x.xStartMountable = purego.NewCallback(func(FileVarp uintptr, FlagsVarp DriveStartFlags, StartOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, MountOperationNewFromInternalPtr(StartOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetStartMountable gets the callback function.
// Starts a mountable object. Since 2.22.
func (x *FileIface) GetStartMountable() func(File, DriveStartFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xStartMountable == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp DriveStartFlags, StartOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xStartMountable)
	return func(FileVar File, FlagsVar DriveStartFlags, StartOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, StartOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideStartMountableFinish sets the callback function.
// Finishes a start operation. Since 2.22.
func (x *FileIface) OverrideStartMountableFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xStartMountableFinish = 0
	} else {
		x.xStartMountableFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetStartMountableFinish gets the callback function.
// Finishes a start operation. Since 2.22.
func (x *FileIface) GetStartMountableFinish() func(File, AsyncResult) bool {
	if x.xStartMountableFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xStartMountableFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideStopMountable sets the callback function.
// Stops a mountable. Since 2.22.
func (x *FileIface) OverrideStopMountable(cb func(File, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xStopMountable = 0
	} else {
		x.xStopMountable = purego.NewCallback(func(FileVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetStopMountable gets the callback function.
// Stops a mountable. Since 2.22.
func (x *FileIface) GetStopMountable() func(File, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xStopMountable == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xStopMountable)
	return func(FileVar File, FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideStopMountableFinish sets the callback function.
// Finishes a stop operation. Since 2.22.
func (x *FileIface) OverrideStopMountableFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xStopMountableFinish = 0
	} else {
		x.xStopMountableFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetStopMountableFinish gets the callback function.
// Finishes a stop operation. Since 2.22.
func (x *FileIface) GetStopMountableFinish() func(File, AsyncResult) bool {
	if x.xStopMountableFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xStopMountableFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideUnmountMountableWithOperation sets the callback function.
// Unmounts a mountable object using a #GMountOperation. Since 2.22.
func (x *FileIface) OverrideUnmountMountableWithOperation(cb func(File, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xUnmountMountableWithOperation = 0
	} else {
		x.xUnmountMountableWithOperation = purego.NewCallback(func(FileVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetUnmountMountableWithOperation gets the callback function.
// Unmounts a mountable object using a #GMountOperation. Since 2.22.
func (x *FileIface) GetUnmountMountableWithOperation() func(File, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xUnmountMountableWithOperation == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnmountMountableWithOperation)
	return func(FileVar File, FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideUnmountMountableWithOperationFinish sets the callback function.
// Finishes an unmount operation using a #GMountOperation. Since 2.22.
func (x *FileIface) OverrideUnmountMountableWithOperationFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xUnmountMountableWithOperationFinish = 0
	} else {
		x.xUnmountMountableWithOperationFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetUnmountMountableWithOperationFinish gets the callback function.
// Finishes an unmount operation using a #GMountOperation. Since 2.22.
func (x *FileIface) GetUnmountMountableWithOperationFinish() func(File, AsyncResult) bool {
	if x.xUnmountMountableWithOperationFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xUnmountMountableWithOperationFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideEjectMountableWithOperation sets the callback function.
// Ejects a mountable object using a #GMountOperation. Since 2.22.
func (x *FileIface) OverrideEjectMountableWithOperation(cb func(File, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEjectMountableWithOperation = 0
	} else {
		x.xEjectMountableWithOperation = purego.NewCallback(func(FileVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEjectMountableWithOperation gets the callback function.
// Ejects a mountable object using a #GMountOperation. Since 2.22.
func (x *FileIface) GetEjectMountableWithOperation() func(File, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEjectMountableWithOperation == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEjectMountableWithOperation)
	return func(FileVar File, FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEjectMountableWithOperationFinish sets the callback function.
// Finishes an eject operation using a #GMountOperation. Since 2.22.
func (x *FileIface) OverrideEjectMountableWithOperationFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xEjectMountableWithOperationFinish = 0
	} else {
		x.xEjectMountableWithOperationFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetEjectMountableWithOperationFinish gets the callback function.
// Finishes an eject operation using a #GMountOperation. Since 2.22.
func (x *FileIface) GetEjectMountableWithOperationFinish() func(File, AsyncResult) bool {
	if x.xEjectMountableWithOperationFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEjectMountableWithOperationFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverridePollMountable sets the callback function.
// Polls a mountable object for media changes. Since 2.22.
func (x *FileIface) OverridePollMountable(cb func(File, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xPollMountable = 0
	} else {
		x.xPollMountable = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetPollMountable gets the callback function.
// Polls a mountable object for media changes. Since 2.22.
func (x *FileIface) GetPollMountable() func(File, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xPollMountable == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPollMountable)
	return func(FileVar File, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverridePollMountableFinish sets the callback function.
// Finishes a poll operation for media changes. Since 2.22.
func (x *FileIface) OverridePollMountableFinish(cb func(File, AsyncResult) bool) {
	if cb == nil {
		x.xPollMountableFinish = 0
	} else {
		x.xPollMountableFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetPollMountableFinish gets the callback function.
// Finishes a poll operation for media changes. Since 2.22.
func (x *FileIface) GetPollMountableFinish() func(File, AsyncResult) bool {
	if x.xPollMountableFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xPollMountableFinish)
	return func(FileVar File, ResultVar AsyncResult) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideMeasureDiskUsage sets the callback function.
// Recursively measures the disk usage of @file. Since 2.38
func (x *FileIface) OverrideMeasureDiskUsage(cb func(File, FileMeasureFlags, *Cancellable, *FileMeasureProgressCallback, uintptr, uint64, uint64, uint64) bool) {
	if cb == nil {
		x.xMeasureDiskUsage = 0
	} else {
		x.xMeasureDiskUsage = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileMeasureFlags, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressDataVarp uintptr, DiskUsageVarp uint64, NumDirsVarp uint64, NumFilesVarp uint64) bool {
			return cb(&FileBase{Ptr: FileVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*FileMeasureProgressCallback)(unsafe.Pointer(ProgressCallbackVarp)), ProgressDataVarp, DiskUsageVarp, NumDirsVarp, NumFilesVarp)
		})
	}
}

// GetMeasureDiskUsage gets the callback function.
// Recursively measures the disk usage of @file. Since 2.38
func (x *FileIface) GetMeasureDiskUsage() func(File, FileMeasureFlags, *Cancellable, *FileMeasureProgressCallback, uintptr, uint64, uint64, uint64) bool {
	if x.xMeasureDiskUsage == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileMeasureFlags, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressDataVarp uintptr, DiskUsageVarp uint64, NumDirsVarp uint64, NumFilesVarp uint64) bool
	purego.RegisterFunc(&rawCallback, x.xMeasureDiskUsage)
	return func(FileVar File, FlagsVar FileMeasureFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) bool {
		return rawCallback(FileVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressDataVar, DiskUsageVar, NumDirsVar, NumFilesVar)
	}
}

// OverrideMeasureDiskUsageAsync sets the callback function.
// Asynchronously recursively measures the disk usage of @file. Since 2.38
func (x *FileIface) OverrideMeasureDiskUsageAsync(cb func(File, FileMeasureFlags, int, *Cancellable, *FileMeasureProgressCallback, uintptr, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xMeasureDiskUsageAsync = 0
	} else {
		x.xMeasureDiskUsageAsync = purego.NewCallback(func(FileVarp uintptr, FlagsVarp FileMeasureFlags, IoPriorityVarp int, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressDataVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&FileBase{Ptr: FileVarp}, FlagsVarp, IoPriorityVarp, CancellableNewFromInternalPtr(CancellableVarp), (*FileMeasureProgressCallback)(unsafe.Pointer(ProgressCallbackVarp)), ProgressDataVarp, (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetMeasureDiskUsageAsync gets the callback function.
// Asynchronously recursively measures the disk usage of @file. Since 2.38
func (x *FileIface) GetMeasureDiskUsageAsync() func(File, FileMeasureFlags, int, *Cancellable, *FileMeasureProgressCallback, uintptr, *AsyncReadyCallback, uintptr) {
	if x.xMeasureDiskUsageAsync == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, FlagsVarp FileMeasureFlags, IoPriorityVarp int, CancellableVarp uintptr, ProgressCallbackVarp uintptr, ProgressDataVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xMeasureDiskUsageAsync)
	return func(FileVar File, FlagsVar FileMeasureFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(FileVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressDataVar, glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideMeasureDiskUsageFinish sets the callback function.
// Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38
func (x *FileIface) OverrideMeasureDiskUsageFinish(cb func(File, AsyncResult, uint64, uint64, uint64) bool) {
	if cb == nil {
		x.xMeasureDiskUsageFinish = 0
	} else {
		x.xMeasureDiskUsageFinish = purego.NewCallback(func(FileVarp uintptr, ResultVarp uintptr, DiskUsageVarp uint64, NumDirsVarp uint64, NumFilesVarp uint64) bool {
			return cb(&FileBase{Ptr: FileVarp}, &AsyncResultBase{Ptr: ResultVarp}, DiskUsageVarp, NumDirsVarp, NumFilesVarp)
		})
	}
}

// GetMeasureDiskUsageFinish gets the callback function.
// Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38
func (x *FileIface) GetMeasureDiskUsageFinish() func(File, AsyncResult, uint64, uint64, uint64) bool {
	if x.xMeasureDiskUsageFinish == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, ResultVarp uintptr, DiskUsageVarp uint64, NumDirsVarp uint64, NumFilesVarp uint64) bool
	purego.RegisterFunc(&rawCallback, x.xMeasureDiskUsageFinish)
	return func(FileVar File, ResultVar AsyncResult, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) bool {
		return rawCallback(FileVar.GoPointer(), ResultVar.GoPointer(), DiskUsageVar, NumDirsVar, NumFilesVar)
	}
}

// OverrideQueryExists sets the callback function.
// Queries whether a file exists. Since 2.84
func (x *FileIface) OverrideQueryExists(cb func(File, *Cancellable) bool) {
	if cb == nil {
		x.xQueryExists = 0
	} else {
		x.xQueryExists = purego.NewCallback(func(FileVarp uintptr, CancellableVarp uintptr) bool {
			return cb(&FileBase{Ptr: FileVarp}, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetQueryExists gets the callback function.
// Queries whether a file exists. Since 2.84
func (x *FileIface) GetQueryExists() func(File, *Cancellable) bool {
	if x.xQueryExists == 0 {
		return nil
	}
	var rawCallback func(FileVarp uintptr, CancellableVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xQueryExists)
	return func(FileVar File, CancellableVar *Cancellable) bool {
		return rawCallback(FileVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// `GFile` is a high level abstraction for manipulating files on a
// virtual file system. `GFile`s are lightweight, immutable objects
// that do no I/O upon creation. It is necessary to understand that
// `GFile` objects do not represent files, merely an identifier for a
// file. All file content I/O is implemented as streaming operations
// (see [class@Gio.InputStream] and [class@Gio.OutputStream]).
//
// To construct a `GFile`, you can use:
//
//   - [func@Gio.File.new_for_path] if you have a path.
//   - [func@Gio.File.new_for_uri] if you have a URI.
//   - [func@Gio.File.new_for_commandline_arg] or
//     [func@Gio.File.new_for_commandline_arg_and_cwd] for a command line
//     argument.
//   - [func@Gio.File.new_tmp] to create a temporary file from a template.
//   - [func@Gio.File.new_tmp_async] to asynchronously create a temporary file.
//   - [func@Gio.File.new_tmp_dir_async] to asynchronously create a temporary
//     directory.
//   - [func@Gio.File.parse_name] from a UTF-8 string gotten from
//     [method@Gio.File.get_parse_name].
//   - [func@Gio.File.new_build_filename] or [func@Gio.File.new_build_filenamev]
//     to create a file from path elements.
//
// One way to think of a `GFile` is as an abstraction of a pathname. For
// normal files the system pathname is what is stored internally, but as
// `GFile`s are extensible it could also be something else that corresponds
// to a pathname in a userspace implementation of a filesystem.
//
// `GFile`s make up hierarchies of directories and files that correspond to
// the files on a filesystem. You can move through the file system with
// `GFile` using [method@Gio.File.get_parent] to get an identifier for the
// parent directory, [method@Gio.File.get_child] to get a child within a
// directory, and [method@Gio.File.resolve_relative_path] to resolve a relative
// path between two `GFile`s. There can be multiple hierarchies, so you may not
// end up at the same root if you repeatedly call [method@Gio.File.get_parent]
// on two different files.
//
// All `GFile`s have a basename (get with [method@Gio.File.get_basename]). These
// names are byte strings that are used to identify the file on the filesystem
// (relative to its parent directory) and there is no guarantees that they
// have any particular charset encoding or even make any sense at all. If
// you want to use filenames in a user interface you should use the display
// name that you can get by requesting the
// `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME` attribute with
// [method@Gio.File.query_info]. This is guaranteed to be in UTF-8 and can be
// used in a user interface. But always store the real basename or the `GFile`
// to use to actually access the file, because there is no way to go from a
// display name to the actual name.
//
// Using `GFile` as an identifier has the same weaknesses as using a path
// in that there may be multiple aliases for the same file. For instance,
// hard or soft links may cause two different `GFile`s to refer to the same
// file. Other possible causes for aliases are: case insensitive filesystems,
// short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
// check if two `GFile`s point to the same file you can query for the
// `G_FILE_ATTRIBUTE_ID_FILE` attribute. Note that `GFile` does some trivial
// canonicalization of pathnames passed in, so that trivial differences in
// the path string used at creation (duplicated slashes, slash at end of
// path, `.` or `..` path segments, etc) does not create different `GFile`s.
//
// Many `GFile` operations have both synchronous and asynchronous versions
// to suit your application. Asynchronous versions of synchronous functions
// simply have `_async()` appended to their function names. The asynchronous
// I/O functions call a [callback@Gio.AsyncReadyCallback] which is then used to
// finalize the operation, producing a [iface@Gio.AsyncResult] which is then
// passed to the functions matching `_finish()` operation.
//
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section](overview.html#asynchronous-programming)
// for more.
//
// Some `GFile` operations almost always take a noticeable amount of time, and
// so do not have synchronous analogs. Notable cases include:
//
//   - [method@Gio.File.mount_mountable] to mount a mountable file.
//   - [method@Gio.File.unmount_mountable_with_operation] to unmount a mountable
//     file.
//   - [method@Gio.File.eject_mountable_with_operation] to eject a mountable file.
//
// ## Entity Tags
//
// One notable feature of `GFile`s are entity tags, or etags for
// short. Entity tags are somewhat like a more abstract version of the
// traditional mtime, and can be used to quickly determine if the file
// has been modified from the version on the file system. See the
// HTTP 1.1
// [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
// for HTTP `ETag` headers, which are a very similar concept.
type File interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	AppendTo(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error)
	AppendToAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	AppendToFinish(ResVar AsyncResult) (*FileOutputStream, error)
	BuildAttributeListForCopy(FlagsVar FileCopyFlags, CancellableVar *Cancellable) (string, error)
	Copy(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) (bool, error)
	CopyAsync(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	CopyAsyncWithClosures(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackClosureVar *gobject.Closure, ReadyCallbackClosureVar *gobject.Closure)
	CopyAttributes(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable) (bool, error)
	CopyFinish(ResVar AsyncResult) (bool, error)
	Create(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error)
	CreateAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	CreateFinish(ResVar AsyncResult) (*FileOutputStream, error)
	CreateReadwrite(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileIOStream, error)
	CreateReadwriteAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	CreateReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error)
	Delete(CancellableVar *Cancellable) (bool, error)
	DeleteAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	DeleteFinish(ResultVar AsyncResult) (bool, error)
	Dup() *FileBase
	EjectMountable(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectMountableFinish(ResultVar AsyncResult) (bool, error)
	EjectMountableWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectMountableWithOperationFinish(ResultVar AsyncResult) (bool, error)
	EnumerateChildren(AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (*FileEnumerator, error)
	EnumerateChildrenAsync(AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EnumerateChildrenFinish(ResVar AsyncResult) (*FileEnumerator, error)
	Equal(File2Var File) bool
	FindEnclosingMount(CancellableVar *Cancellable) (*MountBase, error)
	FindEnclosingMountAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	FindEnclosingMountFinish(ResVar AsyncResult) (*MountBase, error)
	GetBasename() string
	GetChild(NameVar string) *FileBase
	GetChildForDisplayName(DisplayNameVar string) (*FileBase, error)
	GetParent() *FileBase
	GetParseName() string
	GetPath() string
	GetRelativePath(DescendantVar File) string
	GetUri() string
	GetUriScheme() string
	HasParent(ParentVar File) bool
	HasPrefix(PrefixVar File) bool
	HasUriScheme(UriSchemeVar string) bool
	Hash() uint
	IsNative() bool
	LoadBytes(CancellableVar *Cancellable, EtagOutVar string) (*glib.Bytes, error)
	LoadBytesAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	LoadBytesFinish(ResultVar AsyncResult, EtagOutVar string) (*glib.Bytes, error)
	LoadContents(CancellableVar *Cancellable, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error)
	LoadContentsAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	LoadContentsFinish(ResVar AsyncResult, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error)
	LoadPartialContentsAsync(CancellableVar *Cancellable, ReadMoreCallbackVar *FileReadMoreCallback, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	LoadPartialContentsFinish(ResVar AsyncResult, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error)
	MakeDirectory(CancellableVar *Cancellable) (bool, error)
	MakeDirectoryAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MakeDirectoryFinish(ResultVar AsyncResult) (bool, error)
	MakeDirectoryWithParents(CancellableVar *Cancellable) (bool, error)
	MakeSymbolicLink(SymlinkValueVar string, CancellableVar *Cancellable) (bool, error)
	MakeSymbolicLinkAsync(SymlinkValueVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MakeSymbolicLinkFinish(ResultVar AsyncResult) (bool, error)
	MeasureDiskUsage(FlagsVar FileMeasureFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) (bool, error)
	MeasureDiskUsageAsync(FlagsVar FileMeasureFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MeasureDiskUsageFinish(ResultVar AsyncResult, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) (bool, error)
	Monitor(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error)
	MonitorDirectory(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error)
	MonitorFile(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error)
	MountEnclosingVolume(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MountEnclosingVolumeFinish(ResultVar AsyncResult) (bool, error)
	MountMountable(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MountMountableFinish(ResultVar AsyncResult) (*FileBase, error)
	Move(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) (bool, error)
	MoveAsync(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MoveAsyncWithClosures(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackClosureVar *gobject.Closure, ReadyCallbackClosureVar *gobject.Closure)
	MoveFinish(ResultVar AsyncResult) (bool, error)
	OpenReadwrite(CancellableVar *Cancellable) (*FileIOStream, error)
	OpenReadwriteAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	OpenReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error)
	PeekPath() string
	PollMountable(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	PollMountableFinish(ResultVar AsyncResult) (bool, error)
	QueryDefaultHandler(CancellableVar *Cancellable) (*AppInfoBase, error)
	QueryDefaultHandlerAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	QueryDefaultHandlerFinish(ResultVar AsyncResult) (*AppInfoBase, error)
	QueryExists(CancellableVar *Cancellable) bool
	QueryFileType(FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) FileType
	QueryFilesystemInfo(AttributesVar string, CancellableVar *Cancellable) (*FileInfo, error)
	QueryFilesystemInfoAsync(AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	QueryFilesystemInfoFinish(ResVar AsyncResult) (*FileInfo, error)
	QueryInfo(AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (*FileInfo, error)
	QueryInfoAsync(AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	QueryInfoFinish(ResVar AsyncResult) (*FileInfo, error)
	QuerySettableAttributes(CancellableVar *Cancellable) (*FileAttributeInfoList, error)
	QueryWritableNamespaces(CancellableVar *Cancellable) (*FileAttributeInfoList, error)
	Read(CancellableVar *Cancellable) (*FileInputStream, error)
	ReadAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReadFinish(ResVar AsyncResult) (*FileInputStream, error)
	Replace(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error)
	ReplaceAsync(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReplaceContents(ContentsVar string, LengthVar uint, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, NewEtagVar string, CancellableVar *Cancellable) (bool, error)
	ReplaceContentsAsync(ContentsVar string, LengthVar uint, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReplaceContentsBytesAsync(ContentsVar *glib.Bytes, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReplaceContentsFinish(ResVar AsyncResult, NewEtagVar string) (bool, error)
	ReplaceFinish(ResVar AsyncResult) (*FileOutputStream, error)
	ReplaceReadwrite(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileIOStream, error)
	ReplaceReadwriteAsync(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReplaceReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error)
	ResolveRelativePath(RelativePathVar string) *FileBase
	SetAttribute(AttributeVar string, TypeVar FileAttributeType, ValuePVar uintptr, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error)
	SetAttributeByteString(AttributeVar string, ValueVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error)
	SetAttributeInt32(AttributeVar string, ValueVar int32, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error)
	SetAttributeInt64(AttributeVar string, ValueVar int64, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error)
	SetAttributeString(AttributeVar string, ValueVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error)
	SetAttributeUint32(AttributeVar string, ValueVar uint32, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error)
	SetAttributeUint64(AttributeVar string, ValueVar uint64, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error)
	SetAttributesAsync(InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	SetAttributesFinish(ResultVar AsyncResult, InfoVar **FileInfo) (bool, error)
	SetAttributesFromInfo(InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error)
	SetDisplayName(DisplayNameVar string, CancellableVar *Cancellable) (*FileBase, error)
	SetDisplayNameAsync(DisplayNameVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	SetDisplayNameFinish(ResVar AsyncResult) (*FileBase, error)
	StartMountable(FlagsVar DriveStartFlags, StartOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	StartMountableFinish(ResultVar AsyncResult) (bool, error)
	StopMountable(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	StopMountableFinish(ResultVar AsyncResult) (bool, error)
	SupportsThreadContexts() bool
	Trash(CancellableVar *Cancellable) (bool, error)
	TrashAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	TrashFinish(ResultVar AsyncResult) (bool, error)
	UnmountMountable(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	UnmountMountableFinish(ResultVar AsyncResult) (bool, error)
	UnmountMountableWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	UnmountMountableWithOperationFinish(ResultVar AsyncResult) (bool, error)
}

var xFileGLibType func() types.GType

func FileGLibType() types.GType {
	return xFileGLibType()
}

type FileBase struct {
	Ptr uintptr
}

func (x *FileBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *FileBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Gets an output stream for appending data to the file.
// If the file doesn't already exist it is created.
//
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level that
// is supported on the target filesystem.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// Some file systems don't allow all file names, and may return an
// %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
// %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
// possible too, and depend on what kind of filesystem the file is on.
func (x *FileBase) AppendTo(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileAppendTo(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously opens @file for appending.
//
// For more details, see g_file_append_to() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_append_to_finish() to get the result
// of the operation.
func (x *FileBase) AppendToAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileAppendToAsync(x.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file append operation started with
// g_file_append_to_async().
func (x *FileBase) AppendToFinish(ResVar AsyncResult) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileAppendToFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Prepares the file attribute query string for copying to @file.
//
// This function prepares an attribute query string to be
// passed to g_file_query_info() to get a list of attributes
// normally copied with the file (see g_file_copy_attributes()
// for the detailed description). This function is used by the
// implementation of g_file_copy_attributes() and is useful
// when one needs to query and set the attributes in two
// stages (e.g., for recursive move of a directory).
func (x *FileBase) BuildAttributeListForCopy(FlagsVar FileCopyFlags, CancellableVar *Cancellable) (string, error) {
	var cerr *glib.Error

	cret := XGFileBuildAttributeListForCopy(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Copies the file @source to the location specified by @destination.
// Can not handle recursive copies of directories.
//
// If the flag %G_FILE_COPY_OVERWRITE is specified an already
// existing @destination file is overwritten.
//
// If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
// will be copied as symlinks, otherwise the target of the
// @source symlink will be copied.
//
// If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
// that is possible to copy is copied, not just the default subset (which,
// for instance, does not include the owner, see #GFileInfo).
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If @progress_callback is not %NULL, then the operation can be monitored
// by setting this to a #GFileProgressCallback function.
// @progress_callback_data will be passed to this function. It is guaranteed
// that this callback will be called after all data has been transferred with
// the total number of bytes copied during the operation.
//
// If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND error
// is returned, independent on the status of the @destination.
//
// If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
// the error %G_IO_ERROR_EXISTS is returned.
//
// If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
// error is returned. If trying to overwrite a directory with a directory the
// %G_IO_ERROR_WOULD_MERGE error is returned.
//
// If the source is a directory and the target does not exist, or
// %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
// %G_IO_ERROR_WOULD_RECURSE error is returned.
//
// If you are interested in copying the #GFile object itself (not the on-disk
// file), see g_file_dup().
func (x *FileBase) Copy(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) (bool, error) {
	var cerr *glib.Error

	cret := XGFileCopy(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressCallbackDataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Copies the file @source to the location specified by @destination
// asynchronously. For details of the behaviour, see g_file_copy().
//
// If @progress_callback is not %NULL, then that function that will be called
// just like in g_file_copy(). The callback will run in the default main context
// of the thread calling g_file_copy_async()  the same context as @callback is
// run in.
//
// When the operation is finished, @callback will be called. You can then call
// g_file_copy_finish() to get the result of the operation.
func (x *FileBase) CopyAsync(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileCopyAsync(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressCallbackDataVar, glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Version of [method@Gio.File.copy_async] using closures instead of callbacks for
// easier binding in other languages.
func (x *FileBase) CopyAsyncWithClosures(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackClosureVar *gobject.Closure, ReadyCallbackClosureVar *gobject.Closure) {

	XGFileCopyAsyncWithClosures(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), ProgressCallbackClosureVar, ReadyCallbackClosureVar)

}

// Copies the file attributes from @source to @destination.
//
// Normally only a subset of the file attributes are copied,
// those that are copies in a normal file copy operation
// (which for instance does not include e.g. owner). However
// if %G_FILE_COPY_ALL_METADATA is specified in @flags, then
// all the metadata that is possible to copy is copied. This
// is useful when implementing move by copy + delete source.
func (x *FileBase) CopyAttributes(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileCopyAttributes(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Finishes copying the file started with g_file_copy_async().
func (x *FileBase) CopyFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileCopyFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Creates a new file and returns an output stream for writing to it.
// The file must not already exist.
//
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level
// that is supported on the target filesystem.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If a file or directory with this name already exists the
// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
// error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
// be returned. Other errors are possible too, and depend on what kind
// of filesystem the file is on.
func (x *FileBase) Create(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileCreate(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously creates a new file and returns an output stream
// for writing to it. The file must not already exist.
//
// For more details, see g_file_create() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_create_finish() to get the result
// of the operation.
func (x *FileBase) CreateAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileCreateAsync(x.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file create operation started with
// g_file_create_async().
func (x *FileBase) CreateFinish(ResVar AsyncResult) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileCreateFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
//
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level
// that is supported on the target filesystem.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If a file or directory with this name already exists, the
// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
// error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
// will be returned. Other errors are possible too, and depend on what
// kind of filesystem the file is on.
//
// Note that in many non-local file cases read and write streams are
// not supported, so make sure you really need to do read and write
// streaming, rather than just opening for reading or writing.
func (x *FileBase) CreateReadwrite(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileCreateReadwrite(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously creates a new file and returns a stream
// for reading and writing to it. The file must not already exist.
//
// For more details, see g_file_create_readwrite() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_create_readwrite_finish() to get
// the result of the operation.
func (x *FileBase) CreateReadwriteAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileCreateReadwriteAsync(x.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file create operation started with
// g_file_create_readwrite_async().
func (x *FileBase) CreateReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileCreateReadwriteFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Deletes a file. If the @file is a directory, it will only be
// deleted if it is empty. This has the same semantics as g_unlink().
//
// If @file doesnt exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
// for deletion to be implemented avoiding
// [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
// |[
// g_autoptr(GError) local_error = NULL;
// if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
//
//	  !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
//	{
//	  // deletion failed for some reason other than the file not existing:
//	  // so report the error
//	  g_warning ("Failed to delete %s: %s",
//	             g_file_peek_path (my_file), local_error-&gt;message);
//	}
//
// ]|
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) Delete(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileDelete(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously delete a file. If the @file is a directory, it will
// only be deleted if it is empty.  This has the same semantics as
// g_unlink().
func (x *FileBase) DeleteAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileDeleteAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes deleting a file started with g_file_delete_async().
func (x *FileBase) DeleteFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileDeleteFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Duplicates a #GFile handle. This operation does not duplicate
// the actual file or directory represented by the #GFile; see
// g_file_copy() if attempting to copy a file.
//
// g_file_dup() is useful when a second handle is needed to the same underlying
// file, for use in a separate thread (#GFile is not thread-safe). For use
// within the same thread, use g_object_ref() to increment the existing objects
// reference count.
//
// This call does no blocking I/O.
func (x *FileBase) Dup() *FileBase {
	var cls *FileBase

	cret := XGFileDup(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Starts an asynchronous eject on a mountable.
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_eject_mountable_finish().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) EjectMountable(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileEjectMountable(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous eject operation started by
// g_file_eject_mountable().
func (x *FileBase) EjectMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileEjectMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Starts an asynchronous eject on a mountable.
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_eject_mountable_with_operation_finish().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) EjectMountableWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileEjectMountableWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous eject operation started by
// g_file_eject_mountable_with_operation().
func (x *FileBase) EjectMountableWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileEjectMountableWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the requested information about the files in a directory.
// The result is a #GFileEnumerator object that will give out
// #GFileInfo objects for all the files in the directory.
//
// The @attributes value is a string that specifies the file
// attributes that should be gathered. It is not an error if
// it's not possible to read a particular requested attribute
// from a file - it just won't be set. @attributes should
// be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like
// "standard::*" means all attributes in the standard namespace.
// An example attribute query be "standard::*,owner::user".
// The standard attributes are available as defines, like
// %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
// always be specified if you plan to call g_file_enumerator_get_child() or
// g_file_enumerator_iterate() on the returned enumerator.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
// error will be returned. Other errors are possible too.
func (x *FileBase) EnumerateChildren(AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (*FileEnumerator, error) {
	var cls *FileEnumerator
	var cerr *glib.Error

	cret := XGFileEnumerateChildren(x.GoPointer(), AttributesVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileEnumerator{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously gets the requested information about the files
// in a directory. The result is a #GFileEnumerator object that will
// give out #GFileInfo objects for all the files in the directory.
//
// For more details, see g_file_enumerate_children() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can
// then call g_file_enumerate_children_finish() to get the result of
// the operation.
func (x *FileBase) EnumerateChildrenAsync(AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileEnumerateChildrenAsync(x.GoPointer(), AttributesVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an async enumerate children operation.
// See g_file_enumerate_children_async().
func (x *FileBase) EnumerateChildrenFinish(ResVar AsyncResult) (*FileEnumerator, error) {
	var cls *FileEnumerator
	var cerr *glib.Error

	cret := XGFileEnumerateChildrenFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileEnumerator{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Checks if the two given #GFiles refer to the same file.
//
// Note that two #GFiles that differ can still refer to the same
// file on the filesystem due to various forms of filename
// aliasing.
//
// This call does no blocking I/O.
func (x *FileBase) Equal(File2Var File) bool {

	cret := XGFileEqual(x.GoPointer(), File2Var.GoPointer())
	return cret
}

// Gets a #GMount for the #GFile.
//
// #GMount is returned only for user interesting locations, see
// #GVolumeMonitor. If the #GFileIface for @file does not have a #mount,
// @error will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) FindEnclosingMount(CancellableVar *Cancellable) (*MountBase, error) {
	var cls *MountBase
	var cerr *glib.Error

	cret := XGFileFindEnclosingMount(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &MountBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously gets the mount for the file.
//
// For more details, see g_file_find_enclosing_mount() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_find_enclosing_mount_finish() to
// get the result of the operation.
func (x *FileBase) FindEnclosingMountAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileFindEnclosingMountAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous find mount request.
// See g_file_find_enclosing_mount_async().
func (x *FileBase) FindEnclosingMountFinish(ResVar AsyncResult) (*MountBase, error) {
	var cls *MountBase
	var cerr *glib.Error

	cret := XGFileFindEnclosingMountFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &MountBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Gets the base name (the last component of the path) for a given #GFile.
//
// If called for the top level of a system (such as the filesystem root
// or a uri like sftp://host/) it will return a single directory separator
// (and on Windows, possibly a drive letter).
//
// The base name is a byte string (not UTF-8). It has no defined encoding
// or rules other than it may not contain zero bytes.  If you want to use
// filenames in a user interface you should use the display name that you
// can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
// attribute with g_file_query_info().
//
// This call does no blocking I/O.
func (x *FileBase) GetBasename() string {

	cret := XGFileGetBasename(x.GoPointer())
	return cret
}

// Gets a child of @file with basename equal to @name.
//
// Note that the file with that specific name might not exist, but
// you can still have a #GFile that points to it. You can use this
// for instance to create that file.
//
// This call does no blocking I/O.
func (x *FileBase) GetChild(NameVar string) *FileBase {
	var cls *FileBase

	cret := XGFileGetChild(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the child of @file for a given @display_name (i.e. a UTF-8
// version of the name). If this function fails, it returns %NULL
// and @error will be set. This is very useful when constructing a
// #GFile for a new file and the user entered the filename in the
// user interface, for instance when you select a directory and
// type a filename in the file selector.
//
// This call does no blocking I/O.
func (x *FileBase) GetChildForDisplayName(DisplayNameVar string) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := XGFileGetChildForDisplayName(x.GoPointer(), DisplayNameVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Gets the parent directory for the @file.
// If the @file represents the root directory of the
// file system, then %NULL will be returned.
//
// This call does no blocking I/O.
func (x *FileBase) GetParent() *FileBase {
	var cls *FileBase

	cret := XGFileGetParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the parse name of the @file.
// A parse name is a UTF-8 string that describes the
// file such that one can get the #GFile back using
// g_file_parse_name().
//
// This is generally used to show the #GFile as a nice
// full-pathname kind of string in a user interface,
// like in a location entry.
//
// For local files with names that can safely be converted
// to UTF-8 the pathname is used, otherwise the IRI is used
// (a form of URI that allows UTF-8 characters unescaped).
//
// This call does no blocking I/O.
func (x *FileBase) GetParseName() string {

	cret := XGFileGetParseName(x.GoPointer())
	return cret
}

// Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
// guaranteed to be an absolute, canonical path. It might contain symlinks.
//
// This call does no blocking I/O.
func (x *FileBase) GetPath() string {

	cret := XGFileGetPath(x.GoPointer())
	return cret
}

// Gets the path for @descendant relative to @parent.
//
// This call does no blocking I/O.
func (x *FileBase) GetRelativePath(DescendantVar File) string {

	cret := XGFileGetRelativePath(x.GoPointer(), DescendantVar.GoPointer())
	return cret
}

// Gets the URI for the @file.
//
// This call does no blocking I/O.
func (x *FileBase) GetUri() string {

	cret := XGFileGetUri(x.GoPointer())
	return cret
}

// Gets the URI scheme for a #GFile.
// RFC 3986 decodes the scheme as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include "file", "http", "ftp", etc.
//
// The scheme can be different from the one used to construct the #GFile,
// in that it might be replaced with one that is logically equivalent to the #GFile.
//
// This call does no blocking I/O.
func (x *FileBase) GetUriScheme() string {

	cret := XGFileGetUriScheme(x.GoPointer())
	return cret
}

// Checks if @file has a parent, and optionally, if it is @parent.
//
// If @parent is %NULL then this function returns %TRUE if @file has any
// parent at all.  If @parent is non-%NULL then %TRUE is only returned
// if @file is an immediate child of @parent.
func (x *FileBase) HasParent(ParentVar File) bool {

	cret := XGFileHasParent(x.GoPointer(), ParentVar.GoPointer())
	return cret
}

// Checks whether @file has the prefix specified by @prefix.
//
// In other words, if the names of initial elements of @file's
// pathname match @prefix. Only full pathname elements are matched,
// so a path like /foo is not considered a prefix of /foobar, only
// of /foo/bar.
//
// A #GFile is not a prefix of itself. If you want to check for
// equality, use g_file_equal().
//
// This call does no I/O, as it works purely on names. As such it can
// sometimes return %FALSE even if @file is inside a @prefix (from a
// filesystem point of view), because the prefix of @file is an alias
// of @prefix.
func (x *FileBase) HasPrefix(PrefixVar File) bool {

	cret := XGFileHasPrefix(x.GoPointer(), PrefixVar.GoPointer())
	return cret
}

// Checks to see if a #GFile has a given URI scheme.
//
// This call does no blocking I/O.
func (x *FileBase) HasUriScheme(UriSchemeVar string) bool {

	cret := XGFileHasUriScheme(x.GoPointer(), UriSchemeVar)
	return cret
}

// Creates a hash value for a #GFile.
//
// This call does no blocking I/O.
func (x *FileBase) Hash() uint {

	cret := XGFileHash(x.GoPointer())
	return cret
}

// Checks to see if a file is native to the platform.
//
// A native file is one expressed in the platform-native filename format,
// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
// as it might be on a locally mounted remote filesystem.
//
// On some systems non-native files may be available using the native
// filesystem via a userspace filesystem (FUSE), in these cases this call
// will return %FALSE, but g_file_get_path() will still return a native path.
//
// This call does no blocking I/O.
func (x *FileBase) IsNative() bool {

	cret := XGFileIsNative(x.GoPointer())
	return cret
}

// Loads the contents of @file and returns it as #GBytes.
//
// If @file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents() and g_bytes_new_take().
//
// For resources, @etag_out will be set to %NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
func (x *FileBase) LoadBytes(CancellableVar *Cancellable, EtagOutVar string) (*glib.Bytes, error) {
	var cerr *glib.Error

	cret := XGFileLoadBytes(x.GoPointer(), CancellableVar.GoPointer(), EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously loads the contents of @file as #GBytes.
//
// If @file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents_async() and g_bytes_new_take().
//
// @callback should call g_file_load_bytes_finish() to get the result of this
// asynchronous operation.
//
// See g_file_load_bytes() for more information.
func (x *FileBase) LoadBytesAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileLoadBytesAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Completes an asynchronous request to g_file_load_bytes_async().
//
// For resources, @etag_out will be set to %NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
//
// See g_file_load_bytes() for more information.
func (x *FileBase) LoadBytesFinish(ResultVar AsyncResult, EtagOutVar string) (*glib.Bytes, error) {
	var cerr *glib.Error

	cret := XGFileLoadBytesFinish(x.GoPointer(), ResultVar.GoPointer(), EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Loads the content of the file into memory. The data is always
// zero-terminated, but this is not included in the resultant @length.
// The returned @contents should be freed with g_free() when no longer
// needed.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) LoadContents(CancellableVar *Cancellable, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGFileLoadContents(x.GoPointer(), CancellableVar.GoPointer(), ContentsVar, LengthVar, EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Starts an asynchronous load of the @file's contents.
//
// For more details, see g_file_load_contents() which is
// the synchronous version of this call.
//
// When the load operation has completed, @callback will be called
// with @user data. To finish the operation, call
// g_file_load_contents_finish() with the #GAsyncResult returned by
// the @callback.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) LoadContentsAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileLoadContentsAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous load of the @file's contents.
// The contents are placed in @contents, and @length is set to the
// size of the @contents string. The @contents should be freed with
// g_free() when no longer needed. If @etag_out is present, it will be
// set to the new entity tag for the @file.
func (x *FileBase) LoadContentsFinish(ResVar AsyncResult, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGFileLoadContentsFinish(x.GoPointer(), ResVar.GoPointer(), ContentsVar, LengthVar, EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Reads the partial contents of a file. A #GFileReadMoreCallback should
// be used to stop reading from the file when appropriate, else this
// function will behave exactly as g_file_load_contents_async(). This
// operation can be finished by g_file_load_partial_contents_finish().
//
// Users of this function should be aware that @user_data is passed to
// both the @read_more_callback and the @callback.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) LoadPartialContentsAsync(CancellableVar *Cancellable, ReadMoreCallbackVar *FileReadMoreCallback, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileLoadPartialContentsAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(ReadMoreCallbackVar), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous partial load operation that was started
// with g_file_load_partial_contents_async(). The data is always
// zero-terminated, but this is not included in the resultant @length.
// The returned @contents should be freed with g_free() when no longer
// needed.
func (x *FileBase) LoadPartialContentsFinish(ResVar AsyncResult, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGFileLoadPartialContentsFinish(x.GoPointer(), ResVar.GoPointer(), ContentsVar, LengthVar, EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Creates a directory.
//
// Note that this will only create a child directory
// of the immediate parent directory of the path or URI given by the #GFile.
// To recursively create directories, see g_file_make_directory_with_parents().
//
// This function will fail if the parent directory does not exist, setting
// @error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
// creating directories, this function will fail, setting @error to
// %G_IO_ERROR_NOT_SUPPORTED. If the directory already exists,
// [error@Gio.IOErrorEnum.EXISTS] will be returned.
//
// For a local #GFile the newly created directory will have the default
// (current) ownership and permissions of the current process.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) MakeDirectory(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeDirectory(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously creates a directory.
func (x *FileBase) MakeDirectoryAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMakeDirectoryAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous directory creation, started with
// g_file_make_directory_async().
func (x *FileBase) MakeDirectoryFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeDirectoryFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Creates a directory and any parent directories that may not
// exist similar to 'mkdir -p'. If the file system does not support
// creating directories, this function will fail, setting @error to
// %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
// this function will fail setting @error to %G_IO_ERROR_EXISTS, unlike
// the similar g_mkdir_with_parents().
//
// For a local #GFile the newly created directories will have the default
// (current) ownership and permissions of the current process.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) MakeDirectoryWithParents(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeDirectoryWithParents(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Creates a symbolic link named @file which contains the string
// @symlink_value.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) MakeSymbolicLink(SymlinkValueVar string, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeSymbolicLink(x.GoPointer(), SymlinkValueVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously creates a symbolic link named @file which contains the
// string @symlink_value.
func (x *FileBase) MakeSymbolicLinkAsync(SymlinkValueVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMakeSymbolicLinkAsync(x.GoPointer(), SymlinkValueVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous symbolic link creation, started with
// g_file_make_symbolic_link_async().
func (x *FileBase) MakeSymbolicLinkFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeSymbolicLinkFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Recursively measures the disk usage of @file.
//
// This is essentially an analog of the 'du' command, but it also
// reports the number of directories and non-directory files encountered
// (including things like symbolic links).
//
// By default, errors are only reported against the toplevel file
// itself.  Errors found while recursing are silently ignored, unless
// %G_FILE_MEASURE_REPORT_ANY_ERROR is given in @flags.
//
// The returned size, @disk_usage, is in bytes and should be formatted
// with g_format_size() in order to get something reasonable for showing
// in a user interface.
//
// @progress_callback and @progress_data can be given to request
// periodic progress updates while scanning.  See the documentation for
// #GFileMeasureProgressCallback for information about when and how the
// callback will be invoked.
func (x *FileBase) MeasureDiskUsage(FlagsVar FileMeasureFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMeasureDiskUsage(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressDataVar, DiskUsageVar, NumDirsVar, NumFilesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Recursively measures the disk usage of @file.
//
// This is the asynchronous version of g_file_measure_disk_usage().  See
// there for more information.
func (x *FileBase) MeasureDiskUsageAsync(FlagsVar FileMeasureFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMeasureDiskUsageAsync(x.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressDataVar, glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Collects the results from an earlier call to
// g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
// more information.
func (x *FileBase) MeasureDiskUsageFinish(ResultVar AsyncResult, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMeasureDiskUsageFinish(x.GoPointer(), ResultVar.GoPointer(), DiskUsageVar, NumDirsVar, NumFilesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Obtains a file or directory monitor for the given file,
// depending on the type of the file.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) Monitor(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error) {
	var cls *FileMonitor
	var cerr *glib.Error

	cret := XGFileMonitor(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileMonitor{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Obtains a directory monitor for the given file.
// This may fail if directory monitoring is not supported.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// It does not make sense for @flags to contain
// %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
// directories.  It is not possible to monitor all the files in a
// directory for changes made via hard links; if you want to do this then
// you must register individual watches with g_file_monitor().
func (x *FileBase) MonitorDirectory(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error) {
	var cls *FileMonitor
	var cerr *glib.Error

	cret := XGFileMonitorDirectory(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileMonitor{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Obtains a file monitor for the given file. If no file notification
// mechanism exists, then regular polling of the file is used.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If @flags contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
// will also attempt to report changes made to the file via another
// filename (ie, a hard link). Without this flag, you can only rely on
// changes made through the filename contained in @file to be
// reported. Using this flag may result in an increase in resource
// usage, and may not have any effect depending on the #GFileMonitor
// backend and/or filesystem type.
func (x *FileBase) MonitorFile(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error) {
	var cls *FileMonitor
	var cerr *glib.Error

	cret := XGFileMonitorFile(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileMonitor{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Starts a @mount_operation, mounting the volume that contains
// the file @location.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_mount_enclosing_volume_finish().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) MountEnclosingVolume(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMountEnclosingVolume(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes a mount operation started by g_file_mount_enclosing_volume().
func (x *FileBase) MountEnclosingVolumeFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMountEnclosingVolumeFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Mounts a file of type G_FILE_TYPE_MOUNTABLE.
// Using @mount_operation, you can request callbacks when, for instance,
// passwords are needed during authentication.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) MountMountable(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMountMountable(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes a mount operation. See g_file_mount_mountable() for details.
//
// Finish an asynchronous mount operation that was started
// with g_file_mount_mountable().
func (x *FileBase) MountMountableFinish(ResultVar AsyncResult) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := XGFileMountMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Tries to move the file or directory @source to the location specified
// by @destination. If native move operations are supported then this is
// used, otherwise a copy + delete fallback is used. The native
// implementation may support moving directories (for instance on moves
// inside the same filesystem), but the fallback code does not.
//
// If the flag %G_FILE_COPY_OVERWRITE is specified an already
// existing @destination file is overwritten.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If @progress_callback is not %NULL, then the operation can be monitored
// by setting this to a #GFileProgressCallback function.
// @progress_callback_data will be passed to this function. It is
// guaranteed that this callback will be called after all data has been
// transferred with the total number of bytes copied during the operation.
//
// If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND
// error is returned, independent on the status of the @destination.
//
// If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
// then the error %G_IO_ERROR_EXISTS is returned.
//
// If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
// error is returned. If trying to overwrite a directory with a directory the
// %G_IO_ERROR_WOULD_MERGE error is returned.
//
// If the source is a directory and the target does not exist, or
// %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
// the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
// move operation isn't available).
func (x *FileBase) Move(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMove(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressCallbackDataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously moves a file @source to the location of @destination. For details of the behaviour, see g_file_move().
//
// If @progress_callback is not %NULL, then that function that will be called
// just like in g_file_move(). The callback will run in the default main context
// of the thread calling g_file_move_async()  the same context as @callback is
// run in.
//
// When the operation is finished, @callback will be called. You can then call
// g_file_move_finish() to get the result of the operation.
func (x *FileBase) MoveAsync(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMoveAsync(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(ProgressCallbackVar), ProgressCallbackDataVar, glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Version of [method@Gio.File.move_async] using closures instead of callbacks for
// easier binding in other languages.
func (x *FileBase) MoveAsyncWithClosures(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackClosureVar *gobject.Closure, ReadyCallbackClosureVar *gobject.Closure) {

	XGFileMoveAsyncWithClosures(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), ProgressCallbackClosureVar, ReadyCallbackClosureVar)

}

// Finishes an asynchronous file movement, started with
// g_file_move_async().
func (x *FileBase) MoveFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMoveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Opens an existing file for reading and writing. The result is
// a #GFileIOStream that can be used to read and write the contents
// of the file.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
// error will be returned. Other errors are possible too, and depend on
// what kind of filesystem the file is on. Note that in many non-local
// file cases read and write streams are not supported, so make sure you
// really need to do read and write streaming, rather than just opening
// for reading or writing.
func (x *FileBase) OpenReadwrite(CancellableVar *Cancellable) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileOpenReadwrite(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously opens @file for reading and writing.
//
// For more details, see g_file_open_readwrite() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_open_readwrite_finish() to get
// the result of the operation.
func (x *FileBase) OpenReadwriteAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileOpenReadwriteAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
func (x *FileBase) OpenReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileOpenReadwriteFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full().  This is useful for example in C
// applications which mix `g_file_*` APIs with native ones.  It
// also avoids an extra duplicated string when possible, so will be
// generally more efficient.
//
// This call does no blocking I/O.
func (x *FileBase) PeekPath() string {

	cret := XGFilePeekPath(x.GoPointer())
	return cret
}

// Polls a file of type %G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) PollMountable(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFilePollMountable(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes a poll operation. See g_file_poll_mountable() for details.
//
// Finish an asynchronous poll operation that was polled
// with g_file_poll_mountable().
func (x *FileBase) PollMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFilePollMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Returns the #GAppInfo that is registered as the default
// application to handle the file specified by @file.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) QueryDefaultHandler(CancellableVar *Cancellable) (*AppInfoBase, error) {
	var cls *AppInfoBase
	var cerr *glib.Error

	cret := XGFileQueryDefaultHandler(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Async version of g_file_query_default_handler().
func (x *FileBase) QueryDefaultHandlerAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileQueryDefaultHandlerAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes a g_file_query_default_handler_async() operation.
func (x *FileBase) QueryDefaultHandlerFinish(ResultVar AsyncResult) (*AppInfoBase, error) {
	var cls *AppInfoBase
	var cerr *glib.Error

	cret := XGFileQueryDefaultHandlerFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Utility function to check if a particular file exists.
//
// The fallback implementation of this API is using [method@Gio.File.query_info]
// and therefore may do blocking I/O. To asynchronously query the existence
// of a file, use [method@Gio.File.query_info_async].
//
// Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
// and then execute something based on the outcome of that, because the
// file might have been created or removed in between the operations. The
// general approach to handling that is to not check, but just do the
// operation and handle the errors as they come.
//
// As an example of race-free checking, take the case of reading a file,
// and if it doesn't exist, creating it. There are two racy versions: read
// it, and on error create it; and: check if it exists, if not create it.
// These can both result in two processes creating the file (with perhaps
// a partially written file as the result). The correct approach is to
// always try to create the file with g_file_create() which will either
// atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
//
// However, in many cases an existence check is useful in a user interface,
// for instance to make a menu item sensitive/insensitive, so that you don't
// have to fool users that something is possible and then just show an error
// dialog. If you do this, you should make sure to also handle the errors
// that can happen due to races when you execute the operation.
func (x *FileBase) QueryExists(CancellableVar *Cancellable) bool {

	cret := XGFileQueryExists(x.GoPointer(), CancellableVar.GoPointer())
	return cret
}

// Utility function to inspect the #GFileType of a file. This is
// implemented using g_file_query_info() and as such does blocking I/O.
//
// The primary use case of this method is to check if a file is
// a regular file, directory, or symlink.
func (x *FileBase) QueryFileType(FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) FileType {

	cret := XGFileQueryFileType(x.GoPointer(), FlagsVar, CancellableVar.GoPointer())
	return cret
}

// Similar to g_file_query_info(), but obtains information
// about the filesystem the @file is on, rather than the file itself.
// For instance the amount of space available and the type of
// the filesystem.
//
// The @attributes value is a string that specifies the attributes
// that should be gathered. It is not an error if it's not possible
// to read a particular requested attribute from a file - it just
// won't be set. @attributes should be a comma-separated list of
// attributes or attribute wildcards. The wildcard "*" means all
// attributes, and a wildcard like "filesystem::*" means all attributes
// in the filesystem namespace. The standard namespace for filesystem
// attributes is "filesystem". Common attributes of interest are
// %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
// in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
// and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. Other errors are possible too, and depend on what
// kind of filesystem the file is on.
func (x *FileBase) QueryFilesystemInfo(AttributesVar string, CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := XGFileQueryFilesystemInfo(x.GoPointer(), AttributesVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously gets the requested information about the filesystem
// that the specified @file is on. The result is a #GFileInfo object
// that contains key-value attributes (such as type or size for the
// file).
//
// For more details, see g_file_query_filesystem_info() which is the
// synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can
// then call g_file_query_info_finish() to get the result of the
// operation.
func (x *FileBase) QueryFilesystemInfoAsync(AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileQueryFilesystemInfoAsync(x.GoPointer(), AttributesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous filesystem info query.
// See g_file_query_filesystem_info_async().
func (x *FileBase) QueryFilesystemInfoFinish(ResVar AsyncResult) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := XGFileQueryFilesystemInfoFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Gets the requested information about specified @file.
//
// The result is a [class@Gio.FileInfo] object that contains key-value
// attributes (such as the type or size of the file).
//
// The @attributes value is a string that specifies the file
// attributes that should be gathered. It is not an error if
// its not possible to read a particular requested attribute
// from a file  it just won't be set. In particular this means that if a file
// is inaccessible (due to being in a folder with restrictive permissions), for
// example, you can expect the returned [class@Gio.FileInfo] to have very few
// attributes set. You should check whether an attribute is set using
// [method@Gio.FileInfo.has_attribute] before trying to retrieve its value.
//
// It is guaranteed that if any of the following attributes are listed in
// @attributes, they will always be set in the returned [class@Gio.FileInfo],
// even if the user doesnt have permissions to access the file:
//
//   - [const@Gio.FILE_ATTRIBUTE_STANDARD_NAME]
//   - [const@Gio.FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME]
//
// @attributes should be a comma-separated list of attributes or attribute
// wildcards. The wildcard `"*"` means all attributes, and a wildcard like
// `"standard::*"` means all attributes in the standard namespace.
// An example attribute query might be `"standard::*,owner::user"`.
// The standard attributes are available as defines, like
// [const@Gio.FILE_ATTRIBUTE_STANDARD_NAME].
//
// If @cancellable is not `NULL`, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be
// returned.
//
// For symlinks, normally the information about the target of the
// symlink is returned, rather than information about the symlink
// itself. However if you pass [flags@Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS]
// in @flags the information about the symlink itself will be returned.
// Also, for symlinks that point to non-existing files the information
// about the symlink itself will be returned.
//
// If the file does not exist, the [error@Gio.IOErrorEnum.NOT_FOUND] error will be
// returned. Other errors are possible too, and depend on what kind of
// file system the file is on.
func (x *FileBase) QueryInfo(AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := XGFileQueryInfo(x.GoPointer(), AttributesVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously gets the requested information about specified @file.
// The result is a #GFileInfo object that contains key-value attributes
// (such as type or size for the file).
//
// For more details, see g_file_query_info() which is the synchronous
// version of this call.
//
// When the operation is finished, @callback will be called. You can
// then call g_file_query_info_finish() to get the result of the operation.
func (x *FileBase) QueryInfoAsync(AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileQueryInfoAsync(x.GoPointer(), AttributesVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file info query.
// See g_file_query_info_async().
func (x *FileBase) QueryInfoFinish(ResVar AsyncResult) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := XGFileQueryInfoFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Obtain the list of settable attributes for the file.
//
// Returns the type and full attribute name of all the attributes
// that can be set on this file. This doesn't mean setting it will
// always succeed though, you might get an access failure, or some
// specific file may not support a specific attribute.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) QuerySettableAttributes(CancellableVar *Cancellable) (*FileAttributeInfoList, error) {
	var cerr *glib.Error

	cret := XGFileQuerySettableAttributes(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Obtain the list of attribute namespaces where new attributes
// can be created by a user. An example of this is extended
// attributes (in the "xattr" namespace).
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) QueryWritableNamespaces(CancellableVar *Cancellable) (*FileAttributeInfoList, error) {
	var cerr *glib.Error

	cret := XGFileQueryWritableNamespaces(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Opens a file for reading. The result is a #GFileInputStream that
// can be used to read the contents of the file.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
// returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
// error will be returned. Other errors are possible too, and depend
// on what kind of filesystem the file is on.
func (x *FileBase) Read(CancellableVar *Cancellable) (*FileInputStream, error) {
	var cls *FileInputStream
	var cerr *glib.Error

	cret := XGFileRead(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously opens @file for reading.
//
// For more details, see g_file_read() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_read_finish() to get the result
// of the operation.
func (x *FileBase) ReadAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReadAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file read operation started with
// g_file_read_async().
func (x *FileBase) ReadFinish(ResVar AsyncResult) (*FileInputStream, error) {
	var cls *FileInputStream
	var cerr *glib.Error

	cret := XGFileReadFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Returns an output stream for overwriting the file, possibly
// creating a backup copy of the file first. If the file doesn't exist,
// it will be created.
//
// This will try to replace the file in the safest way possible so
// that any errors during the writing will not affect an already
// existing copy of the file. For instance, for local files it
// may write to a temporary file and then atomically rename over
// the destination when the stream is closed.
//
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level that
// is supported on the target filesystem.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If you pass in a non-%NULL @etag value and @file already exists, then
// this value is compared to the current entity tag of the file, and if
// they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
// generally means that the file has been changed since you last read
// it. You can get the new etag from g_file_output_stream_get_etag()
// after you've finished writing and closed the #GFileOutputStream. When
// you load a new file you can use g_file_input_stream_query_info() to
// get the etag of the file.
//
// If @make_backup is %TRUE, this function will attempt to make a
// backup of the current file before overwriting it. If this fails
// a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
// want to replace anyway, try again with @make_backup set to %FALSE.
//
// If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
// be returned, and if the file is some other form of non-regular file
// then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
// file systems don't allow all file names, and may return an
// %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
// %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
// possible too, and depend on what kind of filesystem the file is on.
func (x *FileBase) Replace(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileReplace(x.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously overwrites the file, replacing the contents,
// possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_replace_finish() to get the result
// of the operation.
func (x *FileBase) ReplaceAsync(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReplaceAsync(x.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Replaces the contents of @file with @contents of @length bytes.
//
// If @etag is specified (not %NULL), any existing file must have that etag,
// or the error %G_IO_ERROR_WRONG_ETAG will be returned.
//
// If @make_backup is %TRUE, this function will attempt to make a backup
// of @file. Internally, it uses g_file_replace(), so will try to replace the
// file contents in the safest way possible. For example, atomic renames are
// used when replacing local files contents.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// The returned @new_etag can be used to verify that the file hasn't
// changed the next time it is saved over.
func (x *FileBase) ReplaceContents(ContentsVar string, LengthVar uint, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, NewEtagVar string, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileReplaceContents(x.GoPointer(), ContentsVar, LengthVar, EtagVar, MakeBackupVar, FlagsVar, NewEtagVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Starts an asynchronous replacement of @file with the given
// @contents of @length bytes. @etag will replace the document's
// current entity tag.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If @make_backup is %TRUE, this function will attempt to
// make a backup of @file.
//
// Note that no copy of @contents will be made, so it must stay valid
// until @callback is called. See g_file_replace_contents_bytes_async()
// for a #GBytes version that will automatically hold a reference to the
// contents (without copying) for the duration of the call.
func (x *FileBase) ReplaceContentsAsync(ContentsVar string, LengthVar uint, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReplaceContentsAsync(x.GoPointer(), ContentsVar, LengthVar, EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Same as g_file_replace_contents_async() but takes a #GBytes input instead.
// This function will keep a ref on @contents until the operation is done.
// Unlike g_file_replace_contents_async() this allows forgetting about the
// content without waiting for the callback.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
func (x *FileBase) ReplaceContentsBytesAsync(ContentsVar *glib.Bytes, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReplaceContentsBytesAsync(x.GoPointer(), ContentsVar, EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous replace of the given @file. See
// g_file_replace_contents_async(). Sets @new_etag to the new entity
// tag for the document, if present.
func (x *FileBase) ReplaceContentsFinish(ResVar AsyncResult, NewEtagVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGFileReplaceContentsFinish(x.GoPointer(), ResVar.GoPointer(), NewEtagVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Finishes an asynchronous file replace operation started with
// g_file_replace_async().
func (x *FileBase) ReplaceFinish(ResVar AsyncResult) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileReplaceFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Returns an output stream for overwriting the file in readwrite mode,
// possibly creating a backup copy of the file first. If the file doesn't
// exist, it will be created.
//
// For details about the behaviour, see g_file_replace() which does the
// same thing but returns an output stream only.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
func (x *FileBase) ReplaceReadwrite(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileReplaceReadwrite(x.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously overwrites the file in read-write mode,
// replacing the contents, possibly creating a backup copy
// of the file first.
//
// For more details, see g_file_replace_readwrite() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_replace_readwrite_finish() to get
// the result of the operation.
func (x *FileBase) ReplaceReadwriteAsync(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReplaceReadwriteAsync(x.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file replace operation started with
// g_file_replace_readwrite_async().
func (x *FileBase) ReplaceReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileReplaceReadwriteFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Resolves a relative path for @file to an absolute path.
//
// This call does no blocking I/O.
//
// If the @relative_path is an absolute path name, the resolution
// is done absolutely (without taking @file path as base).
func (x *FileBase) ResolveRelativePath(RelativePathVar string) *FileBase {
	var cls *FileBase

	cret := XGFileResolveRelativePath(x.GoPointer(), RelativePathVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Sets an attribute in the file with attribute name @attribute to @value_p.
//
// Some attributes can be unset by setting @type to
// %G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to %NULL.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttribute(AttributeVar string, TypeVar FileAttributeType, ValuePVar uintptr, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttribute(x.GoPointer(), AttributeVar, TypeVar, ValuePVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value.
// If @attribute is of a different type, this operation will fail,
// returning %FALSE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeByteString(AttributeVar string, ValueVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeByteString(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeInt32(AttributeVar string, ValueVar int32, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeInt32(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeInt64(AttributeVar string, ValueVar int64, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeInt64(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeString(AttributeVar string, ValueVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeString(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeUint32(AttributeVar string, ValueVar uint32, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeUint32(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeUint64(AttributeVar string, ValueVar uint64, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeUint64(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously sets the attributes of @file with @info.
//
// For more details, see g_file_set_attributes_from_info(),
// which is the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_set_attributes_finish() to get
// the result of the operation.
func (x *FileBase) SetAttributesAsync(InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileSetAttributesAsync(x.GoPointer(), InfoVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes setting an attribute started in g_file_set_attributes_async().
func (x *FileBase) SetAttributesFinish(ResultVar AsyncResult, InfoVar **FileInfo) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributesFinish(x.GoPointer(), ResultVar.GoPointer(), *gobject.ConvertPtr(InfoVar), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tries to set all attributes in the #GFileInfo on the target
// values, not stopping on the first error.
//
// If there is any error during this operation then @error will
// be set to the first error. Error on particular fields are flagged
// by setting the "status" field in the attribute value to
// %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
// also detect further errors.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributesFromInfo(InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributesFromInfo(x.GoPointer(), InfoVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Renames @file to the specified display name.
//
// The display name is converted from UTF-8 to the correct encoding
// for the target filesystem if possible and the @file is renamed to this.
//
// If you want to implement a rename operation in the user interface the
// edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
// initial value in the rename widget, and then the result after editing
// should be passed to g_file_set_display_name().
//
// On success the resulting converted filename is returned.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetDisplayName(DisplayNameVar string, CancellableVar *Cancellable) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := XGFileSetDisplayName(x.GoPointer(), DisplayNameVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously sets the display name for a given #GFile.
//
// For more details, see g_file_set_display_name() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_set_display_name_finish() to get
// the result of the operation.
func (x *FileBase) SetDisplayNameAsync(DisplayNameVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileSetDisplayNameAsync(x.GoPointer(), DisplayNameVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes setting a display name started with
// g_file_set_display_name_async().
func (x *FileBase) SetDisplayNameFinish(ResVar AsyncResult) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := XGFileSetDisplayNameFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Starts a file of type %G_FILE_TYPE_MOUNTABLE.
// Using @start_operation, you can request callbacks when, for instance,
// passwords are needed during authentication.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) StartMountable(FlagsVar DriveStartFlags, StartOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileStartMountable(x.GoPointer(), FlagsVar, StartOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes a start operation. See g_file_start_mountable() for details.
//
// Finish an asynchronous start operation that was started
// with g_file_start_mountable().
func (x *FileBase) StartMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileStartMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Stops a file of type %G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_stop_mountable_finish() to get
// the result of the operation.
func (x *FileBase) StopMountable(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileStopMountable(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes a stop operation, see g_file_stop_mountable() for details.
//
// Finish an asynchronous stop operation that was started
// with g_file_stop_mountable().
func (x *FileBase) StopMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileStopMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Checks if @file supports thread-default main contexts
// (see [method@GLib.MainContext.push_thread_default])
// If this returns %FALSE, you cannot perform asynchronous operations on
// @file in a thread that has a thread-default context.
func (x *FileBase) SupportsThreadContexts() bool {

	cret := XGFileSupportsThreadContexts(x.GoPointer())
	return cret
}

// Sends @file to the "Trashcan", if possible. This is similar to
// deleting it, but the user can recover it before emptying the trashcan.
// Trashing is disabled for system mounts by default (see
// g_unix_mount_entry_is_system_internal()), so this call can return the
// %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
// mount option can be used to disable g_file_trash() support for particular
// mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
// Since 2.82, the `x-gvfs-trash` unix mount option can be used to enable
// g_file_trash() support for particular system mounts.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) Trash(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileTrash(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously sends @file to the Trash location, if possible.
func (x *FileBase) TrashAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileTrashAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file trashing operation, started with
// g_file_trash_async().
func (x *FileBase) TrashFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileTrashFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_unmount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) UnmountMountable(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileUnmountMountable(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an unmount operation, see g_file_unmount_mountable() for details.
//
// Finish an asynchronous unmount operation that was started
// with g_file_unmount_mountable().
func (x *FileBase) UnmountMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileUnmountMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_unmount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) UnmountMountableWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileUnmountMountableWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes an unmount operation,
// see g_file_unmount_mountable_with_operation() for details.
//
// Finish an asynchronous unmount operation that was started
// with g_file_unmount_mountable_with_operation().
func (x *FileBase) UnmountMountableWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileUnmountMountableWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var XGFileAppendTo func(uintptr, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileAppendToAsync func(uintptr, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileAppendToFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileBuildAttributeListForCopy func(uintptr, FileCopyFlags, uintptr, **glib.Error) string
var XGFileCopy func(uintptr, uintptr, FileCopyFlags, uintptr, uintptr, uintptr, **glib.Error) bool
var XGFileCopyAsync func(uintptr, uintptr, FileCopyFlags, int, uintptr, uintptr, uintptr, uintptr, uintptr)
var XGFileCopyAsyncWithClosures func(uintptr, uintptr, FileCopyFlags, int, uintptr, *gobject.Closure, *gobject.Closure)
var XGFileCopyAttributes func(uintptr, uintptr, FileCopyFlags, uintptr, **glib.Error) bool
var XGFileCopyFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileCreate func(uintptr, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileCreateAsync func(uintptr, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileCreateFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileCreateReadwrite func(uintptr, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileCreateReadwriteAsync func(uintptr, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileCreateReadwriteFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileDelete func(uintptr, uintptr, **glib.Error) bool
var XGFileDeleteAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileDeleteFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileDup func(uintptr) uintptr
var XGFileEjectMountable func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGFileEjectMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileEjectMountableWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileEjectMountableWithOperationFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileEnumerateChildren func(uintptr, string, FileQueryInfoFlags, uintptr, **glib.Error) uintptr
var XGFileEnumerateChildrenAsync func(uintptr, string, FileQueryInfoFlags, int, uintptr, uintptr, uintptr)
var XGFileEnumerateChildrenFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileEqual func(uintptr, uintptr) bool
var XGFileFindEnclosingMount func(uintptr, uintptr, **glib.Error) uintptr
var XGFileFindEnclosingMountAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileFindEnclosingMountFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileGetBasename func(uintptr) string
var XGFileGetChild func(uintptr, string) uintptr
var XGFileGetChildForDisplayName func(uintptr, string, **glib.Error) uintptr
var XGFileGetParent func(uintptr) uintptr
var XGFileGetParseName func(uintptr) string
var XGFileGetPath func(uintptr) string
var XGFileGetRelativePath func(uintptr, uintptr) string
var XGFileGetUri func(uintptr) string
var XGFileGetUriScheme func(uintptr) string
var XGFileHasParent func(uintptr, uintptr) bool
var XGFileHasPrefix func(uintptr, uintptr) bool
var XGFileHasUriScheme func(uintptr, string) bool
var XGFileHash func(uintptr) uint
var XGFileIsNative func(uintptr) bool
var XGFileLoadBytes func(uintptr, uintptr, string, **glib.Error) *glib.Bytes
var XGFileLoadBytesAsync func(uintptr, uintptr, uintptr, uintptr)
var XGFileLoadBytesFinish func(uintptr, uintptr, string, **glib.Error) *glib.Bytes
var XGFileLoadContents func(uintptr, uintptr, []string, uint, string, **glib.Error) bool
var XGFileLoadContentsAsync func(uintptr, uintptr, uintptr, uintptr)
var XGFileLoadContentsFinish func(uintptr, uintptr, []string, uint, string, **glib.Error) bool
var XGFileLoadPartialContentsAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)
var XGFileLoadPartialContentsFinish func(uintptr, uintptr, []string, uint, string, **glib.Error) bool
var XGFileMakeDirectory func(uintptr, uintptr, **glib.Error) bool
var XGFileMakeDirectoryAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileMakeDirectoryFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileMakeDirectoryWithParents func(uintptr, uintptr, **glib.Error) bool
var XGFileMakeSymbolicLink func(uintptr, string, uintptr, **glib.Error) bool
var XGFileMakeSymbolicLinkAsync func(uintptr, string, int, uintptr, uintptr, uintptr)
var XGFileMakeSymbolicLinkFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileMeasureDiskUsage func(uintptr, FileMeasureFlags, uintptr, uintptr, uintptr, uint64, uint64, uint64, **glib.Error) bool
var XGFileMeasureDiskUsageAsync func(uintptr, FileMeasureFlags, int, uintptr, uintptr, uintptr, uintptr, uintptr)
var XGFileMeasureDiskUsageFinish func(uintptr, uintptr, uint64, uint64, uint64, **glib.Error) bool
var XGFileMonitor func(uintptr, FileMonitorFlags, uintptr, **glib.Error) uintptr
var XGFileMonitorDirectory func(uintptr, FileMonitorFlags, uintptr, **glib.Error) uintptr
var XGFileMonitorFile func(uintptr, FileMonitorFlags, uintptr, **glib.Error) uintptr
var XGFileMountEnclosingVolume func(uintptr, MountMountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileMountEnclosingVolumeFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileMountMountable func(uintptr, MountMountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileMountMountableFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileMove func(uintptr, uintptr, FileCopyFlags, uintptr, uintptr, uintptr, **glib.Error) bool
var XGFileMoveAsync func(uintptr, uintptr, FileCopyFlags, int, uintptr, uintptr, uintptr, uintptr, uintptr)
var XGFileMoveAsyncWithClosures func(uintptr, uintptr, FileCopyFlags, int, uintptr, *gobject.Closure, *gobject.Closure)
var XGFileMoveFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileOpenReadwrite func(uintptr, uintptr, **glib.Error) uintptr
var XGFileOpenReadwriteAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileOpenReadwriteFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFilePeekPath func(uintptr) string
var XGFilePollMountable func(uintptr, uintptr, uintptr, uintptr)
var XGFilePollMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileQueryDefaultHandler func(uintptr, uintptr, **glib.Error) uintptr
var XGFileQueryDefaultHandlerAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileQueryDefaultHandlerFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileQueryExists func(uintptr, uintptr) bool
var XGFileQueryFileType func(uintptr, FileQueryInfoFlags, uintptr) FileType
var XGFileQueryFilesystemInfo func(uintptr, string, uintptr, **glib.Error) uintptr
var XGFileQueryFilesystemInfoAsync func(uintptr, string, int, uintptr, uintptr, uintptr)
var XGFileQueryFilesystemInfoFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileQueryInfo func(uintptr, string, FileQueryInfoFlags, uintptr, **glib.Error) uintptr
var XGFileQueryInfoAsync func(uintptr, string, FileQueryInfoFlags, int, uintptr, uintptr, uintptr)
var XGFileQueryInfoFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileQuerySettableAttributes func(uintptr, uintptr, **glib.Error) *FileAttributeInfoList
var XGFileQueryWritableNamespaces func(uintptr, uintptr, **glib.Error) *FileAttributeInfoList
var XGFileRead func(uintptr, uintptr, **glib.Error) uintptr
var XGFileReadAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileReadFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileReplace func(uintptr, string, bool, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileReplaceAsync func(uintptr, string, bool, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileReplaceContents func(uintptr, string, uint, string, bool, FileCreateFlags, string, uintptr, **glib.Error) bool
var XGFileReplaceContentsAsync func(uintptr, string, uint, string, bool, FileCreateFlags, uintptr, uintptr, uintptr)
var XGFileReplaceContentsBytesAsync func(uintptr, *glib.Bytes, string, bool, FileCreateFlags, uintptr, uintptr, uintptr)
var XGFileReplaceContentsFinish func(uintptr, uintptr, string, **glib.Error) bool
var XGFileReplaceFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileReplaceReadwrite func(uintptr, string, bool, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileReplaceReadwriteAsync func(uintptr, string, bool, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileReplaceReadwriteFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileResolveRelativePath func(uintptr, string) uintptr
var XGFileSetAttribute func(uintptr, string, FileAttributeType, uintptr, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeByteString func(uintptr, string, string, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeInt32 func(uintptr, string, int32, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeInt64 func(uintptr, string, int64, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeString func(uintptr, string, string, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeUint32 func(uintptr, string, uint32, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeUint64 func(uintptr, string, uint64, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributesAsync func(uintptr, uintptr, FileQueryInfoFlags, int, uintptr, uintptr, uintptr)
var XGFileSetAttributesFinish func(uintptr, uintptr, uintptr, **glib.Error) bool
var XGFileSetAttributesFromInfo func(uintptr, uintptr, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetDisplayName func(uintptr, string, uintptr, **glib.Error) uintptr
var XGFileSetDisplayNameAsync func(uintptr, string, int, uintptr, uintptr, uintptr)
var XGFileSetDisplayNameFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileStartMountable func(uintptr, DriveStartFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileStartMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileStopMountable func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileStopMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileSupportsThreadContexts func(uintptr) bool
var XGFileTrash func(uintptr, uintptr, **glib.Error) bool
var XGFileTrashAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileTrashFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileUnmountMountable func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGFileUnmountMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileUnmountMountableWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileUnmountMountableWithOperationFinish func(uintptr, uintptr, **glib.Error) bool

var xFileNewBuildFilenamev func([]string) uintptr

// Constructs a #GFile from a vector of elements using the correct
// separator for filenames.
//
// Using this function is equivalent to calling g_build_filenamev(),
// followed by g_file_new_for_path() on the result.
func FileNewBuildFilenamev(ArgsVar []string) *FileBase {
	var cls *FileBase

	cret := xFileNewBuildFilenamev(ArgsVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewForCommandlineArg func(string) uintptr

// Creates a #GFile with the given argument from the command line.
// The value of @arg can be either a URI, an absolute path or a
// relative path resolved relative to the current working directory.
// This operation never fails, but the returned object might not
// support any I/O operation if @arg points to a malformed path.
//
// Note that on Windows, this function expects its argument to be in
// UTF-8 -- not the system code page.  This means that you
// should not use this function with string from argv as it is passed
// to main().  g_win32_get_command_line() will return a UTF-8 version of
// the commandline.  #GApplication also uses UTF-8 but
// g_application_command_line_create_file_for_arg() may be more useful
// for you there.  It is also always possible to use this function with
// #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
func FileNewForCommandlineArg(ArgVar string) *FileBase {
	var cls *FileBase

	cret := xFileNewForCommandlineArg(ArgVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewForCommandlineArgAndCwd func(string, string) uintptr

// Creates a #GFile with the given argument from the command line.
//
// This function is similar to g_file_new_for_commandline_arg() except
// that it allows for passing the current working directory as an
// argument instead of using the current working directory of the
// process.
//
// This is useful if the commandline argument was given in a context
// other than the invocation of the current process.
//
// See also g_application_command_line_create_file_for_arg().
func FileNewForCommandlineArgAndCwd(ArgVar string, CwdVar string) *FileBase {
	var cls *FileBase

	cret := xFileNewForCommandlineArgAndCwd(ArgVar, CwdVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewForPath func(string) uintptr

// Constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O
// operation if @path is malformed.
func FileNewForPath(PathVar string) *FileBase {
	var cls *FileBase

	cret := xFileNewForPath(PathVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewForUri func(string) uintptr

// Constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O
// operation if @uri is malformed or if the uri type is
// not supported.
func FileNewForUri(UriVar string) *FileBase {
	var cls *FileBase

	cret := xFileNewForUri(UriVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewTmp func(string, uintptr, **glib.Error) uintptr

// Opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and
// #GFileIOStream pointing to it.
//
// @tmpl should be a string in the GLib file name encoding
// containing a sequence of six 'X' characters, and containing no
// directory components. If it is %NULL, a default template is used.
//
// Unlike the other #GFile constructors, this will return %NULL if
// a temporary file could not be created.
func FileNewTmp(TmplVar string, IostreamVar **FileIOStream) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := xFileNewTmp(TmplVar, *gobject.ConvertPtr(IostreamVar), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileNewTmpAsync func(string, int, uintptr, uintptr, uintptr)

// Asynchronously opens a file in the preferred directory for temporary files
//
//	(as returned by g_get_tmp_dir()) as g_file_new_tmp().
//
// @tmpl should be a string in the GLib file name encoding
// containing a sequence of six 'X' characters, and containing no
// directory components. If it is %NULL, a default template is used.
func FileNewTmpAsync(TmplVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xFileNewTmpAsync(TmplVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xFileNewTmpDirAsync func(string, int, uintptr, uintptr, uintptr)

// Asynchronously creates a directory in the preferred directory for
// temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
//
// @tmpl should be a string in the GLib file name encoding
// containing a sequence of six 'X' characters, and containing no
// directory components. If it is %NULL, a default template is used.
func FileNewTmpDirAsync(TmplVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xFileNewTmpDirAsync(TmplVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xFileNewTmpDirFinish func(uintptr, **glib.Error) uintptr

// Finishes a temporary directory creation started by
// g_file_new_tmp_dir_async().
func FileNewTmpDirFinish(ResultVar AsyncResult) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := xFileNewTmpDirFinish(ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileNewTmpFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes a temporary file creation started by g_file_new_tmp_async().
func FileNewTmpFinish(ResultVar AsyncResult, IostreamVar **FileIOStream) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := xFileNewTmpFinish(ResultVar.GoPointer(), *gobject.ConvertPtr(IostreamVar), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileParseName func(string) uintptr

// Constructs a #GFile with the given @parse_name (i.e. something
// given by g_file_get_parse_name()). This operation never fails,
// but the returned object might not support any I/O operation if
// the @parse_name cannot be parsed.
func FileParseName(ParseNameVar string) *FileBase {
	var cls *FileBase

	cret := xFileParseName(ParseNameVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xFileNewBuildFilenamev, libs, "g_file_new_build_filenamev")
	core.PuregoSafeRegister(&xFileNewForCommandlineArg, libs, "g_file_new_for_commandline_arg")
	core.PuregoSafeRegister(&xFileNewForCommandlineArgAndCwd, libs, "g_file_new_for_commandline_arg_and_cwd")
	core.PuregoSafeRegister(&xFileNewForPath, libs, "g_file_new_for_path")
	core.PuregoSafeRegister(&xFileNewForUri, libs, "g_file_new_for_uri")
	core.PuregoSafeRegister(&xFileNewTmp, libs, "g_file_new_tmp")
	core.PuregoSafeRegister(&xFileNewTmpAsync, libs, "g_file_new_tmp_async")
	core.PuregoSafeRegister(&xFileNewTmpDirAsync, libs, "g_file_new_tmp_dir_async")
	core.PuregoSafeRegister(&xFileNewTmpDirFinish, libs, "g_file_new_tmp_dir_finish")
	core.PuregoSafeRegister(&xFileNewTmpFinish, libs, "g_file_new_tmp_finish")
	core.PuregoSafeRegister(&xFileParseName, libs, "g_file_parse_name")

	core.PuregoSafeRegister(&xFileGLibType, libs, "g_file_get_type")

	core.PuregoSafeRegister(&XGFileAppendTo, libs, "g_file_append_to")
	core.PuregoSafeRegister(&XGFileAppendToAsync, libs, "g_file_append_to_async")
	core.PuregoSafeRegister(&XGFileAppendToFinish, libs, "g_file_append_to_finish")
	core.PuregoSafeRegister(&XGFileBuildAttributeListForCopy, libs, "g_file_build_attribute_list_for_copy")
	core.PuregoSafeRegister(&XGFileCopy, libs, "g_file_copy")
	core.PuregoSafeRegister(&XGFileCopyAsync, libs, "g_file_copy_async")
	core.PuregoSafeRegister(&XGFileCopyAsyncWithClosures, libs, "g_file_copy_async_with_closures")
	core.PuregoSafeRegister(&XGFileCopyAttributes, libs, "g_file_copy_attributes")
	core.PuregoSafeRegister(&XGFileCopyFinish, libs, "g_file_copy_finish")
	core.PuregoSafeRegister(&XGFileCreate, libs, "g_file_create")
	core.PuregoSafeRegister(&XGFileCreateAsync, libs, "g_file_create_async")
	core.PuregoSafeRegister(&XGFileCreateFinish, libs, "g_file_create_finish")
	core.PuregoSafeRegister(&XGFileCreateReadwrite, libs, "g_file_create_readwrite")
	core.PuregoSafeRegister(&XGFileCreateReadwriteAsync, libs, "g_file_create_readwrite_async")
	core.PuregoSafeRegister(&XGFileCreateReadwriteFinish, libs, "g_file_create_readwrite_finish")
	core.PuregoSafeRegister(&XGFileDelete, libs, "g_file_delete")
	core.PuregoSafeRegister(&XGFileDeleteAsync, libs, "g_file_delete_async")
	core.PuregoSafeRegister(&XGFileDeleteFinish, libs, "g_file_delete_finish")
	core.PuregoSafeRegister(&XGFileDup, libs, "g_file_dup")
	core.PuregoSafeRegister(&XGFileEjectMountable, libs, "g_file_eject_mountable")
	core.PuregoSafeRegister(&XGFileEjectMountableFinish, libs, "g_file_eject_mountable_finish")
	core.PuregoSafeRegister(&XGFileEjectMountableWithOperation, libs, "g_file_eject_mountable_with_operation")
	core.PuregoSafeRegister(&XGFileEjectMountableWithOperationFinish, libs, "g_file_eject_mountable_with_operation_finish")
	core.PuregoSafeRegister(&XGFileEnumerateChildren, libs, "g_file_enumerate_children")
	core.PuregoSafeRegister(&XGFileEnumerateChildrenAsync, libs, "g_file_enumerate_children_async")
	core.PuregoSafeRegister(&XGFileEnumerateChildrenFinish, libs, "g_file_enumerate_children_finish")
	core.PuregoSafeRegister(&XGFileEqual, libs, "g_file_equal")
	core.PuregoSafeRegister(&XGFileFindEnclosingMount, libs, "g_file_find_enclosing_mount")
	core.PuregoSafeRegister(&XGFileFindEnclosingMountAsync, libs, "g_file_find_enclosing_mount_async")
	core.PuregoSafeRegister(&XGFileFindEnclosingMountFinish, libs, "g_file_find_enclosing_mount_finish")
	core.PuregoSafeRegister(&XGFileGetBasename, libs, "g_file_get_basename")
	core.PuregoSafeRegister(&XGFileGetChild, libs, "g_file_get_child")
	core.PuregoSafeRegister(&XGFileGetChildForDisplayName, libs, "g_file_get_child_for_display_name")
	core.PuregoSafeRegister(&XGFileGetParent, libs, "g_file_get_parent")
	core.PuregoSafeRegister(&XGFileGetParseName, libs, "g_file_get_parse_name")
	core.PuregoSafeRegister(&XGFileGetPath, libs, "g_file_get_path")
	core.PuregoSafeRegister(&XGFileGetRelativePath, libs, "g_file_get_relative_path")
	core.PuregoSafeRegister(&XGFileGetUri, libs, "g_file_get_uri")
	core.PuregoSafeRegister(&XGFileGetUriScheme, libs, "g_file_get_uri_scheme")
	core.PuregoSafeRegister(&XGFileHasParent, libs, "g_file_has_parent")
	core.PuregoSafeRegister(&XGFileHasPrefix, libs, "g_file_has_prefix")
	core.PuregoSafeRegister(&XGFileHasUriScheme, libs, "g_file_has_uri_scheme")
	core.PuregoSafeRegister(&XGFileHash, libs, "g_file_hash")
	core.PuregoSafeRegister(&XGFileIsNative, libs, "g_file_is_native")
	core.PuregoSafeRegister(&XGFileLoadBytes, libs, "g_file_load_bytes")
	core.PuregoSafeRegister(&XGFileLoadBytesAsync, libs, "g_file_load_bytes_async")
	core.PuregoSafeRegister(&XGFileLoadBytesFinish, libs, "g_file_load_bytes_finish")
	core.PuregoSafeRegister(&XGFileLoadContents, libs, "g_file_load_contents")
	core.PuregoSafeRegister(&XGFileLoadContentsAsync, libs, "g_file_load_contents_async")
	core.PuregoSafeRegister(&XGFileLoadContentsFinish, libs, "g_file_load_contents_finish")
	core.PuregoSafeRegister(&XGFileLoadPartialContentsAsync, libs, "g_file_load_partial_contents_async")
	core.PuregoSafeRegister(&XGFileLoadPartialContentsFinish, libs, "g_file_load_partial_contents_finish")
	core.PuregoSafeRegister(&XGFileMakeDirectory, libs, "g_file_make_directory")
	core.PuregoSafeRegister(&XGFileMakeDirectoryAsync, libs, "g_file_make_directory_async")
	core.PuregoSafeRegister(&XGFileMakeDirectoryFinish, libs, "g_file_make_directory_finish")
	core.PuregoSafeRegister(&XGFileMakeDirectoryWithParents, libs, "g_file_make_directory_with_parents")
	core.PuregoSafeRegister(&XGFileMakeSymbolicLink, libs, "g_file_make_symbolic_link")
	core.PuregoSafeRegister(&XGFileMakeSymbolicLinkAsync, libs, "g_file_make_symbolic_link_async")
	core.PuregoSafeRegister(&XGFileMakeSymbolicLinkFinish, libs, "g_file_make_symbolic_link_finish")
	core.PuregoSafeRegister(&XGFileMeasureDiskUsage, libs, "g_file_measure_disk_usage")
	core.PuregoSafeRegister(&XGFileMeasureDiskUsageAsync, libs, "g_file_measure_disk_usage_async")
	core.PuregoSafeRegister(&XGFileMeasureDiskUsageFinish, libs, "g_file_measure_disk_usage_finish")
	core.PuregoSafeRegister(&XGFileMonitor, libs, "g_file_monitor")
	core.PuregoSafeRegister(&XGFileMonitorDirectory, libs, "g_file_monitor_directory")
	core.PuregoSafeRegister(&XGFileMonitorFile, libs, "g_file_monitor_file")
	core.PuregoSafeRegister(&XGFileMountEnclosingVolume, libs, "g_file_mount_enclosing_volume")
	core.PuregoSafeRegister(&XGFileMountEnclosingVolumeFinish, libs, "g_file_mount_enclosing_volume_finish")
	core.PuregoSafeRegister(&XGFileMountMountable, libs, "g_file_mount_mountable")
	core.PuregoSafeRegister(&XGFileMountMountableFinish, libs, "g_file_mount_mountable_finish")
	core.PuregoSafeRegister(&XGFileMove, libs, "g_file_move")
	core.PuregoSafeRegister(&XGFileMoveAsync, libs, "g_file_move_async")
	core.PuregoSafeRegister(&XGFileMoveAsyncWithClosures, libs, "g_file_move_async_with_closures")
	core.PuregoSafeRegister(&XGFileMoveFinish, libs, "g_file_move_finish")
	core.PuregoSafeRegister(&XGFileOpenReadwrite, libs, "g_file_open_readwrite")
	core.PuregoSafeRegister(&XGFileOpenReadwriteAsync, libs, "g_file_open_readwrite_async")
	core.PuregoSafeRegister(&XGFileOpenReadwriteFinish, libs, "g_file_open_readwrite_finish")
	core.PuregoSafeRegister(&XGFilePeekPath, libs, "g_file_peek_path")
	core.PuregoSafeRegister(&XGFilePollMountable, libs, "g_file_poll_mountable")
	core.PuregoSafeRegister(&XGFilePollMountableFinish, libs, "g_file_poll_mountable_finish")
	core.PuregoSafeRegister(&XGFileQueryDefaultHandler, libs, "g_file_query_default_handler")
	core.PuregoSafeRegister(&XGFileQueryDefaultHandlerAsync, libs, "g_file_query_default_handler_async")
	core.PuregoSafeRegister(&XGFileQueryDefaultHandlerFinish, libs, "g_file_query_default_handler_finish")
	core.PuregoSafeRegister(&XGFileQueryExists, libs, "g_file_query_exists")
	core.PuregoSafeRegister(&XGFileQueryFileType, libs, "g_file_query_file_type")
	core.PuregoSafeRegister(&XGFileQueryFilesystemInfo, libs, "g_file_query_filesystem_info")
	core.PuregoSafeRegister(&XGFileQueryFilesystemInfoAsync, libs, "g_file_query_filesystem_info_async")
	core.PuregoSafeRegister(&XGFileQueryFilesystemInfoFinish, libs, "g_file_query_filesystem_info_finish")
	core.PuregoSafeRegister(&XGFileQueryInfo, libs, "g_file_query_info")
	core.PuregoSafeRegister(&XGFileQueryInfoAsync, libs, "g_file_query_info_async")
	core.PuregoSafeRegister(&XGFileQueryInfoFinish, libs, "g_file_query_info_finish")
	core.PuregoSafeRegister(&XGFileQuerySettableAttributes, libs, "g_file_query_settable_attributes")
	core.PuregoSafeRegister(&XGFileQueryWritableNamespaces, libs, "g_file_query_writable_namespaces")
	core.PuregoSafeRegister(&XGFileRead, libs, "g_file_read")
	core.PuregoSafeRegister(&XGFileReadAsync, libs, "g_file_read_async")
	core.PuregoSafeRegister(&XGFileReadFinish, libs, "g_file_read_finish")
	core.PuregoSafeRegister(&XGFileReplace, libs, "g_file_replace")
	core.PuregoSafeRegister(&XGFileReplaceAsync, libs, "g_file_replace_async")
	core.PuregoSafeRegister(&XGFileReplaceContents, libs, "g_file_replace_contents")
	core.PuregoSafeRegister(&XGFileReplaceContentsAsync, libs, "g_file_replace_contents_async")
	core.PuregoSafeRegister(&XGFileReplaceContentsBytesAsync, libs, "g_file_replace_contents_bytes_async")
	core.PuregoSafeRegister(&XGFileReplaceContentsFinish, libs, "g_file_replace_contents_finish")
	core.PuregoSafeRegister(&XGFileReplaceFinish, libs, "g_file_replace_finish")
	core.PuregoSafeRegister(&XGFileReplaceReadwrite, libs, "g_file_replace_readwrite")
	core.PuregoSafeRegister(&XGFileReplaceReadwriteAsync, libs, "g_file_replace_readwrite_async")
	core.PuregoSafeRegister(&XGFileReplaceReadwriteFinish, libs, "g_file_replace_readwrite_finish")
	core.PuregoSafeRegister(&XGFileResolveRelativePath, libs, "g_file_resolve_relative_path")
	core.PuregoSafeRegister(&XGFileSetAttribute, libs, "g_file_set_attribute")
	core.PuregoSafeRegister(&XGFileSetAttributeByteString, libs, "g_file_set_attribute_byte_string")
	core.PuregoSafeRegister(&XGFileSetAttributeInt32, libs, "g_file_set_attribute_int32")
	core.PuregoSafeRegister(&XGFileSetAttributeInt64, libs, "g_file_set_attribute_int64")
	core.PuregoSafeRegister(&XGFileSetAttributeString, libs, "g_file_set_attribute_string")
	core.PuregoSafeRegister(&XGFileSetAttributeUint32, libs, "g_file_set_attribute_uint32")
	core.PuregoSafeRegister(&XGFileSetAttributeUint64, libs, "g_file_set_attribute_uint64")
	core.PuregoSafeRegister(&XGFileSetAttributesAsync, libs, "g_file_set_attributes_async")
	core.PuregoSafeRegister(&XGFileSetAttributesFinish, libs, "g_file_set_attributes_finish")
	core.PuregoSafeRegister(&XGFileSetAttributesFromInfo, libs, "g_file_set_attributes_from_info")
	core.PuregoSafeRegister(&XGFileSetDisplayName, libs, "g_file_set_display_name")
	core.PuregoSafeRegister(&XGFileSetDisplayNameAsync, libs, "g_file_set_display_name_async")
	core.PuregoSafeRegister(&XGFileSetDisplayNameFinish, libs, "g_file_set_display_name_finish")
	core.PuregoSafeRegister(&XGFileStartMountable, libs, "g_file_start_mountable")
	core.PuregoSafeRegister(&XGFileStartMountableFinish, libs, "g_file_start_mountable_finish")
	core.PuregoSafeRegister(&XGFileStopMountable, libs, "g_file_stop_mountable")
	core.PuregoSafeRegister(&XGFileStopMountableFinish, libs, "g_file_stop_mountable_finish")
	core.PuregoSafeRegister(&XGFileSupportsThreadContexts, libs, "g_file_supports_thread_contexts")
	core.PuregoSafeRegister(&XGFileTrash, libs, "g_file_trash")
	core.PuregoSafeRegister(&XGFileTrashAsync, libs, "g_file_trash_async")
	core.PuregoSafeRegister(&XGFileTrashFinish, libs, "g_file_trash_finish")
	core.PuregoSafeRegister(&XGFileUnmountMountable, libs, "g_file_unmount_mountable")
	core.PuregoSafeRegister(&XGFileUnmountMountableFinish, libs, "g_file_unmount_mountable_finish")
	core.PuregoSafeRegister(&XGFileUnmountMountableWithOperation, libs, "g_file_unmount_mountable_with_operation")
	core.PuregoSafeRegister(&XGFileUnmountMountableWithOperationFinish, libs, "g_file_unmount_mountable_with_operation_finish")

}
