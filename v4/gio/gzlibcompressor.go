// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type ZlibCompressorClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *ZlibCompressorClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GZlibCompressor` is an implementation of [iface@Gio.Converter] that
// compresses data using zlib.
type ZlibCompressor struct {
	gobject.Object
}

var xZlibCompressorGLibType func() types.GType

func ZlibCompressorGLibType() types.GType {
	return xZlibCompressorGLibType()
}

func ZlibCompressorNewFromInternalPtr(ptr uintptr) *ZlibCompressor {
	cls := &ZlibCompressor{}
	cls.Ptr = ptr
	return cls
}

var xNewZlibCompressor func(ZlibCompressorFormat, int) uintptr

// Creates a compressor.
func NewZlibCompressor(FormatVar ZlibCompressorFormat, LevelVar int) *ZlibCompressor {
	var cls *ZlibCompressor

	cret := xNewZlibCompressor(FormatVar, LevelVar)

	if cret == 0 {
		return nil
	}
	cls = &ZlibCompressor{}
	cls.Ptr = cret
	return cls
}

var xZlibCompressorGetFileInfo func(uintptr) uintptr

// Gets the [property@Gio.ZlibCompressor:file-info] property.
func (x *ZlibCompressor) GetFileInfo() *FileInfo {
	var cls *FileInfo

	cret := xZlibCompressorGetFileInfo(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileInfo{}
	cls.Ptr = cret
	return cls
}

var xZlibCompressorGetOs func(uintptr) int

// Gets the [property@Gio.ZlibCompressor:os] property.
func (x *ZlibCompressor) GetOs() int {

	cret := xZlibCompressorGetOs(x.GoPointer())

	return cret
}

var xZlibCompressorSetFileInfo func(uintptr, uintptr)

// Sets the [property@Gio.ZlibCompressor:file-info] property.
//
// Note: it is an error to call this function while a compression is in
// progress; it may only be called immediately after creation of @compressor,
// or after resetting it with [method@Gio.Converter.reset].
func (x *ZlibCompressor) SetFileInfo(FileInfoVar *FileInfo) {

	xZlibCompressorSetFileInfo(x.GoPointer(), FileInfoVar.GoPointer())

}

var xZlibCompressorSetOs func(uintptr, int)

// Sets the [property@Gio.ZlibCompressor:os] property.
//
// Note: it is an error to call this function while a compression is in
// progress; it may only be called immediately after creation of @compressor,
// or after resetting it with [method@Gio.Converter.reset].
func (x *ZlibCompressor) SetOs(OsVar int) {

	xZlibCompressorSetOs(x.GoPointer(), OsVar)

}

func (c *ZlibCompressor) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *ZlibCompressor) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyLevel sets the "level" property.
// The level of compression from `0` (no compression) to `9` (most
// compression).
//
// `-1` for the default level.
func (x *ZlibCompressor) SetPropertyLevel(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("level", &v)
}

// GetPropertyLevel gets the "level" property.
// The level of compression from `0` (no compression) to `9` (most
// compression).
//
// `-1` for the default level.
func (x *ZlibCompressor) GetPropertyLevel() int {
	var v gobject.Value
	x.GetProperty("level", &v)
	return v.GetInt()
}

// SetPropertyOs sets the "os" property.
// The OS code of the gzip header.
//
// This will be used if set to a non-negative value, and if
// [property@Gio.ZlibCompressor:format] is
// [enum@Gio.ZlibCompressorFormat.GZIP], the compressor will set the OS code of
// the gzip header to this value.
//
// If the value is unset, zlib will set the OS code depending on the platform.
// This may be undesirable when reproducible output is desired. In that case setting
// the OS code to `3` (for Unix) is recommended.
func (x *ZlibCompressor) SetPropertyOs(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("os", &v)
}

// GetPropertyOs gets the "os" property.
// The OS code of the gzip header.
//
// This will be used if set to a non-negative value, and if
// [property@Gio.ZlibCompressor:format] is
// [enum@Gio.ZlibCompressorFormat.GZIP], the compressor will set the OS code of
// the gzip header to this value.
//
// If the value is unset, zlib will set the OS code depending on the platform.
// This may be undesirable when reproducible output is desired. In that case setting
// the OS code to `3` (for Unix) is recommended.
func (x *ZlibCompressor) GetPropertyOs() int {
	var v gobject.Value
	x.GetProperty("os", &v)
	return v.GetInt()
}

// This is the main operation used when converting data. It is to be called
// multiple times in a loop, and each time it will do some work, i.e.
// producing some output (in @outbuf) or consuming some input (from @inbuf) or
// both. If its not possible to do any work an error is returned.
//
// Note that a single call may not consume all input (or any input at all).
// Also a call may produce output even if given no input, due to state stored
// in the converter producing output.
//
// If any data was either produced or consumed, and then an error happens, then
// only the successful conversion is reported and the error is returned on the
// next call.
//
// A full conversion loop involves calling this method repeatedly, each time
// giving it new input and space output space. When there is no more input
// data after the data in @inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
// The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
// each time until all data is consumed and all output is produced, then
// %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
// may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
// in a decompression converter where the end of data is detectable from the
// data (and there might even be other data after the end of the compressed data).
//
// When some data has successfully been converted @bytes_read and is set to
// the number of bytes read from @inbuf, and @bytes_written is set to indicate
// how many bytes was written to @outbuf. If there are more data to output
// or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
// %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
// then %G_CONVERTER_FINISHED is returned.
//
// On error %G_CONVERTER_ERROR is returned and @error is set accordingly.
// Some errors need special handling:
//
// %G_IO_ERROR_NO_SPACE is returned if there is not enough space
// to write the resulting converted data, the application should
// call the function again with a larger @outbuf to continue.
//
// %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
// input to fully determine what the conversion should produce,
// and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
// example with an incomplete multibyte sequence when converting text,
// or when a regexp matches up to the end of the input (and may match
// further input). It may also happen when @inbuf_size is zero and
// there is no more data to produce.
//
// When this happens the application should read more input and then
// call the function again. If further input shows that there is no
// more data call the function again with the same data but with
// the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
// to finish as e.g. in the regexp match case (or, to fail again with
// %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
// input is actually partial).
//
// After g_converter_convert() has returned %G_CONVERTER_FINISHED the
// converter object is in an invalid state where its not allowed
// to call g_converter_convert() anymore. At this time you can only
// free the object or call g_converter_reset() to reset it to the
// initial state.
//
// If the flag %G_CONVERTER_FLUSH is set then conversion is modified
// to try to write out all internal state to the output. The application
// has to call the function multiple times with the flag set, and when
// the available input has been consumed and all internal state has
// been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
// really at the end) is returned instead of %G_CONVERTER_CONVERTED.
// This is somewhat similar to what happens at the end of the input stream,
// but done in the middle of the data.
//
// This has different meanings for different conversions. For instance
// in a compression converter it would mean that we flush all the
// compression state into output such that if you uncompress the
// compressed data you get back all the input data. Doing this may
// make the final file larger due to padding though. Another example
// is a regexp conversion, where if you at the end of the flushed data
// have a match, but there is also a potential longer match. In the
// non-flushed case we would ask for more input, but when flushing we
// treat this as the end of input and do the match.
//
// Flushing is not always possible (like if a charset converter flushes
// at a partial multibyte sequence). Converters are supposed to try
// to produce as much output as possible and then return an error
// (typically %G_IO_ERROR_PARTIAL_INPUT).
func (x *ZlibCompressor) Convert(InbufVar []byte, InbufSizeVar uint, OutbufVar []byte, OutbufSizeVar uint, FlagsVar ConverterFlags, BytesReadVar *uint, BytesWrittenVar *uint) (ConverterResult, error) {
	var cerr *glib.Error

	cret := XGConverterConvert(x.GoPointer(), InbufVar, InbufSizeVar, OutbufVar, OutbufSizeVar, FlagsVar, BytesReadVar, BytesWrittenVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Applies @converter to the data in @bytes.
func (x *ZlibCompressor) ConvertBytes(BytesVar *glib.Bytes) (*glib.Bytes, error) {
	var cerr *glib.Error

	cret := XGConverterConvertBytes(x.GoPointer(), BytesVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Resets all internal state in the converter, making it behave
// as if it was just created. If the converter has any internal
// state that would produce output then that output is lost.
func (x *ZlibCompressor) Reset() {

	XGConverterReset(x.GoPointer())

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xZlibCompressorGLibType, libs, "g_zlib_compressor_get_type")

	core.PuregoSafeRegister(&xNewZlibCompressor, libs, "g_zlib_compressor_new")

	core.PuregoSafeRegister(&xZlibCompressorGetFileInfo, libs, "g_zlib_compressor_get_file_info")
	core.PuregoSafeRegister(&xZlibCompressorGetOs, libs, "g_zlib_compressor_get_os")
	core.PuregoSafeRegister(&xZlibCompressorSetFileInfo, libs, "g_zlib_compressor_set_file_info")
	core.PuregoSafeRegister(&xZlibCompressorSetOs, libs, "g_zlib_compressor_set_os")

}
