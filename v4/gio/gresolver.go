// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type ResolverClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xReload uintptr

	xLookupByName uintptr

	xLookupByNameAsync uintptr

	xLookupByNameFinish uintptr

	xLookupByAddress uintptr

	xLookupByAddressAsync uintptr

	xLookupByAddressFinish uintptr

	xLookupService uintptr

	xLookupServiceAsync uintptr

	xLookupServiceFinish uintptr

	xLookupRecords uintptr

	xLookupRecordsAsync uintptr

	xLookupRecordsFinish uintptr

	xLookupByNameWithFlagsAsync uintptr

	xLookupByNameWithFlagsFinish uintptr

	xLookupByNameWithFlags uintptr
}

func (x *ResolverClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideReload sets the "reload" callback function.
func (x *ResolverClass) OverrideReload(cb func(*Resolver)) {
	if cb == nil {
		x.xReload = 0
	} else {
		x.xReload = purego.NewCallback(func(ResolverVarp uintptr) {
			cb(ResolverNewFromInternalPtr(ResolverVarp))
		})
	}
}

// GetReload gets the "reload" callback function.
func (x *ResolverClass) GetReload() func(*Resolver) {
	if x.xReload == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xReload)
	return func(ResolverVar *Resolver) {
		rawCallback(ResolverVar.GoPointer())
	}
}

// OverrideLookupByName sets the "lookup_by_name" callback function.
func (x *ResolverClass) OverrideLookupByName(cb func(*Resolver, string, *Cancellable) *glib.List) {
	if cb == nil {
		x.xLookupByName = 0
	} else {
		x.xLookupByName = purego.NewCallback(func(ResolverVarp uintptr, HostnameVarp string, CancellableVarp uintptr) *glib.List {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), HostnameVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetLookupByName gets the "lookup_by_name" callback function.
func (x *ResolverClass) GetLookupByName() func(*Resolver, string, *Cancellable) *glib.List {
	if x.xLookupByName == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, HostnameVarp string, CancellableVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupByName)
	return func(ResolverVar *Resolver, HostnameVar string, CancellableVar *Cancellable) *glib.List {
		return rawCallback(ResolverVar.GoPointer(), HostnameVar, CancellableVar.GoPointer())
	}
}

// OverrideLookupByNameAsync sets the "lookup_by_name_async" callback function.
func (x *ResolverClass) OverrideLookupByNameAsync(cb func(*Resolver, string, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLookupByNameAsync = 0
	} else {
		x.xLookupByNameAsync = purego.NewCallback(func(ResolverVarp uintptr, HostnameVarp string, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(ResolverNewFromInternalPtr(ResolverVarp), HostnameVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLookupByNameAsync gets the "lookup_by_name_async" callback function.
func (x *ResolverClass) GetLookupByNameAsync() func(*Resolver, string, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLookupByNameAsync == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, HostnameVarp string, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLookupByNameAsync)
	return func(ResolverVar *Resolver, HostnameVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(ResolverVar.GoPointer(), HostnameVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLookupByNameFinish sets the "lookup_by_name_finish" callback function.
func (x *ResolverClass) OverrideLookupByNameFinish(cb func(*Resolver, AsyncResult) *glib.List) {
	if cb == nil {
		x.xLookupByNameFinish = 0
	} else {
		x.xLookupByNameFinish = purego.NewCallback(func(ResolverVarp uintptr, ResultVarp uintptr) *glib.List {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetLookupByNameFinish gets the "lookup_by_name_finish" callback function.
func (x *ResolverClass) GetLookupByNameFinish() func(*Resolver, AsyncResult) *glib.List {
	if x.xLookupByNameFinish == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, ResultVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupByNameFinish)
	return func(ResolverVar *Resolver, ResultVar AsyncResult) *glib.List {
		return rawCallback(ResolverVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideLookupByAddress sets the "lookup_by_address" callback function.
func (x *ResolverClass) OverrideLookupByAddress(cb func(*Resolver, *InetAddress, *Cancellable) string) {
	if cb == nil {
		x.xLookupByAddress = 0
	} else {
		x.xLookupByAddress = purego.NewCallback(func(ResolverVarp uintptr, AddressVarp uintptr, CancellableVarp uintptr) string {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), InetAddressNewFromInternalPtr(AddressVarp), CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetLookupByAddress gets the "lookup_by_address" callback function.
func (x *ResolverClass) GetLookupByAddress() func(*Resolver, *InetAddress, *Cancellable) string {
	if x.xLookupByAddress == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, AddressVarp uintptr, CancellableVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xLookupByAddress)
	return func(ResolverVar *Resolver, AddressVar *InetAddress, CancellableVar *Cancellable) string {
		return rawCallback(ResolverVar.GoPointer(), AddressVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideLookupByAddressAsync sets the "lookup_by_address_async" callback function.
func (x *ResolverClass) OverrideLookupByAddressAsync(cb func(*Resolver, *InetAddress, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLookupByAddressAsync = 0
	} else {
		x.xLookupByAddressAsync = purego.NewCallback(func(ResolverVarp uintptr, AddressVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(ResolverNewFromInternalPtr(ResolverVarp), InetAddressNewFromInternalPtr(AddressVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLookupByAddressAsync gets the "lookup_by_address_async" callback function.
func (x *ResolverClass) GetLookupByAddressAsync() func(*Resolver, *InetAddress, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLookupByAddressAsync == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, AddressVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLookupByAddressAsync)
	return func(ResolverVar *Resolver, AddressVar *InetAddress, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(ResolverVar.GoPointer(), AddressVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLookupByAddressFinish sets the "lookup_by_address_finish" callback function.
func (x *ResolverClass) OverrideLookupByAddressFinish(cb func(*Resolver, AsyncResult) string) {
	if cb == nil {
		x.xLookupByAddressFinish = 0
	} else {
		x.xLookupByAddressFinish = purego.NewCallback(func(ResolverVarp uintptr, ResultVarp uintptr) string {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetLookupByAddressFinish gets the "lookup_by_address_finish" callback function.
func (x *ResolverClass) GetLookupByAddressFinish() func(*Resolver, AsyncResult) string {
	if x.xLookupByAddressFinish == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, ResultVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xLookupByAddressFinish)
	return func(ResolverVar *Resolver, ResultVar AsyncResult) string {
		return rawCallback(ResolverVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideLookupService sets the "lookup_service" callback function.
func (x *ResolverClass) OverrideLookupService(cb func(*Resolver, string, *Cancellable) *glib.List) {
	if cb == nil {
		x.xLookupService = 0
	} else {
		x.xLookupService = purego.NewCallback(func(ResolverVarp uintptr, RrnameVarp string, CancellableVarp uintptr) *glib.List {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), RrnameVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetLookupService gets the "lookup_service" callback function.
func (x *ResolverClass) GetLookupService() func(*Resolver, string, *Cancellable) *glib.List {
	if x.xLookupService == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, RrnameVarp string, CancellableVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupService)
	return func(ResolverVar *Resolver, RrnameVar string, CancellableVar *Cancellable) *glib.List {
		return rawCallback(ResolverVar.GoPointer(), RrnameVar, CancellableVar.GoPointer())
	}
}

// OverrideLookupServiceAsync sets the "lookup_service_async" callback function.
func (x *ResolverClass) OverrideLookupServiceAsync(cb func(*Resolver, string, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLookupServiceAsync = 0
	} else {
		x.xLookupServiceAsync = purego.NewCallback(func(ResolverVarp uintptr, RrnameVarp string, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(ResolverNewFromInternalPtr(ResolverVarp), RrnameVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLookupServiceAsync gets the "lookup_service_async" callback function.
func (x *ResolverClass) GetLookupServiceAsync() func(*Resolver, string, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLookupServiceAsync == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, RrnameVarp string, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLookupServiceAsync)
	return func(ResolverVar *Resolver, RrnameVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(ResolverVar.GoPointer(), RrnameVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLookupServiceFinish sets the "lookup_service_finish" callback function.
func (x *ResolverClass) OverrideLookupServiceFinish(cb func(*Resolver, AsyncResult) *glib.List) {
	if cb == nil {
		x.xLookupServiceFinish = 0
	} else {
		x.xLookupServiceFinish = purego.NewCallback(func(ResolverVarp uintptr, ResultVarp uintptr) *glib.List {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetLookupServiceFinish gets the "lookup_service_finish" callback function.
func (x *ResolverClass) GetLookupServiceFinish() func(*Resolver, AsyncResult) *glib.List {
	if x.xLookupServiceFinish == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, ResultVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupServiceFinish)
	return func(ResolverVar *Resolver, ResultVar AsyncResult) *glib.List {
		return rawCallback(ResolverVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideLookupRecords sets the "lookup_records" callback function.
func (x *ResolverClass) OverrideLookupRecords(cb func(*Resolver, string, ResolverRecordType, *Cancellable) *glib.List) {
	if cb == nil {
		x.xLookupRecords = 0
	} else {
		x.xLookupRecords = purego.NewCallback(func(ResolverVarp uintptr, RrnameVarp string, RecordTypeVarp ResolverRecordType, CancellableVarp uintptr) *glib.List {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), RrnameVarp, RecordTypeVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetLookupRecords gets the "lookup_records" callback function.
func (x *ResolverClass) GetLookupRecords() func(*Resolver, string, ResolverRecordType, *Cancellable) *glib.List {
	if x.xLookupRecords == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, RrnameVarp string, RecordTypeVarp ResolverRecordType, CancellableVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupRecords)
	return func(ResolverVar *Resolver, RrnameVar string, RecordTypeVar ResolverRecordType, CancellableVar *Cancellable) *glib.List {
		return rawCallback(ResolverVar.GoPointer(), RrnameVar, RecordTypeVar, CancellableVar.GoPointer())
	}
}

// OverrideLookupRecordsAsync sets the "lookup_records_async" callback function.
func (x *ResolverClass) OverrideLookupRecordsAsync(cb func(*Resolver, string, ResolverRecordType, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLookupRecordsAsync = 0
	} else {
		x.xLookupRecordsAsync = purego.NewCallback(func(ResolverVarp uintptr, RrnameVarp string, RecordTypeVarp ResolverRecordType, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(ResolverNewFromInternalPtr(ResolverVarp), RrnameVarp, RecordTypeVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLookupRecordsAsync gets the "lookup_records_async" callback function.
func (x *ResolverClass) GetLookupRecordsAsync() func(*Resolver, string, ResolverRecordType, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLookupRecordsAsync == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, RrnameVarp string, RecordTypeVarp ResolverRecordType, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLookupRecordsAsync)
	return func(ResolverVar *Resolver, RrnameVar string, RecordTypeVar ResolverRecordType, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(ResolverVar.GoPointer(), RrnameVar, RecordTypeVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLookupRecordsFinish sets the "lookup_records_finish" callback function.
func (x *ResolverClass) OverrideLookupRecordsFinish(cb func(*Resolver, AsyncResult) *glib.List) {
	if cb == nil {
		x.xLookupRecordsFinish = 0
	} else {
		x.xLookupRecordsFinish = purego.NewCallback(func(ResolverVarp uintptr, ResultVarp uintptr) *glib.List {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetLookupRecordsFinish gets the "lookup_records_finish" callback function.
func (x *ResolverClass) GetLookupRecordsFinish() func(*Resolver, AsyncResult) *glib.List {
	if x.xLookupRecordsFinish == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, ResultVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupRecordsFinish)
	return func(ResolverVar *Resolver, ResultVar AsyncResult) *glib.List {
		return rawCallback(ResolverVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideLookupByNameWithFlagsAsync sets the "lookup_by_name_with_flags_async" callback function.
func (x *ResolverClass) OverrideLookupByNameWithFlagsAsync(cb func(*Resolver, string, ResolverNameLookupFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLookupByNameWithFlagsAsync = 0
	} else {
		x.xLookupByNameWithFlagsAsync = purego.NewCallback(func(ResolverVarp uintptr, HostnameVarp string, FlagsVarp ResolverNameLookupFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(ResolverNewFromInternalPtr(ResolverVarp), HostnameVarp, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLookupByNameWithFlagsAsync gets the "lookup_by_name_with_flags_async" callback function.
func (x *ResolverClass) GetLookupByNameWithFlagsAsync() func(*Resolver, string, ResolverNameLookupFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLookupByNameWithFlagsAsync == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, HostnameVarp string, FlagsVarp ResolverNameLookupFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLookupByNameWithFlagsAsync)
	return func(ResolverVar *Resolver, HostnameVar string, FlagsVar ResolverNameLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(ResolverVar.GoPointer(), HostnameVar, FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLookupByNameWithFlagsFinish sets the "lookup_by_name_with_flags_finish" callback function.
func (x *ResolverClass) OverrideLookupByNameWithFlagsFinish(cb func(*Resolver, AsyncResult) *glib.List) {
	if cb == nil {
		x.xLookupByNameWithFlagsFinish = 0
	} else {
		x.xLookupByNameWithFlagsFinish = purego.NewCallback(func(ResolverVarp uintptr, ResultVarp uintptr) *glib.List {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetLookupByNameWithFlagsFinish gets the "lookup_by_name_with_flags_finish" callback function.
func (x *ResolverClass) GetLookupByNameWithFlagsFinish() func(*Resolver, AsyncResult) *glib.List {
	if x.xLookupByNameWithFlagsFinish == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, ResultVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupByNameWithFlagsFinish)
	return func(ResolverVar *Resolver, ResultVar AsyncResult) *glib.List {
		return rawCallback(ResolverVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideLookupByNameWithFlags sets the "lookup_by_name_with_flags" callback function.
func (x *ResolverClass) OverrideLookupByNameWithFlags(cb func(*Resolver, string, ResolverNameLookupFlags, *Cancellable) *glib.List) {
	if cb == nil {
		x.xLookupByNameWithFlags = 0
	} else {
		x.xLookupByNameWithFlags = purego.NewCallback(func(ResolverVarp uintptr, HostnameVarp string, FlagsVarp ResolverNameLookupFlags, CancellableVarp uintptr) *glib.List {
			return cb(ResolverNewFromInternalPtr(ResolverVarp), HostnameVarp, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetLookupByNameWithFlags gets the "lookup_by_name_with_flags" callback function.
func (x *ResolverClass) GetLookupByNameWithFlags() func(*Resolver, string, ResolverNameLookupFlags, *Cancellable) *glib.List {
	if x.xLookupByNameWithFlags == 0 {
		return nil
	}
	var rawCallback func(ResolverVarp uintptr, HostnameVarp string, FlagsVarp ResolverNameLookupFlags, CancellableVarp uintptr) *glib.List
	purego.RegisterFunc(&rawCallback, x.xLookupByNameWithFlags)
	return func(ResolverVar *Resolver, HostnameVar string, FlagsVar ResolverNameLookupFlags, CancellableVar *Cancellable) *glib.List {
		return rawCallback(ResolverVar.GoPointer(), HostnameVar, FlagsVar, CancellableVar.GoPointer())
	}
}

type ResolverPrivate struct {
	_ structs.HostLayout
}

func (x *ResolverPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Flags to modify lookup behavior.
type ResolverNameLookupFlags int

var xResolverNameLookupFlagsGLibType func() types.GType

func ResolverNameLookupFlagsGLibType() types.GType {
	return xResolverNameLookupFlagsGLibType()
}

const (

	// default behavior (same as g_resolver_lookup_by_name())
	GResolverNameLookupFlagsDefaultValue ResolverNameLookupFlags = 0
	// only resolve ipv4 addresses
	GResolverNameLookupFlagsIpv4OnlyValue ResolverNameLookupFlags = 1
	// only resolve ipv6 addresses
	GResolverNameLookupFlagsIpv6OnlyValue ResolverNameLookupFlags = 2
)

var xResolverErrorQuark func() glib.Quark

// Gets the #GResolver Error Quark.
func ResolverErrorQuark() glib.Quark {

	cret := xResolverErrorQuark()

	return cret
}

// The object that handles DNS resolution. Use [func@Gio.Resolver.get_default]
// to get the default resolver.
//
// `GResolver` provides cancellable synchronous and asynchronous DNS
// resolution, for hostnames ([method@Gio.Resolver.lookup_by_address],
// [method@Gio.Resolver.lookup_by_name] and their async variants) and SRV
// (service) records ([method@Gio.Resolver.lookup_service]).
//
// [class@Gio.NetworkAddress] and [class@Gio.NetworkService] provide wrappers
// around `GResolver` functionality that also implement
// [iface@Gio.SocketConnectable], making it easy to connect to a remote
// host/service.
//
// The default resolver (see [func@Gio.Resolver.get_default]) has a timeout of
// 30s set on it since GLib 2.78. Earlier versions of GLib did not support
// resolver timeouts.
//
// This is an abstract type; subclasses of it implement different resolvers for
// different platforms and situations.
type Resolver struct {
	gobject.Object
}

var xResolverGLibType func() types.GType

func ResolverGLibType() types.GType {
	return xResolverGLibType()
}

func ResolverNewFromInternalPtr(ptr uintptr) *Resolver {
	cls := &Resolver{}
	cls.Ptr = ptr
	return cls
}

var xResolverGetTimeout func(uintptr) uint

// Get the timeout applied to all resolver lookups. See #GResolver:timeout.
func (x *Resolver) GetTimeout() uint {

	cret := xResolverGetTimeout(x.GoPointer())

	return cret
}

var xResolverLookupByAddress func(uintptr, uintptr, uintptr, **glib.Error) string

// Synchronously reverse-resolves @address to determine its
// associated hostname.
//
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError.
//
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupByAddress(AddressVar *InetAddress, CancellableVar *Cancellable) (string, error) {
	var cerr *glib.Error

	cret := xResolverLookupByAddress(x.GoPointer(), AddressVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByAddressAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Begins asynchronously reverse-resolving @address to determine its
// associated hostname, and eventually calls @callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
func (x *Resolver) LookupByAddressAsync(AddressVar *InetAddress, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xResolverLookupByAddressAsync(x.GoPointer(), AddressVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xResolverLookupByAddressFinish func(uintptr, uintptr, **glib.Error) string

// Retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupByAddressFinish(ResultVar AsyncResult) (string, error) {
	var cerr *glib.Error

	cret := xResolverLookupByAddressFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByName func(uintptr, string, uintptr, **glib.Error) *glib.List

// Synchronously resolves @hostname to determine its associated IP
// address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
// the textual form of an IP address (in which case this just becomes
// a wrapper around g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// #GInetAddress, sorted in order of preference and guaranteed to not
// contain duplicates. That is, if using the result to connect to
// @hostname, you should attempt to connect to the first address
// first, then the second if the first fails, etc. If you are using
// the result to listen on a socket, it is appropriate to add each
// result using e.g. g_socket_listener_add_address().
//
// If the DNS resolution fails, @error (if non-%NULL) will be set to a
// value from #GResolverError and %NULL will be returned.
//
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP
// address, it may be easier to create a #GNetworkAddress and use its
// #GSocketConnectable interface.
func (x *Resolver) LookupByName(HostnameVar string, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupByName(x.GoPointer(), HostnameVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByNameAsync func(uintptr, string, uintptr, uintptr, uintptr)

// Begins asynchronously resolving @hostname to determine its
// associated IP address(es), and eventually calls @callback, which
// must call g_resolver_lookup_by_name_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
func (x *Resolver) LookupByNameAsync(HostnameVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xResolverLookupByNameAsync(x.GoPointer(), HostnameVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xResolverLookupByNameFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Retrieves the result of a call to
// g_resolver_lookup_by_name_async().
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupByNameFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupByNameFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByNameWithFlags func(uintptr, string, ResolverNameLookupFlags, uintptr, **glib.Error) *glib.List

// This differs from g_resolver_lookup_by_name() in that you can modify
// the lookup behavior with @flags. For example this can be used to limit
// results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
func (x *Resolver) LookupByNameWithFlags(HostnameVar string, FlagsVar ResolverNameLookupFlags, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupByNameWithFlags(x.GoPointer(), HostnameVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByNameWithFlagsAsync func(uintptr, string, ResolverNameLookupFlags, uintptr, uintptr, uintptr)

// Begins asynchronously resolving @hostname to determine its
// associated IP address(es), and eventually calls @callback, which
// must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
func (x *Resolver) LookupByNameWithFlagsAsync(HostnameVar string, FlagsVar ResolverNameLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xResolverLookupByNameWithFlagsAsync(x.GoPointer(), HostnameVar, FlagsVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xResolverLookupByNameWithFlagsFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Retrieves the result of a call to
// g_resolver_lookup_by_name_with_flags_async().
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupByNameWithFlagsFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupByNameWithFlagsFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupRecords func(uintptr, string, ResolverRecordType, uintptr, **glib.Error) *glib.List

// Synchronously performs a DNS record lookup for the given @rrname and returns
// a list of records as #GVariant tuples. See #GResolverRecordType for
// information on what the records contain for each @record_type.
//
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError and %NULL will be returned.
//
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupRecords(RrnameVar string, RecordTypeVar ResolverRecordType, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupRecords(x.GoPointer(), RrnameVar, RecordTypeVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupRecordsAsync func(uintptr, string, ResolverRecordType, uintptr, uintptr, uintptr)

// Begins asynchronously performing a DNS lookup for the given
// @rrname, and eventually calls @callback, which must call
// g_resolver_lookup_records_finish() to get the final result. See
// g_resolver_lookup_records() for more details.
func (x *Resolver) LookupRecordsAsync(RrnameVar string, RecordTypeVar ResolverRecordType, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xResolverLookupRecordsAsync(x.GoPointer(), RrnameVar, RecordTypeVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xResolverLookupRecordsFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Retrieves the result of a previous call to
// g_resolver_lookup_records_async(). Returns a non-empty list of records as
// #GVariant tuples. See #GResolverRecordType for information on what the
// records contain.
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupRecordsFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupRecordsFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupService func(uintptr, string, string, string, uintptr, **glib.Error) *glib.List

// Synchronously performs a DNS SRV lookup for the given @service and
// @protocol in the given @domain and returns an array of #GSrvTarget.
// @domain may be an ASCII-only or UTF-8 hostname. Note also that the
// @service and @protocol arguments do not include the leading underscore
// that appears in the actual DNS entry.
//
// On success, g_resolver_lookup_service() will return a non-empty #GList of
// #GSrvTarget, sorted in order of preference. (That is, you should
// attempt to connect to the first target first, then the second if
// the first fails, etc.)
//
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError and %NULL will be returned.
//
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to the service, it is usually easier
// to create a #GNetworkService and use its #GSocketConnectable
// interface.
func (x *Resolver) LookupService(ServiceVar string, ProtocolVar string, DomainVar string, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupService(x.GoPointer(), ServiceVar, ProtocolVar, DomainVar, CancellableVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupServiceAsync func(uintptr, string, string, string, uintptr, uintptr, uintptr)

// Begins asynchronously performing a DNS SRV lookup for the given
// @service and @protocol in the given @domain, and eventually calls
// @callback, which must call g_resolver_lookup_service_finish() to
// get the final result. See g_resolver_lookup_service() for more
// details.
func (x *Resolver) LookupServiceAsync(ServiceVar string, ProtocolVar string, DomainVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xResolverLookupServiceAsync(x.GoPointer(), ServiceVar, ProtocolVar, DomainVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xResolverLookupServiceFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Retrieves the result of a previous call to
// g_resolver_lookup_service_async().
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupServiceFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupServiceFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverSetDefault func(uintptr)

// Sets @resolver to be the application's default resolver (reffing
// @resolver, and unreffing the previous default resolver, if any).
// Future calls to g_resolver_get_default() will return this resolver.
//
// This can be used if an application wants to perform any sort of DNS
// caching or "pinning"; it can implement its own #GResolver that
// calls the original default resolver for DNS operations, and
// implements its own cache policies on top of that, and then set
// itself as the default resolver for all later code to use.
func (x *Resolver) SetDefault() {

	xResolverSetDefault(x.GoPointer())

}

var xResolverSetTimeout func(uintptr, uint)

// Set the timeout applied to all resolver lookups. See #GResolver:timeout.
func (x *Resolver) SetTimeout(TimeoutMsVar uint) {

	xResolverSetTimeout(x.GoPointer(), TimeoutMsVar)

}

func (c *Resolver) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Resolver) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyTimeout sets the "timeout" property.
// The timeout applied to all resolver lookups, in milliseconds.
//
// This may be changed through the lifetime of the #GResolver. The new value
// will apply to any lookups started after the change, but not to any
// already-ongoing lookups.
//
// If this is `0`, no timeout is applied to lookups.
//
// No timeout was applied to lookups before this property was added in
// GLib 2.78.
func (x *Resolver) SetPropertyTimeout(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("timeout", &v)
}

// GetPropertyTimeout gets the "timeout" property.
// The timeout applied to all resolver lookups, in milliseconds.
//
// This may be changed through the lifetime of the #GResolver. The new value
// will apply to any lookups started after the change, but not to any
// already-ongoing lookups.
//
// If this is `0`, no timeout is applied to lookups.
//
// No timeout was applied to lookups before this property was added in
// GLib 2.78.
func (x *Resolver) GetPropertyTimeout() uint {
	var v gobject.Value
	x.GetProperty("timeout", &v)
	return v.GetUint()
}

// Emitted when the resolver notices that the system resolver
// configuration has changed.
func (x *Resolver) ConnectReload(cb *func(Resolver)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "reload", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Resolver{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "reload", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

var xResolverFreeAddresses func(*glib.List)

// Frees @addresses (which should be the return value from
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_finish()).
// (This is a convenience method; you can also simply free the results
// by hand.)
func ResolverFreeAddresses(AddressesVar *glib.List) {

	xResolverFreeAddresses(AddressesVar)

}

var xResolverFreeTargets func(*glib.List)

// Frees @targets (which should be the return value from
// g_resolver_lookup_service() or g_resolver_lookup_service_finish()).
// (This is a convenience method; you can also simply free the
// results by hand.)
func ResolverFreeTargets(TargetsVar *glib.List) {

	xResolverFreeTargets(TargetsVar)

}

var xResolverGetDefault func() uintptr

// Gets the default #GResolver. You should unref it when you are done
// with it. #GResolver may use its reference count as a hint about how
// many threads it should allocate for concurrent DNS resolutions.
func ResolverGetDefault() *Resolver {
	var cls *Resolver

	cret := xResolverGetDefault()

	if cret == 0 {
		return nil
	}
	cls = &Resolver{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xResolverNameLookupFlagsGLibType, libs, "g_resolver_name_lookup_flags_get_type")

	core.PuregoSafeRegister(&xResolverErrorQuark, libs, "g_resolver_error_quark")

	core.PuregoSafeRegister(&xResolverGLibType, libs, "g_resolver_get_type")

	core.PuregoSafeRegister(&xResolverGetTimeout, libs, "g_resolver_get_timeout")
	core.PuregoSafeRegister(&xResolverLookupByAddress, libs, "g_resolver_lookup_by_address")
	core.PuregoSafeRegister(&xResolverLookupByAddressAsync, libs, "g_resolver_lookup_by_address_async")
	core.PuregoSafeRegister(&xResolverLookupByAddressFinish, libs, "g_resolver_lookup_by_address_finish")
	core.PuregoSafeRegister(&xResolverLookupByName, libs, "g_resolver_lookup_by_name")
	core.PuregoSafeRegister(&xResolverLookupByNameAsync, libs, "g_resolver_lookup_by_name_async")
	core.PuregoSafeRegister(&xResolverLookupByNameFinish, libs, "g_resolver_lookup_by_name_finish")
	core.PuregoSafeRegister(&xResolverLookupByNameWithFlags, libs, "g_resolver_lookup_by_name_with_flags")
	core.PuregoSafeRegister(&xResolverLookupByNameWithFlagsAsync, libs, "g_resolver_lookup_by_name_with_flags_async")
	core.PuregoSafeRegister(&xResolverLookupByNameWithFlagsFinish, libs, "g_resolver_lookup_by_name_with_flags_finish")
	core.PuregoSafeRegister(&xResolverLookupRecords, libs, "g_resolver_lookup_records")
	core.PuregoSafeRegister(&xResolverLookupRecordsAsync, libs, "g_resolver_lookup_records_async")
	core.PuregoSafeRegister(&xResolverLookupRecordsFinish, libs, "g_resolver_lookup_records_finish")
	core.PuregoSafeRegister(&xResolverLookupService, libs, "g_resolver_lookup_service")
	core.PuregoSafeRegister(&xResolverLookupServiceAsync, libs, "g_resolver_lookup_service_async")
	core.PuregoSafeRegister(&xResolverLookupServiceFinish, libs, "g_resolver_lookup_service_finish")
	core.PuregoSafeRegister(&xResolverSetDefault, libs, "g_resolver_set_default")
	core.PuregoSafeRegister(&xResolverSetTimeout, libs, "g_resolver_set_timeout")

	core.PuregoSafeRegister(&xResolverFreeAddresses, libs, "g_resolver_free_addresses")
	core.PuregoSafeRegister(&xResolverFreeTargets, libs, "g_resolver_free_targets")
	core.PuregoSafeRegister(&xResolverGetDefault, libs, "g_resolver_get_default")

}
