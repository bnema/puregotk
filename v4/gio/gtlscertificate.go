// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type TlsCertificateClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xVerify uintptr

	Padding [8]uintptr
}

func (x *TlsCertificateClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideVerify sets the "verify" callback function.
func (x *TlsCertificateClass) OverrideVerify(cb func(*TlsCertificate, SocketConnectable, *TlsCertificate) TlsCertificateFlags) {
	if cb == nil {
		x.xVerify = 0
	} else {
		x.xVerify = purego.NewCallback(func(CertVarp uintptr, IdentityVarp uintptr, TrustedCaVarp uintptr) TlsCertificateFlags {
			return cb(TlsCertificateNewFromInternalPtr(CertVarp), &SocketConnectableBase{Ptr: IdentityVarp}, TlsCertificateNewFromInternalPtr(TrustedCaVarp))
		})
	}
}

// GetVerify gets the "verify" callback function.
func (x *TlsCertificateClass) GetVerify() func(*TlsCertificate, SocketConnectable, *TlsCertificate) TlsCertificateFlags {
	if x.xVerify == 0 {
		return nil
	}
	var rawCallback func(CertVarp uintptr, IdentityVarp uintptr, TrustedCaVarp uintptr) TlsCertificateFlags
	purego.RegisterFunc(&rawCallback, x.xVerify)
	return func(CertVar *TlsCertificate, IdentityVar SocketConnectable, TrustedCaVar *TlsCertificate) TlsCertificateFlags {
		return rawCallback(CertVar.GoPointer(), IdentityVar.GoPointer(), TrustedCaVar.GoPointer())
	}
}

type TlsCertificatePrivate struct {
	_ structs.HostLayout
}

func (x *TlsCertificatePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate
// received by a client from a server), or the combination of
// a certificate and a private key (which is needed when acting as a
// [iface@Gio.TlsServerConnection]).
type TlsCertificate struct {
	gobject.Object
}

var xTlsCertificateGLibType func() types.GType

func TlsCertificateGLibType() types.GType {
	return xTlsCertificateGLibType()
}

func TlsCertificateNewFromInternalPtr(ptr uintptr) *TlsCertificate {
	cls := &TlsCertificate{}
	cls.Ptr = ptr
	return cls
}

var xNewTlsCertificateFromFile func(string, **glib.Error) uintptr

// Creates a #GTlsCertificate from the data in @file.
//
// As of 2.72, if the filename ends in `.p12` or `.pfx` the data is loaded by
// g_tls_certificate_new_from_pkcs12() otherwise it is loaded by
// g_tls_certificate_new_from_pem(). See those functions for
// exact details.
//
// If @file cannot be read or parsed, the function will return %NULL and
// set @error.
func NewTlsCertificateFromFile(FileVar string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromFile(FileVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromFileWithPassword func(string, string, **glib.Error) uintptr

// Creates a #GTlsCertificate from the data in @file.
//
// If @file cannot be read or parsed, the function will return %NULL and
// set @error.
//
// Any unknown file types will error with %G_IO_ERROR_NOT_SUPPORTED.
// Currently only `.p12` and `.pfx` files are supported.
// See g_tls_certificate_new_from_pkcs12() for more details.
func NewTlsCertificateFromFileWithPassword(FileVar string, PasswordVar string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromFileWithPassword(FileVar, PasswordVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromFiles func(string, string, **glib.Error) uintptr

// Creates a #GTlsCertificate from the PEM-encoded data in @cert_file
// and @key_file. The returned certificate will be the first certificate
// found in @cert_file. As of GLib 2.44, if @cert_file contains more
// certificates it will try to load a certificate chain. All
// certificates will be verified in the order found (top-level
// certificate should be the last one in the file) and the
// #GTlsCertificate:issuer property of each certificate will be set
// accordingly if the verification succeeds. If any certificate in the
// chain cannot be verified, the first certificate in the file will
// still be returned.
//
// If either file cannot be read or parsed, the function will return
// %NULL and set @error. Otherwise, this behaves like
// g_tls_certificate_new_from_pem().
func NewTlsCertificateFromFiles(CertFileVar string, KeyFileVar string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromFiles(CertFileVar, KeyFileVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromPem func(string, int, **glib.Error) uintptr

// Creates a #GTlsCertificate from the PEM-encoded data in @data. If
// @data includes both a certificate and a private key, then the
// returned certificate will include the private key data as well. (See
// the #GTlsCertificate:private-key-pem property for information about
// supported formats.)
//
// The returned certificate will be the first certificate found in
// @data. As of GLib 2.44, if @data contains more certificates it will
// try to load a certificate chain. All certificates will be verified in
// the order found (top-level certificate should be the last one in the
// file) and the #GTlsCertificate:issuer property of each certificate
// will be set accordingly if the verification succeeds. If any
// certificate in the chain cannot be verified, the first certificate in
// the file will still be returned.
func NewTlsCertificateFromPem(DataVar string, LengthVar int) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromPem(DataVar, LengthVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromPkcs11Uris func(string, uintptr, **glib.Error) uintptr

// Creates a #GTlsCertificate from a
// [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.
//
// An example @pkcs11_uri would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01`
//
// Where the token’s layout is:
//
// |[
// Object 0:
//
//	URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=private%20key;type=private
//	Type: Private key (RSA-2048)
//	ID: 01
//
// Object 1:
//
//	URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=Certificate%20for%20Authentication;type=cert
//	Type: X.509 Certificate (RSA-2048)
//	ID: 01
//
// ]|
//
// In this case the certificate and private key would both be detected and used as expected.
// @pkcs_uri may also just reference an X.509 certificate object and then optionally
// @private_key_pkcs11_uri allows using a private key exposed under a different URI.
//
// Note that the private key is not accessed until usage and may fail or require a PIN later.
func NewTlsCertificateFromPkcs11Uris(Pkcs11UriVar string, PrivateKeyPkcs11UriVar *string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	PrivateKeyPkcs11UriVarPtr, PrivateKeyPkcs11UriVarBytes := core.NullableStringToPtr(PrivateKeyPkcs11UriVar)

	cret := xNewTlsCertificateFromPkcs11Uris(Pkcs11UriVar, PrivateKeyPkcs11UriVarPtr, &cerr)

	runtime.KeepAlive(PrivateKeyPkcs11UriVarBytes)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromPkcs12 func([]byte, uint, uintptr, **glib.Error) uintptr

// Creates a #GTlsCertificate from the data in @data. It must contain
// a certificate and matching private key.
//
// If extra certificates are included they will be verified as a chain
// and the #GTlsCertificate:issuer property will be set.
// All other data will be ignored.
//
// You can pass as single password for all of the data which will be
// used both for the PKCS #12 container as well as encrypted
// private keys. If decryption fails it will error with
// %G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD.
//
// This constructor requires support in the current #GTlsBackend.
// If support is missing it will error with
// %G_IO_ERROR_NOT_SUPPORTED.
//
// Other parsing failures will error with %G_TLS_ERROR_BAD_CERTIFICATE.
func NewTlsCertificateFromPkcs12(DataVar []byte, LengthVar uint, PasswordVar *string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	PasswordVarPtr, PasswordVarBytes := core.NullableStringToPtr(PasswordVar)

	cret := xNewTlsCertificateFromPkcs12(DataVar, LengthVar, PasswordVarPtr, &cerr)

	runtime.KeepAlive(PasswordVarBytes)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsCertificateGetDnsNames func(uintptr) uintptr

// Gets the value of #GTlsCertificate:dns-names.
func (x *TlsCertificate) GetDnsNames() uintptr {

	cret := xTlsCertificateGetDnsNames(x.GoPointer())

	return cret
}

var xTlsCertificateGetIpAddresses func(uintptr) uintptr

// Gets the value of #GTlsCertificate:ip-addresses.
func (x *TlsCertificate) GetIpAddresses() uintptr {

	cret := xTlsCertificateGetIpAddresses(x.GoPointer())

	return cret
}

var xTlsCertificateGetIssuer func(uintptr) uintptr

// Gets the #GTlsCertificate representing @cert's issuer, if known
func (x *TlsCertificate) GetIssuer() *TlsCertificate {
	var cls *TlsCertificate

	cret := xTlsCertificateGetIssuer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TlsCertificate{}
	cls.Ptr = cret
	return cls
}

var xTlsCertificateGetIssuerName func(uintptr) string

// Returns the issuer name from the certificate.
func (x *TlsCertificate) GetIssuerName() string {

	cret := xTlsCertificateGetIssuerName(x.GoPointer())

	return cret
}

var xTlsCertificateGetNotValidAfter func(uintptr) *glib.DateTime

// Returns the time at which the certificate became or will become invalid.
func (x *TlsCertificate) GetNotValidAfter() *glib.DateTime {

	cret := xTlsCertificateGetNotValidAfter(x.GoPointer())

	return cret
}

var xTlsCertificateGetNotValidBefore func(uintptr) *glib.DateTime

// Returns the time at which the certificate became or will become valid.
func (x *TlsCertificate) GetNotValidBefore() *glib.DateTime {

	cret := xTlsCertificateGetNotValidBefore(x.GoPointer())

	return cret
}

var xTlsCertificateGetSubjectName func(uintptr) string

// Returns the subject name from the certificate.
func (x *TlsCertificate) GetSubjectName() string {

	cret := xTlsCertificateGetSubjectName(x.GoPointer())

	return cret
}

var xTlsCertificateIsSame func(uintptr, uintptr) bool

// Check if two #GTlsCertificate objects represent the same certificate.
// The raw DER byte data of the two certificates are checked for equality.
// This has the effect that two certificates may compare equal even if
// their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
// #GTlsCertificate:private-key-pem properties differ.
func (x *TlsCertificate) IsSame(CertTwoVar *TlsCertificate) bool {

	cret := xTlsCertificateIsSame(x.GoPointer(), CertTwoVar.GoPointer())

	return cret
}

var xTlsCertificateVerify func(uintptr, uintptr, uintptr) TlsCertificateFlags

// This verifies @cert and returns a set of #GTlsCertificateFlags
// indicating any problems found with it. This can be used to verify a
// certificate outside the context of making a connection, or to
// check a certificate against a CA that is not part of the system
// CA database.
//
// If @cert is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
//
// If @identity is not %NULL, @cert's name(s) will be compared against
// it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
// value if it does not match. If @identity is %NULL, that bit will
// never be set in the return value.
//
// If @trusted_ca is not %NULL, then @cert (or one of the certificates
// in its chain) must be signed by it, or else
// %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
// @trusted_ca is %NULL, that bit will never be set in the return
// value.
//
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
//
// Because TLS session context is not used, #GTlsCertificate may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
func (x *TlsCertificate) Verify(IdentityVar SocketConnectable, TrustedCaVar *TlsCertificate) TlsCertificateFlags {

	cret := xTlsCertificateVerify(x.GoPointer(), IdentityVar.GoPointer(), TrustedCaVar.GoPointer())

	return cret
}

func (c *TlsCertificate) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *TlsCertificate) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyCertificate sets the "certificate" property.
// The DER (binary) encoded representation of the certificate.
// This property and the #GTlsCertificate:certificate-pem property
// represent the same data, just in different forms.
func (x *TlsCertificate) SetPropertyCertificate(value []byte) {
	var v gobject.Value
	v.Init(glib.ByteArrayGLibType())
	v.SetBoxed(uintptr(unsafe.Pointer(&value[0])))
	x.SetProperty("certificate", &v)
}

// GetPropertyCertificate gets the "certificate" property.
// The DER (binary) encoded representation of the certificate.
// This property and the #GTlsCertificate:certificate-pem property
// represent the same data, just in different forms.
func (x *TlsCertificate) GetPropertyCertificate() []byte {
	var v gobject.Value
	x.GetProperty("certificate", &v)
	ptr := v.GetBoxed()
	if ptr == 0 {
		return nil
	}
	// GByteArray layout: { guint8 *data; guint len; }
	dataPtr := *(*uintptr)(unsafe.Pointer(ptr))
	length := *(*uint32)(unsafe.Pointer(ptr + unsafe.Sizeof(uintptr(0))))
	if length == 0 || dataPtr == 0 {
		return nil
	}
	return unsafe.Slice((*byte)(unsafe.Pointer(dataPtr)), length)
}

// SetPropertyCertificatePem sets the "certificate-pem" property.
// The PEM (ASCII) encoded representation of the certificate.
// This property and the #GTlsCertificate:certificate
// property represent the same data, just in different forms.
func (x *TlsCertificate) SetPropertyCertificatePem(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("certificate-pem", &v)
}

// GetPropertyCertificatePem gets the "certificate-pem" property.
// The PEM (ASCII) encoded representation of the certificate.
// This property and the #GTlsCertificate:certificate
// property represent the same data, just in different forms.
func (x *TlsCertificate) GetPropertyCertificatePem() string {
	var v gobject.Value
	x.GetProperty("certificate-pem", &v)
	return v.GetString()
}

// GetPropertyDnsNames gets the "dns-names" property.
// The DNS names from the certificate's Subject Alternative Names (SANs),
// %NULL if unavailable.
func (x *TlsCertificate) GetPropertyDnsNames() []uintptr {
	var v gobject.Value
	x.GetProperty("dns-names", &v)
	ptr := v.GetBoxed()
	if ptr == 0 {
		return nil
	}
	// GPtrArray layout: { gpointer *pdata; guint len; }
	dataPtr := *(*uintptr)(unsafe.Pointer(ptr))
	length := *(*uint32)(unsafe.Pointer(ptr + unsafe.Sizeof(uintptr(0))))
	if length == 0 || dataPtr == 0 {
		return nil
	}
	return unsafe.Slice((*uintptr)(unsafe.Pointer(dataPtr)), length)
}

// GetPropertyIpAddresses gets the "ip-addresses" property.
// The IP addresses from the certificate's Subject Alternative Names (SANs),
// %NULL if unavailable.
func (x *TlsCertificate) GetPropertyIpAddresses() []uintptr {
	var v gobject.Value
	x.GetProperty("ip-addresses", &v)
	ptr := v.GetBoxed()
	if ptr == 0 {
		return nil
	}
	// GPtrArray layout: { gpointer *pdata; guint len; }
	dataPtr := *(*uintptr)(unsafe.Pointer(ptr))
	length := *(*uint32)(unsafe.Pointer(ptr + unsafe.Sizeof(uintptr(0))))
	if length == 0 || dataPtr == 0 {
		return nil
	}
	return unsafe.Slice((*uintptr)(unsafe.Pointer(dataPtr)), length)
}

// GetPropertyIssuerName gets the "issuer-name" property.
// The issuer from the certificate,
// %NULL if unavailable.
func (x *TlsCertificate) GetPropertyIssuerName() string {
	var v gobject.Value
	x.GetProperty("issuer-name", &v)
	return v.GetString()
}

// GetPropertyNotValidAfter gets the "not-valid-after" property.
// The time at which this cert is no longer valid,
// %NULL if unavailable.
func (x *TlsCertificate) GetPropertyNotValidAfter() uintptr {
	var v gobject.Value
	x.GetProperty("not-valid-after", &v)
	return v.GetPointer()
}

// GetPropertyNotValidBefore gets the "not-valid-before" property.
// The time at which this cert is considered to be valid,
// %NULL if unavailable.
func (x *TlsCertificate) GetPropertyNotValidBefore() uintptr {
	var v gobject.Value
	x.GetProperty("not-valid-before", &v)
	return v.GetPointer()
}

// SetPropertyPassword sets the "password" property.
// An optional password used when constructed with GTlsCertificate:pkcs12-data.
func (x *TlsCertificate) SetPropertyPassword(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("password", &v)
}

// SetPropertyPkcs11Uri sets the "pkcs11-uri" property.
// A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
// objects containing an X.509 certificate and optionally a private key.
//
// If %NULL, the certificate is either not backed by PKCS \#11 or the
// #GTlsBackend does not support PKCS \#11.
func (x *TlsCertificate) SetPropertyPkcs11Uri(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("pkcs11-uri", &v)
}

// GetPropertyPkcs11Uri gets the "pkcs11-uri" property.
// A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
// objects containing an X.509 certificate and optionally a private key.
//
// If %NULL, the certificate is either not backed by PKCS \#11 or the
// #GTlsBackend does not support PKCS \#11.
func (x *TlsCertificate) GetPropertyPkcs11Uri() string {
	var v gobject.Value
	x.GetProperty("pkcs11-uri", &v)
	return v.GetString()
}

// SetPropertyPkcs12Data sets the "pkcs12-data" property.
// The PKCS #12 formatted data used to construct the object.
//
// See also: g_tls_certificate_new_from_pkcs12()
func (x *TlsCertificate) SetPropertyPkcs12Data(value []byte) {
	var v gobject.Value
	v.Init(glib.ByteArrayGLibType())
	v.SetBoxed(uintptr(unsafe.Pointer(&value[0])))
	x.SetProperty("pkcs12-data", &v)
}

// SetPropertyPrivateKey sets the "private-key" property.
// The DER (binary) encoded representation of the certificate's
// private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
// or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
// PKCS \#8 format is supported since 2.32; earlier releases only
// support PKCS \#1. You can use the `openssl rsa` tool to convert
// PKCS \#8 keys to PKCS \#1.
//
// This property (or the #GTlsCertificate:private-key-pem property)
// can be set when constructing a key (for example, from a file).
// Since GLib 2.70, it is now also readable; however, be aware that if
// the private key is backed by a PKCS \#11 URI – for example, if it
// is stored on a smartcard – then this property will be %NULL. If so,
// the private key must be referenced via its PKCS \#11 URI,
// #GTlsCertificate:private-key-pkcs11-uri. You must check both
// properties to see if the certificate really has a private key.
// When this property is read, the output format will be unencrypted
// PKCS \#8.
func (x *TlsCertificate) SetPropertyPrivateKey(value []byte) {
	var v gobject.Value
	v.Init(glib.ByteArrayGLibType())
	v.SetBoxed(uintptr(unsafe.Pointer(&value[0])))
	x.SetProperty("private-key", &v)
}

// GetPropertyPrivateKey gets the "private-key" property.
// The DER (binary) encoded representation of the certificate's
// private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
// or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
// PKCS \#8 format is supported since 2.32; earlier releases only
// support PKCS \#1. You can use the `openssl rsa` tool to convert
// PKCS \#8 keys to PKCS \#1.
//
// This property (or the #GTlsCertificate:private-key-pem property)
// can be set when constructing a key (for example, from a file).
// Since GLib 2.70, it is now also readable; however, be aware that if
// the private key is backed by a PKCS \#11 URI – for example, if it
// is stored on a smartcard – then this property will be %NULL. If so,
// the private key must be referenced via its PKCS \#11 URI,
// #GTlsCertificate:private-key-pkcs11-uri. You must check both
// properties to see if the certificate really has a private key.
// When this property is read, the output format will be unencrypted
// PKCS \#8.
func (x *TlsCertificate) GetPropertyPrivateKey() []byte {
	var v gobject.Value
	x.GetProperty("private-key", &v)
	ptr := v.GetBoxed()
	if ptr == 0 {
		return nil
	}
	// GByteArray layout: { guint8 *data; guint len; }
	dataPtr := *(*uintptr)(unsafe.Pointer(ptr))
	length := *(*uint32)(unsafe.Pointer(ptr + unsafe.Sizeof(uintptr(0))))
	if length == 0 || dataPtr == 0 {
		return nil
	}
	return unsafe.Slice((*byte)(unsafe.Pointer(dataPtr)), length)
}

// SetPropertyPrivateKeyPem sets the "private-key-pem" property.
// The PEM (ASCII) encoded representation of the certificate's
// private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
// ("`BEGIN RSA PRIVATE KEY`") or unencrypted
// [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
// ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
// earlier releases only support PKCS \#1. You can use the `openssl rsa`
// tool to convert PKCS \#8 keys to PKCS \#1.
//
// This property (or the #GTlsCertificate:private-key property)
// can be set when constructing a key (for example, from a file).
// Since GLib 2.70, it is now also readable; however, be aware that if
// the private key is backed by a PKCS \#11 URI - for example, if it
// is stored on a smartcard - then this property will be %NULL. If so,
// the private key must be referenced via its PKCS \#11 URI,
// #GTlsCertificate:private-key-pkcs11-uri. You must check both
// properties to see if the certificate really has a private key.
// When this property is read, the output format will be unencrypted
// PKCS \#8.
func (x *TlsCertificate) SetPropertyPrivateKeyPem(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("private-key-pem", &v)
}

// GetPropertyPrivateKeyPem gets the "private-key-pem" property.
// The PEM (ASCII) encoded representation of the certificate's
// private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
// ("`BEGIN RSA PRIVATE KEY`") or unencrypted
// [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
// ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
// earlier releases only support PKCS \#1. You can use the `openssl rsa`
// tool to convert PKCS \#8 keys to PKCS \#1.
//
// This property (or the #GTlsCertificate:private-key property)
// can be set when constructing a key (for example, from a file).
// Since GLib 2.70, it is now also readable; however, be aware that if
// the private key is backed by a PKCS \#11 URI - for example, if it
// is stored on a smartcard - then this property will be %NULL. If so,
// the private key must be referenced via its PKCS \#11 URI,
// #GTlsCertificate:private-key-pkcs11-uri. You must check both
// properties to see if the certificate really has a private key.
// When this property is read, the output format will be unencrypted
// PKCS \#8.
func (x *TlsCertificate) GetPropertyPrivateKeyPem() string {
	var v gobject.Value
	x.GetProperty("private-key-pem", &v)
	return v.GetString()
}

// SetPropertyPrivateKeyPkcs11Uri sets the "private-key-pkcs11-uri" property.
// A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
// object containing a private key.
func (x *TlsCertificate) SetPropertyPrivateKeyPkcs11Uri(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("private-key-pkcs11-uri", &v)
}

// GetPropertyPrivateKeyPkcs11Uri gets the "private-key-pkcs11-uri" property.
// A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
// object containing a private key.
func (x *TlsCertificate) GetPropertyPrivateKeyPkcs11Uri() string {
	var v gobject.Value
	x.GetProperty("private-key-pkcs11-uri", &v)
	return v.GetString()
}

// GetPropertySubjectName gets the "subject-name" property.
// The subject from the cert,
// %NULL if unavailable.
func (x *TlsCertificate) GetPropertySubjectName() string {
	var v gobject.Value
	x.GetProperty("subject-name", &v)
	return v.GetString()
}

var xTlsCertificateListNewFromFile func(string, **glib.Error) *glib.List

// Creates one or more #GTlsCertificates from the PEM-encoded
// data in @file. If @file cannot be read or parsed, the function will
// return %NULL and set @error. If @file does not contain any
// PEM-encoded certificates, this will return an empty list and not
// set @error.
func TlsCertificateListNewFromFile(FileVar string) (*glib.List, error) {
	var cerr *glib.Error

	cret := xTlsCertificateListNewFromFile(FileVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTlsCertificateGLibType, libs, "g_tls_certificate_get_type")

	core.PuregoSafeRegister(&xNewTlsCertificateFromFile, libs, "g_tls_certificate_new_from_file")
	core.PuregoSafeRegister(&xNewTlsCertificateFromFileWithPassword, libs, "g_tls_certificate_new_from_file_with_password")
	core.PuregoSafeRegister(&xNewTlsCertificateFromFiles, libs, "g_tls_certificate_new_from_files")
	core.PuregoSafeRegister(&xNewTlsCertificateFromPem, libs, "g_tls_certificate_new_from_pem")
	core.PuregoSafeRegister(&xNewTlsCertificateFromPkcs11Uris, libs, "g_tls_certificate_new_from_pkcs11_uris")
	core.PuregoSafeRegister(&xNewTlsCertificateFromPkcs12, libs, "g_tls_certificate_new_from_pkcs12")

	core.PuregoSafeRegister(&xTlsCertificateGetDnsNames, libs, "g_tls_certificate_get_dns_names")
	core.PuregoSafeRegister(&xTlsCertificateGetIpAddresses, libs, "g_tls_certificate_get_ip_addresses")
	core.PuregoSafeRegister(&xTlsCertificateGetIssuer, libs, "g_tls_certificate_get_issuer")
	core.PuregoSafeRegister(&xTlsCertificateGetIssuerName, libs, "g_tls_certificate_get_issuer_name")
	core.PuregoSafeRegister(&xTlsCertificateGetNotValidAfter, libs, "g_tls_certificate_get_not_valid_after")
	core.PuregoSafeRegister(&xTlsCertificateGetNotValidBefore, libs, "g_tls_certificate_get_not_valid_before")
	core.PuregoSafeRegister(&xTlsCertificateGetSubjectName, libs, "g_tls_certificate_get_subject_name")
	core.PuregoSafeRegister(&xTlsCertificateIsSame, libs, "g_tls_certificate_is_same")
	core.PuregoSafeRegister(&xTlsCertificateVerify, libs, "g_tls_certificate_verify")

	core.PuregoSafeRegister(&xTlsCertificateListNewFromFile, libs, "g_tls_certificate_list_new_from_file")

}
