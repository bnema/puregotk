// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Interface for implementing operations for mounts.
type MountIface struct {
	_ structs.HostLayout

	GIface uintptr

	xChanged uintptr

	xUnmounted uintptr

	xGetRoot uintptr

	xGetName uintptr

	xGetIcon uintptr

	xGetUuid uintptr

	xGetVolume uintptr

	xGetDrive uintptr

	xCanUnmount uintptr

	xCanEject uintptr

	xUnmount uintptr

	xUnmountFinish uintptr

	xEject uintptr

	xEjectFinish uintptr

	xRemount uintptr

	xRemountFinish uintptr

	xGuessContentType uintptr

	xGuessContentTypeFinish uintptr

	xGuessContentTypeSync uintptr

	xPreUnmount uintptr

	xUnmountWithOperation uintptr

	xUnmountWithOperationFinish uintptr

	xEjectWithOperation uintptr

	xEjectWithOperationFinish uintptr

	xGetDefaultLocation uintptr

	xGetSortKey uintptr

	xGetSymbolicIcon uintptr
}

func (x *MountIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideChanged sets the callback function.
// Changed signal that is emitted when the mount's state has changed.
func (x *MountIface) OverrideChanged(cb func(Mount)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(MountVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp})
		})
	}
}

// GetChanged gets the callback function.
// Changed signal that is emitted when the mount's state has changed.
func (x *MountIface) GetChanged() func(Mount) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(MountVar Mount) {
		rawCallback(MountVar.GoPointer())
	}
}

// OverrideUnmounted sets the callback function.
// The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
func (x *MountIface) OverrideUnmounted(cb func(Mount)) {
	if cb == nil {
		x.xUnmounted = 0
	} else {
		x.xUnmounted = purego.NewCallback(func(MountVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp})
		})
	}
}

// GetUnmounted gets the callback function.
// The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
func (x *MountIface) GetUnmounted() func(Mount) {
	if x.xUnmounted == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnmounted)
	return func(MountVar Mount) {
		rawCallback(MountVar.GoPointer())
	}
}

// OverrideGetRoot sets the callback function.
// Gets a #GFile to the root directory of the #GMount.
func (x *MountIface) OverrideGetRoot(cb func(Mount) *FileBase) {
	if cb == nil {
		x.xGetRoot = 0
	} else {
		x.xGetRoot = purego.NewCallback(func(MountVarp uintptr) uintptr {
			ret := cb(&MountBase{Ptr: MountVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetRoot gets the callback function.
// Gets a #GFile to the root directory of the #GMount.
func (x *MountIface) GetGetRoot() func(Mount) *FileBase {
	if x.xGetRoot == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetRoot)
	return func(MountVar Mount) *FileBase {
		rawRet := rawCallback(MountVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetName sets the callback function.
// Gets a string containing the name of the #GMount.
func (x *MountIface) OverrideGetName(cb func(Mount) string) {
	if cb == nil {
		x.xGetName = 0
	} else {
		x.xGetName = purego.NewCallback(func(MountVarp uintptr) string {
			return cb(&MountBase{Ptr: MountVarp})
		})
	}
}

// GetGetName gets the callback function.
// Gets a string containing the name of the #GMount.
func (x *MountIface) GetGetName() func(Mount) string {
	if x.xGetName == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetName)
	return func(MountVar Mount) string {
		return rawCallback(MountVar.GoPointer())
	}
}

// OverrideGetIcon sets the callback function.
// Gets a #GIcon for the #GMount.
func (x *MountIface) OverrideGetIcon(cb func(Mount) *IconBase) {
	if cb == nil {
		x.xGetIcon = 0
	} else {
		x.xGetIcon = purego.NewCallback(func(MountVarp uintptr) uintptr {
			ret := cb(&MountBase{Ptr: MountVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetIcon gets the callback function.
// Gets a #GIcon for the #GMount.
func (x *MountIface) GetGetIcon() func(Mount) *IconBase {
	if x.xGetIcon == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetIcon)
	return func(MountVar Mount) *IconBase {
		rawRet := rawCallback(MountVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetUuid sets the callback function.
// Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.
func (x *MountIface) OverrideGetUuid(cb func(Mount) string) {
	if cb == nil {
		x.xGetUuid = 0
	} else {
		x.xGetUuid = purego.NewCallback(func(MountVarp uintptr) string {
			return cb(&MountBase{Ptr: MountVarp})
		})
	}
}

// GetGetUuid gets the callback function.
// Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.
func (x *MountIface) GetGetUuid() func(Mount) string {
	if x.xGetUuid == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetUuid)
	return func(MountVar Mount) string {
		return rawCallback(MountVar.GoPointer())
	}
}

// OverrideGetVolume sets the callback function.
// Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.
func (x *MountIface) OverrideGetVolume(cb func(Mount) *VolumeBase) {
	if cb == nil {
		x.xGetVolume = 0
	} else {
		x.xGetVolume = purego.NewCallback(func(MountVarp uintptr) uintptr {
			ret := cb(&MountBase{Ptr: MountVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetVolume gets the callback function.
// Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.
func (x *MountIface) GetGetVolume() func(Mount) *VolumeBase {
	if x.xGetVolume == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetVolume)
	return func(MountVar Mount) *VolumeBase {
		rawRet := rawCallback(MountVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &VolumeBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetDrive sets the callback function.
// Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.
func (x *MountIface) OverrideGetDrive(cb func(Mount) *DriveBase) {
	if cb == nil {
		x.xGetDrive = 0
	} else {
		x.xGetDrive = purego.NewCallback(func(MountVarp uintptr) uintptr {
			ret := cb(&MountBase{Ptr: MountVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetDrive gets the callback function.
// Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.
func (x *MountIface) GetGetDrive() func(Mount) *DriveBase {
	if x.xGetDrive == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetDrive)
	return func(MountVar Mount) *DriveBase {
		rawRet := rawCallback(MountVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &DriveBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideCanUnmount sets the callback function.
// Checks if a #GMount can be unmounted.
func (x *MountIface) OverrideCanUnmount(cb func(Mount) bool) {
	if cb == nil {
		x.xCanUnmount = 0
	} else {
		x.xCanUnmount = purego.NewCallback(func(MountVarp uintptr) bool {
			return cb(&MountBase{Ptr: MountVarp})
		})
	}
}

// GetCanUnmount gets the callback function.
// Checks if a #GMount can be unmounted.
func (x *MountIface) GetCanUnmount() func(Mount) bool {
	if x.xCanUnmount == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanUnmount)
	return func(MountVar Mount) bool {
		return rawCallback(MountVar.GoPointer())
	}
}

// OverrideCanEject sets the callback function.
// Checks if a #GMount can be ejected.
func (x *MountIface) OverrideCanEject(cb func(Mount) bool) {
	if cb == nil {
		x.xCanEject = 0
	} else {
		x.xCanEject = purego.NewCallback(func(MountVarp uintptr) bool {
			return cb(&MountBase{Ptr: MountVarp})
		})
	}
}

// GetCanEject gets the callback function.
// Checks if a #GMount can be ejected.
func (x *MountIface) GetCanEject() func(Mount) bool {
	if x.xCanEject == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanEject)
	return func(MountVar Mount) bool {
		return rawCallback(MountVar.GoPointer())
	}
}

// OverrideUnmount sets the callback function.
// Starts unmounting a #GMount.
func (x *MountIface) OverrideUnmount(cb func(Mount, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xUnmount = 0
	} else {
		x.xUnmount = purego.NewCallback(func(MountVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetUnmount gets the callback function.
// Starts unmounting a #GMount.
func (x *MountIface) GetUnmount() func(Mount, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xUnmount == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnmount)
	return func(MountVar Mount, FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(MountVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideUnmountFinish sets the callback function.
// Finishes an unmounting operation.
func (x *MountIface) OverrideUnmountFinish(cb func(Mount, AsyncResult) bool) {
	if cb == nil {
		x.xUnmountFinish = 0
	} else {
		x.xUnmountFinish = purego.NewCallback(func(MountVarp uintptr, ResultVarp uintptr) bool {
			return cb(&MountBase{Ptr: MountVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetUnmountFinish gets the callback function.
// Finishes an unmounting operation.
func (x *MountIface) GetUnmountFinish() func(Mount, AsyncResult) bool {
	if x.xUnmountFinish == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xUnmountFinish)
	return func(MountVar Mount, ResultVar AsyncResult) bool {
		return rawCallback(MountVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideEject sets the callback function.
// Starts ejecting a #GMount.
func (x *MountIface) OverrideEject(cb func(Mount, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEject = 0
	} else {
		x.xEject = purego.NewCallback(func(MountVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp}, FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEject gets the callback function.
// Starts ejecting a #GMount.
func (x *MountIface) GetEject() func(Mount, MountUnmountFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEject == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, FlagsVarp MountUnmountFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEject)
	return func(MountVar Mount, FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(MountVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEjectFinish sets the callback function.
// Finishes an eject operation.
func (x *MountIface) OverrideEjectFinish(cb func(Mount, AsyncResult) bool) {
	if cb == nil {
		x.xEjectFinish = 0
	} else {
		x.xEjectFinish = purego.NewCallback(func(MountVarp uintptr, ResultVarp uintptr) bool {
			return cb(&MountBase{Ptr: MountVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetEjectFinish gets the callback function.
// Finishes an eject operation.
func (x *MountIface) GetEjectFinish() func(Mount, AsyncResult) bool {
	if x.xEjectFinish == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEjectFinish)
	return func(MountVar Mount, ResultVar AsyncResult) bool {
		return rawCallback(MountVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideRemount sets the callback function.
// Starts remounting a #GMount.
func (x *MountIface) OverrideRemount(cb func(Mount, MountMountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xRemount = 0
	} else {
		x.xRemount = purego.NewCallback(func(MountVarp uintptr, FlagsVarp MountMountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetRemount gets the callback function.
// Starts remounting a #GMount.
func (x *MountIface) GetRemount() func(Mount, MountMountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xRemount == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, FlagsVarp MountMountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRemount)
	return func(MountVar Mount, FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(MountVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideRemountFinish sets the callback function.
// Finishes a remounting operation.
func (x *MountIface) OverrideRemountFinish(cb func(Mount, AsyncResult) bool) {
	if cb == nil {
		x.xRemountFinish = 0
	} else {
		x.xRemountFinish = purego.NewCallback(func(MountVarp uintptr, ResultVarp uintptr) bool {
			return cb(&MountBase{Ptr: MountVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetRemountFinish gets the callback function.
// Finishes a remounting operation.
func (x *MountIface) GetRemountFinish() func(Mount, AsyncResult) bool {
	if x.xRemountFinish == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xRemountFinish)
	return func(MountVar Mount, ResultVar AsyncResult) bool {
		return rawCallback(MountVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGuessContentType sets the callback function.
// Starts guessing the type of the content of a #GMount.
//
//	See g_mount_guess_content_type() for more information on content
//	type guessing. This operation was added in 2.18.
func (x *MountIface) OverrideGuessContentType(cb func(Mount, bool, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xGuessContentType = 0
	} else {
		x.xGuessContentType = purego.NewCallback(func(MountVarp uintptr, ForceRescanVarp bool, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp}, ForceRescanVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetGuessContentType gets the callback function.
// Starts guessing the type of the content of a #GMount.
//
//	See g_mount_guess_content_type() for more information on content
//	type guessing. This operation was added in 2.18.
func (x *MountIface) GetGuessContentType() func(Mount, bool, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xGuessContentType == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, ForceRescanVarp bool, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xGuessContentType)
	return func(MountVar Mount, ForceRescanVar bool, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(MountVar.GoPointer(), ForceRescanVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideGuessContentTypeFinish sets the callback function.
// Finishes a content type guessing operation. Added in 2.18.
func (x *MountIface) OverrideGuessContentTypeFinish(cb func(Mount, AsyncResult) []string) {
	if cb == nil {
		x.xGuessContentTypeFinish = 0
	} else {
		x.xGuessContentTypeFinish = purego.NewCallback(func(MountVarp uintptr, ResultVarp uintptr) []string {
			return cb(&MountBase{Ptr: MountVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetGuessContentTypeFinish gets the callback function.
// Finishes a content type guessing operation. Added in 2.18.
func (x *MountIface) GetGuessContentTypeFinish() func(Mount, AsyncResult) []string {
	if x.xGuessContentTypeFinish == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, ResultVarp uintptr) []string
	purego.RegisterFunc(&rawCallback, x.xGuessContentTypeFinish)
	return func(MountVar Mount, ResultVar AsyncResult) []string {
		return rawCallback(MountVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGuessContentTypeSync sets the callback function.
// Synchronous variant of @guess_content_type. Added in 2.18
func (x *MountIface) OverrideGuessContentTypeSync(cb func(Mount, bool, *Cancellable) []string) {
	if cb == nil {
		x.xGuessContentTypeSync = 0
	} else {
		x.xGuessContentTypeSync = purego.NewCallback(func(MountVarp uintptr, ForceRescanVarp bool, CancellableVarp uintptr) []string {
			return cb(&MountBase{Ptr: MountVarp}, ForceRescanVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetGuessContentTypeSync gets the callback function.
// Synchronous variant of @guess_content_type. Added in 2.18
func (x *MountIface) GetGuessContentTypeSync() func(Mount, bool, *Cancellable) []string {
	if x.xGuessContentTypeSync == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, ForceRescanVarp bool, CancellableVarp uintptr) []string
	purego.RegisterFunc(&rawCallback, x.xGuessContentTypeSync)
	return func(MountVar Mount, ForceRescanVar bool, CancellableVar *Cancellable) []string {
		return rawCallback(MountVar.GoPointer(), ForceRescanVar, CancellableVar.GoPointer())
	}
}

// OverridePreUnmount sets the callback function.
// The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
func (x *MountIface) OverridePreUnmount(cb func(Mount)) {
	if cb == nil {
		x.xPreUnmount = 0
	} else {
		x.xPreUnmount = purego.NewCallback(func(MountVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp})
		})
	}
}

// GetPreUnmount gets the callback function.
// The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
func (x *MountIface) GetPreUnmount() func(Mount) {
	if x.xPreUnmount == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xPreUnmount)
	return func(MountVar Mount) {
		rawCallback(MountVar.GoPointer())
	}
}

// OverrideUnmountWithOperation sets the callback function.
// Starts unmounting a #GMount using a #GMountOperation. Since 2.22.
func (x *MountIface) OverrideUnmountWithOperation(cb func(Mount, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xUnmountWithOperation = 0
	} else {
		x.xUnmountWithOperation = purego.NewCallback(func(MountVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetUnmountWithOperation gets the callback function.
// Starts unmounting a #GMount using a #GMountOperation. Since 2.22.
func (x *MountIface) GetUnmountWithOperation() func(Mount, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xUnmountWithOperation == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xUnmountWithOperation)
	return func(MountVar Mount, FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(MountVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideUnmountWithOperationFinish sets the callback function.
// Finishes an unmounting operation using a #GMountOperation. Since 2.22.
func (x *MountIface) OverrideUnmountWithOperationFinish(cb func(Mount, AsyncResult) bool) {
	if cb == nil {
		x.xUnmountWithOperationFinish = 0
	} else {
		x.xUnmountWithOperationFinish = purego.NewCallback(func(MountVarp uintptr, ResultVarp uintptr) bool {
			return cb(&MountBase{Ptr: MountVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetUnmountWithOperationFinish gets the callback function.
// Finishes an unmounting operation using a #GMountOperation. Since 2.22.
func (x *MountIface) GetUnmountWithOperationFinish() func(Mount, AsyncResult) bool {
	if x.xUnmountWithOperationFinish == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xUnmountWithOperationFinish)
	return func(MountVar Mount, ResultVar AsyncResult) bool {
		return rawCallback(MountVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideEjectWithOperation sets the callback function.
// Starts ejecting a #GMount using a #GMountOperation. Since 2.22.
func (x *MountIface) OverrideEjectWithOperation(cb func(Mount, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xEjectWithOperation = 0
	} else {
		x.xEjectWithOperation = purego.NewCallback(func(MountVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&MountBase{Ptr: MountVarp}, FlagsVarp, MountOperationNewFromInternalPtr(MountOperationVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetEjectWithOperation gets the callback function.
// Starts ejecting a #GMount using a #GMountOperation. Since 2.22.
func (x *MountIface) GetEjectWithOperation() func(Mount, MountUnmountFlags, *MountOperation, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xEjectWithOperation == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, FlagsVarp MountUnmountFlags, MountOperationVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xEjectWithOperation)
	return func(MountVar Mount, FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(MountVar.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideEjectWithOperationFinish sets the callback function.
// Finishes an eject operation using a #GMountOperation. Since 2.22.
func (x *MountIface) OverrideEjectWithOperationFinish(cb func(Mount, AsyncResult) bool) {
	if cb == nil {
		x.xEjectWithOperationFinish = 0
	} else {
		x.xEjectWithOperationFinish = purego.NewCallback(func(MountVarp uintptr, ResultVarp uintptr) bool {
			return cb(&MountBase{Ptr: MountVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetEjectWithOperationFinish gets the callback function.
// Finishes an eject operation using a #GMountOperation. Since 2.22.
func (x *MountIface) GetEjectWithOperationFinish() func(Mount, AsyncResult) bool {
	if x.xEjectWithOperationFinish == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEjectWithOperationFinish)
	return func(MountVar Mount, ResultVar AsyncResult) bool {
		return rawCallback(MountVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideGetDefaultLocation sets the callback function.
// Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.
func (x *MountIface) OverrideGetDefaultLocation(cb func(Mount) *FileBase) {
	if cb == nil {
		x.xGetDefaultLocation = 0
	} else {
		x.xGetDefaultLocation = purego.NewCallback(func(MountVarp uintptr) uintptr {
			ret := cb(&MountBase{Ptr: MountVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetDefaultLocation gets the callback function.
// Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.
func (x *MountIface) GetGetDefaultLocation() func(Mount) *FileBase {
	if x.xGetDefaultLocation == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetDefaultLocation)
	return func(MountVar Mount) *FileBase {
		rawRet := rawCallback(MountVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &FileBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideGetSortKey sets the callback function.
// Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.
func (x *MountIface) OverrideGetSortKey(cb func(Mount) string) {
	if cb == nil {
		x.xGetSortKey = 0
	} else {
		x.xGetSortKey = purego.NewCallback(func(MountVarp uintptr) string {
			return cb(&MountBase{Ptr: MountVarp})
		})
	}
}

// GetGetSortKey gets the callback function.
// Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.
func (x *MountIface) GetGetSortKey() func(Mount) string {
	if x.xGetSortKey == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetSortKey)
	return func(MountVar Mount) string {
		return rawCallback(MountVar.GoPointer())
	}
}

// OverrideGetSymbolicIcon sets the callback function.
// Gets a symbolic #GIcon for the #GMount. Since 2.34.
func (x *MountIface) OverrideGetSymbolicIcon(cb func(Mount) *IconBase) {
	if cb == nil {
		x.xGetSymbolicIcon = 0
	} else {
		x.xGetSymbolicIcon = purego.NewCallback(func(MountVarp uintptr) uintptr {
			ret := cb(&MountBase{Ptr: MountVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetSymbolicIcon gets the callback function.
// Gets a symbolic #GIcon for the #GMount. Since 2.34.
func (x *MountIface) GetGetSymbolicIcon() func(Mount) *IconBase {
	if x.xGetSymbolicIcon == 0 {
		return nil
	}
	var rawCallback func(MountVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetSymbolicIcon)
	return func(MountVar Mount) *IconBase {
		rawRet := rawCallback(MountVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// The `GMount` interface represents a user-visible mount, such as a mounted
// file system.
//
// `GMount` is a ‘mounted’ filesystem that you can access. Mounted is in
// quotes because it’s not the same as a UNIX mount, it might be a GVFS
// mount, but you can still access the files on it if you use GIO.
//
// A `GMount` might be associated with a [iface@Gio.Volume] (such as a USB flash
// drive) which hosts it.
//
// Unmounting a `GMount` instance is an asynchronous operation. For
// more information about asynchronous operations, see [iface@Gio.AsyncResult]
// and [class@Gio.Task]. To unmount a `GMount` instance, first call
// [method@Gio.Mount.unmount_with_operation] with (at least) the `GMount`
// instance and a [type@Gio.AsyncReadyCallback].  The callback will be fired
// when the operation has resolved (either with success or failure), and a
// [iface@Gio.AsyncResult] structure will be passed to the callback.  That
// callback should then call [method@Gio.Mount.unmount_with_operation_finish]
// with the `GMount` and the [iface@Gio.AsyncResult] data to see if the
// operation was completed successfully.  If an `error` is present when
// [method@Gio.Mount.unmount_with_operation_finish] is called, then it will be
// filled with any error information.
//
// Note, when [porting from GnomeVFS](migrating-gnome-vfs.html), `GMount` is the
// moral equivalent of `GnomeVFSVolume`.
type Mount interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	CanEject() bool
	CanUnmount() bool
	Eject(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectFinish(ResultVar AsyncResult) (bool, error)
	EjectWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectWithOperationFinish(ResultVar AsyncResult) (bool, error)
	GetDefaultLocation() *FileBase
	GetDrive() *DriveBase
	GetIcon() *IconBase
	GetName() string
	GetRoot() *FileBase
	GetSortKey() string
	GetSymbolicIcon() *IconBase
	GetUuid() string
	GetVolume() *VolumeBase
	GuessContentType(ForceRescanVar bool, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	GuessContentTypeFinish(ResultVar AsyncResult) ([]string, error)
	GuessContentTypeSync(ForceRescanVar bool, CancellableVar *Cancellable) ([]string, error)
	IsShadowed() bool
	Remount(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	RemountFinish(ResultVar AsyncResult) (bool, error)
	Shadow()
	Unmount(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	UnmountFinish(ResultVar AsyncResult) (bool, error)
	UnmountWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	UnmountWithOperationFinish(ResultVar AsyncResult) (bool, error)
	Unshadow()
}

var xMountGLibType func() types.GType

func MountGLibType() types.GType {
	return xMountGLibType()
}

type MountBase struct {
	Ptr uintptr
}

func (x *MountBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *MountBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Checks if @mount can be ejected.
func (x *MountBase) CanEject() bool {

	cret := XGMountCanEject(x.GoPointer())
	return cret
}

// Checks if @mount can be unmounted.
func (x *MountBase) CanUnmount() bool {

	cret := XGMountCanUnmount(x.GoPointer())
	return cret
}

// Ejects a mount. This is an asynchronous operation, and is
// finished by calling g_mount_eject_finish() with the @mount
// and #GAsyncResult data returned in the @callback.
func (x *MountBase) Eject(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGMountEject(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes ejecting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *MountBase) EjectFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGMountEjectFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Ejects a mount. This is an asynchronous operation, and is
// finished by calling g_mount_eject_with_operation_finish() with the @mount
// and #GAsyncResult data returned in the @callback.
func (x *MountBase) EjectWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGMountEjectWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes ejecting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *MountBase) EjectWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGMountEjectWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the default location of @mount. The default location of the given
// @mount is a path that reflects the main entry point for the user (e.g.
// the home directory, or the root of the volume).
func (x *MountBase) GetDefaultLocation() *FileBase {
	var cls *FileBase

	cret := XGMountGetDefaultLocation(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the drive for the @mount.
//
// This is a convenience method for getting the #GVolume and then
// using that object to get the #GDrive.
func (x *MountBase) GetDrive() *DriveBase {
	var cls *DriveBase

	cret := XGMountGetDrive(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &DriveBase{}
	cls.Ptr = cret
	return cls
}

// Gets the icon for @mount.
func (x *MountBase) GetIcon() *IconBase {
	var cls *IconBase

	cret := XGMountGetIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Gets the name of @mount.
func (x *MountBase) GetName() string {

	cret := XGMountGetName(x.GoPointer())
	return cret
}

// Gets the root directory on @mount.
func (x *MountBase) GetRoot() *FileBase {
	var cls *FileBase

	cret := XGMountGetRoot(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the sort key for @mount, if any.
func (x *MountBase) GetSortKey() string {

	cret := XGMountGetSortKey(x.GoPointer())
	return cret
}

// Gets the symbolic icon for @mount.
func (x *MountBase) GetSymbolicIcon() *IconBase {
	var cls *IconBase

	cret := XGMountGetSymbolicIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Gets the UUID for the @mount. The reference is typically based on
// the file system UUID for the mount in question and should be
// considered an opaque string. Returns %NULL if there is no UUID
// available.
func (x *MountBase) GetUuid() string {

	cret := XGMountGetUuid(x.GoPointer())
	return cret
}

// Gets the volume for the @mount.
func (x *MountBase) GetVolume() *VolumeBase {
	var cls *VolumeBase

	cret := XGMountGetVolume(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &VolumeBase{}
	cls.Ptr = cret
	return cls
}

// Tries to guess the type of content stored on @mount. Returns one or
// more textual identifiers of well-known content types (typically
// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
// memory cards. See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This is an asynchronous operation (see
// g_mount_guess_content_type_sync() for the synchronous version), and
// is finished by calling g_mount_guess_content_type_finish() with the
// @mount and #GAsyncResult data returned in the @callback.
func (x *MountBase) GuessContentType(ForceRescanVar bool, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGMountGuessContentType(x.GoPointer(), ForceRescanVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes guessing content types of @mount. If any errors occurred
// during the operation, @error will be set to contain the errors and
// %FALSE will be returned. In particular, you may get an
// %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
// guessing.
func (x *MountBase) GuessContentTypeFinish(ResultVar AsyncResult) ([]string, error) {
	var cerr *glib.Error

	cret := XGMountGuessContentTypeFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tries to guess the type of content stored on @mount. Returns one or
// more textual identifiers of well-known content types (typically
// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
// memory cards. See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This is a synchronous operation and as such may block doing IO;
// see g_mount_guess_content_type() for the asynchronous version.
func (x *MountBase) GuessContentTypeSync(ForceRescanVar bool, CancellableVar *Cancellable) ([]string, error) {
	var cerr *glib.Error

	cret := XGMountGuessContentTypeSync(x.GoPointer(), ForceRescanVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Determines if @mount is shadowed. Applications or libraries should
// avoid displaying @mount in the user interface if it is shadowed.
//
// A mount is said to be shadowed if there exists one or more user
// visible objects (currently #GMount objects) with a root that is
// inside the root of @mount.
//
// One application of shadow mounts is when exposing a single file
// system that is used to address several logical volumes. In this
// situation, a #GVolumeMonitor implementation would create two
// #GVolume objects (for example, one for the camera functionality of
// the device and one for a SD card reader on the device) with
// activation URIs `gphoto2://[usb:001,002]/store1/`
// and `gphoto2://[usb:001,002]/store2/`. When the
// underlying mount (with root
// `gphoto2://[usb:001,002]/`) is mounted, said
// #GVolumeMonitor implementation would create two #GMount objects
// (each with their root matching the corresponding volume activation
// root) that would shadow the original mount.
//
// The proxy monitor in GVfs 2.26 and later, automatically creates and
// manage shadow mounts (and shadows the underlying mount) if the
// activation root on a #GVolume is set.
func (x *MountBase) IsShadowed() bool {

	cret := XGMountIsShadowed(x.GoPointer())
	return cret
}

// Remounts a mount. This is an asynchronous operation, and is
// finished by calling g_mount_remount_finish() with the @mount
// and #GAsyncResults data returned in the @callback.
//
// Remounting is useful when some setting affecting the operation
// of the volume has been changed, as these may need a remount to
// take affect. While this is semantically equivalent with unmounting
// and then remounting not all backends might need to actually be
// unmounted.
func (x *MountBase) Remount(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGMountRemount(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes remounting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *MountBase) RemountFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGMountRemountFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Increments the shadow count on @mount. Usually used by
// #GVolumeMonitor implementations when creating a shadow mount for
// @mount, see g_mount_is_shadowed() for more information. The caller
// will need to emit the #GMount::changed signal on @mount manually.
func (x *MountBase) Shadow() {

	XGMountShadow(x.GoPointer())

}

// Unmounts a mount. This is an asynchronous operation, and is
// finished by calling g_mount_unmount_finish() with the @mount
// and #GAsyncResult data returned in the @callback.
func (x *MountBase) Unmount(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGMountUnmount(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes unmounting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *MountBase) UnmountFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGMountUnmountFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Unmounts a mount. This is an asynchronous operation, and is
// finished by calling g_mount_unmount_with_operation_finish() with the @mount
// and #GAsyncResult data returned in the @callback.
func (x *MountBase) UnmountWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGMountUnmountWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes unmounting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *MountBase) UnmountWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGMountUnmountWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Decrements the shadow count on @mount. Usually used by
// #GVolumeMonitor implementations when destroying a shadow mount for
// @mount, see g_mount_is_shadowed() for more information. The caller
// will need to emit the #GMount::changed signal on @mount manually.
func (x *MountBase) Unshadow() {

	XGMountUnshadow(x.GoPointer())

}

var XGMountCanEject func(uintptr) bool
var XGMountCanUnmount func(uintptr) bool
var XGMountEject func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGMountEjectFinish func(uintptr, uintptr, **glib.Error) bool
var XGMountEjectWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGMountEjectWithOperationFinish func(uintptr, uintptr, **glib.Error) bool
var XGMountGetDefaultLocation func(uintptr) uintptr
var XGMountGetDrive func(uintptr) uintptr
var XGMountGetIcon func(uintptr) uintptr
var XGMountGetName func(uintptr) string
var XGMountGetRoot func(uintptr) uintptr
var XGMountGetSortKey func(uintptr) string
var XGMountGetSymbolicIcon func(uintptr) uintptr
var XGMountGetUuid func(uintptr) string
var XGMountGetVolume func(uintptr) uintptr
var XGMountGuessContentType func(uintptr, bool, uintptr, uintptr, uintptr)
var XGMountGuessContentTypeFinish func(uintptr, uintptr, **glib.Error) []string
var XGMountGuessContentTypeSync func(uintptr, bool, uintptr, **glib.Error) []string
var XGMountIsShadowed func(uintptr) bool
var XGMountRemount func(uintptr, MountMountFlags, uintptr, uintptr, uintptr, uintptr)
var XGMountRemountFinish func(uintptr, uintptr, **glib.Error) bool
var XGMountShadow func(uintptr)
var XGMountUnmount func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGMountUnmountFinish func(uintptr, uintptr, **glib.Error) bool
var XGMountUnmountWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGMountUnmountWithOperationFinish func(uintptr, uintptr, **glib.Error) bool
var XGMountUnshadow func(uintptr)

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibrary("GIO", "libgio-2.0.so.0")
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xMountGLibType, lib, "g_mount_get_type")

	core.PuregoSafeRegister(&XGMountCanEject, lib, "g_mount_can_eject")
	core.PuregoSafeRegister(&XGMountCanUnmount, lib, "g_mount_can_unmount")
	core.PuregoSafeRegister(&XGMountEject, lib, "g_mount_eject")
	core.PuregoSafeRegister(&XGMountEjectFinish, lib, "g_mount_eject_finish")
	core.PuregoSafeRegister(&XGMountEjectWithOperation, lib, "g_mount_eject_with_operation")
	core.PuregoSafeRegister(&XGMountEjectWithOperationFinish, lib, "g_mount_eject_with_operation_finish")
	core.PuregoSafeRegister(&XGMountGetDefaultLocation, lib, "g_mount_get_default_location")
	core.PuregoSafeRegister(&XGMountGetDrive, lib, "g_mount_get_drive")
	core.PuregoSafeRegister(&XGMountGetIcon, lib, "g_mount_get_icon")
	core.PuregoSafeRegister(&XGMountGetName, lib, "g_mount_get_name")
	core.PuregoSafeRegister(&XGMountGetRoot, lib, "g_mount_get_root")
	core.PuregoSafeRegister(&XGMountGetSortKey, lib, "g_mount_get_sort_key")
	core.PuregoSafeRegister(&XGMountGetSymbolicIcon, lib, "g_mount_get_symbolic_icon")
	core.PuregoSafeRegister(&XGMountGetUuid, lib, "g_mount_get_uuid")
	core.PuregoSafeRegister(&XGMountGetVolume, lib, "g_mount_get_volume")
	core.PuregoSafeRegister(&XGMountGuessContentType, lib, "g_mount_guess_content_type")
	core.PuregoSafeRegister(&XGMountGuessContentTypeFinish, lib, "g_mount_guess_content_type_finish")
	core.PuregoSafeRegister(&XGMountGuessContentTypeSync, lib, "g_mount_guess_content_type_sync")
	core.PuregoSafeRegister(&XGMountIsShadowed, lib, "g_mount_is_shadowed")
	core.PuregoSafeRegister(&XGMountRemount, lib, "g_mount_remount")
	core.PuregoSafeRegister(&XGMountRemountFinish, lib, "g_mount_remount_finish")
	core.PuregoSafeRegister(&XGMountShadow, lib, "g_mount_shadow")
	core.PuregoSafeRegister(&XGMountUnmount, lib, "g_mount_unmount")
	core.PuregoSafeRegister(&XGMountUnmountFinish, lib, "g_mount_unmount_finish")
	core.PuregoSafeRegister(&XGMountUnmountWithOperation, lib, "g_mount_unmount_with_operation")
	core.PuregoSafeRegister(&XGMountUnmountWithOperationFinish, lib, "g_mount_unmount_with_operation_finish")
	core.PuregoSafeRegister(&XGMountUnshadow, lib, "g_mount_unshadow")

}
