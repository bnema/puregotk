// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Changes the size of the memory block pointed to by @data to
// @size bytes.
//
// The function should have the same semantics as realloc().
type ReallocFunc func(uintptr, uint) uintptr

type MemoryOutputStreamClass struct {
	_ structs.HostLayout

	ParentClass OutputStreamClass

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr

	xGReserved4 uintptr

	xGReserved5 uintptr
}

func (x *MemoryOutputStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGReserved1 sets the "_g_reserved1" callback function.
func (x *MemoryOutputStreamClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the "_g_reserved1" callback function.
func (x *MemoryOutputStreamClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the "_g_reserved2" callback function.
func (x *MemoryOutputStreamClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the "_g_reserved2" callback function.
func (x *MemoryOutputStreamClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the "_g_reserved3" callback function.
func (x *MemoryOutputStreamClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the "_g_reserved3" callback function.
func (x *MemoryOutputStreamClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved4 sets the "_g_reserved4" callback function.
func (x *MemoryOutputStreamClass) OverrideGReserved4(cb func()) {
	if cb == nil {
		x.xGReserved4 = 0
	} else {
		x.xGReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved4 gets the "_g_reserved4" callback function.
func (x *MemoryOutputStreamClass) GetGReserved4() func() {
	if x.xGReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved5 sets the "_g_reserved5" callback function.
func (x *MemoryOutputStreamClass) OverrideGReserved5(cb func()) {
	if cb == nil {
		x.xGReserved5 = 0
	} else {
		x.xGReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved5 gets the "_g_reserved5" callback function.
func (x *MemoryOutputStreamClass) GetGReserved5() func() {
	if x.xGReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved5)
	return func() {
		rawCallback()
	}
}

type MemoryOutputStreamPrivate struct {
	_ structs.HostLayout
}

func (x *MemoryOutputStreamPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GMemoryOutputStream` is a class for using arbitrary
// memory chunks as output for GIO streaming output operations.
//
// As of GLib 2.34, `GMemoryOutputStream` trivially implements
// [iface@Gio.PollableOutputStream]: it always polls as ready.
type MemoryOutputStream struct {
	OutputStream
}

var xMemoryOutputStreamGLibType func() types.GType

func MemoryOutputStreamGLibType() types.GType {
	return xMemoryOutputStreamGLibType()
}

func MemoryOutputStreamNewFromInternalPtr(ptr uintptr) *MemoryOutputStream {
	cls := &MemoryOutputStream{}
	cls.Ptr = ptr
	return cls
}

var xNewMemoryOutputStream func(uintptr, uint, uintptr, uintptr) uintptr

// Creates a new #GMemoryOutputStream.
//
// In most cases this is not the function you want.  See
// g_memory_output_stream_new_resizable() instead.
//
// If @data is non-%NULL, the stream will use that for its internal storage.
//
// If @realloc_fn is non-%NULL, it will be used for resizing the internal
// storage when necessary and the stream will be considered resizable.
// In that case, the stream will start out being (conceptually) empty.
// @size is used only as a hint for how big @data is.  Specifically,
// seeking to the end of a newly-created stream will seek to zero, not
// @size.  Seeking past the end of the stream and then writing will
// introduce a zero-filled gap.
//
// If @realloc_fn is %NULL then the stream is fixed-sized.  Seeking to
// the end will seek to @size exactly.  Writing past the end will give
// an 'out of space' error.  Attempting to seek past the end will fail.
// Unlike the resizable case, seeking to an offset within the stream and
// writing will preserve the bytes passed in as @data before that point
// and will return them as part of g_memory_output_stream_steal_data().
// If you intend to seek you should probably therefore ensure that @data
// is properly initialised.
//
// It is probably only meaningful to provide @data and @size in the case
// that you want a fixed-sized stream.  Put another way: if @realloc_fn
// is non-%NULL then it makes most sense to give @data as %NULL and
// @size as 0 (allowing #GMemoryOutputStream to do the initial
// allocation for itself).
//
// |[&lt;!-- language="C" --&gt;
// // a stream that can grow
// stream = g_memory_output_stream_new (NULL, 0, realloc, free);
//
// // another stream that can grow
// stream2 = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);
//
// // a fixed-size stream
// data = malloc (200);
// stream3 = g_memory_output_stream_new (data, 200, NULL, free);
// ]|
func NewMemoryOutputStream(DataVar uintptr, SizeVar uint, ReallocFunctionVar *ReallocFunc, DestroyFunctionVar *glib.DestroyNotify) *MemoryOutputStream {
	var cls *MemoryOutputStream

	cret := xNewMemoryOutputStream(DataVar, SizeVar, glib.NewCallbackNullable(ReallocFunctionVar), glib.NewCallbackNullable(DestroyFunctionVar))

	if cret == 0 {
		return nil
	}
	cls = &MemoryOutputStream{}
	cls.Ptr = cret
	return cls
}

var xNewMemoryOutputStreamResizable func() uintptr

// Creates a new #GMemoryOutputStream, using g_realloc() and g_free()
// for memory allocation.
func NewMemoryOutputStreamResizable() *MemoryOutputStream {
	var cls *MemoryOutputStream

	cret := xNewMemoryOutputStreamResizable()

	if cret == 0 {
		return nil
	}
	cls = &MemoryOutputStream{}
	cls.Ptr = cret
	return cls
}

var xMemoryOutputStreamGetData func(uintptr) uintptr

// Gets any loaded data from the @ostream.
//
// Note that the returned pointer may become invalid on the next
// write or truncate operation on the stream.
func (x *MemoryOutputStream) GetData() uintptr {

	cret := xMemoryOutputStreamGetData(x.GoPointer())
	return cret
}

var xMemoryOutputStreamGetDataSize func(uintptr) uint

// Returns the number of bytes from the start up to including the last
// byte written in the stream that has not been truncated away.
func (x *MemoryOutputStream) GetDataSize() uint {

	cret := xMemoryOutputStreamGetDataSize(x.GoPointer())
	return cret
}

var xMemoryOutputStreamGetSize func(uintptr) uint

// Gets the size of the currently allocated data area (available from
// g_memory_output_stream_get_data()).
//
// You probably don't want to use this function on resizable streams.
// See g_memory_output_stream_get_data_size() instead.  For resizable
// streams the size returned by this function is an implementation
// detail and may be change at any time in response to operations on the
// stream.
//
// If the stream is fixed-sized (ie: no realloc was passed to
// g_memory_output_stream_new()) then this is the maximum size of the
// stream and further writes will return %G_IO_ERROR_NO_SPACE.
//
// In any case, if you want the number of bytes currently written to the
// stream, use g_memory_output_stream_get_data_size().
func (x *MemoryOutputStream) GetSize() uint {

	cret := xMemoryOutputStreamGetSize(x.GoPointer())
	return cret
}

var xMemoryOutputStreamStealAsBytes func(uintptr) *glib.Bytes

// Returns data from the @ostream as a #GBytes. @ostream must be
// closed before calling this function.
func (x *MemoryOutputStream) StealAsBytes() *glib.Bytes {

	cret := xMemoryOutputStreamStealAsBytes(x.GoPointer())
	return cret
}

var xMemoryOutputStreamStealData func(uintptr) uintptr

// Gets any loaded data from the @ostream. Ownership of the data
// is transferred to the caller; when no longer needed it must be
// freed using the free function set in @ostream's
// #GMemoryOutputStream:destroy-function property.
//
// @ostream must be closed before calling this function.
func (x *MemoryOutputStream) StealData() uintptr {

	cret := xMemoryOutputStreamStealData(x.GoPointer())
	return cret
}

func (c *MemoryOutputStream) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *MemoryOutputStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyData sets the "data" property.
// Pointer to buffer where data will be written.
func (x *MemoryOutputStream) SetPropertyData(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("data", &v)
}

// GetPropertyData gets the "data" property.
// Pointer to buffer where data will be written.
func (x *MemoryOutputStream) GetPropertyData() uintptr {
	var v gobject.Value
	x.GetProperty("data", &v)
	return v.GetPointer()
}

// GetPropertyDataSize gets the "data-size" property.
// Size of data written to the buffer.
func (x *MemoryOutputStream) GetPropertyDataSize() uint32 {
	var v gobject.Value
	x.GetProperty("data-size", &v)
	return v.GetUlong()
}

// SetPropertyDestroyFunction sets the "destroy-function" property.
// Function called with the buffer as argument when the stream is destroyed.
func (x *MemoryOutputStream) SetPropertyDestroyFunction(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("destroy-function", &v)
}

// GetPropertyDestroyFunction gets the "destroy-function" property.
// Function called with the buffer as argument when the stream is destroyed.
func (x *MemoryOutputStream) GetPropertyDestroyFunction() uintptr {
	var v gobject.Value
	x.GetProperty("destroy-function", &v)
	return v.GetPointer()
}

// SetPropertyReallocFunction sets the "realloc-function" property.
// Function with realloc semantics called to enlarge the buffer.
func (x *MemoryOutputStream) SetPropertyReallocFunction(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("realloc-function", &v)
}

// GetPropertyReallocFunction gets the "realloc-function" property.
// Function with realloc semantics called to enlarge the buffer.
func (x *MemoryOutputStream) GetPropertyReallocFunction() uintptr {
	var v gobject.Value
	x.GetProperty("realloc-function", &v)
	return v.GetPointer()
}

// SetPropertySize sets the "size" property.
// Current size of the data buffer.
func (x *MemoryOutputStream) SetPropertySize(value uint32) {
	var v gobject.Value
	v.Init(gobject.TypeUlongVal)
	v.SetUlong(value)
	x.SetProperty("size", &v)
}

// GetPropertySize gets the "size" property.
// Current size of the data buffer.
func (x *MemoryOutputStream) GetPropertySize() uint32 {
	var v gobject.Value
	x.GetProperty("size", &v)
	return v.GetUlong()
}

// Checks if @stream is actually pollable. Some classes may implement
// #GPollableOutputStream but have only certain instances of that
// class be pollable. If this method returns %FALSE, then the behavior
// of other #GPollableOutputStream methods is undefined.
//
// For any given stream, the value returned by this method is constant;
// a stream cannot switch from pollable to non-pollable or vice versa.
func (x *MemoryOutputStream) CanPoll() bool {

	cret := XGPollableOutputStreamCanPoll(x.GoPointer())
	return cret
}

// Creates a #GSource that triggers when @stream can be written, or
// @cancellable is triggered or an error occurs. The callback on the
// source is of the #GPollableSourceFunc type.
//
// As with g_pollable_output_stream_is_writable(), it is possible that
// the stream may not actually be writable even after the source
// triggers, so you should use g_pollable_output_stream_write_nonblocking()
// rather than g_output_stream_write() from the callback.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
func (x *MemoryOutputStream) CreateSource(CancellableVar *Cancellable) *glib.Source {

	cret := XGPollableOutputStreamCreateSource(x.GoPointer(), CancellableVar.GoPointer())
	return cret
}

// Checks if @stream can be written.
//
// Note that some stream types may not be able to implement this 100%
// reliably, and it is possible that a call to g_output_stream_write()
// after this returns %TRUE would still block. To guarantee
// non-blocking behavior, you should always use
// g_pollable_output_stream_write_nonblocking(), which will return a
// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
func (x *MemoryOutputStream) IsWritable() bool {

	cret := XGPollableOutputStreamIsWritable(x.GoPointer())
	return cret
}

// Attempts to write up to @count bytes from @buffer to @stream, as
// with g_output_stream_write(). If @stream is not currently writable,
// this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
// use g_pollable_output_stream_create_source() to create a #GSource
// that will be triggered when @stream is writable.
//
// Note that since this method never blocks, you cannot actually
// use @cancellable to cancel it. However, it will return an error
// if @cancellable has already been cancelled when you call, which
// may happen if you call this method after a source triggers due
// to having been cancelled.
//
// Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same @buffer and
// @count in the next write call.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
func (x *MemoryOutputStream) WriteNonblocking(BufferVar []byte, CountVar uint, CancellableVar *Cancellable) (int, error) {
	var cerr *glib.Error

	cret := XGPollableOutputStreamWriteNonblocking(x.GoPointer(), BufferVar, CountVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Attempts to write the bytes contained in the @n_vectors @vectors to @stream,
// as with g_output_stream_writev(). If @stream is not currently writable,
// this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
// use g_pollable_output_stream_create_source() to create a #GSource
// that will be triggered when @stream is writable. @error will *not* be
// set in that case.
//
// Note that since this method never blocks, you cannot actually
// use @cancellable to cancel it. However, it will return an error
// if @cancellable has already been cancelled when you call, which
// may happen if you call this method after a source triggers due
// to having been cancelled.
//
// Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same @vectors and
// @n_vectors in the next write call.
//
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
func (x *MemoryOutputStream) WritevNonblocking(VectorsVar []OutputVector, NVectorsVar uint, BytesWrittenVar *uint, CancellableVar *Cancellable) (PollableReturn, error) {
	var cerr *glib.Error

	cret := XGPollableOutputStreamWritevNonblocking(x.GoPointer(), VectorsVar, NVectorsVar, BytesWrittenVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tests if the stream supports the #GSeekableIface.
func (x *MemoryOutputStream) CanSeek() bool {

	cret := XGSeekableCanSeek(x.GoPointer())
	return cret
}

// Tests if the length of the stream can be adjusted with
// g_seekable_truncate().
func (x *MemoryOutputStream) CanTruncate() bool {

	cret := XGSeekableCanTruncate(x.GoPointer())
	return cret
}

// Seeks in the stream by the given @offset, modified by @type.
//
// Attempting to seek past the end of the stream will have different
// results depending on if the stream is fixed-sized or resizable.  If
// the stream is resizable then seeking past the end and then writing
// will result in zeros filling the empty space.  Seeking past the end
// of a resizable stream and reading will result in EOF.  Seeking past
// the end of a fixed-sized stream will fail.
//
// Any operation that would result in a negative offset will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *MemoryOutputStream) Seek(OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableSeek(x.GoPointer(), OffsetVar, TypeVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tells the current position within the stream.
func (x *MemoryOutputStream) Tell() int64 {

	cret := XGSeekableTell(x.GoPointer())
	return cret
}

// Sets the length of the stream to @offset. If the stream was previously
// larger than @offset, the extra data is discarded. If the stream was
// previously shorter than @offset, it is extended with NUL ('\0') bytes.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (x *MemoryOutputStream) Truncate(OffsetVar int64, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableTruncate(x.GoPointer(), OffsetVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMemoryOutputStreamGLibType, libs, "g_memory_output_stream_get_type")

	core.PuregoSafeRegister(&xNewMemoryOutputStream, libs, "g_memory_output_stream_new")
	core.PuregoSafeRegister(&xNewMemoryOutputStreamResizable, libs, "g_memory_output_stream_new_resizable")

	core.PuregoSafeRegister(&xMemoryOutputStreamGetData, libs, "g_memory_output_stream_get_data")
	core.PuregoSafeRegister(&xMemoryOutputStreamGetDataSize, libs, "g_memory_output_stream_get_data_size")
	core.PuregoSafeRegister(&xMemoryOutputStreamGetSize, libs, "g_memory_output_stream_get_size")
	core.PuregoSafeRegister(&xMemoryOutputStreamStealAsBytes, libs, "g_memory_output_stream_steal_as_bytes")
	core.PuregoSafeRegister(&xMemoryOutputStreamStealData, libs, "g_memory_output_stream_steal_data")

}
