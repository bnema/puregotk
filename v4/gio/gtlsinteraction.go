// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The class for #GTlsInteraction. Derived classes implement the various
// virtual interaction methods to handle TLS interactions.
//
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. If a derived class implements an async method,
// it must also implement the corresponding finish method.
//
// The synchronous interaction methods should implement to display modal dialogs,
// and the asynchronous methods to display modeless dialogs.
//
// If the user cancels an interaction, then the result should be
// %G_TLS_INTERACTION_FAILED and the error should be set with a domain of
// %G_IO_ERROR and code of %G_IO_ERROR_CANCELLED.
type TlsInteractionClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xAskPassword uintptr

	xAskPasswordAsync uintptr

	xAskPasswordFinish uintptr

	xRequestCertificate uintptr

	xRequestCertificateAsync uintptr

	xRequestCertificateFinish uintptr

	Padding [21]uintptr
}

func (x *TlsInteractionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideAskPassword sets the "ask_password" callback function.
// ask for a password synchronously. If the implementation
//
//	returns %G_TLS_INTERACTION_HANDLED, then the password argument should
//	have been filled in by using g_tls_password_set_value() or a similar
//	function.
func (x *TlsInteractionClass) OverrideAskPassword(cb func(*TlsInteraction, *TlsPassword, *Cancellable) TlsInteractionResult) {
	if cb == nil {
		x.xAskPassword = 0
	} else {
		x.xAskPassword = purego.NewCallback(func(InteractionVarp uintptr, PasswordVarp uintptr, CancellableVarp uintptr) TlsInteractionResult {
			return cb(TlsInteractionNewFromInternalPtr(InteractionVarp), TlsPasswordNewFromInternalPtr(PasswordVarp), CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetAskPassword gets the "ask_password" callback function.
// ask for a password synchronously. If the implementation
//
//	returns %G_TLS_INTERACTION_HANDLED, then the password argument should
//	have been filled in by using g_tls_password_set_value() or a similar
//	function.
func (x *TlsInteractionClass) GetAskPassword() func(*TlsInteraction, *TlsPassword, *Cancellable) TlsInteractionResult {
	if x.xAskPassword == 0 {
		return nil
	}
	var rawCallback func(InteractionVarp uintptr, PasswordVarp uintptr, CancellableVarp uintptr) TlsInteractionResult
	purego.RegisterFunc(&rawCallback, x.xAskPassword)
	return func(InteractionVar *TlsInteraction, PasswordVar *TlsPassword, CancellableVar *Cancellable) TlsInteractionResult {
		return rawCallback(InteractionVar.GoPointer(), PasswordVar.GoPointer(), CancellableVar.GoPointer())
	}
}

// OverrideAskPasswordAsync sets the "ask_password_async" callback function.
// ask for a password asynchronously.
func (x *TlsInteractionClass) OverrideAskPasswordAsync(cb func(*TlsInteraction, *TlsPassword, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xAskPasswordAsync = 0
	} else {
		x.xAskPasswordAsync = purego.NewCallback(func(InteractionVarp uintptr, PasswordVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(TlsInteractionNewFromInternalPtr(InteractionVarp), TlsPasswordNewFromInternalPtr(PasswordVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetAskPasswordAsync gets the "ask_password_async" callback function.
// ask for a password asynchronously.
func (x *TlsInteractionClass) GetAskPasswordAsync() func(*TlsInteraction, *TlsPassword, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xAskPasswordAsync == 0 {
		return nil
	}
	var rawCallback func(InteractionVarp uintptr, PasswordVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xAskPasswordAsync)
	return func(InteractionVar *TlsInteraction, PasswordVar *TlsPassword, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(InteractionVar.GoPointer(), PasswordVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideAskPasswordFinish sets the "ask_password_finish" callback function.
// complete operation to ask for a password asynchronously.
//
//	If the implementation returns %G_TLS_INTERACTION_HANDLED, then the
//	password argument of the async method should have been filled in by using
//	g_tls_password_set_value() or a similar function.
func (x *TlsInteractionClass) OverrideAskPasswordFinish(cb func(*TlsInteraction, AsyncResult) TlsInteractionResult) {
	if cb == nil {
		x.xAskPasswordFinish = 0
	} else {
		x.xAskPasswordFinish = purego.NewCallback(func(InteractionVarp uintptr, ResultVarp uintptr) TlsInteractionResult {
			return cb(TlsInteractionNewFromInternalPtr(InteractionVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetAskPasswordFinish gets the "ask_password_finish" callback function.
// complete operation to ask for a password asynchronously.
//
//	If the implementation returns %G_TLS_INTERACTION_HANDLED, then the
//	password argument of the async method should have been filled in by using
//	g_tls_password_set_value() or a similar function.
func (x *TlsInteractionClass) GetAskPasswordFinish() func(*TlsInteraction, AsyncResult) TlsInteractionResult {
	if x.xAskPasswordFinish == 0 {
		return nil
	}
	var rawCallback func(InteractionVarp uintptr, ResultVarp uintptr) TlsInteractionResult
	purego.RegisterFunc(&rawCallback, x.xAskPasswordFinish)
	return func(InteractionVar *TlsInteraction, ResultVar AsyncResult) TlsInteractionResult {
		return rawCallback(InteractionVar.GoPointer(), ResultVar.GoPointer())
	}
}

// OverrideRequestCertificate sets the "request_certificate" callback function.
// ask for a certificate synchronously. If the
//
//	implementation returns %G_TLS_INTERACTION_HANDLED, then the connection
//	argument should have been filled in by using
//	g_tls_connection_set_certificate().
func (x *TlsInteractionClass) OverrideRequestCertificate(cb func(*TlsInteraction, *TlsConnection, TlsCertificateRequestFlags, *Cancellable) TlsInteractionResult) {
	if cb == nil {
		x.xRequestCertificate = 0
	} else {
		x.xRequestCertificate = purego.NewCallback(func(InteractionVarp uintptr, ConnectionVarp uintptr, FlagsVarp TlsCertificateRequestFlags, CancellableVarp uintptr) TlsInteractionResult {
			return cb(TlsInteractionNewFromInternalPtr(InteractionVarp), TlsConnectionNewFromInternalPtr(ConnectionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp))
		})
	}
}

// GetRequestCertificate gets the "request_certificate" callback function.
// ask for a certificate synchronously. If the
//
//	implementation returns %G_TLS_INTERACTION_HANDLED, then the connection
//	argument should have been filled in by using
//	g_tls_connection_set_certificate().
func (x *TlsInteractionClass) GetRequestCertificate() func(*TlsInteraction, *TlsConnection, TlsCertificateRequestFlags, *Cancellable) TlsInteractionResult {
	if x.xRequestCertificate == 0 {
		return nil
	}
	var rawCallback func(InteractionVarp uintptr, ConnectionVarp uintptr, FlagsVarp TlsCertificateRequestFlags, CancellableVarp uintptr) TlsInteractionResult
	purego.RegisterFunc(&rawCallback, x.xRequestCertificate)
	return func(InteractionVar *TlsInteraction, ConnectionVar *TlsConnection, FlagsVar TlsCertificateRequestFlags, CancellableVar *Cancellable) TlsInteractionResult {
		return rawCallback(InteractionVar.GoPointer(), ConnectionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer())
	}
}

// OverrideRequestCertificateAsync sets the "request_certificate_async" callback function.
// ask for a certificate asynchronously.
func (x *TlsInteractionClass) OverrideRequestCertificateAsync(cb func(*TlsInteraction, *TlsConnection, TlsCertificateRequestFlags, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xRequestCertificateAsync = 0
	} else {
		x.xRequestCertificateAsync = purego.NewCallback(func(InteractionVarp uintptr, ConnectionVarp uintptr, FlagsVarp TlsCertificateRequestFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(TlsInteractionNewFromInternalPtr(InteractionVarp), TlsConnectionNewFromInternalPtr(ConnectionVarp), FlagsVarp, CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetRequestCertificateAsync gets the "request_certificate_async" callback function.
// ask for a certificate asynchronously.
func (x *TlsInteractionClass) GetRequestCertificateAsync() func(*TlsInteraction, *TlsConnection, TlsCertificateRequestFlags, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xRequestCertificateAsync == 0 {
		return nil
	}
	var rawCallback func(InteractionVarp uintptr, ConnectionVarp uintptr, FlagsVarp TlsCertificateRequestFlags, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRequestCertificateAsync)
	return func(InteractionVar *TlsInteraction, ConnectionVar *TlsConnection, FlagsVar TlsCertificateRequestFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(InteractionVar.GoPointer(), ConnectionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideRequestCertificateFinish sets the "request_certificate_finish" callback function.
// complete operation to ask for a certificate
//
//	asynchronously. If the implementation returns %G_TLS_INTERACTION_HANDLED,
//	then the connection argument of the async method should have been
//	filled in by using g_tls_connection_set_certificate().
func (x *TlsInteractionClass) OverrideRequestCertificateFinish(cb func(*TlsInteraction, AsyncResult) TlsInteractionResult) {
	if cb == nil {
		x.xRequestCertificateFinish = 0
	} else {
		x.xRequestCertificateFinish = purego.NewCallback(func(InteractionVarp uintptr, ResultVarp uintptr) TlsInteractionResult {
			return cb(TlsInteractionNewFromInternalPtr(InteractionVarp), &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetRequestCertificateFinish gets the "request_certificate_finish" callback function.
// complete operation to ask for a certificate
//
//	asynchronously. If the implementation returns %G_TLS_INTERACTION_HANDLED,
//	then the connection argument of the async method should have been
//	filled in by using g_tls_connection_set_certificate().
func (x *TlsInteractionClass) GetRequestCertificateFinish() func(*TlsInteraction, AsyncResult) TlsInteractionResult {
	if x.xRequestCertificateFinish == 0 {
		return nil
	}
	var rawCallback func(InteractionVarp uintptr, ResultVarp uintptr) TlsInteractionResult
	purego.RegisterFunc(&rawCallback, x.xRequestCertificateFinish)
	return func(InteractionVar *TlsInteraction, ResultVar AsyncResult) TlsInteractionResult {
		return rawCallback(InteractionVar.GoPointer(), ResultVar.GoPointer())
	}
}

type TlsInteractionPrivate struct {
	_ structs.HostLayout
}

func (x *TlsInteractionPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GTlsInteraction` provides a mechanism for the TLS connection and database
// code to interact with the user. It can be used to ask the user for passwords.
//
// To use a `GTlsInteraction` with a TLS connection use
// [method@Gio.TlsConnection.set_interaction].
//
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
//
// Callers should use the 'invoke' functions like
// [method@Gio.TlsInteraction.invoke_ask_password] to run interaction methods.
// These functions make sure that the interaction is invoked in the main loop
// and not in the current thread, if the current thread is not running the
// main loop.
//
// Derived classes can choose to implement whichever interactions methods theyâ€™d
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// `G_TLS_INTERACTION_UNHANDLED`. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TlsInteraction struct {
	gobject.Object
}

var xTlsInteractionGLibType func() types.GType

func TlsInteractionGLibType() types.GType {
	return xTlsInteractionGLibType()
}

func TlsInteractionNewFromInternalPtr(ptr uintptr) *TlsInteraction {
	cls := &TlsInteraction{}
	cls.Ptr = ptr
	return cls
}

var xTlsInteractionAskPassword func(uintptr, uintptr, uintptr, **glib.Error) TlsInteractionResult

// Run synchronous interaction to ask the user for a password. In general,
// g_tls_interaction_invoke_ask_password() should be used instead of this
// function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (x *TlsInteraction) AskPassword(PasswordVar *TlsPassword, CancellableVar *Cancellable) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionAskPassword(x.GoPointer(), PasswordVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionAskPasswordAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Run asynchronous interaction to ask the user for a password. In general,
// g_tls_interaction_invoke_ask_password() should be used instead of this
// function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
//
// Certain implementations may not support immediate cancellation.
func (x *TlsInteraction) AskPasswordAsync(PasswordVar *TlsPassword, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsInteractionAskPasswordAsync(x.GoPointer(), PasswordVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xTlsInteractionAskPasswordFinish func(uintptr, uintptr, **glib.Error) TlsInteractionResult

// Complete an ask password user interaction request. This should be once
// the g_tls_interaction_ask_password_async() completion callback is called.
//
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
// to g_tls_interaction_ask_password() will have its password filled in.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code.
func (x *TlsInteraction) AskPasswordFinish(ResultVar AsyncResult) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionAskPasswordFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionInvokeAskPassword func(uintptr, uintptr, uintptr, **glib.Error) TlsInteractionResult

// Invoke the interaction to ask the user for a password. It invokes this
// interaction in the main loop, specifically the #GMainContext returned by
// g_main_context_get_thread_default() when the interaction is created. This
// is called by called by #GTlsConnection or #GTlsDatabase to ask the user
// for a password.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
//
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (x *TlsInteraction) InvokeAskPassword(PasswordVar *TlsPassword, CancellableVar *Cancellable) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionInvokeAskPassword(x.GoPointer(), PasswordVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionInvokeRequestCertificate func(uintptr, uintptr, TlsCertificateRequestFlags, uintptr, **glib.Error) TlsInteractionResult

// Invoke the interaction to ask the user to choose a certificate to
// use with the connection. It invokes this interaction in the main
// loop, specifically the #GMainContext returned by
// g_main_context_get_thread_default() when the interaction is
// created. This is called by called by #GTlsConnection when the peer
// requests a certificate during the handshake.
//
// Derived subclasses usually implement a certificate selector,
// although they may also choose to provide a certificate from
// elsewhere. Alternatively the user may abort this certificate
// request, which may or may not abort the TLS connection.
//
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (x *TlsInteraction) InvokeRequestCertificate(ConnectionVar *TlsConnection, FlagsVar TlsCertificateRequestFlags, CancellableVar *Cancellable) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionInvokeRequestCertificate(x.GoPointer(), ConnectionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionRequestCertificate func(uintptr, uintptr, TlsCertificateRequestFlags, uintptr, **glib.Error) TlsInteractionResult

// Run synchronous interaction to ask the user to choose a certificate to use
// with the connection. In general, g_tls_interaction_invoke_request_certificate()
// should be used instead of this function.
//
// Derived subclasses usually implement a certificate selector, although they may
// also choose to provide a certificate from elsewhere. Alternatively the user may
// abort this certificate request, which will usually abort the TLS connection.
//
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
// passed to g_tls_interaction_request_certificate() will have had its
// #GTlsConnection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (x *TlsInteraction) RequestCertificate(ConnectionVar *TlsConnection, FlagsVar TlsCertificateRequestFlags, CancellableVar *Cancellable) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionRequestCertificate(x.GoPointer(), ConnectionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionRequestCertificateAsync func(uintptr, uintptr, TlsCertificateRequestFlags, uintptr, uintptr, uintptr)

// Run asynchronous interaction to ask the user for a certificate to use with
// the connection. In general, g_tls_interaction_invoke_request_certificate() should
// be used instead of this function.
//
// Derived subclasses usually implement a certificate selector, although they may
// also choose to provide a certificate from elsewhere. @callback will be called
// when the operation completes. Alternatively the user may abort this certificate
// request, which will usually abort the TLS connection.
func (x *TlsInteraction) RequestCertificateAsync(ConnectionVar *TlsConnection, FlagsVar TlsCertificateRequestFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsInteractionRequestCertificateAsync(x.GoPointer(), ConnectionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xTlsInteractionRequestCertificateFinish func(uintptr, uintptr, **glib.Error) TlsInteractionResult

// Complete a request certificate user interaction request. This should be once
// the g_tls_interaction_request_certificate_async() completion callback is called.
//
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
// passed to g_tls_interaction_request_certificate_async() will have had its
// #GTlsConnection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code.
func (x *TlsInteraction) RequestCertificateFinish(ResultVar AsyncResult) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionRequestCertificateFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *TlsInteraction) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *TlsInteraction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTlsInteractionGLibType, libs, "g_tls_interaction_get_type")

	core.PuregoSafeRegister(&xTlsInteractionAskPassword, libs, "g_tls_interaction_ask_password")
	core.PuregoSafeRegister(&xTlsInteractionAskPasswordAsync, libs, "g_tls_interaction_ask_password_async")
	core.PuregoSafeRegister(&xTlsInteractionAskPasswordFinish, libs, "g_tls_interaction_ask_password_finish")
	core.PuregoSafeRegister(&xTlsInteractionInvokeAskPassword, libs, "g_tls_interaction_invoke_ask_password")
	core.PuregoSafeRegister(&xTlsInteractionInvokeRequestCertificate, libs, "g_tls_interaction_invoke_request_certificate")
	core.PuregoSafeRegister(&xTlsInteractionRequestCertificate, libs, "g_tls_interaction_request_certificate")
	core.PuregoSafeRegister(&xTlsInteractionRequestCertificateAsync, libs, "g_tls_interaction_request_certificate_async")
	core.PuregoSafeRegister(&xTlsInteractionRequestCertificateFinish, libs, "g_tls_interaction_request_certificate_finish")

}
