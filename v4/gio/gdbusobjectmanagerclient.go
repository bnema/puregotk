// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Class structure for #GDBusObjectManagerClient.
type DBusObjectManagerClientClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xInterfaceProxySignal uintptr

	xInterfaceProxyPropertiesChanged uintptr

	Padding [8]uintptr
}

func (x *DBusObjectManagerClientClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideInterfaceProxySignal sets the "interface_proxy_signal" callback function.
// Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.
func (x *DBusObjectManagerClientClass) OverrideInterfaceProxySignal(cb func(*DBusObjectManagerClient, *DBusObjectProxy, *DBusProxy, string, string, *glib.Variant)) {
	if cb == nil {
		x.xInterfaceProxySignal = 0
	} else {
		x.xInterfaceProxySignal = purego.NewCallback(func(ManagerVarp uintptr, ObjectProxyVarp uintptr, InterfaceProxyVarp uintptr, SenderNameVarp string, SignalNameVarp string, ParametersVarp *glib.Variant) {
			cb(DBusObjectManagerClientNewFromInternalPtr(ManagerVarp), DBusObjectProxyNewFromInternalPtr(ObjectProxyVarp), DBusProxyNewFromInternalPtr(InterfaceProxyVarp), SenderNameVarp, SignalNameVarp, ParametersVarp)
		})
	}
}

// GetInterfaceProxySignal gets the "interface_proxy_signal" callback function.
// Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.
func (x *DBusObjectManagerClientClass) GetInterfaceProxySignal() func(*DBusObjectManagerClient, *DBusObjectProxy, *DBusProxy, string, string, *glib.Variant) {
	if x.xInterfaceProxySignal == 0 {
		return nil
	}
	var rawCallback func(ManagerVarp uintptr, ObjectProxyVarp uintptr, InterfaceProxyVarp uintptr, SenderNameVarp string, SignalNameVarp string, ParametersVarp *glib.Variant)
	purego.RegisterFunc(&rawCallback, x.xInterfaceProxySignal)
	return func(ManagerVar *DBusObjectManagerClient, ObjectProxyVar *DBusObjectProxy, InterfaceProxyVar *DBusProxy, SenderNameVar string, SignalNameVar string, ParametersVar *glib.Variant) {
		rawCallback(ManagerVar.GoPointer(), ObjectProxyVar.GoPointer(), InterfaceProxyVar.GoPointer(), SenderNameVar, SignalNameVar, ParametersVar)
	}
}

// OverrideInterfaceProxyPropertiesChanged sets the "interface_proxy_properties_changed" callback function.
// Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.
func (x *DBusObjectManagerClientClass) OverrideInterfaceProxyPropertiesChanged(cb func(*DBusObjectManagerClient, *DBusObjectProxy, *DBusProxy, *glib.Variant, string)) {
	if cb == nil {
		x.xInterfaceProxyPropertiesChanged = 0
	} else {
		x.xInterfaceProxyPropertiesChanged = purego.NewCallback(func(ManagerVarp uintptr, ObjectProxyVarp uintptr, InterfaceProxyVarp uintptr, ChangedPropertiesVarp *glib.Variant, InvalidatedPropertiesVarp string) {
			cb(DBusObjectManagerClientNewFromInternalPtr(ManagerVarp), DBusObjectProxyNewFromInternalPtr(ObjectProxyVarp), DBusProxyNewFromInternalPtr(InterfaceProxyVarp), ChangedPropertiesVarp, InvalidatedPropertiesVarp)
		})
	}
}

// GetInterfaceProxyPropertiesChanged gets the "interface_proxy_properties_changed" callback function.
// Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.
func (x *DBusObjectManagerClientClass) GetInterfaceProxyPropertiesChanged() func(*DBusObjectManagerClient, *DBusObjectProxy, *DBusProxy, *glib.Variant, string) {
	if x.xInterfaceProxyPropertiesChanged == 0 {
		return nil
	}
	var rawCallback func(ManagerVarp uintptr, ObjectProxyVarp uintptr, InterfaceProxyVarp uintptr, ChangedPropertiesVarp *glib.Variant, InvalidatedPropertiesVarp string)
	purego.RegisterFunc(&rawCallback, x.xInterfaceProxyPropertiesChanged)
	return func(ManagerVar *DBusObjectManagerClient, ObjectProxyVar *DBusObjectProxy, InterfaceProxyVar *DBusProxy, ChangedPropertiesVar *glib.Variant, InvalidatedPropertiesVar string) {
		rawCallback(ManagerVar.GoPointer(), ObjectProxyVar.GoPointer(), InterfaceProxyVar.GoPointer(), ChangedPropertiesVar, InvalidatedPropertiesVar)
	}
}

type DBusObjectManagerClientPrivate struct {
	_ structs.HostLayout
}

func (x *DBusObjectManagerClientPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GDBusObjectManagerClient` is used to create, monitor and delete object
// proxies for remote objects exported by a [class@Gio.DBusObjectManagerServer]
// (or any code implementing the
// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to
// the [signal@Gio.DBusObjectManager::object-added] and
// [signal@Gio.DBusObjectManager::object-removed signals] and inspect the
// [class@Gio.DBusObjectProxy] objects returned by
// [method@Gio.DBusObjectManager.get_objects].
//
// If the name for a `GDBusObjectManagerClient` is not owned by anyone at
// object construction time, the default behavior is to request the
// message bus to launch an owner for the name. This behavior can be
// disabled using the `G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START`
// flag. It’s also worth noting that this only works if the name of
// interest is activatable in the first place. E.g. in some cases it
// is not possible to launch an owner for the requested name. In this
// case, `GDBusObjectManagerClient` object construction still succeeds but
// there will be no object proxies
// (e.g. [method@Gio.DBusObjectManager.get_objects] returns the empty list) and
// the [property@Gio.DBusObjectManagerClient:name-owner] property is `NULL`.
//
// The owner of the requested name can come and go (for example
// consider a system service being restarted) – `GDBusObjectManagerClient`
// handles this case too; simply connect to the [signal@GObject.Object::notify]
// signal to watch for changes on the
// [property@Gio.DBusObjectManagerClient:name-owner] property. When the name
// owner vanishes, the behavior is that
// [property@Gio.DBusObjectManagerClient:name-owner] is set to `NULL` (this
// includes emission of the [signal@GObject.Object::notify] signal) and then
// [signal@Gio.DBusObjectManager::object-removed] signals are synthesized
// for all currently existing object proxies. Since
// [property@Gio.DBusObjectManagerClient:name-owner] is `NULL` when this
// happens, you can use this information to disambiguate a synthesized signal
// from a genuine signal caused by object removal on the remote
// [iface@Gio.DBusObjectManager]. Similarly, when a new name owner appears,
// [signal@Gio.DBusObjectManager::object-added] signals are synthesized
// while [property@Gio.DBusObjectManagerClient:name-owner] is still `NULL`. Only
// when all object proxies have been added, the
// [property@Gio.DBusObjectManagerClient:name-owner] is set to the new name
// owner (this includes emission of the [signal@GObject.Object::notify] signal).
// Furthermore, you are guaranteed that
// [property@Gio.DBusObjectManagerClient:name-owner] will alternate between a
// name owner (e.g. `:1.42`) and `NULL` even in the case where
// the name of interest is atomically replaced
//
// Ultimately, `GDBusObjectManagerClient` is used to obtain
// [class@Gio.DBusProxy] instances. All signals (including the
// `org.freedesktop.DBus.Properties::PropertiesChanged` signal)
// delivered to [class@Gio.DBusProxy] instances are guaranteed to originate
// from the name owner. This guarantee along with the behavior
// described above, means that certain race conditions including the
// “half the proxy is from the old owner and the other half is from
// the new owner” problem cannot happen.
//
// To avoid having the application connect to signals on the returned
// [class@Gio.DBusObjectProxy] and [class@Gio.DBusProxy] objects, the
// [signal@Gio.DBusObject::interface-added],
// [signal@Gio.DBusObject::interface-removed],
// [signal@Gio.DBusProxy::g-properties-changed] and
// [signal@Gio.DBusProxy::g-signal] signals
// are also emitted on the `GDBusObjectManagerClient` instance managing these
// objects. The signals emitted are
// [signal@Gio.DBusObjectManager::interface-added],
// [signal@Gio.DBusObjectManager::interface-removed],
// [signal@Gio.DBusObjectManagerClient::interface-proxy-properties-changed] and
// [signal@Gio.DBusObjectManagerClient::interface-proxy-signal].
//
// Note that all callbacks and signals are emitted in the
// thread-default main context (see
// [method@GLib.MainContext.push_thread_default]) that the
// `GDBusObjectManagerClient` object was constructed in. Additionally, the
// [class@Gio.DBusObjectProxy] and [class@Gio.DBusProxy] objects
// originating from the `GDBusObjectManagerClient` object will be created in
// the same context and, consequently, will deliver signals in the
// same main loop.
type DBusObjectManagerClient struct {
	gobject.Object
}

var xDBusObjectManagerClientGLibType func() types.GType

func DBusObjectManagerClientGLibType() types.GType {
	return xDBusObjectManagerClientGLibType()
}

func DBusObjectManagerClientNewFromInternalPtr(ptr uintptr) *DBusObjectManagerClient {
	cls := &DBusObjectManagerClient{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusObjectManagerClientFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_object_manager_client_new().
func NewDBusObjectManagerClientFinish(ResVar AsyncResult) (*DBusObjectManagerClient, error) {
	var cls *DBusObjectManagerClient
	var cerr *glib.Error

	cret := xNewDBusObjectManagerClientFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusObjectManagerClient{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusObjectManagerClientForBusFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_object_manager_client_new_for_bus().
func NewDBusObjectManagerClientForBusFinish(ResVar AsyncResult) (*DBusObjectManagerClient, error) {
	var cls *DBusObjectManagerClient
	var cerr *glib.Error

	cret := xNewDBusObjectManagerClientForBusFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusObjectManagerClient{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusObjectManagerClientForBusSync func(BusType, DBusObjectManagerClientFlags, string, string, uintptr, uintptr, uintptr, uintptr, **glib.Error) uintptr

// Like g_dbus_object_manager_client_new_sync() but takes a #GBusType instead
// of a #GDBusConnection.
//
// This is a synchronous failable constructor - the calling thread is
// blocked until a reply is received. See g_dbus_object_manager_client_new_for_bus()
// for the asynchronous version.
func NewDBusObjectManagerClientForBusSync(BusTypeVar BusType, FlagsVar DBusObjectManagerClientFlags, NameVar string, ObjectPathVar string, GetProxyTypeFuncVar *DBusProxyTypeFunc, GetProxyTypeUserDataVar uintptr, GetProxyTypeDestroyNotifyVar *glib.DestroyNotify, CancellableVar *Cancellable) (*DBusObjectManagerClient, error) {
	var cls *DBusObjectManagerClient
	var cerr *glib.Error

	cret := xNewDBusObjectManagerClientForBusSync(BusTypeVar, FlagsVar, NameVar, ObjectPathVar, glib.NewCallbackNullable(GetProxyTypeFuncVar), GetProxyTypeUserDataVar, glib.NewCallbackNullable(GetProxyTypeDestroyNotifyVar), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusObjectManagerClient{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusObjectManagerClientSync func(uintptr, DBusObjectManagerClientFlags, string, string, uintptr, uintptr, uintptr, uintptr, **glib.Error) uintptr

// Creates a new #GDBusObjectManagerClient object.
//
// This is a synchronous failable constructor - the calling thread is
// blocked until a reply is received. See g_dbus_object_manager_client_new()
// for the asynchronous version.
func NewDBusObjectManagerClientSync(ConnectionVar *DBusConnection, FlagsVar DBusObjectManagerClientFlags, NameVar string, ObjectPathVar string, GetProxyTypeFuncVar *DBusProxyTypeFunc, GetProxyTypeUserDataVar uintptr, GetProxyTypeDestroyNotifyVar *glib.DestroyNotify, CancellableVar *Cancellable) (*DBusObjectManagerClient, error) {
	var cls *DBusObjectManagerClient
	var cerr *glib.Error

	cret := xNewDBusObjectManagerClientSync(ConnectionVar.GoPointer(), FlagsVar, NameVar, ObjectPathVar, glib.NewCallbackNullable(GetProxyTypeFuncVar), GetProxyTypeUserDataVar, glib.NewCallbackNullable(GetProxyTypeDestroyNotifyVar), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusObjectManagerClient{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusObjectManagerClientGetConnection func(uintptr) uintptr

// Gets the #GDBusConnection used by @manager.
func (x *DBusObjectManagerClient) GetConnection() *DBusConnection {
	var cls *DBusConnection

	cret := xDBusObjectManagerClientGetConnection(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &DBusConnection{}
	cls.Ptr = cret
	return cls
}

var xDBusObjectManagerClientGetFlags func(uintptr) DBusObjectManagerClientFlags

// Gets the flags that @manager was constructed with.
func (x *DBusObjectManagerClient) GetFlags() DBusObjectManagerClientFlags {

	cret := xDBusObjectManagerClientGetFlags(x.GoPointer())
	return cret
}

var xDBusObjectManagerClientGetName func(uintptr) string

// Gets the name that @manager is for, or %NULL if not a message bus
// connection.
func (x *DBusObjectManagerClient) GetName() string {

	cret := xDBusObjectManagerClientGetName(x.GoPointer())
	return cret
}

var xDBusObjectManagerClientGetNameOwner func(uintptr) string

// The unique name that owns the name that @manager is for or %NULL if
// no-one currently owns that name. You can connect to the
// #GObject::notify signal to track changes to the
// #GDBusObjectManagerClient:name-owner property.
func (x *DBusObjectManagerClient) GetNameOwner() string {

	cret := xDBusObjectManagerClientGetNameOwner(x.GoPointer())
	return cret
}

func (c *DBusObjectManagerClient) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *DBusObjectManagerClient) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyGetProxyTypeDestroyNotify sets the "get-proxy-type-destroy-notify" property.
// A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
func (x *DBusObjectManagerClient) SetPropertyGetProxyTypeDestroyNotify(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("get-proxy-type-destroy-notify", &v)
}

// GetPropertyGetProxyTypeDestroyNotify gets the "get-proxy-type-destroy-notify" property.
// A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
func (x *DBusObjectManagerClient) GetPropertyGetProxyTypeDestroyNotify() uintptr {
	var v gobject.Value
	x.GetProperty("get-proxy-type-destroy-notify", &v)
	return v.GetPointer()
}

// SetPropertyGetProxyTypeFunc sets the "get-proxy-type-func" property.
// The #GDBusProxyTypeFunc to use when determining what #GType to
// use for interface proxies or %NULL.
func (x *DBusObjectManagerClient) SetPropertyGetProxyTypeFunc(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("get-proxy-type-func", &v)
}

// GetPropertyGetProxyTypeFunc gets the "get-proxy-type-func" property.
// The #GDBusProxyTypeFunc to use when determining what #GType to
// use for interface proxies or %NULL.
func (x *DBusObjectManagerClient) GetPropertyGetProxyTypeFunc() uintptr {
	var v gobject.Value
	x.GetProperty("get-proxy-type-func", &v)
	return v.GetPointer()
}

// SetPropertyGetProxyTypeUserData sets the "get-proxy-type-user-data" property.
// The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
func (x *DBusObjectManagerClient) SetPropertyGetProxyTypeUserData(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("get-proxy-type-user-data", &v)
}

// GetPropertyGetProxyTypeUserData gets the "get-proxy-type-user-data" property.
// The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
func (x *DBusObjectManagerClient) GetPropertyGetProxyTypeUserData() uintptr {
	var v gobject.Value
	x.GetProperty("get-proxy-type-user-data", &v)
	return v.GetPointer()
}

// SetPropertyName sets the "name" property.
// The well-known name or unique name that the manager is for.
func (x *DBusObjectManagerClient) SetPropertyName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("name", &v)
}

// GetPropertyName gets the "name" property.
// The well-known name or unique name that the manager is for.
func (x *DBusObjectManagerClient) GetPropertyName() string {
	var v gobject.Value
	x.GetProperty("name", &v)
	return v.GetString()
}

// GetPropertyNameOwner gets the "name-owner" property.
// The unique name that owns #GDBusObjectManagerClient:name or %NULL if
// no-one is currently owning the name. Connect to the
// #GObject::notify signal to track changes to this property.
func (x *DBusObjectManagerClient) GetPropertyNameOwner() string {
	var v gobject.Value
	x.GetProperty("name-owner", &v)
	return v.GetString()
}

// SetPropertyObjectPath sets the "object-path" property.
// The object path the manager is for.
func (x *DBusObjectManagerClient) SetPropertyObjectPath(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(value)
	x.SetProperty("object-path", &v)
}

// GetPropertyObjectPath gets the "object-path" property.
// The object path the manager is for.
func (x *DBusObjectManagerClient) GetPropertyObjectPath() string {
	var v gobject.Value
	x.GetProperty("object-path", &v)
	return v.GetString()
}

// Emitted when one or more D-Bus properties on proxy changes. The
// local cache has already been updated when this signal fires. Note
// that both @changed_properties and @invalidated_properties are
// guaranteed to never be %NULL (either may be empty though).
//
// This signal exists purely as a convenience to avoid having to
// connect signals to all interface proxies managed by @manager.
//
// This signal is emitted in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// that @manager was constructed in.
func (x *DBusObjectManagerClient) ConnectInterfaceProxyPropertiesChanged(cb *func(DBusObjectManagerClient, uintptr, uintptr, uintptr, []string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "interface-proxy-properties-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectProxyVarp uintptr, InterfaceProxyVarp uintptr, ChangedPropertiesVarp uintptr, InvalidatedPropertiesVarp []string) {
		fa := DBusObjectManagerClient{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ObjectProxyVarp, InterfaceProxyVarp, ChangedPropertiesVarp, InvalidatedPropertiesVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "interface-proxy-properties-changed", cbRefPtr)
}

// Emitted when a D-Bus signal is received on @interface_proxy.
//
// This signal exists purely as a convenience to avoid having to
// connect signals to all interface proxies managed by @manager.
//
// This signal is emitted in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// that @manager was constructed in.
func (x *DBusObjectManagerClient) ConnectInterfaceProxySignal(cb *func(DBusObjectManagerClient, uintptr, uintptr, string, string, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "interface-proxy-signal", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectProxyVarp uintptr, InterfaceProxyVarp uintptr, SenderNameVarp string, SignalNameVarp string, ParametersVarp uintptr) {
		fa := DBusObjectManagerClient{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ObjectProxyVarp, InterfaceProxyVarp, SenderNameVarp, SignalNameVarp, ParametersVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "interface-proxy-signal", cbRefPtr)
}

// Starts asynchronous initialization of the object implementing the
// interface. This must be done before any real use of the object after
// initial construction. If the object also implements #GInitable you can
// optionally call g_initable_init() instead.
//
// This method is intended for language bindings. If writing in C,
// g_async_initable_new_async() should typically be used instead.
//
// When the initialization is finished, @callback will be called. You can
// then call g_async_initable_init_finish() to get the result of the
// initialization.
//
// Implementations may also support cancellation. If @cancellable is not
// %NULL, then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
// the object doesn't support cancellable initialization, the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// As with #GInitable, if the object is not initialized, or initialization
// returns with an error, then all operations on the object except
// g_object_ref() and g_object_unref() are considered to be invalid, and
// have undefined behaviour. They will often fail with g_critical() or
// g_warning(), but this must not be relied on.
//
// Callers should not assume that a class which implements #GAsyncInitable can
// be initialized multiple times; for more information, see g_initable_init().
// If a class explicitly supports being initialized multiple times,
// implementation requires yielding all subsequent calls to init_async() on the
// results of the first call.
//
// For classes that also support the #GInitable interface, the default
// implementation of this method will run the g_initable_init() function
// in a thread, so if you want to support asynchronous initialization via
// threads, just implement the #GAsyncInitable interface without overriding
// any interface methods.
func (x *DBusObjectManagerClient) InitAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGAsyncInitableInitAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes asynchronous initialization and returns the result.
// See g_async_initable_init_async().
func (x *DBusObjectManagerClient) InitFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGAsyncInitableInitFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Finishes the async construction for the various g_async_initable_new
// calls, returning the created object or %NULL on error.
func (x *DBusObjectManagerClient) NewFinish(ResVar AsyncResult) (*gobject.Object, error) {
	var cls *gobject.Object
	var cerr *glib.Error

	cret := XGAsyncInitableNewFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Gets the interface proxy for @interface_name at @object_path, if
// any.
func (x *DBusObjectManagerClient) GetInterface(ObjectPathVar string, InterfaceNameVar string) *DBusInterfaceBase {
	var cls *DBusInterfaceBase

	cret := XGDbusObjectManagerGetInterface(x.GoPointer(), ObjectPathVar, InterfaceNameVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusInterfaceBase{}
	cls.Ptr = cret
	return cls
}

// Gets the #GDBusObject at @object_path, if any.
func (x *DBusObjectManagerClient) GetObject(ObjectPathVar string) *DBusObjectBase {
	var cls *DBusObjectBase

	cret := XGDbusObjectManagerGetObject(x.GoPointer(), ObjectPathVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusObjectBase{}
	cls.Ptr = cret
	return cls
}

// Gets the object path that @manager is for.
func (x *DBusObjectManagerClient) GetObjectPath() string {

	cret := XGDbusObjectManagerGetObjectPath(x.GoPointer())
	return cret
}

// Gets all #GDBusObject objects known to @manager.
func (x *DBusObjectManagerClient) GetObjects() *glib.List {

	cret := XGDbusObjectManagerGetObjects(x.GoPointer())
	return cret
}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [description][iface@Gio.Initable#description] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class’ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *DBusObjectManagerClient) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusObjectManagerClientNew func(uintptr, DBusObjectManagerClientFlags, string, string, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr)

// Asynchronously creates a new #GDBusObjectManagerClient object.
//
// This is an asynchronous failable constructor. When the result is
// ready, @callback will be invoked in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from. You can then call
// g_dbus_object_manager_client_new_finish() to get the result. See
// g_dbus_object_manager_client_new_sync() for the synchronous version.
func DBusObjectManagerClientNew(ConnectionVar *DBusConnection, FlagsVar DBusObjectManagerClientFlags, NameVar string, ObjectPathVar string, GetProxyTypeFuncVar *DBusProxyTypeFunc, GetProxyTypeUserDataVar uintptr, GetProxyTypeDestroyNotifyVar *glib.DestroyNotify, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusObjectManagerClientNew(ConnectionVar.GoPointer(), FlagsVar, NameVar, ObjectPathVar, glib.NewCallbackNullable(GetProxyTypeFuncVar), GetProxyTypeUserDataVar, glib.NewCallbackNullable(GetProxyTypeDestroyNotifyVar), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xDBusObjectManagerClientNewForBus func(BusType, DBusObjectManagerClientFlags, string, string, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr)

// Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
// #GDBusConnection.
//
// This is an asynchronous failable constructor. When the result is
// ready, @callback will be invoked in the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// of the thread you are calling this method from. You can
// then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
// g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
func DBusObjectManagerClientNewForBus(BusTypeVar BusType, FlagsVar DBusObjectManagerClientFlags, NameVar string, ObjectPathVar string, GetProxyTypeFuncVar *DBusProxyTypeFunc, GetProxyTypeUserDataVar uintptr, GetProxyTypeDestroyNotifyVar *glib.DestroyNotify, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusObjectManagerClientNewForBus(BusTypeVar, FlagsVar, NameVar, ObjectPathVar, glib.NewCallbackNullable(GetProxyTypeFuncVar), GetProxyTypeUserDataVar, glib.NewCallbackNullable(GetProxyTypeDestroyNotifyVar), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xDBusObjectManagerClientGLibType, libs, "g_dbus_object_manager_client_get_type")

	core.PuregoSafeRegister(&xNewDBusObjectManagerClientFinish, libs, "g_dbus_object_manager_client_new_finish")
	core.PuregoSafeRegister(&xNewDBusObjectManagerClientForBusFinish, libs, "g_dbus_object_manager_client_new_for_bus_finish")
	core.PuregoSafeRegister(&xNewDBusObjectManagerClientForBusSync, libs, "g_dbus_object_manager_client_new_for_bus_sync")
	core.PuregoSafeRegister(&xNewDBusObjectManagerClientSync, libs, "g_dbus_object_manager_client_new_sync")

	core.PuregoSafeRegister(&xDBusObjectManagerClientGetConnection, libs, "g_dbus_object_manager_client_get_connection")
	core.PuregoSafeRegister(&xDBusObjectManagerClientGetFlags, libs, "g_dbus_object_manager_client_get_flags")
	core.PuregoSafeRegister(&xDBusObjectManagerClientGetName, libs, "g_dbus_object_manager_client_get_name")
	core.PuregoSafeRegister(&xDBusObjectManagerClientGetNameOwner, libs, "g_dbus_object_manager_client_get_name_owner")

	core.PuregoSafeRegister(&xDBusObjectManagerClientNew, libs, "g_dbus_object_manager_client_new")
	core.PuregoSafeRegister(&xDBusObjectManagerClientNewForBus, libs, "g_dbus_object_manager_client_new_for_bus")

}
