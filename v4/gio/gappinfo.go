// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Application Information interface, for operating system portability.
type AppInfoIface struct {
	_ structs.HostLayout

	GIface uintptr

	xDup uintptr

	xEqual uintptr

	xGetId uintptr

	xGetName uintptr

	xGetDescription uintptr

	xGetExecutable uintptr

	xGetIcon uintptr

	xLaunch uintptr

	xSupportsUris uintptr

	xSupportsFiles uintptr

	xLaunchUris uintptr

	xShouldShow uintptr

	xSetAsDefaultForType uintptr

	xSetAsDefaultForExtension uintptr

	xAddSupportsType uintptr

	xCanRemoveSupportsType uintptr

	xRemoveSupportsType uintptr

	xCanDelete uintptr

	xDoDelete uintptr

	xGetCommandline uintptr

	xGetDisplayName uintptr

	xSetAsLastUsedForType uintptr

	xGetSupportedTypes uintptr

	xLaunchUrisAsync uintptr

	xLaunchUrisFinish uintptr
}

func (x *AppInfoIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideDup sets the "dup" callback function.
// Copies a [iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideDup(cb func(AppInfo) *AppInfoBase) {
	if cb == nil {
		x.xDup = 0
	} else {
		x.xDup = purego.NewCallback(func(AppinfoVarp uintptr) uintptr {
			ret := cb(&AppInfoBase{Ptr: AppinfoVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetDup gets the "dup" callback function.
// Copies a [iface@Gio.AppInfo].
func (x *AppInfoIface) GetDup() func(AppInfo) *AppInfoBase {
	if x.xDup == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xDup)
	return func(AppinfoVar AppInfo) *AppInfoBase {
		rawRet := rawCallback(AppinfoVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &AppInfoBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideEqual sets the "equal" callback function.
// Checks two [iface@Gio.AppInfo]s for equality.
func (x *AppInfoIface) OverrideEqual(cb func(AppInfo, AppInfo) bool) {
	if cb == nil {
		x.xEqual = 0
	} else {
		x.xEqual = purego.NewCallback(func(Appinfo1Varp uintptr, Appinfo2Varp uintptr) bool {
			return cb(&AppInfoBase{Ptr: Appinfo1Varp}, &AppInfoBase{Ptr: Appinfo2Varp})
		})
	}
}

// GetEqual gets the "equal" callback function.
// Checks two [iface@Gio.AppInfo]s for equality.
func (x *AppInfoIface) GetEqual() func(AppInfo, AppInfo) bool {
	if x.xEqual == 0 {
		return nil
	}
	var rawCallback func(Appinfo1Varp uintptr, Appinfo2Varp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEqual)
	return func(Appinfo1Var AppInfo, Appinfo2Var AppInfo) bool {
		return rawCallback(Appinfo1Var.GoPointer(), Appinfo2Var.GoPointer())
	}
}

// OverrideGetId sets the "get_id" callback function.
// Gets a string identifier for a [iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideGetId(cb func(AppInfo) string) {
	if cb == nil {
		x.xGetId = 0
	} else {
		x.xGetId = purego.NewCallback(func(AppinfoVarp uintptr) string {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetGetId gets the "get_id" callback function.
// Gets a string identifier for a [iface@Gio.AppInfo].
func (x *AppInfoIface) GetGetId() func(AppInfo) string {
	if x.xGetId == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetId)
	return func(AppinfoVar AppInfo) string {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideGetName sets the "get_name" callback function.
// Gets the name of the application for a [iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideGetName(cb func(AppInfo) string) {
	if cb == nil {
		x.xGetName = 0
	} else {
		x.xGetName = purego.NewCallback(func(AppinfoVarp uintptr) string {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetGetName gets the "get_name" callback function.
// Gets the name of the application for a [iface@Gio.AppInfo].
func (x *AppInfoIface) GetGetName() func(AppInfo) string {
	if x.xGetName == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetName)
	return func(AppinfoVar AppInfo) string {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideGetDescription sets the "get_description" callback function.
// Gets a short description for the application described by
//
//	the [iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideGetDescription(cb func(AppInfo) string) {
	if cb == nil {
		x.xGetDescription = 0
	} else {
		x.xGetDescription = purego.NewCallback(func(AppinfoVarp uintptr) string {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetGetDescription gets the "get_description" callback function.
// Gets a short description for the application described by
//
//	the [iface@Gio.AppInfo].
func (x *AppInfoIface) GetGetDescription() func(AppInfo) string {
	if x.xGetDescription == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetDescription)
	return func(AppinfoVar AppInfo) string {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideGetExecutable sets the "get_executable" callback function.
// Gets the executable name for the [iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideGetExecutable(cb func(AppInfo) string) {
	if cb == nil {
		x.xGetExecutable = 0
	} else {
		x.xGetExecutable = purego.NewCallback(func(AppinfoVarp uintptr) string {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetGetExecutable gets the "get_executable" callback function.
// Gets the executable name for the [iface@Gio.AppInfo].
func (x *AppInfoIface) GetGetExecutable() func(AppInfo) string {
	if x.xGetExecutable == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetExecutable)
	return func(AppinfoVar AppInfo) string {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideGetIcon sets the "get_icon" callback function.
// Gets the [iface@Gio.Icon] for the [iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideGetIcon(cb func(AppInfo) *IconBase) {
	if cb == nil {
		x.xGetIcon = 0
	} else {
		x.xGetIcon = purego.NewCallback(func(AppinfoVarp uintptr) uintptr {
			ret := cb(&AppInfoBase{Ptr: AppinfoVarp})
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetGetIcon gets the "get_icon" callback function.
// Gets the [iface@Gio.Icon] for the [iface@Gio.AppInfo].
func (x *AppInfoIface) GetGetIcon() func(AppInfo) *IconBase {
	if x.xGetIcon == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) uintptr
	purego.RegisterFunc(&rawCallback, x.xGetIcon)
	return func(AppinfoVar AppInfo) *IconBase {
		rawRet := rawCallback(AppinfoVar.GoPointer())
		if rawRet == 0 {
			return nil
		}
		ret := &IconBase{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideLaunch sets the "launch" callback function.
// Launches an application specified by the [iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideLaunch(cb func(AppInfo, *glib.List, *AppLaunchContext) bool) {
	if cb == nil {
		x.xLaunch = 0
	} else {
		x.xLaunch = purego.NewCallback(func(AppinfoVarp uintptr, FilesVarp *glib.List, ContextVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp}, FilesVarp, AppLaunchContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetLaunch gets the "launch" callback function.
// Launches an application specified by the [iface@Gio.AppInfo].
func (x *AppInfoIface) GetLaunch() func(AppInfo, *glib.List, *AppLaunchContext) bool {
	if x.xLaunch == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, FilesVarp *glib.List, ContextVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xLaunch)
	return func(AppinfoVar AppInfo, FilesVar *glib.List, ContextVar *AppLaunchContext) bool {
		return rawCallback(AppinfoVar.GoPointer(), FilesVar, ContextVar.GoPointer())
	}
}

// OverrideSupportsUris sets the "supports_uris" callback function.
// Indicates whether the application specified supports
//
//	launching URIs.
func (x *AppInfoIface) OverrideSupportsUris(cb func(AppInfo) bool) {
	if cb == nil {
		x.xSupportsUris = 0
	} else {
		x.xSupportsUris = purego.NewCallback(func(AppinfoVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetSupportsUris gets the "supports_uris" callback function.
// Indicates whether the application specified supports
//
//	launching URIs.
func (x *AppInfoIface) GetSupportsUris() func(AppInfo) bool {
	if x.xSupportsUris == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSupportsUris)
	return func(AppinfoVar AppInfo) bool {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideSupportsFiles sets the "supports_files" callback function.
// Indicates whether the application specified accepts
//
//	filename arguments.
func (x *AppInfoIface) OverrideSupportsFiles(cb func(AppInfo) bool) {
	if cb == nil {
		x.xSupportsFiles = 0
	} else {
		x.xSupportsFiles = purego.NewCallback(func(AppinfoVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetSupportsFiles gets the "supports_files" callback function.
// Indicates whether the application specified accepts
//
//	filename arguments.
func (x *AppInfoIface) GetSupportsFiles() func(AppInfo) bool {
	if x.xSupportsFiles == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xSupportsFiles)
	return func(AppinfoVar AppInfo) bool {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideLaunchUris sets the "launch_uris" callback function.
// Launches an application with a list of URIs.
func (x *AppInfoIface) OverrideLaunchUris(cb func(AppInfo, *glib.List, *AppLaunchContext) bool) {
	if cb == nil {
		x.xLaunchUris = 0
	} else {
		x.xLaunchUris = purego.NewCallback(func(AppinfoVarp uintptr, UrisVarp *glib.List, ContextVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp}, UrisVarp, AppLaunchContextNewFromInternalPtr(ContextVarp))
		})
	}
}

// GetLaunchUris gets the "launch_uris" callback function.
// Launches an application with a list of URIs.
func (x *AppInfoIface) GetLaunchUris() func(AppInfo, *glib.List, *AppLaunchContext) bool {
	if x.xLaunchUris == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, UrisVarp *glib.List, ContextVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xLaunchUris)
	return func(AppinfoVar AppInfo, UrisVar *glib.List, ContextVar *AppLaunchContext) bool {
		return rawCallback(AppinfoVar.GoPointer(), UrisVar, ContextVar.GoPointer())
	}
}

// OverrideShouldShow sets the "should_show" callback function.
// Returns whether an application should be shown (e.g. when
//
//	getting a list of installed applications).
//	[FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
func (x *AppInfoIface) OverrideShouldShow(cb func(AppInfo) bool) {
	if cb == nil {
		x.xShouldShow = 0
	} else {
		x.xShouldShow = purego.NewCallback(func(AppinfoVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetShouldShow gets the "should_show" callback function.
// Returns whether an application should be shown (e.g. when
//
//	getting a list of installed applications).
//	[FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
func (x *AppInfoIface) GetShouldShow() func(AppInfo) bool {
	if x.xShouldShow == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xShouldShow)
	return func(AppinfoVar AppInfo) bool {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideSetAsDefaultForType sets the "set_as_default_for_type" callback function.
// Sets an application as default for a given content
//
//	type.
func (x *AppInfoIface) OverrideSetAsDefaultForType(cb func(AppInfo, string) bool) {
	if cb == nil {
		x.xSetAsDefaultForType = 0
	} else {
		x.xSetAsDefaultForType = purego.NewCallback(func(AppinfoVarp uintptr, ContentTypeVarp string) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp}, ContentTypeVarp)
		})
	}
}

// GetSetAsDefaultForType gets the "set_as_default_for_type" callback function.
// Sets an application as default for a given content
//
//	type.
func (x *AppInfoIface) GetSetAsDefaultForType() func(AppInfo, string) bool {
	if x.xSetAsDefaultForType == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, ContentTypeVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xSetAsDefaultForType)
	return func(AppinfoVar AppInfo, ContentTypeVar string) bool {
		return rawCallback(AppinfoVar.GoPointer(), ContentTypeVar)
	}
}

// OverrideSetAsDefaultForExtension sets the "set_as_default_for_extension" callback function.
// Sets an application as default for a given
//
//	file extension.
func (x *AppInfoIface) OverrideSetAsDefaultForExtension(cb func(AppInfo, string) bool) {
	if cb == nil {
		x.xSetAsDefaultForExtension = 0
	} else {
		x.xSetAsDefaultForExtension = purego.NewCallback(func(AppinfoVarp uintptr, ExtensionVarp string) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp}, ExtensionVarp)
		})
	}
}

// GetSetAsDefaultForExtension gets the "set_as_default_for_extension" callback function.
// Sets an application as default for a given
//
//	file extension.
func (x *AppInfoIface) GetSetAsDefaultForExtension() func(AppInfo, string) bool {
	if x.xSetAsDefaultForExtension == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, ExtensionVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xSetAsDefaultForExtension)
	return func(AppinfoVar AppInfo, ExtensionVar string) bool {
		return rawCallback(AppinfoVar.GoPointer(), ExtensionVar)
	}
}

// OverrideAddSupportsType sets the "add_supports_type" callback function.
// Adds to the [iface@Gio.AppInfo] information about
//
//	supported file types.
func (x *AppInfoIface) OverrideAddSupportsType(cb func(AppInfo, string) bool) {
	if cb == nil {
		x.xAddSupportsType = 0
	} else {
		x.xAddSupportsType = purego.NewCallback(func(AppinfoVarp uintptr, ContentTypeVarp string) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp}, ContentTypeVarp)
		})
	}
}

// GetAddSupportsType gets the "add_supports_type" callback function.
// Adds to the [iface@Gio.AppInfo] information about
//
//	supported file types.
func (x *AppInfoIface) GetAddSupportsType() func(AppInfo, string) bool {
	if x.xAddSupportsType == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, ContentTypeVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xAddSupportsType)
	return func(AppinfoVar AppInfo, ContentTypeVar string) bool {
		return rawCallback(AppinfoVar.GoPointer(), ContentTypeVar)
	}
}

// OverrideCanRemoveSupportsType sets the "can_remove_supports_type" callback function.
// Checks for support for removing supported file
//
//	types from a [iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideCanRemoveSupportsType(cb func(AppInfo) bool) {
	if cb == nil {
		x.xCanRemoveSupportsType = 0
	} else {
		x.xCanRemoveSupportsType = purego.NewCallback(func(AppinfoVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetCanRemoveSupportsType gets the "can_remove_supports_type" callback function.
// Checks for support for removing supported file
//
//	types from a [iface@Gio.AppInfo].
func (x *AppInfoIface) GetCanRemoveSupportsType() func(AppInfo) bool {
	if x.xCanRemoveSupportsType == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanRemoveSupportsType)
	return func(AppinfoVar AppInfo) bool {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideRemoveSupportsType sets the "remove_supports_type" callback function.
// Removes a supported application type from a
//
//	[iface@Gio.AppInfo].
func (x *AppInfoIface) OverrideRemoveSupportsType(cb func(AppInfo, string) bool) {
	if cb == nil {
		x.xRemoveSupportsType = 0
	} else {
		x.xRemoveSupportsType = purego.NewCallback(func(AppinfoVarp uintptr, ContentTypeVarp string) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp}, ContentTypeVarp)
		})
	}
}

// GetRemoveSupportsType gets the "remove_supports_type" callback function.
// Removes a supported application type from a
//
//	[iface@Gio.AppInfo].
func (x *AppInfoIface) GetRemoveSupportsType() func(AppInfo, string) bool {
	if x.xRemoveSupportsType == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, ContentTypeVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xRemoveSupportsType)
	return func(AppinfoVar AppInfo, ContentTypeVar string) bool {
		return rawCallback(AppinfoVar.GoPointer(), ContentTypeVar)
	}
}

// OverrideCanDelete sets the "can_delete" callback function.
// Checks if a [iface@Gio.AppInfo] can be deleted. (Since 2.20)
func (x *AppInfoIface) OverrideCanDelete(cb func(AppInfo) bool) {
	if cb == nil {
		x.xCanDelete = 0
	} else {
		x.xCanDelete = purego.NewCallback(func(AppinfoVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetCanDelete gets the "can_delete" callback function.
// Checks if a [iface@Gio.AppInfo] can be deleted. (Since 2.20)
func (x *AppInfoIface) GetCanDelete() func(AppInfo) bool {
	if x.xCanDelete == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanDelete)
	return func(AppinfoVar AppInfo) bool {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideDoDelete sets the "do_delete" callback function.
// Deletes a [iface@Gio.AppInfo]. (Since 2.20)
func (x *AppInfoIface) OverrideDoDelete(cb func(AppInfo) bool) {
	if cb == nil {
		x.xDoDelete = 0
	} else {
		x.xDoDelete = purego.NewCallback(func(AppinfoVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetDoDelete gets the "do_delete" callback function.
// Deletes a [iface@Gio.AppInfo]. (Since 2.20)
func (x *AppInfoIface) GetDoDelete() func(AppInfo) bool {
	if x.xDoDelete == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xDoDelete)
	return func(AppinfoVar AppInfo) bool {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideGetCommandline sets the "get_commandline" callback function.
// Gets the commandline for the [iface@Gio.AppInfo].
//
//	(Since 2.20)
func (x *AppInfoIface) OverrideGetCommandline(cb func(AppInfo) string) {
	if cb == nil {
		x.xGetCommandline = 0
	} else {
		x.xGetCommandline = purego.NewCallback(func(AppinfoVarp uintptr) string {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetGetCommandline gets the "get_commandline" callback function.
// Gets the commandline for the [iface@Gio.AppInfo].
//
//	(Since 2.20)
func (x *AppInfoIface) GetGetCommandline() func(AppInfo) string {
	if x.xGetCommandline == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetCommandline)
	return func(AppinfoVar AppInfo) string {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideGetDisplayName sets the "get_display_name" callback function.
// Gets the display name for the [iface@Gio.AppInfo].
//
//	(Since 2.24)
func (x *AppInfoIface) OverrideGetDisplayName(cb func(AppInfo) string) {
	if cb == nil {
		x.xGetDisplayName = 0
	} else {
		x.xGetDisplayName = purego.NewCallback(func(AppinfoVarp uintptr) string {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetGetDisplayName gets the "get_display_name" callback function.
// Gets the display name for the [iface@Gio.AppInfo].
//
//	(Since 2.24)
func (x *AppInfoIface) GetGetDisplayName() func(AppInfo) string {
	if x.xGetDisplayName == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetDisplayName)
	return func(AppinfoVar AppInfo) string {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideSetAsLastUsedForType sets the "set_as_last_used_for_type" callback function.
// Sets the application as the last used. See
//
//	[method@Gio.AppInfo.set_as_last_used_for_type].
func (x *AppInfoIface) OverrideSetAsLastUsedForType(cb func(AppInfo, string) bool) {
	if cb == nil {
		x.xSetAsLastUsedForType = 0
	} else {
		x.xSetAsLastUsedForType = purego.NewCallback(func(AppinfoVarp uintptr, ContentTypeVarp string) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp}, ContentTypeVarp)
		})
	}
}

// GetSetAsLastUsedForType gets the "set_as_last_used_for_type" callback function.
// Sets the application as the last used. See
//
//	[method@Gio.AppInfo.set_as_last_used_for_type].
func (x *AppInfoIface) GetSetAsLastUsedForType() func(AppInfo, string) bool {
	if x.xSetAsLastUsedForType == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, ContentTypeVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xSetAsLastUsedForType)
	return func(AppinfoVar AppInfo, ContentTypeVar string) bool {
		return rawCallback(AppinfoVar.GoPointer(), ContentTypeVar)
	}
}

// OverrideGetSupportedTypes sets the "get_supported_types" callback function.
// Retrieves the list of content types that @app_info
//
//	claims to support.
func (x *AppInfoIface) OverrideGetSupportedTypes(cb func(AppInfo) []string) {
	if cb == nil {
		x.xGetSupportedTypes = 0
	} else {
		x.xGetSupportedTypes = purego.NewCallback(func(AppinfoVarp uintptr) []string {
			return cb(&AppInfoBase{Ptr: AppinfoVarp})
		})
	}
}

// GetGetSupportedTypes gets the "get_supported_types" callback function.
// Retrieves the list of content types that @app_info
//
//	claims to support.
func (x *AppInfoIface) GetGetSupportedTypes() func(AppInfo) []string {
	if x.xGetSupportedTypes == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr) []string
	purego.RegisterFunc(&rawCallback, x.xGetSupportedTypes)
	return func(AppinfoVar AppInfo) []string {
		return rawCallback(AppinfoVar.GoPointer())
	}
}

// OverrideLaunchUrisAsync sets the "launch_uris_async" callback function.
// Asynchronously launches an application with a list of
//
//	URIs. (Since: 2.60)
func (x *AppInfoIface) OverrideLaunchUrisAsync(cb func(AppInfo, *glib.List, *AppLaunchContext, *Cancellable, *AsyncReadyCallback, uintptr)) {
	if cb == nil {
		x.xLaunchUrisAsync = 0
	} else {
		x.xLaunchUrisAsync = purego.NewCallback(func(AppinfoVarp uintptr, UrisVarp *glib.List, ContextVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr) {
			cb(&AppInfoBase{Ptr: AppinfoVarp}, UrisVarp, AppLaunchContextNewFromInternalPtr(ContextVarp), CancellableNewFromInternalPtr(CancellableVarp), (*AsyncReadyCallback)(unsafe.Pointer(CallbackVarp)), UserDataVarp)
		})
	}
}

// GetLaunchUrisAsync gets the "launch_uris_async" callback function.
// Asynchronously launches an application with a list of
//
//	URIs. (Since: 2.60)
func (x *AppInfoIface) GetLaunchUrisAsync() func(AppInfo, *glib.List, *AppLaunchContext, *Cancellable, *AsyncReadyCallback, uintptr) {
	if x.xLaunchUrisAsync == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, UrisVarp *glib.List, ContextVarp uintptr, CancellableVarp uintptr, CallbackVarp uintptr, UserDataVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xLaunchUrisAsync)
	return func(AppinfoVar AppInfo, UrisVar *glib.List, ContextVar *AppLaunchContext, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {
		rawCallback(AppinfoVar.GoPointer(), UrisVar, ContextVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
	}
}

// OverrideLaunchUrisFinish sets the "launch_uris_finish" callback function.
// Finishes an operation started with @launch_uris_async.
//
//	(Since: 2.60)
func (x *AppInfoIface) OverrideLaunchUrisFinish(cb func(AppInfo, AsyncResult) bool) {
	if cb == nil {
		x.xLaunchUrisFinish = 0
	} else {
		x.xLaunchUrisFinish = purego.NewCallback(func(AppinfoVarp uintptr, ResultVarp uintptr) bool {
			return cb(&AppInfoBase{Ptr: AppinfoVarp}, &AsyncResultBase{Ptr: ResultVarp})
		})
	}
}

// GetLaunchUrisFinish gets the "launch_uris_finish" callback function.
// Finishes an operation started with @launch_uris_async.
//
//	(Since: 2.60)
func (x *AppInfoIface) GetLaunchUrisFinish() func(AppInfo, AsyncResult) bool {
	if x.xLaunchUrisFinish == 0 {
		return nil
	}
	var rawCallback func(AppinfoVarp uintptr, ResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xLaunchUrisFinish)
	return func(AppinfoVar AppInfo, ResultVar AsyncResult) bool {
		return rawCallback(AppinfoVar.GoPointer(), ResultVar.GoPointer())
	}
}

type AppLaunchContextClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xGetDisplay uintptr

	xGetStartupNotifyId uintptr

	xLaunchFailed uintptr

	xLaunched uintptr

	xLaunchStarted uintptr

	xGReserved1 uintptr

	xGReserved2 uintptr

	xGReserved3 uintptr
}

func (x *AppLaunchContextClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideGetDisplay sets the "get_display" callback function.
func (x *AppLaunchContextClass) OverrideGetDisplay(cb func(*AppLaunchContext, AppInfo, *glib.List) string) {
	if cb == nil {
		x.xGetDisplay = 0
	} else {
		x.xGetDisplay = purego.NewCallback(func(ContextVarp uintptr, InfoVarp uintptr, FilesVarp *glib.List) string {
			return cb(AppLaunchContextNewFromInternalPtr(ContextVarp), &AppInfoBase{Ptr: InfoVarp}, FilesVarp)
		})
	}
}

// GetGetDisplay gets the "get_display" callback function.
func (x *AppLaunchContextClass) GetGetDisplay() func(*AppLaunchContext, AppInfo, *glib.List) string {
	if x.xGetDisplay == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, InfoVarp uintptr, FilesVarp *glib.List) string
	purego.RegisterFunc(&rawCallback, x.xGetDisplay)
	return func(ContextVar *AppLaunchContext, InfoVar AppInfo, FilesVar *glib.List) string {
		return rawCallback(ContextVar.GoPointer(), InfoVar.GoPointer(), FilesVar)
	}
}

// OverrideGetStartupNotifyId sets the "get_startup_notify_id" callback function.
func (x *AppLaunchContextClass) OverrideGetStartupNotifyId(cb func(*AppLaunchContext, AppInfo, *glib.List) string) {
	if cb == nil {
		x.xGetStartupNotifyId = 0
	} else {
		x.xGetStartupNotifyId = purego.NewCallback(func(ContextVarp uintptr, InfoVarp uintptr, FilesVarp *glib.List) string {
			return cb(AppLaunchContextNewFromInternalPtr(ContextVarp), &AppInfoBase{Ptr: InfoVarp}, FilesVarp)
		})
	}
}

// GetGetStartupNotifyId gets the "get_startup_notify_id" callback function.
func (x *AppLaunchContextClass) GetGetStartupNotifyId() func(*AppLaunchContext, AppInfo, *glib.List) string {
	if x.xGetStartupNotifyId == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, InfoVarp uintptr, FilesVarp *glib.List) string
	purego.RegisterFunc(&rawCallback, x.xGetStartupNotifyId)
	return func(ContextVar *AppLaunchContext, InfoVar AppInfo, FilesVar *glib.List) string {
		return rawCallback(ContextVar.GoPointer(), InfoVar.GoPointer(), FilesVar)
	}
}

// OverrideLaunchFailed sets the "launch_failed" callback function.
func (x *AppLaunchContextClass) OverrideLaunchFailed(cb func(*AppLaunchContext, string)) {
	if cb == nil {
		x.xLaunchFailed = 0
	} else {
		x.xLaunchFailed = purego.NewCallback(func(ContextVarp uintptr, StartupNotifyIdVarp string) {
			cb(AppLaunchContextNewFromInternalPtr(ContextVarp), StartupNotifyIdVarp)
		})
	}
}

// GetLaunchFailed gets the "launch_failed" callback function.
func (x *AppLaunchContextClass) GetLaunchFailed() func(*AppLaunchContext, string) {
	if x.xLaunchFailed == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, StartupNotifyIdVarp string)
	purego.RegisterFunc(&rawCallback, x.xLaunchFailed)
	return func(ContextVar *AppLaunchContext, StartupNotifyIdVar string) {
		rawCallback(ContextVar.GoPointer(), StartupNotifyIdVar)
	}
}

// OverrideLaunched sets the "launched" callback function.
func (x *AppLaunchContextClass) OverrideLaunched(cb func(*AppLaunchContext, AppInfo, *glib.Variant)) {
	if cb == nil {
		x.xLaunched = 0
	} else {
		x.xLaunched = purego.NewCallback(func(ContextVarp uintptr, InfoVarp uintptr, PlatformDataVarp *glib.Variant) {
			cb(AppLaunchContextNewFromInternalPtr(ContextVarp), &AppInfoBase{Ptr: InfoVarp}, PlatformDataVarp)
		})
	}
}

// GetLaunched gets the "launched" callback function.
func (x *AppLaunchContextClass) GetLaunched() func(*AppLaunchContext, AppInfo, *glib.Variant) {
	if x.xLaunched == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, InfoVarp uintptr, PlatformDataVarp *glib.Variant)
	purego.RegisterFunc(&rawCallback, x.xLaunched)
	return func(ContextVar *AppLaunchContext, InfoVar AppInfo, PlatformDataVar *glib.Variant) {
		rawCallback(ContextVar.GoPointer(), InfoVar.GoPointer(), PlatformDataVar)
	}
}

// OverrideLaunchStarted sets the "launch_started" callback function.
func (x *AppLaunchContextClass) OverrideLaunchStarted(cb func(*AppLaunchContext, AppInfo, *glib.Variant)) {
	if cb == nil {
		x.xLaunchStarted = 0
	} else {
		x.xLaunchStarted = purego.NewCallback(func(ContextVarp uintptr, InfoVarp uintptr, PlatformDataVarp *glib.Variant) {
			cb(AppLaunchContextNewFromInternalPtr(ContextVarp), &AppInfoBase{Ptr: InfoVarp}, PlatformDataVarp)
		})
	}
}

// GetLaunchStarted gets the "launch_started" callback function.
func (x *AppLaunchContextClass) GetLaunchStarted() func(*AppLaunchContext, AppInfo, *glib.Variant) {
	if x.xLaunchStarted == 0 {
		return nil
	}
	var rawCallback func(ContextVarp uintptr, InfoVarp uintptr, PlatformDataVarp *glib.Variant)
	purego.RegisterFunc(&rawCallback, x.xLaunchStarted)
	return func(ContextVar *AppLaunchContext, InfoVar AppInfo, PlatformDataVar *glib.Variant) {
		rawCallback(ContextVar.GoPointer(), InfoVar.GoPointer(), PlatformDataVar)
	}
}

// OverrideGReserved1 sets the "_g_reserved1" callback function.
func (x *AppLaunchContextClass) OverrideGReserved1(cb func()) {
	if cb == nil {
		x.xGReserved1 = 0
	} else {
		x.xGReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved1 gets the "_g_reserved1" callback function.
func (x *AppLaunchContextClass) GetGReserved1() func() {
	if x.xGReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved2 sets the "_g_reserved2" callback function.
func (x *AppLaunchContextClass) OverrideGReserved2(cb func()) {
	if cb == nil {
		x.xGReserved2 = 0
	} else {
		x.xGReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved2 gets the "_g_reserved2" callback function.
func (x *AppLaunchContextClass) GetGReserved2() func() {
	if x.xGReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideGReserved3 sets the "_g_reserved3" callback function.
func (x *AppLaunchContextClass) OverrideGReserved3(cb func()) {
	if cb == nil {
		x.xGReserved3 = 0
	} else {
		x.xGReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetGReserved3 gets the "_g_reserved3" callback function.
func (x *AppLaunchContextClass) GetGReserved3() func() {
	if x.xGReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xGReserved3)
	return func() {
		rawCallback()
	}
}

type AppLaunchContextPrivate struct {
	_ structs.HostLayout
}

func (x *AppLaunchContextPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Information about an installed application and methods to launch
// it (with file arguments).
//
// `GAppInfo` and `GAppLaunchContext` are used for describing and launching
// applications installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths
// (using [method@Gio.File.get_path]) when using [method@Gio.AppInfo.launch]
// even if the application requested an URI and not a POSIX path. For example
// for a desktop-file based application with the following Exec key:
//
// ```
// Exec=totem %U
// ```
//
// and a single URI, `sftp://foo/file.avi`, then
// `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only work
// if a set of suitable GIO extensions (such as GVfs 2.26 compiled with FUSE
// support), is available and operational; if this is not the case, the URI
// will be passed unmodified to the application. Some URIs, such as `mailto:`,
// of course cannot be mapped to a POSIX path (in GVfs there’s no FUSE mount
// for it); such URIs will be passed unmodified to the application.
//
// Specifically for GVfs 2.26 and later, the POSIX URI will be mapped
// back to the GIO URI in the [iface@Gio.File] constructors (since GVfs
// implements the GVfs extension point). As such, if the application
// needs to examine the URI, it needs to use [method@Gio.File.get_uri]
// or similar on [iface@Gio.File]. In other words, an application cannot
// assume that the URI passed to e.g. [func@Gio.File.new_for_commandline_arg]
// is equal to the result of [method@Gio.File.get_uri]. The following snippet
// illustrates this:
//
// ```c
// GFile *f;
// char *uri;
//
// file = g_file_new_for_commandline_arg (uri_from_commandline);
//
// uri = g_file_get_uri (file);
// strcmp (uri, uri_from_commandline) == 0;
// g_free (uri);
//
// if (g_file_has_uri_scheme (file, "cdda"))
//
//	{
//	  // do something special with uri
//	}
//
// g_object_unref (file);
// ```
//
// This code will work when both `cdda://sr0/Track 1.wav` and
// `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
// application. It should be noted that it’s generally not safe
// for applications to rely on the format of a particular URIs.
// Different launcher applications (e.g. file managers) may have
// different ideas of what a given URI means.
type AppInfo interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	AddSupportsType(ContentTypeVar string) (bool, error)
	CanDelete() bool
	CanRemoveSupportsType() bool
	Delete() bool
	Dup() *AppInfoBase
	Equal(Appinfo2Var AppInfo) bool
	GetCommandline() string
	GetDescription() string
	GetDisplayName() string
	GetExecutable() string
	GetIcon() *IconBase
	GetId() string
	GetName() string
	GetSupportedTypes() []string
	Launch(FilesVar *glib.List, ContextVar *AppLaunchContext) (bool, error)
	LaunchUris(UrisVar *glib.List, ContextVar *AppLaunchContext) (bool, error)
	LaunchUrisAsync(UrisVar *glib.List, ContextVar *AppLaunchContext, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	LaunchUrisFinish(ResultVar AsyncResult) (bool, error)
	RemoveSupportsType(ContentTypeVar string) (bool, error)
	SetAsDefaultForExtension(ExtensionVar string) (bool, error)
	SetAsDefaultForType(ContentTypeVar string) (bool, error)
	SetAsLastUsedForType(ContentTypeVar string) (bool, error)
	ShouldShow() bool
	SupportsFiles() bool
	SupportsUris() bool
}

var xAppInfoGLibType func() types.GType

func AppInfoGLibType() types.GType {
	return xAppInfoGLibType()
}

type AppInfoBase struct {
	Ptr uintptr
}

func (x *AppInfoBase) GoPointer() uintptr {
	if x == nil {
		return 0
	}
	return x.Ptr
}

func (x *AppInfoBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Adds a content type to the application information to indicate the
// application is capable of opening files with the given content type.
func (x *AppInfoBase) AddSupportsType(ContentTypeVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGAppInfoAddSupportsType(x.GoPointer(), ContentTypeVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Obtains the information whether the [iface@Gio.AppInfo] can be deleted.
// See [method@Gio.AppInfo.delete].
func (x *AppInfoBase) CanDelete() bool {

	cret := XGAppInfoCanDelete(x.GoPointer())

	return cret
}

// Checks if a supported content type can be removed from an application.
func (x *AppInfoBase) CanRemoveSupportsType() bool {

	cret := XGAppInfoCanRemoveSupportsType(x.GoPointer())

	return cret
}

// Tries to delete a [iface@Gio.AppInfo].
//
// On some platforms, there may be a difference between user-defined
// [iface@Gio.AppInfo]s which can be deleted, and system-wide ones which cannot.
// See [method@Gio.AppInfo.can_delete].
func (x *AppInfoBase) Delete() bool {

	cret := XGAppInfoDelete(x.GoPointer())

	return cret
}

// Creates a duplicate of a [iface@Gio.AppInfo].
func (x *AppInfoBase) Dup() *AppInfoBase {
	var cls *AppInfoBase

	cret := XGAppInfoDup(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	return cls
}

// Checks if two [iface@Gio.AppInfo]s are equal.
//
// Note that the check *may not* compare each individual field, and only does
// an identity check. In case detecting changes in the contents is needed,
// program code must additionally compare relevant fields.
func (x *AppInfoBase) Equal(Appinfo2Var AppInfo) bool {

	cret := XGAppInfoEqual(x.GoPointer(), Appinfo2Var.GoPointer())

	return cret
}

// Gets the commandline with which the application will be
// started.
func (x *AppInfoBase) GetCommandline() string {

	cret := XGAppInfoGetCommandline(x.GoPointer())

	return cret
}

// Gets a human-readable description of an installed application.
func (x *AppInfoBase) GetDescription() string {

	cret := XGAppInfoGetDescription(x.GoPointer())

	return cret
}

// Gets the display name of the application. The display name is often more
// descriptive to the user than the name itself.
func (x *AppInfoBase) GetDisplayName() string {

	cret := XGAppInfoGetDisplayName(x.GoPointer())

	return cret
}

// Gets the executable’s name for the installed application.
//
// This is intended to be used for debugging or labelling what program is going
// to be run. To launch the executable, use [method@Gio.AppInfo.launch] and related
// functions, rather than spawning the return value from this function.
func (x *AppInfoBase) GetExecutable() string {

	cret := XGAppInfoGetExecutable(x.GoPointer())

	return cret
}

// Gets the icon for the application.
func (x *AppInfoBase) GetIcon() *IconBase {
	var cls *IconBase

	cret := XGAppInfoGetIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Gets the ID of an application. An id is a string that identifies the
// application. The exact format of the id is platform dependent. For instance,
// on Unix this is the desktop file id from the xdg menu specification.
//
// Note that the returned ID may be `NULL`, depending on how the @appinfo has
// been constructed.
func (x *AppInfoBase) GetId() string {

	cret := XGAppInfoGetId(x.GoPointer())

	return cret
}

// Gets the installed name of the application.
func (x *AppInfoBase) GetName() string {

	cret := XGAppInfoGetName(x.GoPointer())

	return cret
}

// Retrieves the list of content types that @app_info claims to support.
// If this information is not provided by the environment, this function
// will return `NULL`.
//
// This function does not take in consideration associations added with
// [method@Gio.AppInfo.add_supports_type], but only those exported directly by
// the application.
func (x *AppInfoBase) GetSupportedTypes() []string {

	cret := XGAppInfoGetSupportedTypes(x.GoPointer())

	return cret
}

// Launches the application. Passes @files to the launched application
// as arguments, using the optional @context to get information
// about the details of the launcher (like what screen it is on).
// On error, @error will be set accordingly.
//
// To launch the application without arguments pass a `NULL` @files list.
//
// Note that even if the launch is successful the application launched
// can fail to start if it runs into problems during startup. There is
// no way to detect this.
//
// Some URIs can be changed when passed through a GFile (for instance
// unsupported URIs with strange formats like mailto:), so if you have
// a textual URI you want to pass in as argument, consider using
// [method@Gio.AppInfo.launch_uris] instead.
//
// The launched application inherits the environment of the launching
// process, but it can be modified with [method@Gio.AppLaunchContext.setenv]
// and [method@Gio.AppLaunchContext.unsetenv].
//
// On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
// environment variable with the path of the launched desktop file and
// `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
// process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
// should it be inherited by further processes. The `DISPLAY`,
// `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
// variables are also set, based on information provided in @context.
func (x *AppInfoBase) Launch(FilesVar *glib.List, ContextVar *AppLaunchContext) (bool, error) {
	var cerr *glib.Error

	cret := XGAppInfoLaunch(x.GoPointer(), FilesVar, ContextVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Launches the application. This passes the @uris to the launched application
// as arguments, using the optional @context to get information
// about the details of the launcher (like what screen it is on).
// On error, @error will be set accordingly. If the application only supports
// one URI per invocation as part of their command-line, multiple instances
// of the application will be spawned.
//
// To launch the application without arguments pass a `NULL` @uris list.
//
// Note that even if the launch is successful the application launched
// can fail to start if it runs into problems during startup. There is
// no way to detect this.
func (x *AppInfoBase) LaunchUris(UrisVar *glib.List, ContextVar *AppLaunchContext) (bool, error) {
	var cerr *glib.Error

	cret := XGAppInfoLaunchUris(x.GoPointer(), UrisVar, ContextVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Async version of [method@Gio.AppInfo.launch_uris].
//
// The @callback is invoked immediately after the application launch, but it
// waits for activation in case of D-Bus–activated applications and also provides
// extended error information for sandboxed applications, see notes for
// [func@Gio.AppInfo.launch_default_for_uri_async].
func (x *AppInfoBase) LaunchUrisAsync(UrisVar *glib.List, ContextVar *AppLaunchContext, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGAppInfoLaunchUrisAsync(x.GoPointer(), UrisVar, ContextVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

// Finishes a [method@Gio.AppInfo.launch_uris_async] operation.
func (x *AppInfoBase) LaunchUrisFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGAppInfoLaunchUrisFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Removes a supported type from an application, if possible.
func (x *AppInfoBase) RemoveSupportsType(ContentTypeVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGAppInfoRemoveSupportsType(x.GoPointer(), ContentTypeVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the application as the default handler for the given file extension.
func (x *AppInfoBase) SetAsDefaultForExtension(ExtensionVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGAppInfoSetAsDefaultForExtension(x.GoPointer(), ExtensionVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the application as the default handler for a given type.
func (x *AppInfoBase) SetAsDefaultForType(ContentTypeVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGAppInfoSetAsDefaultForType(x.GoPointer(), ContentTypeVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the application as the last used application for a given type. This
// will make the application appear as first in the list returned by
// [func@Gio.AppInfo.get_recommended_for_type], regardless of the default
// application for that content type.
func (x *AppInfoBase) SetAsLastUsedForType(ContentTypeVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGAppInfoSetAsLastUsedForType(x.GoPointer(), ContentTypeVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Checks if the application info should be shown in menus that
// list available applications.
func (x *AppInfoBase) ShouldShow() bool {

	cret := XGAppInfoShouldShow(x.GoPointer())

	return cret
}

// Checks if the application accepts files as arguments.
func (x *AppInfoBase) SupportsFiles() bool {

	cret := XGAppInfoSupportsFiles(x.GoPointer())

	return cret
}

// Checks if the application supports reading files and directories from URIs.
func (x *AppInfoBase) SupportsUris() bool {

	cret := XGAppInfoSupportsUris(x.GoPointer())

	return cret
}

var XGAppInfoAddSupportsType func(uintptr, string, **glib.Error) bool
var XGAppInfoCanDelete func(uintptr) bool
var XGAppInfoCanRemoveSupportsType func(uintptr) bool
var XGAppInfoDelete func(uintptr) bool
var XGAppInfoDup func(uintptr) uintptr
var XGAppInfoEqual func(uintptr, uintptr) bool
var XGAppInfoGetCommandline func(uintptr) string
var XGAppInfoGetDescription func(uintptr) string
var XGAppInfoGetDisplayName func(uintptr) string
var XGAppInfoGetExecutable func(uintptr) string
var XGAppInfoGetIcon func(uintptr) uintptr
var XGAppInfoGetId func(uintptr) string
var XGAppInfoGetName func(uintptr) string
var XGAppInfoGetSupportedTypes func(uintptr) []string
var XGAppInfoLaunch func(uintptr, *glib.List, uintptr, **glib.Error) bool
var XGAppInfoLaunchUris func(uintptr, *glib.List, uintptr, **glib.Error) bool
var XGAppInfoLaunchUrisAsync func(uintptr, *glib.List, uintptr, uintptr, uintptr, uintptr)
var XGAppInfoLaunchUrisFinish func(uintptr, uintptr, **glib.Error) bool
var XGAppInfoRemoveSupportsType func(uintptr, string, **glib.Error) bool
var XGAppInfoSetAsDefaultForExtension func(uintptr, string, **glib.Error) bool
var XGAppInfoSetAsDefaultForType func(uintptr, string, **glib.Error) bool
var XGAppInfoSetAsLastUsedForType func(uintptr, string, **glib.Error) bool
var XGAppInfoShouldShow func(uintptr) bool
var XGAppInfoSupportsFiles func(uintptr) bool
var XGAppInfoSupportsUris func(uintptr) bool

var xAppInfoCreateFromCommandline func(string, uintptr, AppInfoCreateFlags, **glib.Error) uintptr

// Creates a new [iface@Gio.AppInfo] from the given information.
//
// Note that for @commandline, the quoting rules of the `Exec` key of the
// [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
// are applied. For example, if the @commandline contains
// percent-encoded URIs, the percent-character must be doubled in order to prevent it from
// being swallowed by `Exec` key unquoting. See
// [the specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)
// for exact quoting rules.
func AppInfoCreateFromCommandline(CommandlineVar string, ApplicationNameVar *string, FlagsVar AppInfoCreateFlags) (*AppInfoBase, error) {
	var cls *AppInfoBase
	var cerr *glib.Error

	ApplicationNameVarPtr, ApplicationNameVarBytes := core.NullableStringToPtr(ApplicationNameVar)

	cret := xAppInfoCreateFromCommandline(CommandlineVar, ApplicationNameVarPtr, FlagsVar, &cerr)

	runtime.KeepAlive(ApplicationNameVarBytes)

	if cret == 0 {
		return nil, cerr
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xAppInfoGetAll func() *glib.List

// Gets a list of all of the applications currently registered
// on this system.
//
// For desktop files, this includes applications that have
// [`NoDisplay=true`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-nodisplay)
// set or are excluded from display by means of
// [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-onlyshowin)
// or [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-notshowin).
// See [method@Gio.AppInfo.should_show].
//
// The returned list does not include applications which have the
// [`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-hidden)
// set.
func AppInfoGetAll() *glib.List {

	cret := xAppInfoGetAll()

	return cret
}

var xAppInfoGetAllForType func(string) *glib.List

// Gets a list of all [iface@Gio.AppInfo]s for a given content type,
// including the recommended and fallback [iface@Gio.AppInfo]s. See
// [func@Gio.AppInfo.get_recommended_for_type] and
// [func@Gio.AppInfo.get_fallback_for_type].
func AppInfoGetAllForType(ContentTypeVar string) *glib.List {

	cret := xAppInfoGetAllForType(ContentTypeVar)

	return cret
}

var xAppInfoGetDefaultForType func(string, bool) uintptr

// Gets the default [iface@Gio.AppInfo] for a given content type.
func AppInfoGetDefaultForType(ContentTypeVar string, MustSupportUrisVar bool) *AppInfoBase {
	var cls *AppInfoBase

	cret := xAppInfoGetDefaultForType(ContentTypeVar, MustSupportUrisVar)

	if cret == 0 {
		return nil
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	return cls
}

var xAppInfoGetDefaultForTypeAsync func(string, bool, uintptr, uintptr, uintptr)

// Asynchronously gets the default [iface@Gio.AppInfo] for a given content
// type.
func AppInfoGetDefaultForTypeAsync(ContentTypeVar string, MustSupportUrisVar bool, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xAppInfoGetDefaultForTypeAsync(ContentTypeVar, MustSupportUrisVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xAppInfoGetDefaultForTypeFinish func(uintptr, **glib.Error) uintptr

// Finishes a default [iface@Gio.AppInfo] lookup started by
// [func@Gio.AppInfo.get_default_for_type_async].
//
// If no #[iface@Gio.AppInfo] is found, then @error will be set to
// [error@Gio.IOErrorEnum.NOT_FOUND].
func AppInfoGetDefaultForTypeFinish(ResultVar AsyncResult) (*AppInfoBase, error) {
	var cls *AppInfoBase
	var cerr *glib.Error

	cret := xAppInfoGetDefaultForTypeFinish(ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xAppInfoGetDefaultForUriScheme func(string) uintptr

// Gets the default application for handling URIs with the given URI scheme.
//
// A URI scheme is the initial part of the URI, up to but not including the `:`.
// For example, `http`, `ftp` or `sip`.
func AppInfoGetDefaultForUriScheme(UriSchemeVar string) *AppInfoBase {
	var cls *AppInfoBase

	cret := xAppInfoGetDefaultForUriScheme(UriSchemeVar)

	if cret == 0 {
		return nil
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	return cls
}

var xAppInfoGetDefaultForUriSchemeAsync func(string, uintptr, uintptr, uintptr)

// Asynchronously gets the default application for handling URIs with
// the given URI scheme. A URI scheme is the initial part
// of the URI, up to but not including the `:`, e.g. `http`,
// `ftp` or `sip`.
func AppInfoGetDefaultForUriSchemeAsync(UriSchemeVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xAppInfoGetDefaultForUriSchemeAsync(UriSchemeVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xAppInfoGetDefaultForUriSchemeFinish func(uintptr, **glib.Error) uintptr

// Finishes a default [iface@Gio.AppInfo] lookup started by
// [func@Gio.AppInfo.get_default_for_uri_scheme_async].
//
// If no [iface@Gio.AppInfo] is found, then @error will be set to
// [error@Gio.IOErrorEnum.NOT_FOUND].
func AppInfoGetDefaultForUriSchemeFinish(ResultVar AsyncResult) (*AppInfoBase, error) {
	var cls *AppInfoBase
	var cerr *glib.Error

	cret := xAppInfoGetDefaultForUriSchemeFinish(ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xAppInfoGetFallbackForType func(string) *glib.List

// Gets a list of fallback [iface@Gio.AppInfo]s for a given content type, i.e.
// those applications which claim to support the given content type by MIME
// type subclassing and not directly.
func AppInfoGetFallbackForType(ContentTypeVar string) *glib.List {

	cret := xAppInfoGetFallbackForType(ContentTypeVar)

	return cret
}

var xAppInfoGetRecommendedForType func(string) *glib.List

// Gets a list of recommended [iface@Gio.AppInfo]s for a given content type,
// i.e. those applications which claim to support the given content type
// exactly, and not by MIME type subclassing.
//
// Note that the first application of the list is the last used one, i.e.
// the last one for which [method@Gio.AppInfo.set_as_last_used_for_type] has
// been called.
func AppInfoGetRecommendedForType(ContentTypeVar string) *glib.List {

	cret := xAppInfoGetRecommendedForType(ContentTypeVar)

	return cret
}

var xAppInfoLaunchDefaultForUri func(string, uintptr, **glib.Error) bool

// Utility function that launches the default application registered to handle
// the specified uri. Synchronous I/O is done on the uri to detect the type of
// the file if required.
//
// The D-Bus–activated applications don’t have to be started if your application
// terminates too soon after this function. To prevent this, use
// [func@Gio.AppInfo.launch_default_for_uri_async] instead.
func AppInfoLaunchDefaultForUri(UriVar string, ContextVar *AppLaunchContext) (bool, error) {
	var cerr *glib.Error

	cret := xAppInfoLaunchDefaultForUri(UriVar, ContextVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xAppInfoLaunchDefaultForUriAsync func(string, uintptr, uintptr, uintptr, uintptr)

// Async version of [func@Gio.AppInfo.launch_default_for_uri].
//
// This version is useful if you are interested in receiving error information
// in the case where the application is sandboxed and the portal may present an
// application chooser dialog to the user.
//
// This is also useful if you want to be sure that the D-Bus–activated
// applications are really started before termination and if you are interested
// in receiving error information from their activation.
func AppInfoLaunchDefaultForUriAsync(UriVar string, ContextVar *AppLaunchContext, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xAppInfoLaunchDefaultForUriAsync(UriVar, ContextVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xAppInfoLaunchDefaultForUriFinish func(uintptr, **glib.Error) bool

// Finishes an asynchronous launch-default-for-uri operation.
func AppInfoLaunchDefaultForUriFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xAppInfoLaunchDefaultForUriFinish(ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xAppInfoResetTypeAssociations func(string)

// Removes all changes to the type associations done by
// [method@Gio.AppInfo.set_as_default_for_type],
// [method@Gio.AppInfo.set_as_default_for_extension],
// [method@Gio.AppInfo.add_supports_type] or
// [method@Gio.AppInfo.remove_supports_type].
func AppInfoResetTypeAssociations(ContentTypeVar string) {

	xAppInfoResetTypeAssociations(ContentTypeVar)

}

// `GAppInfoMonitor` monitors application information for changes.
//
// `GAppInfoMonitor` is a very simple object used for monitoring the app
// info database for changes (newly installed or removed applications).
//
// Call [func@Gio.AppInfoMonitor.get] to get a `GAppInfoMonitor` and connect
// to the [signal@Gio.AppInfoMonitor::changed] signal. The signal will be emitted once when
// the app info database changes, and will not be emitted again until after the
// next call to [func@Gio.AppInfo.get_all] or another `g_app_info_*()` function.
// This is because monitoring the app info database for changes is expensive.
//
// The following functions will re-arm the [signal@Gio.AppInfoMonitor::changed]
// signal so it can be emitted again:
//
//   - [func@Gio.AppInfo.get_all]
//   - [func@Gio.AppInfo.get_all_for_type]
//   - [func@Gio.AppInfo.get_default_for_type]
//   - [func@Gio.AppInfo.get_fallback_for_type]
//   - [func@Gio.AppInfo.get_recommended_for_type]
//   - [`g_desktop_app_info_get_implementations()`](../gio-unix/type_func.DesktopAppInfo.get_implementation.html)
//   - [`g_desktop_app_info_new()`](../gio-unix/ctor.DesktopAppInfo.new.html)
//   - [`g_desktop_app_info_new_from_filename()`](../gio-unix/ctor.DesktopAppInfo.new_from_filename.html)
//   - [`g_desktop_app_info_new_from_keyfile()`](../gio-unix/ctor.DesktopAppInfo.new_from_keyfile.html)
//   - [`g_desktop_app_info_search()`](../gio-unix/type_func.DesktopAppInfo.search.html)
//
// The latter functions are available if using
// [`GDesktopAppInfo`](../gio-unix/class.DesktopAppInfo.html) from
// `gio-unix-2.0.pc` (GIR namespace `GioUnix-2.0`).
//
// In the usual case, applications should try to make note of the change
// (doing things like invalidating caches) but not act on it. In
// particular, applications should avoid making calls to `GAppInfo` APIs
// in response to the change signal, deferring these until the time that
// the updated data is actually required. The exception to this case is when
// application information is actually being displayed on the screen
// (for example, during a search or when the list of all applications is shown).
// The reason for this is that changes to the list of installed applications
// often come in groups (like during system updates) and rescanning the list
// on every change is pointless and expensive.
type AppInfoMonitor struct {
	gobject.Object
}

var xAppInfoMonitorGLibType func() types.GType

func AppInfoMonitorGLibType() types.GType {
	return xAppInfoMonitorGLibType()
}

func AppInfoMonitorNewFromInternalPtr(ptr uintptr) *AppInfoMonitor {
	cls := &AppInfoMonitor{}
	cls.Ptr = ptr
	return cls
}

func (c *AppInfoMonitor) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *AppInfoMonitor) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Signal emitted when the app info database changes, when applications are
// installed or removed.
func (x *AppInfoMonitor) ConnectChanged(cb *func(AppInfoMonitor)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := AppInfoMonitor{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

var xAppInfoMonitorGet func() uintptr

// Gets the #GAppInfoMonitor for the current thread-default main
// context.
//
// The #GAppInfoMonitor will emit a “changed” signal in the
// thread-default main context whenever the list of installed
// applications (as reported by g_app_info_get_all()) may have changed.
//
// The #GAppInfoMonitor::changed signal will only be emitted once until
// g_app_info_get_all() (or another `g_app_info_*()` function) is called. Doing
// so will re-arm the signal ready to notify about the next change.
//
// You must only call g_object_unref() on the return value from under
// the same main context as you created it.
func AppInfoMonitorGet() *AppInfoMonitor {
	var cls *AppInfoMonitor

	cret := xAppInfoMonitorGet()

	if cret == 0 {
		return nil
	}
	cls = &AppInfoMonitor{}
	cls.Ptr = cret
	return cls
}

// Integrating the launch with the launching application. This is used to
// handle for instance startup notification and launching the new application
// on the same screen as the launching window.
type AppLaunchContext struct {
	gobject.Object
}

var xAppLaunchContextGLibType func() types.GType

func AppLaunchContextGLibType() types.GType {
	return xAppLaunchContextGLibType()
}

func AppLaunchContextNewFromInternalPtr(ptr uintptr) *AppLaunchContext {
	cls := &AppLaunchContext{}
	cls.Ptr = ptr
	return cls
}

var xNewAppLaunchContext func() uintptr

// Creates a new application launch context. This is not normally used,
// instead you instantiate a subclass of this, such as
// [`GdkAppLaunchContext`](https://docs.gtk.org/gdk4/class.AppLaunchContext.html).
func NewAppLaunchContext() *AppLaunchContext {
	var cls *AppLaunchContext

	cret := xNewAppLaunchContext()

	if cret == 0 {
		return nil
	}
	cls = &AppLaunchContext{}
	cls.Ptr = cret
	return cls
}

var xAppLaunchContextGetDisplay func(uintptr, uintptr, *glib.List) string

// Gets the display string for the @context. This is used to ensure new
// applications are started on the same display as the launching
// application, by setting the `DISPLAY` environment variable.
func (x *AppLaunchContext) GetDisplay(InfoVar AppInfo, FilesVar *glib.List) string {

	cret := xAppLaunchContextGetDisplay(x.GoPointer(), InfoVar.GoPointer(), FilesVar)

	return cret
}

var xAppLaunchContextGetEnvironment func(uintptr) []string

// Gets the complete environment variable list to be passed to
// the child process when @context is used to launch an application.
// This is a `NULL`-terminated array of strings, where each string has
// the form `KEY=VALUE`.
func (x *AppLaunchContext) GetEnvironment() []string {

	cret := xAppLaunchContextGetEnvironment(x.GoPointer())

	return cret
}

var xAppLaunchContextGetStartupNotifyId func(uintptr, uintptr, *glib.List) string

// Initiates startup notification for the application and returns the
// `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
// if supported.
//
// The returned token may be referred to equivalently as an ‘activation token’
// (using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
// The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
//
// Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
// and startup notification IDs are defined in the
// [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
//
// Support for the XDG Activation Protocol was added in GLib 2.76.
// Since GLib 2.82 @info and @files can be `NULL`. If that’s not supported by the backend,
// the returned token will be `NULL`.
func (x *AppLaunchContext) GetStartupNotifyId(InfoVar AppInfo, FilesVar *glib.List) string {

	cret := xAppLaunchContextGetStartupNotifyId(x.GoPointer(), InfoVar.GoPointer(), FilesVar)

	return cret
}

var xAppLaunchContextLaunchFailed func(uintptr, string)

// Called when an application has failed to launch, so that it can cancel
// the application startup notification started in
// [method@Gio.AppLaunchContext.get_startup_notify_id].
func (x *AppLaunchContext) LaunchFailed(StartupNotifyIdVar string) {

	xAppLaunchContextLaunchFailed(x.GoPointer(), StartupNotifyIdVar)

}

var xAppLaunchContextSetenv func(uintptr, string, string)

// Arranges for @variable to be set to @value in the child’s environment when
// @context is used to launch an application.
func (x *AppLaunchContext) Setenv(VariableVar string, ValueVar string) {

	xAppLaunchContextSetenv(x.GoPointer(), VariableVar, ValueVar)

}

var xAppLaunchContextUnsetenv func(uintptr, string)

// Arranges for @variable to be unset in the child’s environment when @context
// is used to launch an application.
func (x *AppLaunchContext) Unsetenv(VariableVar string) {

	xAppLaunchContextUnsetenv(x.GoPointer(), VariableVar)

}

func (c *AppLaunchContext) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *AppLaunchContext) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The [signal@Gio.AppLaunchContext::launch-failed] signal is emitted when a
// [iface@Gio.AppInfo] launch fails. The startup notification id is provided,
// so that the launcher can cancel the startup notification.
//
// Because a launch operation may involve spawning multiple instances of the
// target application, you should expect this signal to be emitted multiple
// times, one for each spawned instance.
func (x *AppLaunchContext) ConnectLaunchFailed(cb *func(AppLaunchContext, string)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "launch-failed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, StartupNotifyIdVarp string) {
		fa := AppLaunchContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StartupNotifyIdVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "launch-failed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The [signal@Gio.AppLaunchContext::launch-started] signal is emitted when a
// [iface@Gio.AppInfo] is about to be launched. If non-null the
// @platform_data is an GVariant dictionary mapping strings to variants
// (ie `a{sv}`), which contains additional, platform-specific data about this
// launch. On UNIX, at least the `startup-notification-id` keys will be
// present.
//
// The value of the `startup-notification-id` key (type `s`) is a startup
// notification ID corresponding to the format from the [startup-notification
// specification](https://specifications.freedesktop.org/startup-notification-spec/startup-notification-0.1.txt).
// It allows tracking the progress of the launchee through startup.
//
// It is guaranteed that this signal is followed by either a
// [signal@Gio.AppLaunchContext::launched] or
// [signal@Gio.AppLaunchContext::launch-failed] signal.
//
// Because a launch operation may involve spawning multiple instances of the
// target application, you should expect this signal to be emitted multiple
// times, one for each spawned instance.
func (x *AppLaunchContext) ConnectLaunchStarted(cb *func(AppLaunchContext, uintptr, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "launch-started", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, InfoVarp uintptr, PlatformDataVarp uintptr) {
		fa := AppLaunchContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, InfoVarp, PlatformDataVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "launch-started", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// The [signal@Gio.AppLaunchContext::launched] signal is emitted when a
// [iface@Gio.AppInfo] is successfully launched.
//
// Because a launch operation may involve spawning multiple instances of the
// target application, you should expect this signal to be emitted multiple
// times, one time for each spawned instance.
//
// The @platform_data is an GVariant dictionary mapping
// strings to variants (ie `a{sv}`), which contains additional,
// platform-specific data about this launch. On UNIX, at least the
// `pid` and `startup-notification-id` keys will be present.
//
// Since 2.72 the `pid` may be 0 if the process id wasn’t known (for
// example if the process was launched via D-Bus). The `pid` may not be
// set at all in subsequent releases.
//
// On Windows, `pid` is guaranteed to be valid only for the duration of the
// [signal@Gio.AppLaunchContext::launched] signal emission; after the signal
// is emitted, GLib will call [func@GLib.spawn_close_pid]. If you need to
// keep the [alias@GLib.Pid] after the signal has been emitted, then you can
// duplicate `pid` using `DuplicateHandle()`.
func (x *AppLaunchContext) ConnectLaunched(cb *func(AppLaunchContext, uintptr, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "launched", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, InfoVarp uintptr, PlatformDataVarp uintptr) {
		fa := AppLaunchContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, InfoVarp, PlatformDataVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "launched", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func init() {
	core.SetPackageName("GIO", "gio-2.0")
	core.SetSharedLibraries("GIO", []string{"libgio-2.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("GIO") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAppInfoCreateFromCommandline, libs, "g_app_info_create_from_commandline")
	core.PuregoSafeRegister(&xAppInfoGetAll, libs, "g_app_info_get_all")
	core.PuregoSafeRegister(&xAppInfoGetAllForType, libs, "g_app_info_get_all_for_type")
	core.PuregoSafeRegister(&xAppInfoGetDefaultForType, libs, "g_app_info_get_default_for_type")
	core.PuregoSafeRegister(&xAppInfoGetDefaultForTypeAsync, libs, "g_app_info_get_default_for_type_async")
	core.PuregoSafeRegister(&xAppInfoGetDefaultForTypeFinish, libs, "g_app_info_get_default_for_type_finish")
	core.PuregoSafeRegister(&xAppInfoGetDefaultForUriScheme, libs, "g_app_info_get_default_for_uri_scheme")
	core.PuregoSafeRegister(&xAppInfoGetDefaultForUriSchemeAsync, libs, "g_app_info_get_default_for_uri_scheme_async")
	core.PuregoSafeRegister(&xAppInfoGetDefaultForUriSchemeFinish, libs, "g_app_info_get_default_for_uri_scheme_finish")
	core.PuregoSafeRegister(&xAppInfoGetFallbackForType, libs, "g_app_info_get_fallback_for_type")
	core.PuregoSafeRegister(&xAppInfoGetRecommendedForType, libs, "g_app_info_get_recommended_for_type")
	core.PuregoSafeRegister(&xAppInfoLaunchDefaultForUri, libs, "g_app_info_launch_default_for_uri")
	core.PuregoSafeRegister(&xAppInfoLaunchDefaultForUriAsync, libs, "g_app_info_launch_default_for_uri_async")
	core.PuregoSafeRegister(&xAppInfoLaunchDefaultForUriFinish, libs, "g_app_info_launch_default_for_uri_finish")
	core.PuregoSafeRegister(&xAppInfoResetTypeAssociations, libs, "g_app_info_reset_type_associations")

	core.PuregoSafeRegister(&xAppInfoMonitorGLibType, libs, "g_app_info_monitor_get_type")

	core.PuregoSafeRegister(&xAppInfoMonitorGet, libs, "g_app_info_monitor_get")

	core.PuregoSafeRegister(&xAppLaunchContextGLibType, libs, "g_app_launch_context_get_type")

	core.PuregoSafeRegister(&xNewAppLaunchContext, libs, "g_app_launch_context_new")

	core.PuregoSafeRegister(&xAppLaunchContextGetDisplay, libs, "g_app_launch_context_get_display")
	core.PuregoSafeRegister(&xAppLaunchContextGetEnvironment, libs, "g_app_launch_context_get_environment")
	core.PuregoSafeRegister(&xAppLaunchContextGetStartupNotifyId, libs, "g_app_launch_context_get_startup_notify_id")
	core.PuregoSafeRegister(&xAppLaunchContextLaunchFailed, libs, "g_app_launch_context_launch_failed")
	core.PuregoSafeRegister(&xAppLaunchContextSetenv, libs, "g_app_launch_context_setenv")
	core.PuregoSafeRegister(&xAppLaunchContextUnsetenv, libs, "g_app_launch_context_unsetenv")

	core.PuregoSafeRegister(&xAppInfoGLibType, libs, "g_app_info_get_type")

	core.PuregoSafeRegister(&XGAppInfoAddSupportsType, libs, "g_app_info_add_supports_type")
	core.PuregoSafeRegister(&XGAppInfoCanDelete, libs, "g_app_info_can_delete")
	core.PuregoSafeRegister(&XGAppInfoCanRemoveSupportsType, libs, "g_app_info_can_remove_supports_type")
	core.PuregoSafeRegister(&XGAppInfoDelete, libs, "g_app_info_delete")
	core.PuregoSafeRegister(&XGAppInfoDup, libs, "g_app_info_dup")
	core.PuregoSafeRegister(&XGAppInfoEqual, libs, "g_app_info_equal")
	core.PuregoSafeRegister(&XGAppInfoGetCommandline, libs, "g_app_info_get_commandline")
	core.PuregoSafeRegister(&XGAppInfoGetDescription, libs, "g_app_info_get_description")
	core.PuregoSafeRegister(&XGAppInfoGetDisplayName, libs, "g_app_info_get_display_name")
	core.PuregoSafeRegister(&XGAppInfoGetExecutable, libs, "g_app_info_get_executable")
	core.PuregoSafeRegister(&XGAppInfoGetIcon, libs, "g_app_info_get_icon")
	core.PuregoSafeRegister(&XGAppInfoGetId, libs, "g_app_info_get_id")
	core.PuregoSafeRegister(&XGAppInfoGetName, libs, "g_app_info_get_name")
	core.PuregoSafeRegister(&XGAppInfoGetSupportedTypes, libs, "g_app_info_get_supported_types")
	core.PuregoSafeRegister(&XGAppInfoLaunch, libs, "g_app_info_launch")
	core.PuregoSafeRegister(&XGAppInfoLaunchUris, libs, "g_app_info_launch_uris")
	core.PuregoSafeRegister(&XGAppInfoLaunchUrisAsync, libs, "g_app_info_launch_uris_async")
	core.PuregoSafeRegister(&XGAppInfoLaunchUrisFinish, libs, "g_app_info_launch_uris_finish")
	core.PuregoSafeRegister(&XGAppInfoRemoveSupportsType, libs, "g_app_info_remove_supports_type")
	core.PuregoSafeRegister(&XGAppInfoSetAsDefaultForExtension, libs, "g_app_info_set_as_default_for_extension")
	core.PuregoSafeRegister(&XGAppInfoSetAsDefaultForType, libs, "g_app_info_set_as_default_for_type")
	core.PuregoSafeRegister(&XGAppInfoSetAsLastUsedForType, libs, "g_app_info_set_as_last_used_for_type")
	core.PuregoSafeRegister(&XGAppInfoShouldShow, libs, "g_app_info_should_show")
	core.PuregoSafeRegister(&XGAppInfoSupportsFiles, libs, "g_app_info_supports_files")
	core.PuregoSafeRegister(&XGAppInfoSupportsUris, libs, "g_app_info_supports_uris")

}
